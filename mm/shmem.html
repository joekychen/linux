<!DOCTYPE html>
<html><head><title>joekychen/linux » mm › shmem.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>shmem.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Resizable virtual memory filesystem for Linux.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2000 Linus Torvalds.</span>
<span class="cm"> *		 2000 Transmeta Corp.</span>
<span class="cm"> *		 2000-2001 Christoph Rohland</span>
<span class="cm"> *		 2000-2001 SAP AG</span>
<span class="cm"> *		 2002 Red Hat Inc.</span>
<span class="cm"> * Copyright (C) 2002-2011 Hugh Dickins.</span>
<span class="cm"> * Copyright (C) 2011 Google Inc.</span>
<span class="cm"> * Copyright (C) 2002-2005 VERITAS Software Corporation.</span>
<span class="cm"> * Copyright (C) 2004 Andi Kleen, SuSE Labs</span>
<span class="cm"> *</span>
<span class="cm"> * Extended attribute support for tmpfs:</span>
<span class="cm"> * Copyright (c) 2004, Luke Kenneth Casson Leighton &lt;lkcl@lkcl.net&gt;</span>
<span class="cm"> * Copyright (c) 2004 Red Hat, Inc., James Morris &lt;jmorris@redhat.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * tiny-shmem:</span>
<span class="cm"> * Copyright (c) 2004, 2008 Matt Mackall &lt;mpm@selenic.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This file is released under the GPL.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/vfs.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">shm_mnt</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SHMEM</span>
<span class="cm">/*</span>
<span class="cm"> * This virtual memory filesystem is heavily based on the ramfs. It</span>
<span class="cm"> * extends ramfs by the ability to use swap and honor resource limits</span>
<span class="cm"> * which makes it a completely usable filesystem.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/xattr.h&gt;</span>
<span class="cp">#include &lt;linux/exportfs.h&gt;</span>
<span class="cp">#include &lt;linux/posix_acl.h&gt;</span>
<span class="cp">#include &lt;linux/generic_acl.h&gt;</span>
<span class="cp">#include &lt;linux/mman.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/backing-dev.h&gt;</span>
<span class="cp">#include &lt;linux/shmem_fs.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/pagevec.h&gt;</span>
<span class="cp">#include &lt;linux/percpu_counter.h&gt;</span>
<span class="cp">#include &lt;linux/falloc.h&gt;</span>
<span class="cp">#include &lt;linux/splice.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/swapops.h&gt;</span>
<span class="cp">#include &lt;linux/mempolicy.h&gt;</span>
<span class="cp">#include &lt;linux/namei.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/migrate.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/magic.h&gt;</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>

<span class="cp">#define BLOCKS_PER_PAGE  (PAGE_CACHE_SIZE/512)</span>
<span class="cp">#define VM_ACCT(size)    (PAGE_CACHE_ALIGN(size) &gt;&gt; PAGE_SHIFT)</span>

<span class="cm">/* Pretend that each entry is of this size in directory&#39;s i_size */</span>
<span class="cp">#define BOGO_DIRENT_SIZE 20</span>

<span class="cm">/* Symlink up to this size is kmalloc&#39;ed instead of using a swappable page */</span>
<span class="cp">#define SHORT_SYMLINK_LEN 128</span>

<span class="k">struct</span> <span class="n">shmem_xattr</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>	<span class="cm">/* anchored by shmem_inode_info-&gt;xattr_list */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>		<span class="cm">/* xattr name */</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * shmem_fallocate and shmem_writepage communicate via inode-&gt;i_private</span>
<span class="cm"> * (with i_mutex making sure that it has only one user at a time):</span>
<span class="cm"> * we would prefer not to enlarge the shmem inode just for that.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">shmem_falloc</span> <span class="p">{</span>
	<span class="n">pgoff_t</span> <span class="n">start</span><span class="p">;</span>		<span class="cm">/* start of range currently being fallocated */</span>
	<span class="n">pgoff_t</span> <span class="n">next</span><span class="p">;</span>		<span class="cm">/* the next page offset to be fallocated */</span>
	<span class="n">pgoff_t</span> <span class="n">nr_falloced</span><span class="p">;</span>	<span class="cm">/* how many new pages have been fallocated */</span>
	<span class="n">pgoff_t</span> <span class="n">nr_unswapped</span><span class="p">;</span>	<span class="cm">/* how often writepage refused to swap out */</span>
<span class="p">};</span>

<span class="cm">/* Flag allocation requirements to shmem_getpage */</span>
<span class="k">enum</span> <span class="n">sgp_type</span> <span class="p">{</span>
	<span class="n">SGP_READ</span><span class="p">,</span>	<span class="cm">/* don&#39;t exceed i_size, don&#39;t allocate page */</span>
	<span class="n">SGP_CACHE</span><span class="p">,</span>	<span class="cm">/* don&#39;t exceed i_size, may allocate page */</span>
	<span class="n">SGP_DIRTY</span><span class="p">,</span>	<span class="cm">/* like SGP_CACHE, but set new page dirty */</span>
	<span class="n">SGP_WRITE</span><span class="p">,</span>	<span class="cm">/* may exceed i_size, may allocate !Uptodate page */</span>
	<span class="n">SGP_FALLOC</span><span class="p">,</span>	<span class="cm">/* like SGP_WRITE, but make existing page Uptodate */</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_TMPFS</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">shmem_default_max_blocks</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">totalram_pages</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">shmem_default_max_inodes</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">min</span><span class="p">(</span><span class="n">totalram_pages</span> <span class="o">-</span> <span class="n">totalhigh_pages</span><span class="p">,</span> <span class="n">totalram_pages</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">shmem_should_replace_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">shmem_replace_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pagep</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">shmem_inode_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">index</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">shmem_getpage_gfp</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pagep</span><span class="p">,</span> <span class="k">enum</span> <span class="n">sgp_type</span> <span class="n">sgp</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">fault_type</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">shmem_getpage</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pagep</span><span class="p">,</span> <span class="k">enum</span> <span class="n">sgp_type</span> <span class="n">sgp</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">fault_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">shmem_getpage_gfp</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">pagep</span><span class="p">,</span> <span class="n">sgp</span><span class="p">,</span>
			<span class="n">mapping_gfp_mask</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">),</span> <span class="n">fault_type</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">shmem_sb_info</span> <span class="o">*</span><span class="nf">SHMEM_SB</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * shmem_file_setup pre-accounts the whole fixed size of a VM object,</span>
<span class="cm"> * for shared memory and for shared anonymous (/dev/zero) mappings</span>
<span class="cm"> * (unless MAP_NORESERVE and sysctl_overcommit_memory &lt;= 1),</span>
<span class="cm"> * consistent with the pre-accounting of private mappings ...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">shmem_acct_size</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">VM_NORESERVE</span><span class="p">)</span> <span class="o">?</span>
		<span class="mi">0</span> <span class="o">:</span> <span class="n">security_vm_enough_memory_mm</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="n">VM_ACCT</span><span class="p">(</span><span class="n">size</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">shmem_unacct_size</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">VM_NORESERVE</span><span class="p">))</span>
		<span class="n">vm_unacct_memory</span><span class="p">(</span><span class="n">VM_ACCT</span><span class="p">(</span><span class="n">size</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ... whereas tmpfs objects are accounted incrementally as</span>
<span class="cm"> * pages are allocated, in order to allow huge sparse files.</span>
<span class="cm"> * shmem_getpage reports shmem_acct_block failure as -ENOSPC not -ENOMEM,</span>
<span class="cm"> * so that a failure on a sparse tmpfs mapping will give SIGBUS not OOM.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">shmem_acct_block</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">VM_NORESERVE</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">security_vm_enough_memory_mm</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="n">VM_ACCT</span><span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span><span class="p">))</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">shmem_unacct_blocks</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">long</span> <span class="n">pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">VM_NORESERVE</span><span class="p">)</span>
		<span class="n">vm_unacct_memory</span><span class="p">(</span><span class="n">pages</span> <span class="o">*</span> <span class="n">VM_ACCT</span><span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">super_operations</span> <span class="n">shmem_ops</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">shmem_aops</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">shmem_file_operations</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">shmem_inode_operations</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">shmem_dir_inode_operations</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">shmem_special_inode_operations</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">vm_operations_struct</span> <span class="n">shmem_vm_ops</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="n">shmem_backing_dev_info</span>  <span class="n">__read_mostly</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ra_pages</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* No readahead */</span>
	<span class="p">.</span><span class="n">capabilities</span>	<span class="o">=</span> <span class="n">BDI_CAP_NO_ACCT_AND_WRITEBACK</span> <span class="o">|</span> <span class="n">BDI_CAP_SWAP_BACKED</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">shmem_swaplist</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">shmem_swaplist_mutex</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">shmem_reserve_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">shmem_sb_info</span> <span class="o">*</span><span class="n">sbinfo</span> <span class="o">=</span> <span class="n">SHMEM_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">max_inodes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">free_inodes</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">free_inodes</span><span class="o">--</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">shmem_free_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">shmem_sb_info</span> <span class="o">*</span><span class="n">sbinfo</span> <span class="o">=</span> <span class="n">SHMEM_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">max_inodes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
		<span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">free_inodes</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * shmem_recalc_inode - recalculate the block usage of an inode</span>
<span class="cm"> * @inode: inode to recalc</span>
<span class="cm"> *</span>
<span class="cm"> * We have to calculate the free blocks since the mm can drop</span>
<span class="cm"> * undirtied hole pages behind our back.</span>
<span class="cm"> *</span>
<span class="cm"> * But normally   info-&gt;alloced == inode-&gt;i_mapping-&gt;nrpages + info-&gt;swapped</span>
<span class="cm"> * So mm freed is info-&gt;alloced - (inode-&gt;i_mapping-&gt;nrpages + info-&gt;swapped)</span>
<span class="cm"> *</span>
<span class="cm"> * It has to be called with the spinlock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">shmem_recalc_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">shmem_inode_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">SHMEM_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">long</span> <span class="n">freed</span><span class="p">;</span>

	<span class="n">freed</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">alloced</span> <span class="o">-</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">swapped</span> <span class="o">-</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">nrpages</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">freed</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">shmem_sb_info</span> <span class="o">*</span><span class="n">sbinfo</span> <span class="o">=</span> <span class="n">SHMEM_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">max_blocks</span><span class="p">)</span>
			<span class="n">percpu_counter_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">used_blocks</span><span class="p">,</span> <span class="o">-</span><span class="n">freed</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">alloced</span> <span class="o">-=</span> <span class="n">freed</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">-=</span> <span class="n">freed</span> <span class="o">*</span> <span class="n">BLOCKS_PER_PAGE</span><span class="p">;</span>
		<span class="n">shmem_unacct_blocks</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">freed</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Replace item expected in radix tree by a new item, while holding tree lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">shmem_radix_tree_replace</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">expected</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">replacement</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">**</span><span class="n">pslot</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">item</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">expected</span><span class="p">);</span>
	<span class="n">pslot</span> <span class="o">=</span> <span class="n">radix_tree_lookup_slot</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">page_tree</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pslot</span><span class="p">)</span>
		<span class="n">item</span> <span class="o">=</span> <span class="n">radix_tree_deref_slot_protected</span><span class="p">(</span><span class="n">pslot</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">tree_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">item</span> <span class="o">!=</span> <span class="n">expected</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">replacement</span><span class="p">)</span>
		<span class="n">radix_tree_replace_slot</span><span class="p">(</span><span class="n">pslot</span><span class="p">,</span> <span class="n">replacement</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">radix_tree_delete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">page_tree</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Like add_to_page_cache_locked, but error if expected item has gone.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">shmem_add_to_page_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				   <span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">expected</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageSwapBacked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">expected</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">radix_tree_preload</span><span class="p">(</span><span class="n">gfp</span> <span class="o">&amp;</span> <span class="n">GFP_RECLAIM_MASK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page_cache_get</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">;</span>
		<span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">tree_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">expected</span><span class="p">)</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">radix_tree_insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">page_tree</span><span class="p">,</span>
							<span class="n">index</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">shmem_radix_tree_replace</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
							<span class="n">expected</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mapping</span><span class="o">-&gt;</span><span class="n">nrpages</span><span class="o">++</span><span class="p">;</span>
			<span class="n">__inc_zone_page_state</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">NR_FILE_PAGES</span><span class="p">);</span>
			<span class="n">__inc_zone_page_state</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">NR_SHMEM</span><span class="p">);</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">tree_lock</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">tree_lock</span><span class="p">);</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">expected</span><span class="p">)</span>
			<span class="n">radix_tree_preload_end</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">mem_cgroup_uncharge_cache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Like delete_from_page_cache, but substitutes swap for page.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">shmem_delete_from_page_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">radswap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">tree_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">shmem_radix_tree_replace</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">radswap</span><span class="p">);</span>
	<span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mapping</span><span class="o">-&gt;</span><span class="n">nrpages</span><span class="o">--</span><span class="p">;</span>
	<span class="n">__dec_zone_page_state</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">NR_FILE_PAGES</span><span class="p">);</span>
	<span class="n">__dec_zone_page_state</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">NR_SHMEM</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">tree_lock</span><span class="p">);</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Like find_get_pages, but collecting swap entries as well as pages.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">shmem_find_get_pages_and_swap</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
					<span class="n">pgoff_t</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_pages</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="o">*</span><span class="n">indices</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_found</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="nl">restart:</span>
	<span class="n">nr_found</span> <span class="o">=</span> <span class="n">radix_tree_gang_lookup_slot</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">page_tree</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">void</span> <span class="o">***</span><span class="p">)</span><span class="n">pages</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_found</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
<span class="nl">repeat:</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">radix_tree_deref_slot</span><span class="p">((</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">radix_tree_exception</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">radix_tree_deref_retry</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Otherwise, we must be storing a swap entry</span>
<span class="cm">			 * here as an exceptional entry: so return it</span>
<span class="cm">			 * without attempting to raise page count.</span>
<span class="cm">			 */</span>
			<span class="k">goto</span> <span class="n">export</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_cache_get_speculative</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>

		<span class="cm">/* Has the page moved? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">page</span> <span class="o">!=</span> <span class="o">*</span><span class="p">((</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span> <span class="p">{</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
		<span class="p">}</span>
<span class="nl">export:</span>
		<span class="n">indices</span><span class="p">[</span><span class="n">ret</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">pages</span><span class="p">[</span><span class="n">ret</span><span class="p">]</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
		<span class="n">ret</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">nr_found</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove swap entry from radix tree, free the swap and its page cache.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">shmem_free_swap</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			   <span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">radswap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">tree_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">shmem_radix_tree_replace</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">radswap</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">tree_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
		<span class="n">free_swap_and_cache</span><span class="p">(</span><span class="n">radix_to_swp_entry</span><span class="p">(</span><span class="n">radswap</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Pagevec may contain swap entries, so shuffle up pages before releasing.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">shmem_deswap_pagevec</span><span class="p">(</span><span class="k">struct</span> <span class="n">pagevec</span> <span class="o">*</span><span class="n">pvec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pagevec_count</span><span class="p">(</span><span class="n">pvec</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">pvec</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">radix_tree_exceptional_entry</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="n">pvec</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pvec</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * SysV IPC SHM_UNLOCK restore Unevictable pages to their evictable lists.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">shmem_unlock_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pagevec</span> <span class="n">pvec</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">indices</span><span class="p">[</span><span class="n">PAGEVEC_SIZE</span><span class="p">];</span>
	<span class="n">pgoff_t</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pagevec_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Minor point, but we might as well stop if someone else SHM_LOCKs it.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">mapping_unevictable</span><span class="p">(</span><span class="n">mapping</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Avoid pagevec_lookup(): find_get_pages() returns 0 as if it</span>
<span class="cm">		 * has finished, if it hits a row of PAGEVEC_SIZE swap entries.</span>
<span class="cm">		 */</span>
		<span class="n">pvec</span><span class="p">.</span><span class="n">nr</span> <span class="o">=</span> <span class="n">shmem_find_get_pages_and_swap</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
					<span class="n">PAGEVEC_SIZE</span><span class="p">,</span> <span class="n">pvec</span><span class="p">.</span><span class="n">pages</span><span class="p">,</span> <span class="n">indices</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pvec</span><span class="p">.</span><span class="n">nr</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">pvec</span><span class="p">.</span><span class="n">nr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">shmem_deswap_pagevec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">);</span>
		<span class="n">check_move_unevictable_pages</span><span class="p">(</span><span class="n">pvec</span><span class="p">.</span><span class="n">pages</span><span class="p">,</span> <span class="n">pvec</span><span class="p">.</span><span class="n">nr</span><span class="p">);</span>
		<span class="n">pagevec_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">);</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove range of pages and swap entries from radix tree, and free them.</span>
<span class="cm"> * If !unfalloc, truncate or punch hole; if unfalloc, undo failed fallocate.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">shmem_undo_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">lstart</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">lend</span><span class="p">,</span>
								 <span class="n">bool</span> <span class="n">unfalloc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">shmem_inode_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">SHMEM_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">pgoff_t</span> <span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="n">lstart</span> <span class="o">+</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">lend</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">partial_start</span> <span class="o">=</span> <span class="n">lstart</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">partial_end</span> <span class="o">=</span> <span class="p">(</span><span class="n">lend</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pagevec</span> <span class="n">pvec</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">indices</span><span class="p">[</span><span class="n">PAGEVEC_SIZE</span><span class="p">];</span>
	<span class="kt">long</span> <span class="n">nr_swaps_freed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lend</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">end</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* unsigned, so actually very big */</span>

	<span class="n">pagevec_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pvec</span><span class="p">.</span><span class="n">nr</span> <span class="o">=</span> <span class="n">shmem_find_get_pages_and_swap</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
				<span class="n">min</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">pgoff_t</span><span class="p">)</span><span class="n">PAGEVEC_SIZE</span><span class="p">),</span>
							<span class="n">pvec</span><span class="p">.</span><span class="n">pages</span><span class="p">,</span> <span class="n">indices</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pvec</span><span class="p">.</span><span class="n">nr</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">mem_cgroup_uncharge_start</span><span class="p">();</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pagevec_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">pvec</span><span class="p">.</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="n">index</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">radix_tree_exceptional_entry</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">unfalloc</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="n">nr_swaps_freed</span> <span class="o">+=</span> <span class="o">!</span><span class="n">shmem_free_swap</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span>
								<span class="n">index</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trylock_page</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">unfalloc</span> <span class="o">||</span> <span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">==</span> <span class="n">mapping</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">PageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
					<span class="n">truncate_inode_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">shmem_deswap_pagevec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">);</span>
		<span class="n">pagevec_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">);</span>
		<span class="n">mem_cgroup_uncharge_end</span><span class="p">();</span>
		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="n">index</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">partial_start</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">shmem_getpage</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="n">SGP_READ</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">top</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">top</span> <span class="o">=</span> <span class="n">partial_end</span><span class="p">;</span>
				<span class="n">partial_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">zero_user_segment</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">partial_start</span><span class="p">,</span> <span class="n">top</span><span class="p">);</span>
			<span class="n">set_page_dirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">partial_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">shmem_getpage</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="n">SGP_READ</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">zero_user_segment</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">partial_end</span><span class="p">);</span>
			<span class="n">set_page_dirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="n">pvec</span><span class="p">.</span><span class="n">nr</span> <span class="o">=</span> <span class="n">shmem_find_get_pages_and_swap</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
				<span class="n">min</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">pgoff_t</span><span class="p">)</span><span class="n">PAGEVEC_SIZE</span><span class="p">),</span>
							<span class="n">pvec</span><span class="p">.</span><span class="n">pages</span><span class="p">,</span> <span class="n">indices</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pvec</span><span class="p">.</span><span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">start</span> <span class="o">||</span> <span class="n">unfalloc</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">index</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">index</span> <span class="o">==</span> <span class="n">start</span> <span class="o">||</span> <span class="n">unfalloc</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">shmem_deswap_pagevec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">);</span>
			<span class="n">pagevec_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mem_cgroup_uncharge_start</span><span class="p">();</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pagevec_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">pvec</span><span class="p">.</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="n">index</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">radix_tree_exceptional_entry</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">unfalloc</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="n">nr_swaps_freed</span> <span class="o">+=</span> <span class="o">!</span><span class="n">shmem_free_swap</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span>
								<span class="n">index</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">lock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">unfalloc</span> <span class="o">||</span> <span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">==</span> <span class="n">mapping</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">PageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
					<span class="n">truncate_inode_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">shmem_deswap_pagevec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">);</span>
		<span class="n">pagevec_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">);</span>
		<span class="n">mem_cgroup_uncharge_end</span><span class="p">();</span>
		<span class="n">index</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">swapped</span> <span class="o">-=</span> <span class="n">nr_swaps_freed</span><span class="p">;</span>
	<span class="n">shmem_recalc_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">shmem_truncate_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">lstart</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">lend</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">shmem_undo_range</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">lstart</span><span class="p">,</span> <span class="n">lend</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">CURRENT_TIME</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">shmem_truncate_range</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">shmem_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">inode_change_ok</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_SIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">loff_t</span> <span class="n">oldsize</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
		<span class="n">loff_t</span> <span class="n">newsize</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_size</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">newsize</span> <span class="o">!=</span> <span class="n">oldsize</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">i_size_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">newsize</span><span class="p">);</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">CURRENT_TIME</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newsize</span> <span class="o">&lt;</span> <span class="n">oldsize</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">loff_t</span> <span class="n">holebegin</span> <span class="o">=</span> <span class="n">round_up</span><span class="p">(</span><span class="n">newsize</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
			<span class="n">unmap_mapping_range</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">holebegin</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">shmem_truncate_range</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">newsize</span><span class="p">,</span> <span class="p">(</span><span class="n">loff_t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="cm">/* unmap again to remove racily COWed private pages */</span>
			<span class="n">unmap_mapping_range</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">holebegin</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">setattr_copy</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_TMPFS_POSIX_ACL</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_MODE</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">generic_acl_chmod</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">shmem_evict_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">shmem_inode_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">SHMEM_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">shmem_xattr</span> <span class="o">*</span><span class="n">xattr</span><span class="p">,</span> <span class="o">*</span><span class="n">nxattr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">shmem_aops</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">shmem_unacct_size</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">shmem_truncate_range</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">loff_t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">swaplist</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shmem_swaplist_mutex</span><span class="p">);</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">swaplist</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shmem_swaplist_mutex</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">symlink</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">xattr</span><span class="p">,</span> <span class="n">nxattr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">xattr_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">xattr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">xattr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span><span class="p">);</span>
	<span class="n">shmem_free_inode</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="n">clear_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If swap found in inode, free it and move page from swapcache to filecache.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">shmem_unuse_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmem_inode_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
			     <span class="n">swp_entry_t</span> <span class="n">swap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pagep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">.</span><span class="n">i_mapping</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">radswap</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">radswap</span> <span class="o">=</span> <span class="n">swp_to_radix_entry</span><span class="p">(</span><span class="n">swap</span><span class="p">);</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">radix_tree_locate_item</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">page_tree</span><span class="p">,</span> <span class="n">radswap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Move _head_ to start search for next from here.</span>
<span class="cm">	 * But be careful: shmem_evict_inode checks list_empty without taking</span>
<span class="cm">	 * mutex, and there&#39;s an instant in list_move_tail when info-&gt;swaplist</span>
<span class="cm">	 * would appear empty, if it were the only one on shmem_swaplist.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shmem_swaplist</span><span class="p">.</span><span class="n">next</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">swaplist</span><span class="p">)</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shmem_swaplist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">swaplist</span><span class="p">);</span>

	<span class="n">gfp</span> <span class="o">=</span> <span class="n">mapping_gfp_mask</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shmem_should_replace_page</span><span class="p">(</span><span class="o">*</span><span class="n">pagep</span><span class="p">,</span> <span class="n">gfp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shmem_swaplist_mutex</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">shmem_replace_page</span><span class="p">(</span><span class="n">pagep</span><span class="p">,</span> <span class="n">gfp</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shmem_swaplist_mutex</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * We needed to drop mutex to make that restrictive page</span>
<span class="cm">		 * allocation, but the inode might have been freed while we</span>
<span class="cm">		 * dropped it: although a racing shmem_evict_inode() cannot</span>
<span class="cm">		 * complete without emptying the radix_tree, our page lock</span>
<span class="cm">		 * on this swapcache page is not enough to prevent that -</span>
<span class="cm">		 * free_swap_and_cache() of our swap entry will only</span>
<span class="cm">		 * trylock_page(), removing swap from radix_tree whatever.</span>
<span class="cm">		 *</span>
<span class="cm">		 * We must not proceed to shmem_add_to_page_cache() if the</span>
<span class="cm">		 * inode has been freed, but of course we cannot rely on</span>
<span class="cm">		 * inode or mapping or info to check that.  However, we can</span>
<span class="cm">		 * safely check if our swap entry is still in use (and here</span>
<span class="cm">		 * it can&#39;t have got reused for another page): if it&#39;s still</span>
<span class="cm">		 * in use, then the inode cannot have been freed yet, and we</span>
<span class="cm">		 * can safely proceed (if it&#39;s no longer in use, that tells</span>
<span class="cm">		 * nothing about the inode, but we don&#39;t need to unuse swap).</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_swapcount</span><span class="p">(</span><span class="o">*</span><span class="n">pagep</span><span class="p">))</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We rely on shmem_swaplist_mutex, not only to protect the swaplist,</span>
<span class="cm">	 * but also to hold up shmem_evict_inode(): so inode cannot be freed</span>
<span class="cm">	 * beneath us (pagelock doesn&#39;t help until the page is in pagecache).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">shmem_add_to_page_cache</span><span class="p">(</span><span class="o">*</span><span class="n">pagep</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
						<span class="n">GFP_NOWAIT</span><span class="p">,</span> <span class="n">radswap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Truncation and eviction use free_swap_and_cache(), which</span>
<span class="cm">		 * only does trylock page: if we raced, best clean up here.</span>
<span class="cm">		 */</span>
		<span class="n">delete_from_swap_cache</span><span class="p">(</span><span class="o">*</span><span class="n">pagep</span><span class="p">);</span>
		<span class="n">set_page_dirty</span><span class="p">(</span><span class="o">*</span><span class="n">pagep</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">swapped</span><span class="o">--</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">swap_free</span><span class="p">(</span><span class="n">swap</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* not an error, but entry was found */</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Search through swapped inodes to find and replace swap by page.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">shmem_unuse</span><span class="p">(</span><span class="n">swp_entry_t</span> <span class="n">swap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">shmem_inode_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * There&#39;s a faint possibility that swap page was replaced before</span>
<span class="cm">	 * caller locked it: caller will come back later with the right page.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">PageSwapCache</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">||</span> <span class="n">page_private</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">!=</span> <span class="n">swap</span><span class="p">.</span><span class="n">val</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Charge page using GFP_KERNEL while we can wait, before taking</span>
<span class="cm">	 * the shmem_swaplist_mutex which might hold up shmem_writepage().</span>
<span class="cm">	 * Charged back to the user (not to caller) when swap account is used.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">mem_cgroup_cache_charge</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/* No radix_tree_preload: swap entry keeps a place for page in tree */</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shmem_swaplist_mutex</span><span class="p">);</span>
	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shmem_swaplist</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="k">struct</span> <span class="n">shmem_inode_info</span><span class="p">,</span> <span class="n">swaplist</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">swapped</span><span class="p">)</span>
			<span class="n">found</span> <span class="o">=</span> <span class="n">shmem_unuse_inode</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">swap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">swaplist</span><span class="p">);</span>
		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shmem_swaplist_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">found</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Move the page from the page cache to the swap cache.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">shmem_writepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">shmem_inode_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="n">swp_entry_t</span> <span class="n">swap</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">mapping</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">;</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
	<span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">info</span> <span class="o">=</span> <span class="n">SHMEM_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">VM_LOCKED</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">redirty</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">total_swap_pages</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">redirty</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * shmem_backing_dev_info&#39;s capabilities prevent regular writeback or</span>
<span class="cm">	 * sync from ever calling shmem_writepage; but a stacking filesystem</span>
<span class="cm">	 * might use -&gt;writepage of its underlying filesystem, in which case</span>
<span class="cm">	 * tmpfs should write out to swap only in response to memory pressure,</span>
<span class="cm">	 * and not for the writeback threads or sync.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">for_reclaim</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>	<span class="cm">/* Still happens? Tell us about it! */</span>
		<span class="k">goto</span> <span class="n">redirty</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is somewhat ridiculous, but without plumbing a SWAP_MAP_FALLOC</span>
<span class="cm">	 * value into swapfile.c, the only way we can correctly account for a</span>
<span class="cm">	 * fallocated page arriving here is now to initialize it and write it.</span>
<span class="cm">	 *</span>
<span class="cm">	 * That&#39;s okay for a page already fallocated earlier, but if we have</span>
<span class="cm">	 * not yet completed the fallocation, then (a) we want to keep track</span>
<span class="cm">	 * of this page in case we have to undo it, and (b) it may not be a</span>
<span class="cm">	 * good idea to continue anyway, once we&#39;re pushing into swap.  So</span>
<span class="cm">	 * reactivate the page, and let shmem_fallocate() quit when too many.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">shmem_falloc</span> <span class="o">*</span><span class="n">shmem_falloc</span><span class="p">;</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
			<span class="n">shmem_falloc</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">shmem_falloc</span> <span class="o">&amp;&amp;</span>
			    <span class="n">index</span> <span class="o">&gt;=</span> <span class="n">shmem_falloc</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&amp;&amp;</span>
			    <span class="n">index</span> <span class="o">&lt;</span> <span class="n">shmem_falloc</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
				<span class="n">shmem_falloc</span><span class="o">-&gt;</span><span class="n">nr_unswapped</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">shmem_falloc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">shmem_falloc</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">redirty</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">clear_highpage</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">swap</span> <span class="o">=</span> <span class="n">get_swap_page</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">swap</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">redirty</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Add inode to shmem_unuse()&#39;s list of swapped-out inodes,</span>
<span class="cm">	 * if it&#39;s not already there.  Do it now before the page is</span>
<span class="cm">	 * moved to swap cache, when its pagelock no longer protects</span>
<span class="cm">	 * the inode from eviction.  But don&#39;t unlock the mutex until</span>
<span class="cm">	 * we&#39;ve incremented swapped, because shmem_unuse_inode() will</span>
<span class="cm">	 * prune a !swapped inode from the swaplist under this mutex.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shmem_swaplist_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">swaplist</span><span class="p">))</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">swaplist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shmem_swaplist</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">add_to_swap_cache</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">swap</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">swap_shmem_alloc</span><span class="p">(</span><span class="n">swap</span><span class="p">);</span>
		<span class="n">shmem_delete_from_page_cache</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">swp_to_radix_entry</span><span class="p">(</span><span class="n">swap</span><span class="p">));</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">swapped</span><span class="o">++</span><span class="p">;</span>
		<span class="n">shmem_recalc_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shmem_swaplist_mutex</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">page_mapped</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
		<span class="n">swap_writepage</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">wbc</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shmem_swaplist_mutex</span><span class="p">);</span>
	<span class="n">swapcache_free</span><span class="p">(</span><span class="n">swap</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="nl">redirty:</span>
	<span class="n">set_page_dirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">for_reclaim</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">AOP_WRITEPAGE_ACTIVATE</span><span class="p">;</span>	<span class="cm">/* Return with page locked */</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NUMA</span>
<span class="cp">#ifdef CONFIG_TMPFS</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">shmem_show_mpol</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">mpol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mpol</span> <span class="o">||</span> <span class="n">mpol</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MPOL_DEFAULT</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>		<span class="cm">/* show nothing */</span>

	<span class="n">mpol_to_str</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="n">mpol</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;,mpol=%s&quot;</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="nf">shmem_get_sbmpol</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmem_sb_info</span> <span class="o">*</span><span class="n">sbinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">mpol</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">mpol</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>	<span class="cm">/* prevent replace/use races */</span>
		<span class="n">mpol</span> <span class="o">=</span> <span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">mpol</span><span class="p">;</span>
		<span class="n">mpol_get</span><span class="p">(</span><span class="n">mpol</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">mpol</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_TMPFS */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">shmem_swapin</span><span class="p">(</span><span class="n">swp_entry_t</span> <span class="n">swap</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">shmem_inode_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mempolicy</span> <span class="n">mpol</span><span class="p">,</span> <span class="o">*</span><span class="n">spol</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="n">pvma</span><span class="p">;</span>

	<span class="n">spol</span> <span class="o">=</span> <span class="n">mpol_cond_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mpol</span><span class="p">,</span>
			<span class="n">mpol_shared_policy_lookup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">policy</span><span class="p">,</span> <span class="n">index</span><span class="p">));</span>

	<span class="cm">/* Create a pseudo vma that just contains the policy */</span>
	<span class="n">pvma</span><span class="p">.</span><span class="n">vm_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pvma</span><span class="p">.</span><span class="n">vm_pgoff</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">pvma</span><span class="p">.</span><span class="n">vm_ops</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">pvma</span><span class="p">.</span><span class="n">vm_policy</span> <span class="o">=</span> <span class="n">spol</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">swapin_readahead</span><span class="p">(</span><span class="n">swap</span><span class="p">,</span> <span class="n">gfp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pvma</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">shmem_alloc_page</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">shmem_inode_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="n">pvma</span><span class="p">;</span>

	<span class="cm">/* Create a pseudo vma that just contains the policy */</span>
	<span class="n">pvma</span><span class="p">.</span><span class="n">vm_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pvma</span><span class="p">.</span><span class="n">vm_pgoff</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">pvma</span><span class="p">.</span><span class="n">vm_ops</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">pvma</span><span class="p">.</span><span class="n">vm_policy</span> <span class="o">=</span> <span class="n">mpol_shared_policy_lookup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">policy</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * alloc_page_vma() will drop the shared policy reference</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">alloc_page_vma</span><span class="p">(</span><span class="n">gfp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pvma</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* !CONFIG_NUMA */</span><span class="cp"></span>
<span class="cp">#ifdef CONFIG_TMPFS</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">shmem_show_mpol</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">mpol</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_TMPFS */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">shmem_swapin</span><span class="p">(</span><span class="n">swp_entry_t</span> <span class="n">swap</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">shmem_inode_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">swapin_readahead</span><span class="p">(</span><span class="n">swap</span><span class="p">,</span> <span class="n">gfp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">shmem_alloc_page</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">shmem_inode_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">gfp</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_NUMA */</span><span class="cp"></span>

<span class="cp">#if !defined(CONFIG_NUMA) || !defined(CONFIG_TMPFS)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="nf">shmem_get_sbmpol</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmem_sb_info</span> <span class="o">*</span><span class="n">sbinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * When a page is moved from swapcache to shmem filecache (either by the</span>
<span class="cm"> * usual swapin of shmem_getpage_gfp(), or by the less common swapoff of</span>
<span class="cm"> * shmem_unuse_inode()), it may have been read in earlier from swap, in</span>
<span class="cm"> * ignorance of the mapping it belongs to.  If that mapping has special</span>
<span class="cm"> * constraints (like the gma500 GEM driver, which requires RAM below 4GB),</span>
<span class="cm"> * we may need to copy to a suitable page before moving to filecache.</span>
<span class="cm"> *</span>
<span class="cm"> * In a future release, this may well be extended to respect cpuset and</span>
<span class="cm"> * NUMA mempolicy, and applied also to anonymous pages in do_swap_page();</span>
<span class="cm"> * but for now it is a simple matter of zone.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">shmem_should_replace_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">page_zonenum</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">gfp_zone</span><span class="p">(</span><span class="n">gfp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">shmem_replace_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pagep</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">shmem_inode_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">oldpage</span><span class="p">,</span> <span class="o">*</span><span class="n">newpage</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">swap_mapping</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">swap_index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">oldpage</span> <span class="o">=</span> <span class="o">*</span><span class="n">pagep</span><span class="p">;</span>
	<span class="n">swap_index</span> <span class="o">=</span> <span class="n">page_private</span><span class="p">(</span><span class="n">oldpage</span><span class="p">);</span>
	<span class="n">swap_mapping</span> <span class="o">=</span> <span class="n">page_mapping</span><span class="p">(</span><span class="n">oldpage</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We have arrived here because our zones are constrained, so don&#39;t</span>
<span class="cm">	 * limit chance of success by further cpuset and node constraints.</span>
<span class="cm">	 */</span>
	<span class="n">gfp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">GFP_CONSTRAINT_MASK</span><span class="p">;</span>
	<span class="n">newpage</span> <span class="o">=</span> <span class="n">shmem_alloc_page</span><span class="p">(</span><span class="n">gfp</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newpage</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">page_cache_get</span><span class="p">(</span><span class="n">newpage</span><span class="p">);</span>
	<span class="n">copy_highpage</span><span class="p">(</span><span class="n">newpage</span><span class="p">,</span> <span class="n">oldpage</span><span class="p">);</span>
	<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">newpage</span><span class="p">);</span>

	<span class="n">__set_page_locked</span><span class="p">(</span><span class="n">newpage</span><span class="p">);</span>
	<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">newpage</span><span class="p">);</span>
	<span class="n">SetPageSwapBacked</span><span class="p">(</span><span class="n">newpage</span><span class="p">);</span>
	<span class="n">set_page_private</span><span class="p">(</span><span class="n">newpage</span><span class="p">,</span> <span class="n">swap_index</span><span class="p">);</span>
	<span class="n">SetPageSwapCache</span><span class="p">(</span><span class="n">newpage</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Our caller will very soon move newpage out of swapcache, but it&#39;s</span>
<span class="cm">	 * a nice clean interface for us to replace oldpage by newpage there.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_mapping</span><span class="o">-&gt;</span><span class="n">tree_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">shmem_radix_tree_replace</span><span class="p">(</span><span class="n">swap_mapping</span><span class="p">,</span> <span class="n">swap_index</span><span class="p">,</span> <span class="n">oldpage</span><span class="p">,</span>
								   <span class="n">newpage</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__inc_zone_page_state</span><span class="p">(</span><span class="n">newpage</span><span class="p">,</span> <span class="n">NR_FILE_PAGES</span><span class="p">);</span>
		<span class="n">__dec_zone_page_state</span><span class="p">(</span><span class="n">oldpage</span><span class="p">,</span> <span class="n">NR_FILE_PAGES</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_mapping</span><span class="o">-&gt;</span><span class="n">tree_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Is this possible?  I think not, now that our callers check</span>
<span class="cm">		 * both PageSwapCache and page_private after getting page lock;</span>
<span class="cm">		 * but be defensive.  Reverse old to newpage for clear and free.</span>
<span class="cm">		 */</span>
		<span class="n">oldpage</span> <span class="o">=</span> <span class="n">newpage</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mem_cgroup_replace_page_cache</span><span class="p">(</span><span class="n">oldpage</span><span class="p">,</span> <span class="n">newpage</span><span class="p">);</span>
		<span class="n">lru_cache_add_anon</span><span class="p">(</span><span class="n">newpage</span><span class="p">);</span>
		<span class="o">*</span><span class="n">pagep</span> <span class="o">=</span> <span class="n">newpage</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ClearPageSwapCache</span><span class="p">(</span><span class="n">oldpage</span><span class="p">);</span>
	<span class="n">set_page_private</span><span class="p">(</span><span class="n">oldpage</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">unlock_page</span><span class="p">(</span><span class="n">oldpage</span><span class="p">);</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">oldpage</span><span class="p">);</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">oldpage</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * shmem_getpage_gfp - find page in cache, or get from swap, or allocate</span>
<span class="cm"> *</span>
<span class="cm"> * If we allocate a new one we do not mark it dirty. That&#39;s up to the</span>
<span class="cm"> * vm. If we swap it in we mark it dirty since we also free the swap</span>
<span class="cm"> * entry since a page cannot live in both the swap and page cache</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">shmem_getpage_gfp</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pagep</span><span class="p">,</span> <span class="k">enum</span> <span class="n">sgp_type</span> <span class="n">sgp</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">fault_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">shmem_inode_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">shmem_sb_info</span> <span class="o">*</span><span class="n">sbinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="n">swp_entry_t</span> <span class="n">swap</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">once</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">alloced</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">MAX_LFS_FILESIZE</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFBIG</span><span class="p">;</span>
<span class="nl">repeat:</span>
	<span class="n">swap</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">find_lock_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">radix_tree_exceptional_entry</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">swap</span> <span class="o">=</span> <span class="n">radix_to_swp_entry</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sgp</span> <span class="o">!=</span> <span class="n">SGP_WRITE</span> <span class="o">&amp;&amp;</span> <span class="n">sgp</span> <span class="o">!=</span> <span class="n">SGP_FALLOC</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">loff_t</span><span class="p">)</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* fallocated page? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sgp</span> <span class="o">!=</span> <span class="n">SGP_READ</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">clear</span><span class="p">;</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">||</span> <span class="p">(</span><span class="n">sgp</span> <span class="o">==</span> <span class="n">SGP_READ</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">swap</span><span class="p">.</span><span class="n">val</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">pagep</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fast cache lookup did not find it:</span>
<span class="cm">	 * bring it back from swap or allocate.</span>
<span class="cm">	 */</span>
	<span class="n">info</span> <span class="o">=</span> <span class="n">SHMEM_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">sbinfo</span> <span class="o">=</span> <span class="n">SHMEM_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">swap</span><span class="p">.</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Look it up and read it in.. */</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">lookup_swap_cache</span><span class="p">(</span><span class="n">swap</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* here we actually do the io */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fault_type</span><span class="p">)</span>
				<span class="o">*</span><span class="n">fault_type</span> <span class="o">|=</span> <span class="n">VM_FAULT_MAJOR</span><span class="p">;</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">shmem_swapin</span><span class="p">(</span><span class="n">swap</span><span class="p">,</span> <span class="n">gfp</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* We have to do this with page locked to prevent races */</span>
		<span class="n">lock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageSwapCache</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">||</span> <span class="n">page_private</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">!=</span> <span class="n">swap</span><span class="p">.</span><span class="n">val</span> <span class="o">||</span>
		    <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>	<span class="cm">/* try again */</span>
			<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">wait_on_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">shmem_should_replace_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">gfp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">shmem_replace_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="n">gfp</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">mem_cgroup_cache_charge</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span>
						<span class="n">gfp</span> <span class="o">&amp;</span> <span class="n">GFP_RECLAIM_MASK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">shmem_add_to_page_cache</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
						<span class="n">gfp</span><span class="p">,</span> <span class="n">swp_to_radix_entry</span><span class="p">(</span><span class="n">swap</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">swapped</span><span class="o">--</span><span class="p">;</span>
		<span class="n">shmem_recalc_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">delete_from_swap_cache</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">set_page_dirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">swap_free</span><span class="p">(</span><span class="n">swap</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">shmem_acct_block</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">max_blocks</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">percpu_counter_compare</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">used_blocks</span><span class="p">,</span>
						<span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">max_blocks</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">unacct</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">percpu_counter_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">used_blocks</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">page</span> <span class="o">=</span> <span class="n">shmem_alloc_page</span><span class="p">(</span><span class="n">gfp</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">decused</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">SetPageSwapBacked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">__set_page_locked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">mem_cgroup_cache_charge</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span>
						<span class="n">gfp</span> <span class="o">&amp;</span> <span class="n">GFP_RECLAIM_MASK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">shmem_add_to_page_cache</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
						<span class="n">gfp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">decused</span><span class="p">;</span>
		<span class="n">lru_cache_add_anon</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">alloced</span><span class="o">++</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">+=</span> <span class="n">BLOCKS_PER_PAGE</span><span class="p">;</span>
		<span class="n">shmem_recalc_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">alloced</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Let SGP_FALLOC use the SGP_WRITE optimization on a new page.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sgp</span> <span class="o">==</span> <span class="n">SGP_FALLOC</span><span class="p">)</span>
			<span class="n">sgp</span> <span class="o">=</span> <span class="n">SGP_WRITE</span><span class="p">;</span>
<span class="nl">clear:</span>
		<span class="cm">/*</span>
<span class="cm">		 * Let SGP_WRITE caller clear ends if write does not fill page;</span>
<span class="cm">		 * but SGP_FALLOC on a page fallocated earlier must initialize</span>
<span class="cm">		 * it now, lest undo on failure cancel our earlier guarantee.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sgp</span> <span class="o">!=</span> <span class="n">SGP_WRITE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">clear_highpage</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sgp</span> <span class="o">==</span> <span class="n">SGP_DIRTY</span><span class="p">)</span>
			<span class="n">set_page_dirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Perhaps the file has been truncated since we checked */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sgp</span> <span class="o">!=</span> <span class="n">SGP_WRITE</span> <span class="o">&amp;&amp;</span> <span class="n">sgp</span> <span class="o">!=</span> <span class="n">SGP_FALLOC</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">loff_t</span><span class="p">)</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">alloced</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">trunc</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">pagep</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Error recovery.</span>
<span class="cm">	 */</span>
<span class="nl">trunc:</span>
	<span class="n">info</span> <span class="o">=</span> <span class="n">SHMEM_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">ClearPageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">delete_from_page_cache</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">alloced</span><span class="o">--</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">-=</span> <span class="n">BLOCKS_PER_PAGE</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="nl">decused:</span>
	<span class="n">sbinfo</span> <span class="o">=</span> <span class="n">SHMEM_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">max_blocks</span><span class="p">)</span>
		<span class="n">percpu_counter_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">used_blocks</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="nl">unacct:</span>
	<span class="n">shmem_unacct_blocks</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="nl">failed:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">swap</span><span class="p">.</span><span class="n">val</span> <span class="o">&amp;&amp;</span> <span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">test</span> <span class="o">=</span> <span class="n">find_get_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">radix_tree_exceptional_entry</span><span class="p">(</span><span class="n">test</span><span class="p">))</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">test</span><span class="p">);</span>
		<span class="cm">/* Have another try if the entry has changed */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test</span> <span class="o">!=</span> <span class="n">swp_to_radix_entry</span><span class="p">(</span><span class="n">swap</span><span class="p">))</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">once</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span> <span class="o">=</span> <span class="n">SHMEM_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">shmem_recalc_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">shmem_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">VM_FAULT_LOCKED</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">shmem_getpage</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">vmf</span><span class="o">-&gt;</span><span class="n">pgoff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">,</span> <span class="n">SGP_CACHE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ret</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">((</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">)</span> <span class="o">?</span> <span class="n">VM_FAULT_OOM</span> <span class="o">:</span> <span class="n">VM_FAULT_SIGBUS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_MAJOR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">count_vm_event</span><span class="p">(</span><span class="n">PGMAJFAULT</span><span class="p">);</span>
		<span class="n">mem_cgroup_count_vm_event</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">PGMAJFAULT</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NUMA</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">shmem_set_policy</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">mpol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">mpol_set_shared_policy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SHMEM_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">policy</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">mpol</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="nf">shmem_get_policy</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">index</span> <span class="o">=</span> <span class="p">((</span><span class="n">addr</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">mpol_shared_policy_lookup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SHMEM_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">policy</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">int</span> <span class="nf">shmem_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">user_struct</span> <span class="o">*</span><span class="n">user</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">shmem_inode_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">SHMEM_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lock</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">VM_LOCKED</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">user_shm_lock</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">,</span> <span class="n">user</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_nomem</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">VM_LOCKED</span><span class="p">;</span>
		<span class="n">mapping_set_unevictable</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lock</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">VM_LOCKED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">user</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">user_shm_unlock</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">,</span> <span class="n">user</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">VM_LOCKED</span><span class="p">;</span>
		<span class="n">mapping_clear_unevictable</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_nomem:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">shmem_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">file_accessed</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">shmem_vm_ops</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_CAN_NONLINEAR</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">shmem_get_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
				     <span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span> <span class="n">dev_t</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">shmem_inode_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">shmem_sb_info</span> <span class="o">*</span><span class="n">sbinfo</span> <span class="o">=</span> <span class="n">SHMEM_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">shmem_reserve_inode</span><span class="p">(</span><span class="n">sb</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">new_inode</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">=</span> <span class="n">get_next_ino</span><span class="p">();</span>
		<span class="n">inode_init_owner</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">shmem_backing_dev_info</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">CURRENT_TIME</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_generation</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">();</span>
		<span class="n">info</span> <span class="o">=</span> <span class="n">SHMEM_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">inode</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="p">);</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">VM_NORESERVE</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">swaplist</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">xattr_list</span><span class="p">);</span>
		<span class="n">cache_no_acl</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">S_IFMT</span><span class="p">)</span> <span class="p">{</span>
		<span class="nl">default:</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">shmem_special_inode_operations</span><span class="p">;</span>
			<span class="n">init_special_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">S_IFREG</span>:
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">shmem_aops</span><span class="p">;</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">shmem_inode_operations</span><span class="p">;</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">shmem_file_operations</span><span class="p">;</span>
			<span class="n">mpol_shared_policy_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">policy</span><span class="p">,</span>
						 <span class="n">shmem_get_sbmpol</span><span class="p">(</span><span class="n">sbinfo</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">S_IFDIR</span>:
			<span class="n">inc_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="cm">/* Some things misbehave if size == 0 on a directory */</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">BOGO_DIRENT_SIZE</span><span class="p">;</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">shmem_dir_inode_operations</span><span class="p">;</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">simple_dir_operations</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">S_IFLNK</span>:
			<span class="cm">/*</span>
<span class="cm">			 * Must not load anything in the rbtree,</span>
<span class="cm">			 * mpol_free_shared_policy will not be called.</span>
<span class="cm">			 */</span>
			<span class="n">mpol_shared_policy_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">policy</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">shmem_free_inode</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_TMPFS</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">shmem_symlink_inode_operations</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">shmem_short_symlink_operations</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_TMPFS_XATTR</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">shmem_initxattrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">xattr</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp">#define shmem_initxattrs NULL</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">shmem_write_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			<span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pagep</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">fsdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">index</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">shmem_getpage</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">pagep</span><span class="p">,</span> <span class="n">SGP_WRITE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">shmem_write_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			<span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">copied</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fsdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">copied</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span>
		<span class="n">i_size_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">copied</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copied</span> <span class="o">&lt;</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="n">from</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">zero_user_segments</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span>
					<span class="n">from</span> <span class="o">+</span> <span class="n">copied</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">set_page_dirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">copied</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_shmem_file_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span> <span class="n">read_descriptor_t</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="n">read_actor_t</span> <span class="n">actor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">sgp_type</span> <span class="n">sgp</span> <span class="o">=</span> <span class="n">SGP_READ</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Might this read be for a stacking filesystem?  Then when reading</span>
<span class="cm">	 * holes of a sparse file, we actually need to allocate those pages,</span>
<span class="cm">	 * and even mark them dirty, so it cannot exceed the max_blocks limit.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">segment_eq</span><span class="p">(</span><span class="n">get_fs</span><span class="p">(),</span> <span class="n">KERNEL_DS</span><span class="p">))</span>
		<span class="n">sgp</span> <span class="o">=</span> <span class="n">SGP_DIRTY</span><span class="p">;</span>

	<span class="n">index</span> <span class="o">=</span> <span class="o">*</span><span class="n">ppos</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="o">*</span><span class="n">ppos</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_CACHE_MASK</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">pgoff_t</span> <span class="n">end_index</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">loff_t</span> <span class="n">i_size</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

		<span class="n">end_index</span> <span class="o">=</span> <span class="n">i_size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;</span> <span class="n">end_index</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">end_index</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nr</span> <span class="o">=</span> <span class="n">i_size</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_CACHE_MASK</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&lt;=</span> <span class="n">offset</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="n">shmem_getpage</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="n">sgp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">)</span>
				<span class="n">desc</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * We must evaluate after, since reads (unlike writes)</span>
<span class="cm">		 * are called without i_mutex protection against truncate</span>
<span class="cm">		 */</span>
		<span class="n">nr</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">;</span>
		<span class="n">i_size</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">end_index</span> <span class="o">=</span> <span class="n">i_size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">end_index</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nr</span> <span class="o">=</span> <span class="n">i_size</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_CACHE_MASK</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&lt;=</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span>
					<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">nr</span> <span class="o">-=</span> <span class="n">offset</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If users can be writing to this page using arbitrary</span>
<span class="cm">			 * virtual addresses, take care about potential aliasing</span>
<span class="cm">			 * before reading the page on the kernel side.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mapping_writably_mapped</span><span class="p">(</span><span class="n">mapping</span><span class="p">))</span>
				<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Mark the page accessed if we read the beginning.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">offset</span><span class="p">)</span>
				<span class="n">mark_page_accessed</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">ZERO_PAGE</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="n">page_cache_get</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Ok, we have the page, and it&#39;s up-to-date, so</span>
<span class="cm">		 * now we can copy it to user space...</span>
<span class="cm">		 *</span>
<span class="cm">		 * The actor routine returns how many bytes were actually used..</span>
<span class="cm">		 * NOTE! This may not be the same as how much of a user buffer</span>
<span class="cm">		 * we filled up (we may be padding etc), so we can only update</span>
<span class="cm">		 * &quot;pos&quot; here (the actor routine has to update the user buffer</span>
<span class="cm">		 * pointers and the remaining count).</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">actor</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">index</span> <span class="o">+=</span> <span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PAGE_CACHE_MASK</span><span class="p">;</span>

		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">nr</span> <span class="o">||</span> <span class="o">!</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">ppos</span> <span class="o">=</span> <span class="p">((</span><span class="n">loff_t</span><span class="p">)</span> <span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">file_accessed</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">shmem_file_aio_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">seg</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">generic_segment_checks</span><span class="p">(</span><span class="n">iov</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr_segs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="n">VERIFY_WRITE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">seg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">seg</span> <span class="o">&lt;</span> <span class="n">nr_segs</span><span class="p">;</span> <span class="n">seg</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">read_descriptor_t</span> <span class="n">desc</span><span class="p">;</span>

		<span class="n">desc</span><span class="p">.</span><span class="n">written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">desc</span><span class="p">.</span><span class="n">arg</span><span class="p">.</span><span class="n">buf</span> <span class="o">=</span> <span class="n">iov</span><span class="p">[</span><span class="n">seg</span><span class="p">].</span><span class="n">iov_base</span><span class="p">;</span>
		<span class="n">desc</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">iov</span><span class="p">[</span><span class="n">seg</span><span class="p">].</span><span class="n">iov_len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="p">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">desc</span><span class="p">.</span><span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">do_shmem_file_read</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span> <span class="n">file_read_actor</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">+=</span> <span class="n">desc</span><span class="p">.</span><span class="n">written</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="p">.</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">retval</span> <span class="o">?:</span> <span class="n">desc</span><span class="p">.</span><span class="n">error</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="p">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">shmem_file_splice_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">loff</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="n">req_pages</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pages</span><span class="p">[</span><span class="n">PIPE_DEF_BUFFERS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">partial_page</span> <span class="n">partial</span><span class="p">[</span><span class="n">PIPE_DEF_BUFFERS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span> <span class="n">end_index</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">isize</span><span class="p">,</span> <span class="n">left</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">page_nr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">splice_pipe_desc</span> <span class="n">spd</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">pages</span> <span class="o">=</span> <span class="n">pages</span><span class="p">,</span>
		<span class="p">.</span><span class="n">partial</span> <span class="o">=</span> <span class="n">partial</span><span class="p">,</span>
		<span class="p">.</span><span class="n">nr_pages_max</span> <span class="o">=</span> <span class="n">PIPE_DEF_BUFFERS</span><span class="p">,</span>
		<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">,</span>
		<span class="p">.</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">page_cache_pipe_buf_ops</span><span class="p">,</span>
		<span class="p">.</span><span class="n">spd_release</span> <span class="o">=</span> <span class="n">spd_release_page</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="n">isize</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">*</span><span class="n">ppos</span> <span class="o">&gt;=</span> <span class="n">isize</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">left</span> <span class="o">=</span> <span class="n">isize</span> <span class="o">-</span> <span class="o">*</span><span class="n">ppos</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">))</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">splice_grow_spd</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spd</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">index</span> <span class="o">=</span> <span class="o">*</span><span class="n">ppos</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="n">loff</span> <span class="o">=</span> <span class="o">*</span><span class="n">ppos</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_CACHE_MASK</span><span class="p">;</span>
	<span class="n">req_pages</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="n">loff</span> <span class="o">+</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="n">nr_pages</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">req_pages</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">);</span>

	<span class="n">spd</span><span class="p">.</span><span class="n">nr_pages</span> <span class="o">=</span> <span class="n">find_get_pages_contig</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
						<span class="n">nr_pages</span><span class="p">,</span> <span class="n">spd</span><span class="p">.</span><span class="n">pages</span><span class="p">);</span>
	<span class="n">index</span> <span class="o">+=</span> <span class="n">spd</span><span class="p">.</span><span class="n">nr_pages</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">spd</span><span class="p">.</span><span class="n">nr_pages</span> <span class="o">&lt;</span> <span class="n">nr_pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">shmem_getpage</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="n">SGP_CACHE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">spd</span><span class="p">.</span><span class="n">pages</span><span class="p">[</span><span class="n">spd</span><span class="p">.</span><span class="n">nr_pages</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
		<span class="n">index</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">index</span> <span class="o">=</span> <span class="o">*</span><span class="n">ppos</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="n">nr_pages</span> <span class="o">=</span> <span class="n">spd</span><span class="p">.</span><span class="n">nr_pages</span><span class="p">;</span>
	<span class="n">spd</span><span class="p">.</span><span class="n">nr_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">page_nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">page_nr</span> <span class="o">&lt;</span> <span class="n">nr_pages</span><span class="p">;</span> <span class="n">page_nr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">this_len</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">this_len</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="n">loff</span><span class="p">);</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">spd</span><span class="p">.</span><span class="n">pages</span><span class="p">[</span><span class="n">page_nr</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">||</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">!=</span> <span class="n">mapping</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">shmem_getpage</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">,</span>
							<span class="n">SGP_CACHE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">spd</span><span class="p">.</span><span class="n">pages</span><span class="p">[</span><span class="n">page_nr</span><span class="p">]);</span>
			<span class="n">spd</span><span class="p">.</span><span class="n">pages</span><span class="p">[</span><span class="n">page_nr</span><span class="p">]</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">isize</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">end_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">isize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">isize</span> <span class="o">||</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="n">end_index</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">end_index</span> <span class="o">==</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">plen</span><span class="p">;</span>

			<span class="n">plen</span> <span class="o">=</span> <span class="p">((</span><span class="n">isize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_CACHE_MASK</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">plen</span> <span class="o">&lt;=</span> <span class="n">loff</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">this_len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">this_len</span><span class="p">,</span> <span class="n">plen</span> <span class="o">-</span> <span class="n">loff</span><span class="p">);</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">this_len</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">spd</span><span class="p">.</span><span class="n">partial</span><span class="p">[</span><span class="n">page_nr</span><span class="p">].</span><span class="n">offset</span> <span class="o">=</span> <span class="n">loff</span><span class="p">;</span>
		<span class="n">spd</span><span class="p">.</span><span class="n">partial</span><span class="p">[</span><span class="n">page_nr</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="n">this_len</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">this_len</span><span class="p">;</span>
		<span class="n">loff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spd</span><span class="p">.</span><span class="n">nr_pages</span><span class="o">++</span><span class="p">;</span>
		<span class="n">index</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">page_nr</span> <span class="o">&lt;</span> <span class="n">nr_pages</span><span class="p">)</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">spd</span><span class="p">.</span><span class="n">pages</span><span class="p">[</span><span class="n">page_nr</span><span class="o">++</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spd</span><span class="p">.</span><span class="n">nr_pages</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">splice_to_pipe</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spd</span><span class="p">);</span>

	<span class="n">splice_shrink_spd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">ppos</span> <span class="o">+=</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">file_accessed</span><span class="p">(</span><span class="n">in</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * llseek SEEK_DATA or SEEK_HOLE through the radix_tree.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">pgoff_t</span> <span class="nf">shmem_seek_hole_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				    <span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int</span> <span class="n">origin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pagevec</span> <span class="n">pvec</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">indices</span><span class="p">[</span><span class="n">PAGEVEC_SIZE</span><span class="p">];</span>
	<span class="n">bool</span> <span class="n">done</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">pagevec_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">pvec</span><span class="p">.</span><span class="n">nr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>		<span class="cm">/* start small: we may be there already */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pvec</span><span class="p">.</span><span class="n">nr</span> <span class="o">=</span> <span class="n">shmem_find_get_pages_and_swap</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
					<span class="n">pvec</span><span class="p">.</span><span class="n">nr</span><span class="p">,</span> <span class="n">pvec</span><span class="p">.</span><span class="n">pages</span><span class="p">,</span> <span class="n">indices</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pvec</span><span class="p">.</span><span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">origin</span> <span class="o">==</span> <span class="n">SEEK_DATA</span><span class="p">)</span>
				<span class="n">index</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pvec</span><span class="p">.</span><span class="n">nr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">origin</span> <span class="o">==</span> <span class="n">SEEK_HOLE</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">index</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="p">}</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">pvec</span><span class="p">.</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">radix_tree_exceptional_entry</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
					<span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">end</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">page</span> <span class="o">&amp;&amp;</span> <span class="n">origin</span> <span class="o">==</span> <span class="n">SEEK_DATA</span><span class="p">)</span> <span class="o">||</span>
			    <span class="p">(</span><span class="o">!</span><span class="n">page</span> <span class="o">&amp;&amp;</span> <span class="n">origin</span> <span class="o">==</span> <span class="n">SEEK_HOLE</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">shmem_deswap_pagevec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">);</span>
		<span class="n">pagevec_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">);</span>
		<span class="n">pvec</span><span class="p">.</span><span class="n">nr</span> <span class="o">=</span> <span class="n">PAGEVEC_SIZE</span><span class="p">;</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">index</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">loff_t</span> <span class="nf">shmem_file_llseek</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">origin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">new_offset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">origin</span> <span class="o">!=</span> <span class="n">SEEK_DATA</span> <span class="o">&amp;&amp;</span> <span class="n">origin</span> <span class="o">!=</span> <span class="n">SEEK_HOLE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">generic_file_llseek_size</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span>
							<span class="n">MAX_LFS_FILESIZE</span><span class="p">);</span>
	<span class="n">mapping</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>
	<span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="cm">/* We&#39;re holding i_mutex so we can access i_size directly */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">+</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
		<span class="n">new_offset</span> <span class="o">=</span> <span class="n">shmem_seek_hole_data</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">origin</span><span class="p">);</span>
		<span class="n">new_offset</span> <span class="o">&lt;&lt;=</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_offset</span> <span class="o">&gt;</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">new_offset</span> <span class="o">&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span>
				<span class="n">offset</span> <span class="o">=</span> <span class="n">new_offset</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">origin</span> <span class="o">==</span> <span class="n">SEEK_DATA</span><span class="p">)</span>
				<span class="n">offset</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">offset</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">offset</span> <span class="o">!=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_version</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">shmem_fallocate</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span>
							 <span class="n">loff_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">shmem_sb_info</span> <span class="o">*</span><span class="n">sbinfo</span> <span class="o">=</span> <span class="n">SHMEM_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">shmem_falloc</span> <span class="n">shmem_falloc</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">FALLOC_FL_PUNCH_HOLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>
		<span class="n">loff_t</span> <span class="n">unmap_start</span> <span class="o">=</span> <span class="n">round_up</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
		<span class="n">loff_t</span> <span class="n">unmap_end</span> <span class="o">=</span> <span class="n">round_down</span><span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">unmap_end</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">unmap_start</span><span class="p">)</span>
			<span class="n">unmap_mapping_range</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">unmap_start</span><span class="p">,</span>
					    <span class="mi">1</span> <span class="o">+</span> <span class="n">unmap_end</span> <span class="o">-</span> <span class="n">unmap_start</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">shmem_truncate_range</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="cm">/* No need to unmap again: hole-punching leaves COWed pages */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We need to check rlimit even when FALLOC_FL_KEEP_SIZE */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">inode_newsize_ok</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">len</span> <span class="o">+</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="cm">/* Try to avoid a swapstorm if len is impossible to satisfy */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">max_blocks</span> <span class="o">&amp;&amp;</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">max_blocks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">shmem_falloc</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">shmem_falloc</span><span class="p">.</span><span class="n">next</span>  <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">shmem_falloc</span><span class="p">.</span><span class="n">nr_falloced</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">shmem_falloc</span><span class="p">.</span><span class="n">nr_unswapped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">shmem_falloc</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Good, the fallocate(2) manpage permits EINTR: we may have</span>
<span class="cm">		 * been interrupted because we are using up too much memory.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">shmem_falloc</span><span class="p">.</span><span class="n">nr_unswapped</span> <span class="o">&gt;</span> <span class="n">shmem_falloc</span><span class="p">.</span><span class="n">nr_falloced</span><span class="p">)</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">shmem_getpage</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="n">SGP_FALLOC</span><span class="p">,</span>
									<span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Remove the !PageUptodate pages we added */</span>
			<span class="n">shmem_undo_range</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
				<span class="p">(</span><span class="n">loff_t</span><span class="p">)</span><span class="n">start</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">,</span>
				<span class="p">(</span><span class="n">loff_t</span><span class="p">)</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">undone</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Inform shmem_writepage() how far we have reached.</span>
<span class="cm">		 * No need for lock or barrier: we have the page lock.</span>
<span class="cm">		 */</span>
		<span class="n">shmem_falloc</span><span class="p">.</span><span class="n">next</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="n">shmem_falloc</span><span class="p">.</span><span class="n">nr_falloced</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If !PageUptodate, leave it that way so that freeable pages</span>
<span class="cm">		 * can be recognized if we need to rollback on error later.</span>
<span class="cm">		 * But set_page_dirty so that memory pressure will swap rather</span>
<span class="cm">		 * than free the pages we are allocating (and SGP_CACHE pages</span>
<span class="cm">		 * might still be clean: we now need to mark those dirty too).</span>
<span class="cm">		 */</span>
		<span class="n">set_page_dirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">FALLOC_FL_KEEP_SIZE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span>
		<span class="n">i_size_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">CURRENT_TIME</span><span class="p">;</span>
<span class="nl">undone:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">shmem_statfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kstatfs</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">shmem_sb_info</span> <span class="o">*</span><span class="n">sbinfo</span> <span class="o">=</span> <span class="n">SHMEM_SB</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">);</span>

	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_type</span> <span class="o">=</span> <span class="n">TMPFS_MAGIC</span><span class="p">;</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_bsize</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">;</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_namelen</span> <span class="o">=</span> <span class="n">NAME_MAX</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">max_blocks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_blocks</span> <span class="o">=</span> <span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">max_blocks</span><span class="p">;</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_bavail</span> <span class="o">=</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_bfree</span>  <span class="o">=</span> <span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">max_blocks</span> <span class="o">-</span>
				<span class="n">percpu_counter_sum</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">used_blocks</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">max_inodes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_files</span> <span class="o">=</span> <span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">max_inodes</span><span class="p">;</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_ffree</span> <span class="o">=</span> <span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">free_inodes</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* else leave those fields 0 like simple_statfs */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * File creation. Allocate an inode, and we&#39;re done..</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">shmem_mknod</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span> <span class="n">dev_t</span> <span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">shmem_get_inode</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">VM_NORESERVE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">security_inode_init_security</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span>
						     <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">,</span>
						     <span class="n">shmem_initxattrs</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
<span class="cp">#ifdef CONFIG_TMPFS_POSIX_ACL</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">generic_acl_init</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#else</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">+=</span> <span class="n">BOGO_DIRENT_SIZE</span><span class="p">;</span>
		<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">CURRENT_TIME</span><span class="p">;</span>
		<span class="n">d_instantiate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">dget</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span> <span class="cm">/* Extra count - pin the dentry in core */</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">shmem_mkdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">shmem_mknod</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">mode</span> <span class="o">|</span> <span class="n">S_IFDIR</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">inc_nlink</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">shmem_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">shmem_mknod</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">mode</span> <span class="o">|</span> <span class="n">S_IFREG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Link a file..</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">shmem_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * No ordinary (disk based) filesystem counts links as inodes;</span>
<span class="cm">	 * but each new link needs a new dentry, pinning lowmem, and</span>
<span class="cm">	 * tmpfs dentries cannot be pruned until they are unlinked.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">shmem_reserve_inode</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">+=</span> <span class="n">BOGO_DIRENT_SIZE</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">CURRENT_TIME</span><span class="p">;</span>
	<span class="n">inc_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">ihold</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>	<span class="cm">/* New dentry reference */</span>
	<span class="n">dget</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>		<span class="cm">/* Extra pinning count for the created dentry */</span>
	<span class="n">d_instantiate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">shmem_unlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="n">shmem_free_inode</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>

	<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">-=</span> <span class="n">BOGO_DIRENT_SIZE</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">CURRENT_TIME</span><span class="p">;</span>
	<span class="n">drop_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>	<span class="cm">/* Undo the count from &quot;create&quot; - this does all the work */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">shmem_rmdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">simple_empty</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTEMPTY</span><span class="p">;</span>

	<span class="n">drop_nlink</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="n">drop_nlink</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">shmem_unlink</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The VFS layer already does all the dentry stuff for rename,</span>
<span class="cm"> * we just have to decrement the usage count for the target if</span>
<span class="cm"> * it exists so that the VFS layer correctly free&#39;s it when it</span>
<span class="cm"> * gets overwritten.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">shmem_rename</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">old_dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">new_dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new_dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">they_are_dirs</span> <span class="o">=</span> <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">simple_empty</span><span class="p">(</span><span class="n">new_dentry</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTEMPTY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">shmem_unlink</span><span class="p">(</span><span class="n">new_dir</span><span class="p">,</span> <span class="n">new_dentry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">they_are_dirs</span><span class="p">)</span>
			<span class="n">drop_nlink</span><span class="p">(</span><span class="n">old_dir</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">they_are_dirs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">drop_nlink</span><span class="p">(</span><span class="n">old_dir</span><span class="p">);</span>
		<span class="n">inc_nlink</span><span class="p">(</span><span class="n">new_dir</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">old_dir</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">-=</span> <span class="n">BOGO_DIRENT_SIZE</span><span class="p">;</span>
	<span class="n">new_dir</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">+=</span> <span class="n">BOGO_DIRENT_SIZE</span><span class="p">;</span>
	<span class="n">old_dir</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">old_dir</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span>
	<span class="n">new_dir</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">new_dir</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">CURRENT_TIME</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">shmem_symlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">symname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">kaddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">shmem_inode_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">symname</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENAMETOOLONG</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">shmem_get_inode</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">S_IFLNK</span><span class="o">|</span><span class="n">S_IRWXUGO</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">VM_NORESERVE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">security_inode_init_security</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">,</span>
					     <span class="n">shmem_initxattrs</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">info</span> <span class="o">=</span> <span class="n">SHMEM_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">SHORT_SYMLINK_LEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">symlink</span> <span class="o">=</span> <span class="n">kmemdup</span><span class="p">(</span><span class="n">symname</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">symlink</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">shmem_short_symlink_operations</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">shmem_getpage</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="n">SGP_WRITE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">shmem_aops</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">shmem_symlink_inode_operations</span><span class="p">;</span>
		<span class="n">kaddr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">kaddr</span><span class="p">,</span> <span class="n">symname</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">kaddr</span><span class="p">);</span>
		<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">set_page_dirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">+=</span> <span class="n">BOGO_DIRENT_SIZE</span><span class="p">;</span>
	<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">CURRENT_TIME</span><span class="p">;</span>
	<span class="n">d_instantiate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">dget</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">shmem_follow_short_symlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nd_set_link</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">SHMEM_I</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">symlink</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">shmem_follow_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="n">shmem_getpage</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="n">SGP_READ</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">nd_set_link</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">error</span> <span class="o">?</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="o">:</span> <span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">shmem_put_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">nd_get_link</span><span class="p">(</span><span class="n">nd</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">cookie</span><span class="p">;</span>
		<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">mark_page_accessed</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_TMPFS_XATTR</span>
<span class="cm">/*</span>
<span class="cm"> * Superblocks without xattr inode operations may get some security.* xattr</span>
<span class="cm"> * support from the LSM &quot;for free&quot;. As soon as we have any other xattrs</span>
<span class="cm"> * like ACLs, we also need to implement the security.* handlers at</span>
<span class="cm"> * filesystem level, though.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate new xattr and copy in the value; but leave the name to callers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">shmem_xattr</span> <span class="o">*</span><span class="nf">shmem_xattr_alloc</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">shmem_xattr</span> <span class="o">*</span><span class="n">new_xattr</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>

	<span class="cm">/* wrap around? */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">new_xattr</span><span class="p">)</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">new_xattr</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">new_xattr</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_xattr</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">new_xattr</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">new_xattr</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">new_xattr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Callback for security_inode_init_security() for acquiring xattrs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">shmem_initxattrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			    <span class="k">const</span> <span class="k">struct</span> <span class="n">xattr</span> <span class="o">*</span><span class="n">xattr_array</span><span class="p">,</span>
			    <span class="kt">void</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">shmem_inode_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">SHMEM_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">xattr</span> <span class="o">*</span><span class="n">xattr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">shmem_xattr</span> <span class="o">*</span><span class="n">new_xattr</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">xattr</span> <span class="o">=</span> <span class="n">xattr_array</span><span class="p">;</span> <span class="n">xattr</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">xattr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new_xattr</span> <span class="o">=</span> <span class="n">shmem_xattr_alloc</span><span class="p">(</span><span class="n">xattr</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">,</span> <span class="n">xattr</span><span class="o">-&gt;</span><span class="n">value_len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_xattr</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">xattr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">new_xattr</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">XATTR_SECURITY_PREFIX_LEN</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span>
					  <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_xattr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">new_xattr</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="n">new_xattr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">XATTR_SECURITY_PREFIX</span><span class="p">,</span>
		       <span class="n">XATTR_SECURITY_PREFIX_LEN</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">new_xattr</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">+</span> <span class="n">XATTR_SECURITY_PREFIX_LEN</span><span class="p">,</span>
		       <span class="n">xattr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_xattr</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">xattr_list</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">shmem_xattr_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			   <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">shmem_inode_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">shmem_xattr</span> <span class="o">*</span><span class="n">xattr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>

	<span class="n">info</span> <span class="o">=</span> <span class="n">SHMEM_I</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">xattr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">xattr_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">xattr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">xattr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">xattr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">xattr</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">,</span> <span class="n">xattr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">shmem_xattr_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			   <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">shmem_inode_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">SHMEM_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">shmem_xattr</span> <span class="o">*</span><span class="n">xattr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">shmem_xattr</span> <span class="o">*</span><span class="n">new_xattr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* value == NULL means remove */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new_xattr</span> <span class="o">=</span> <span class="n">shmem_xattr_alloc</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_xattr</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">new_xattr</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_xattr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">new_xattr</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">xattr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">xattr_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">xattr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XATTR_CREATE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">xattr</span> <span class="o">=</span> <span class="n">new_xattr</span><span class="p">;</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">new_xattr</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">list_replace</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xattr</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_xattr</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xattr</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XATTR_REPLACE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xattr</span> <span class="o">=</span> <span class="n">new_xattr</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_xattr</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">xattr_list</span><span class="p">);</span>
		<span class="n">xattr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xattr</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">xattr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">xattr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">xattr_handler</span> <span class="o">*</span><span class="n">shmem_xattr_handlers</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_TMPFS_POSIX_ACL</span>
	<span class="o">&amp;</span><span class="n">generic_acl_access_handler</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">generic_acl_default_handler</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="nb">NULL</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">shmem_xattr_validate</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="p">{</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prefix</span><span class="p">;</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span> <span class="p">}</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">{</span> <span class="n">XATTR_SECURITY_PREFIX</span><span class="p">,</span> <span class="n">XATTR_SECURITY_PREFIX_LEN</span> <span class="p">},</span>
		<span class="p">{</span> <span class="n">XATTR_TRUSTED_PREFIX</span><span class="p">,</span> <span class="n">XATTR_TRUSTED_PREFIX_LEN</span> <span class="p">}</span>
	<span class="p">};</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">preflen</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">prefix</span><span class="p">,</span> <span class="n">preflen</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">name</span><span class="p">[</span><span class="n">preflen</span><span class="p">])</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">shmem_getxattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			      <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is a request for a synthetic attribute in the system.*</span>
<span class="cm">	 * namespace use the generic infrastructure to resolve a handler</span>
<span class="cm">	 * for it via sb-&gt;s_xattr.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">XATTR_SYSTEM_PREFIX</span><span class="p">,</span> <span class="n">XATTR_SYSTEM_PREFIX_LEN</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">generic_getxattr</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">shmem_xattr_validate</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">shmem_xattr_get</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">shmem_setxattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is a request for a synthetic attribute in the system.*</span>
<span class="cm">	 * namespace use the generic infrastructure to resolve a handler</span>
<span class="cm">	 * for it via sb-&gt;s_xattr.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">XATTR_SYSTEM_PREFIX</span><span class="p">,</span> <span class="n">XATTR_SYSTEM_PREFIX_LEN</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">generic_setxattr</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">shmem_xattr_validate</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">value</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>  <span class="cm">/* empty EA, do not remove */</span>

	<span class="k">return</span> <span class="n">shmem_xattr_set</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">shmem_removexattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is a request for a synthetic attribute in the system.*</span>
<span class="cm">	 * namespace use the generic infrastructure to resolve a handler</span>
<span class="cm">	 * for it via sb-&gt;s_xattr.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">XATTR_SYSTEM_PREFIX</span><span class="p">,</span> <span class="n">XATTR_SYSTEM_PREFIX_LEN</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">generic_removexattr</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">shmem_xattr_validate</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">shmem_xattr_set</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XATTR_REPLACE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">xattr_is_trusted</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">XATTR_TRUSTED_PREFIX</span><span class="p">,</span> <span class="n">XATTR_TRUSTED_PREFIX_LEN</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">shmem_listxattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">trusted</span> <span class="o">=</span> <span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">shmem_xattr</span> <span class="o">*</span><span class="n">xattr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">shmem_inode_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">info</span> <span class="o">=</span> <span class="n">SHMEM_I</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">xattr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">xattr_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>

		<span class="cm">/* skip &quot;trusted.&quot; attributes for unprivileged callers */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trusted</span> <span class="o">&amp;&amp;</span> <span class="n">xattr_is_trusted</span><span class="p">(</span><span class="n">xattr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">xattr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">used</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">used</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">used</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">xattr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="n">buffer</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">used</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_TMPFS_XATTR */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">shmem_short_symlink_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">readlink</span>	<span class="o">=</span> <span class="n">generic_readlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">follow_link</span>	<span class="o">=</span> <span class="n">shmem_follow_short_symlink</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_TMPFS_XATTR</span>
	<span class="p">.</span><span class="n">setxattr</span>	<span class="o">=</span> <span class="n">shmem_setxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getxattr</span>	<span class="o">=</span> <span class="n">shmem_getxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">listxattr</span>	<span class="o">=</span> <span class="n">shmem_listxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">removexattr</span>	<span class="o">=</span> <span class="n">shmem_removexattr</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">shmem_symlink_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">readlink</span>	<span class="o">=</span> <span class="n">generic_readlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">follow_link</span>	<span class="o">=</span> <span class="n">shmem_follow_link</span><span class="p">,</span>
	<span class="p">.</span><span class="n">put_link</span>	<span class="o">=</span> <span class="n">shmem_put_link</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_TMPFS_XATTR</span>
	<span class="p">.</span><span class="n">setxattr</span>	<span class="o">=</span> <span class="n">shmem_setxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getxattr</span>	<span class="o">=</span> <span class="n">shmem_getxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">listxattr</span>	<span class="o">=</span> <span class="n">shmem_listxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">removexattr</span>	<span class="o">=</span> <span class="n">shmem_removexattr</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">shmem_get_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">child</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ESTALE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">shmem_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ino</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">vfh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u32</span> <span class="o">*</span><span class="n">fh</span> <span class="o">=</span> <span class="n">vfh</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">inum</span> <span class="o">=</span> <span class="n">fh</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">inum</span> <span class="o">=</span> <span class="p">(</span><span class="n">inum</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">|</span> <span class="n">fh</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">return</span> <span class="n">ino</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">==</span> <span class="n">inum</span> <span class="o">&amp;&amp;</span> <span class="n">fh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ino</span><span class="o">-&gt;</span><span class="n">i_generation</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">shmem_fh_to_dentry</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">fid</span> <span class="o">*</span><span class="n">fid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fh_len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fh_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">inum</span> <span class="o">=</span> <span class="n">fid</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">inum</span> <span class="o">=</span> <span class="p">(</span><span class="n">inum</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">|</span> <span class="n">fid</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fh_len</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">ilookup5</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">inum</span> <span class="o">+</span> <span class="n">fid</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
			<span class="n">shmem_match</span><span class="p">,</span> <span class="n">fid</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dentry</span> <span class="o">=</span> <span class="n">d_find_alias</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">dentry</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">shmem_encode_fh</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">__u32</span> <span class="o">*</span><span class="n">fh</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">len</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">len</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">255</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode_unhashed</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Unfortunately insert_inode_hash is not idempotent,</span>
<span class="cm">		 * so as we hash inodes here rather than at creation</span>
<span class="cm">		 * time, we need a lock to ensure we only try</span>
<span class="cm">		 * to do it once</span>
<span class="cm">		 */</span>
		<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode_unhashed</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
			<span class="n">__insert_inode_hash</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
					    <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">+</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_generation</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">fh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_generation</span><span class="p">;</span>
	<span class="n">fh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">;</span>
	<span class="n">fh</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">__u64</span><span class="p">)</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">;</span>

	<span class="o">*</span><span class="n">len</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">export_operations</span> <span class="n">shmem_export_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">get_parent</span>     <span class="o">=</span> <span class="n">shmem_get_parent</span><span class="p">,</span>
	<span class="p">.</span><span class="n">encode_fh</span>      <span class="o">=</span> <span class="n">shmem_encode_fh</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fh_to_dentry</span>	<span class="o">=</span> <span class="n">shmem_fh_to_dentry</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">shmem_parse_options</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">options</span><span class="p">,</span> <span class="k">struct</span> <span class="n">shmem_sb_info</span> <span class="o">*</span><span class="n">sbinfo</span><span class="p">,</span>
			       <span class="n">bool</span> <span class="n">remount</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">this_char</span><span class="p">,</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span><span class="p">;</span>
	<span class="n">uid_t</span> <span class="n">uid</span><span class="p">;</span>
	<span class="n">gid_t</span> <span class="n">gid</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">options</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">this_char</span> <span class="o">=</span> <span class="n">options</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * NUL-terminate this option: unfortunately,</span>
<span class="cm">			 * mount options form a comma-separated list,</span>
<span class="cm">			 * but mpol&#39;s nodelist may also contain commas.</span>
<span class="cm">			 */</span>
			<span class="n">options</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="sc">&#39;,&#39;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">options</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">options</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isdigit</span><span class="p">(</span><span class="o">*</span><span class="n">options</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">options</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">this_char</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">value</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">this_char</span><span class="p">,</span><span class="sc">&#39;=&#39;</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">value</span><span class="o">++</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
			    <span class="s">&quot;tmpfs: No value for mount option &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">this_char</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">this_char</span><span class="p">,</span><span class="s">&quot;size&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
			<span class="n">size</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="o">&amp;</span><span class="n">rest</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">rest</span> <span class="o">==</span> <span class="sc">&#39;%&#39;</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">size</span> <span class="o">&lt;&lt;=</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
				<span class="n">size</span> <span class="o">*=</span> <span class="n">totalram_pages</span><span class="p">;</span>
				<span class="n">do_div</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
				<span class="n">rest</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">rest</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">bad_val</span><span class="p">;</span>
			<span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">max_blocks</span> <span class="o">=</span>
				<span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">this_char</span><span class="p">,</span><span class="s">&quot;nr_blocks&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">max_blocks</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rest</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">rest</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">bad_val</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">this_char</span><span class="p">,</span><span class="s">&quot;nr_inodes&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">max_inodes</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rest</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">rest</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">bad_val</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">this_char</span><span class="p">,</span><span class="s">&quot;mode&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">remount</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rest</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mo">07777</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">rest</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">bad_val</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">this_char</span><span class="p">,</span><span class="s">&quot;uid&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">remount</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">uid</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rest</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">rest</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">bad_val</span><span class="p">;</span>
			<span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">uid</span> <span class="o">=</span> <span class="n">make_kuid</span><span class="p">(</span><span class="n">current_user_ns</span><span class="p">(),</span> <span class="n">uid</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uid_valid</span><span class="p">(</span><span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">bad_val</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">this_char</span><span class="p">,</span><span class="s">&quot;gid&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">remount</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">gid</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rest</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">rest</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">bad_val</span><span class="p">;</span>
			<span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">gid</span> <span class="o">=</span> <span class="n">make_kgid</span><span class="p">(</span><span class="n">current_user_ns</span><span class="p">(),</span> <span class="n">gid</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gid_valid</span><span class="p">(</span><span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">gid</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">bad_val</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">this_char</span><span class="p">,</span><span class="s">&quot;mpol&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mpol_parse_str</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">mpol</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">bad_val</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;tmpfs: Bad mount option %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">this_char</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">bad_val:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;tmpfs: Bad value &#39;%s&#39; for mount option &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">value</span><span class="p">,</span> <span class="n">this_char</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">shmem_remount_fs</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">flags</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">shmem_sb_info</span> <span class="o">*</span><span class="n">sbinfo</span> <span class="o">=</span> <span class="n">SHMEM_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">shmem_sb_info</span> <span class="n">config</span> <span class="o">=</span> <span class="o">*</span><span class="n">sbinfo</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">inodes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">shmem_parse_options</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">config</span><span class="p">,</span> <span class="nb">true</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
	<span class="n">inodes</span> <span class="o">=</span> <span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">max_inodes</span> <span class="o">-</span> <span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">free_inodes</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">percpu_counter_compare</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">used_blocks</span><span class="p">,</span> <span class="n">config</span><span class="p">.</span><span class="n">max_blocks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">max_inodes</span> <span class="o">&lt;</span> <span class="n">inodes</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Those tests disallow limited-&gt;unlimited while any are in use;</span>
<span class="cm">	 * but we must separately disallow unlimited-&gt;limited, because</span>
<span class="cm">	 * in that case we have no record of how much is already in use.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">max_blocks</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">max_blocks</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">max_inodes</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">max_inodes</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">max_blocks</span>  <span class="o">=</span> <span class="n">config</span><span class="p">.</span><span class="n">max_blocks</span><span class="p">;</span>
	<span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">max_inodes</span>  <span class="o">=</span> <span class="n">config</span><span class="p">.</span><span class="n">max_inodes</span><span class="p">;</span>
	<span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">free_inodes</span> <span class="o">=</span> <span class="n">config</span><span class="p">.</span><span class="n">max_inodes</span> <span class="o">-</span> <span class="n">inodes</span><span class="p">;</span>

	<span class="n">mpol_put</span><span class="p">(</span><span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">mpol</span><span class="p">);</span>
	<span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">mpol</span>        <span class="o">=</span> <span class="n">config</span><span class="p">.</span><span class="n">mpol</span><span class="p">;</span>	<span class="cm">/* transfers initial ref */</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">shmem_show_options</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">shmem_sb_info</span> <span class="o">*</span><span class="n">sbinfo</span> <span class="o">=</span> <span class="n">SHMEM_SB</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">max_blocks</span> <span class="o">!=</span> <span class="n">shmem_default_max_blocks</span><span class="p">())</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;,size=%luk&quot;</span><span class="p">,</span>
			<span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">max_blocks</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SHIFT</span> <span class="o">-</span> <span class="mi">10</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">max_inodes</span> <span class="o">!=</span> <span class="n">shmem_default_max_inodes</span><span class="p">())</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;,nr_inodes=%lu&quot;</span><span class="p">,</span> <span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">max_inodes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">!=</span> <span class="p">(</span><span class="n">S_IRWXUGO</span> <span class="o">|</span> <span class="n">S_ISVTX</span><span class="p">))</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;,mode=%03ho&quot;</span><span class="p">,</span> <span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">,</span> <span class="n">GLOBAL_ROOT_UID</span><span class="p">))</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;,uid=%u&quot;</span><span class="p">,</span>
				<span class="n">from_kuid_munged</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_user_ns</span><span class="p">,</span> <span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gid_eq</span><span class="p">(</span><span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">gid</span><span class="p">,</span> <span class="n">GLOBAL_ROOT_GID</span><span class="p">))</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;,gid=%u&quot;</span><span class="p">,</span>
				<span class="n">from_kgid_munged</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_user_ns</span><span class="p">,</span> <span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">gid</span><span class="p">));</span>
	<span class="n">shmem_show_mpol</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">mpol</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_TMPFS */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">shmem_put_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">shmem_sb_info</span> <span class="o">*</span><span class="n">sbinfo</span> <span class="o">=</span> <span class="n">SHMEM_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="n">percpu_counter_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">used_blocks</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sbinfo</span><span class="p">);</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">shmem_fill_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">silent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">shmem_sb_info</span> <span class="o">*</span><span class="n">sbinfo</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Round up to L1_CACHE_BYTES to resist false sharing */</span>
	<span class="n">sbinfo</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">max</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmem_sb_info</span><span class="p">),</span>
				<span class="n">L1_CACHE_BYTES</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sbinfo</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">S_IRWXUGO</span> <span class="o">|</span> <span class="n">S_ISVTX</span><span class="p">;</span>
	<span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">uid</span> <span class="o">=</span> <span class="n">current_fsuid</span><span class="p">();</span>
	<span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">gid</span> <span class="o">=</span> <span class="n">current_fsgid</span><span class="p">();</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span> <span class="o">=</span> <span class="n">sbinfo</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_TMPFS</span>
	<span class="cm">/*</span>
<span class="cm">	 * Per default we only allow half of the physical ram per</span>
<span class="cm">	 * tmpfs instance, limiting inodes to one per page of lowmem;</span>
<span class="cm">	 * but the internal instance is left unlimited.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_NOUSER</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">max_blocks</span> <span class="o">=</span> <span class="n">shmem_default_max_blocks</span><span class="p">();</span>
		<span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">max_inodes</span> <span class="o">=</span> <span class="n">shmem_default_max_inodes</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">shmem_parse_options</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sbinfo</span><span class="p">,</span> <span class="nb">false</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_export_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">shmem_export_ops</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">|=</span> <span class="n">MS_NOSEC</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">|=</span> <span class="n">MS_NOUSER</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">percpu_counter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">used_blocks</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">free_inodes</span> <span class="o">=</span> <span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">max_inodes</span><span class="p">;</span>

	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_maxbytes</span> <span class="o">=</span> <span class="n">MAX_LFS_FILESIZE</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_magic</span> <span class="o">=</span> <span class="n">TMPFS_MAGIC</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">shmem_ops</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_time_gran</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_TMPFS_XATTR</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_xattr</span> <span class="o">=</span> <span class="n">shmem_xattr_handlers</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_TMPFS_POSIX_ACL</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">|=</span> <span class="n">MS_POSIXACL</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">shmem_get_inode</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">S_IFDIR</span> <span class="o">|</span> <span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">VM_NORESERVE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">=</span> <span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="n">sbinfo</span><span class="o">-&gt;</span><span class="n">gid</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span> <span class="o">=</span> <span class="n">d_make_root</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">failed:</span>
	<span class="n">shmem_put_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">shmem_inode_cachep</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">shmem_alloc_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">shmem_inode_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="n">info</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">shmem_inode_cachep</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">shmem_destroy_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span><span class="p">,</span> <span class="n">i_rcu</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">shmem_inode_cachep</span><span class="p">,</span> <span class="n">SHMEM_I</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">shmem_destroy_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="n">mpol_free_shared_policy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SHMEM_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">policy</span><span class="p">);</span>
	<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rcu</span><span class="p">,</span> <span class="n">shmem_destroy_callback</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">shmem_init_inode</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">foo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">shmem_inode_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">foo</span><span class="p">;</span>
	<span class="n">inode_init_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">shmem_init_inodecache</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">shmem_inode_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;shmem_inode_cache&quot;</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmem_inode_info</span><span class="p">),</span>
				<span class="mi">0</span><span class="p">,</span> <span class="n">SLAB_PANIC</span><span class="p">,</span> <span class="n">shmem_init_inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">shmem_destroy_inodecache</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">shmem_inode_cachep</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">shmem_aops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">writepage</span>	<span class="o">=</span> <span class="n">shmem_writepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_page_dirty</span>	<span class="o">=</span> <span class="n">__set_page_dirty_no_writeback</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_TMPFS</span>
	<span class="p">.</span><span class="n">write_begin</span>	<span class="o">=</span> <span class="n">shmem_write_begin</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_end</span>	<span class="o">=</span> <span class="n">shmem_write_end</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">migratepage</span>	<span class="o">=</span> <span class="n">migrate_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">error_remove_page</span> <span class="o">=</span> <span class="n">generic_error_remove_page</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">shmem_file_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">mmap</span>		<span class="o">=</span> <span class="n">shmem_mmap</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_TMPFS</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">shmem_file_llseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">do_sync_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">do_sync_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">aio_read</span>	<span class="o">=</span> <span class="n">shmem_file_aio_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">aio_write</span>	<span class="o">=</span> <span class="n">generic_file_aio_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fsync</span>		<span class="o">=</span> <span class="n">noop_fsync</span><span class="p">,</span>
	<span class="p">.</span><span class="n">splice_read</span>	<span class="o">=</span> <span class="n">shmem_file_splice_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">splice_write</span>	<span class="o">=</span> <span class="n">generic_file_splice_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fallocate</span>	<span class="o">=</span> <span class="n">shmem_fallocate</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">shmem_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">setattr</span>	<span class="o">=</span> <span class="n">shmem_setattr</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_TMPFS_XATTR</span>
	<span class="p">.</span><span class="n">setxattr</span>	<span class="o">=</span> <span class="n">shmem_setxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getxattr</span>	<span class="o">=</span> <span class="n">shmem_getxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">listxattr</span>	<span class="o">=</span> <span class="n">shmem_listxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">removexattr</span>	<span class="o">=</span> <span class="n">shmem_removexattr</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">shmem_dir_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_TMPFS</span>
	<span class="p">.</span><span class="n">create</span>		<span class="o">=</span> <span class="n">shmem_create</span><span class="p">,</span>
	<span class="p">.</span><span class="n">lookup</span>		<span class="o">=</span> <span class="n">simple_lookup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">link</span>		<span class="o">=</span> <span class="n">shmem_link</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlink</span>		<span class="o">=</span> <span class="n">shmem_unlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">symlink</span>	<span class="o">=</span> <span class="n">shmem_symlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mkdir</span>		<span class="o">=</span> <span class="n">shmem_mkdir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rmdir</span>		<span class="o">=</span> <span class="n">shmem_rmdir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mknod</span>		<span class="o">=</span> <span class="n">shmem_mknod</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rename</span>		<span class="o">=</span> <span class="n">shmem_rename</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_TMPFS_XATTR</span>
	<span class="p">.</span><span class="n">setxattr</span>	<span class="o">=</span> <span class="n">shmem_setxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getxattr</span>	<span class="o">=</span> <span class="n">shmem_getxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">listxattr</span>	<span class="o">=</span> <span class="n">shmem_listxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">removexattr</span>	<span class="o">=</span> <span class="n">shmem_removexattr</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_TMPFS_POSIX_ACL</span>
	<span class="p">.</span><span class="n">setattr</span>	<span class="o">=</span> <span class="n">shmem_setattr</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">shmem_special_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_TMPFS_XATTR</span>
	<span class="p">.</span><span class="n">setxattr</span>	<span class="o">=</span> <span class="n">shmem_setxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getxattr</span>	<span class="o">=</span> <span class="n">shmem_getxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">listxattr</span>	<span class="o">=</span> <span class="n">shmem_listxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">removexattr</span>	<span class="o">=</span> <span class="n">shmem_removexattr</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_TMPFS_POSIX_ACL</span>
	<span class="p">.</span><span class="n">setattr</span>	<span class="o">=</span> <span class="n">shmem_setattr</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">super_operations</span> <span class="n">shmem_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">alloc_inode</span>	<span class="o">=</span> <span class="n">shmem_alloc_inode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">destroy_inode</span>	<span class="o">=</span> <span class="n">shmem_destroy_inode</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_TMPFS</span>
	<span class="p">.</span><span class="n">statfs</span>		<span class="o">=</span> <span class="n">shmem_statfs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remount_fs</span>	<span class="o">=</span> <span class="n">shmem_remount_fs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_options</span>	<span class="o">=</span> <span class="n">shmem_show_options</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">evict_inode</span>	<span class="o">=</span> <span class="n">shmem_evict_inode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">drop_inode</span>	<span class="o">=</span> <span class="n">generic_delete_inode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">put_super</span>	<span class="o">=</span> <span class="n">shmem_put_super</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">vm_operations_struct</span> <span class="n">shmem_vm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">fault</span>		<span class="o">=</span> <span class="n">shmem_fault</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_NUMA</span>
	<span class="p">.</span><span class="n">set_policy</span>     <span class="o">=</span> <span class="n">shmem_set_policy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_policy</span>     <span class="o">=</span> <span class="n">shmem_get_policy</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">shmem_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">fs_type</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mount_nodev</span><span class="p">(</span><span class="n">fs_type</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">shmem_fill_super</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">file_system_type</span> <span class="n">shmem_fs_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;tmpfs&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mount</span>		<span class="o">=</span> <span class="n">shmem_mount</span><span class="p">,</span>
	<span class="p">.</span><span class="n">kill_sb</span>	<span class="o">=</span> <span class="n">kill_litter_super</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">shmem_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">bdi_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shmem_backing_dev_info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out4</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">shmem_init_inodecache</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out3</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">register_filesystem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shmem_fs_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Could not register tmpfs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">shm_mnt</span> <span class="o">=</span> <span class="n">vfs_kern_mount</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shmem_fs_type</span><span class="p">,</span> <span class="n">MS_NOUSER</span><span class="p">,</span>
				 <span class="n">shmem_fs_type</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">shm_mnt</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">shm_mnt</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Could not kern_mount tmpfs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out1:</span>
	<span class="n">unregister_filesystem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shmem_fs_type</span><span class="p">);</span>
<span class="nl">out2:</span>
	<span class="n">shmem_destroy_inodecache</span><span class="p">();</span>
<span class="nl">out3:</span>
	<span class="n">bdi_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shmem_backing_dev_info</span><span class="p">);</span>
<span class="nl">out4:</span>
	<span class="n">shm_mnt</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* !CONFIG_SHMEM */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * tiny-shmem: simple shmemfs and tmpfs using ramfs code</span>
<span class="cm"> *</span>
<span class="cm"> * This is intended for small system where the benefits of the full</span>
<span class="cm"> * shmem code (swap-backed and resource-limited) are outweighed by</span>
<span class="cm"> * their complexity. On systems without swap this code should be</span>
<span class="cm"> * effectively equivalent, but much lighter weight.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/ramfs.h&gt;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">file_system_type</span> <span class="n">shmem_fs_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;tmpfs&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mount</span>		<span class="o">=</span> <span class="n">ramfs_mount</span><span class="p">,</span>
	<span class="p">.</span><span class="n">kill_sb</span>	<span class="o">=</span> <span class="n">kill_litter_super</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">shmem_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">register_filesystem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shmem_fs_type</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">shm_mnt</span> <span class="o">=</span> <span class="n">kern_mount</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shmem_fs_type</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">shm_mnt</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">shmem_unuse</span><span class="p">(</span><span class="n">swp_entry_t</span> <span class="n">swap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">shmem_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">user_struct</span> <span class="o">*</span><span class="n">user</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">shmem_unlock_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">shmem_truncate_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">lstart</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">lend</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">truncate_inode_pages_range</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">lstart</span><span class="p">,</span> <span class="n">lend</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">shmem_truncate_range</span><span class="p">);</span>

<span class="cp">#define shmem_vm_ops				generic_file_vm_ops</span>
<span class="cp">#define shmem_file_operations			ramfs_file_operations</span>
<span class="cp">#define shmem_get_inode(sb, dir, mode, dev, flags)	ramfs_get_inode(sb, dir, mode, dev)</span>
<span class="cp">#define shmem_acct_size(flags, size)		0</span>
<span class="cp">#define shmem_unacct_size(flags, size)		do {} while (0)</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_SHMEM */</span><span class="cp"></span>

<span class="cm">/* common code */</span>

<span class="cm">/**</span>
<span class="cm"> * shmem_file_setup - get an unlinked file living in tmpfs</span>
<span class="cm"> * @name: name for dentry (to be seen in /proc/&lt;pid&gt;/maps</span>
<span class="cm"> * @size: size to be set for the file</span>
<span class="cm"> * @flags: VM_NORESERVE suppresses pre-accounting of the entire object size</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="nf">shmem_file_setup</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qstr</span> <span class="n">this</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">shm_mnt</span><span class="p">))</span>
		<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">shm_mnt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">MAX_LFS_FILESIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">shmem_acct_size</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">this</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
	<span class="n">this</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="n">this</span><span class="p">.</span><span class="n">hash</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* will go */</span>
	<span class="n">root</span> <span class="o">=</span> <span class="n">shm_mnt</span><span class="o">-&gt;</span><span class="n">mnt_root</span><span class="p">;</span>
	<span class="n">path</span><span class="p">.</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">d_alloc</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">this</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">put_memory</span><span class="p">;</span>
	<span class="n">path</span><span class="p">.</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">mntget</span><span class="p">(</span><span class="n">shm_mnt</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="n">inode</span> <span class="o">=</span> <span class="n">shmem_get_inode</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">S_IFREG</span> <span class="o">|</span> <span class="n">S_IRWXUGO</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">put_dentry</span><span class="p">;</span>

	<span class="n">d_instantiate</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">clear_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>	<span class="cm">/* It is unlinked */</span>
<span class="cp">#ifndef CONFIG_MMU</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">ramfs_nommu_expand_for_mapping</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">put_dentry</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENFILE</span><span class="p">;</span>
	<span class="n">file</span> <span class="o">=</span> <span class="n">alloc_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">,</span> <span class="n">FMODE_WRITE</span> <span class="o">|</span> <span class="n">FMODE_READ</span><span class="p">,</span>
		  <span class="o">&amp;</span><span class="n">shmem_file_operations</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">put_dentry</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">file</span><span class="p">;</span>

<span class="nl">put_dentry:</span>
	<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
<span class="nl">put_memory:</span>
	<span class="n">shmem_unacct_size</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">shmem_file_setup</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * shmem_zero_setup - setup a shared anonymous mapping</span>
<span class="cm"> * @vma: the vma to be mmapped is prepared by do_mmap_pgoff</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">shmem_zero_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>

	<span class="n">file</span> <span class="o">=</span> <span class="n">shmem_file_setup</span><span class="p">(</span><span class="s">&quot;dev/zero&quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">file</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">)</span>
		<span class="n">fput</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">);</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span> <span class="o">=</span> <span class="n">file</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">shmem_vm_ops</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_CAN_NONLINEAR</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * shmem_read_mapping_page_gfp - read into page cache, using specified page allocation flags.</span>
<span class="cm"> * @mapping:	the page&#39;s address_space</span>
<span class="cm"> * @index:	the page index</span>
<span class="cm"> * @gfp:	the page allocator flags to use if allocating</span>
<span class="cm"> *</span>
<span class="cm"> * This behaves as a tmpfs &quot;read_cache_page_gfp(mapping, index, gfp)&quot;,</span>
<span class="cm"> * with any new page allocations done using the specified allocation flags.</span>
<span class="cm"> * But read_cache_page_gfp() uses the -&gt;readpage() method: which does not</span>
<span class="cm"> * suit tmpfs, since it may have pages in swapcache, and needs to find those</span>
<span class="cm"> * for itself; although drivers/gpu/drm i915 and ttm rely upon this support.</span>
<span class="cm"> *</span>
<span class="cm"> * i915_gem_object_get_pages_gtt() mixes __GFP_NORETRY | __GFP_NOWARN in</span>
<span class="cm"> * with the mapping_gfp_mask(), to avoid OOMing the machine unnecessarily.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">shmem_read_mapping_page_gfp</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
					 <span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SHMEM</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">shmem_aops</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">shmem_getpage_gfp</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="n">SGP_CACHE</span><span class="p">,</span> <span class="n">gfp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="cm">/*</span>
<span class="cm">	 * The tiny !SHMEM case uses ramfs without swap</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">read_cache_page_gfp</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">shmem_read_mapping_page_gfp</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
