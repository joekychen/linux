<!DOCTYPE html>
<html><head><title>joekychen/linux » mm › filemap.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>filemap.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *	linux/mm/filemap.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1994-1999  Linus Torvalds</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This file handles the generic file mmap semantics used by</span>
<span class="cm"> * most &quot;normal&quot; filesystems (but you don&#39;t /have/ to use this:</span>
<span class="cm"> * the NFS filesystem used to do this differently, for example)</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/aio.h&gt;</span>
<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/kernel_stat.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/mman.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/uio.h&gt;</span>
<span class="cp">#include &lt;linux/hash.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>
<span class="cp">#include &lt;linux/backing-dev.h&gt;</span>
<span class="cp">#include &lt;linux/pagevec.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/cpuset.h&gt;</span>
<span class="cp">#include &lt;linux/hardirq.h&gt; </span><span class="cm">/* for BUG_ON(!in_atomic()) only */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/memcontrol.h&gt;</span>
<span class="cp">#include &lt;linux/cleancache.h&gt;</span>
<span class="cp">#include &quot;internal.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * FIXME: remove all knowledge of the buffer layer from the core VM</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/buffer_head.h&gt; </span><span class="cm">/* for try_to_free_buffers */</span><span class="cp"></span>

<span class="cp">#include &lt;asm/mman.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Shared mappings implemented 30.11.1994. It&#39;s not fully working yet,</span>
<span class="cm"> * though.</span>
<span class="cm"> *</span>
<span class="cm"> * Shared mappings now work. 15.8.1995  Bruno.</span>
<span class="cm"> *</span>
<span class="cm"> * finished &#39;unifying&#39; the page and buffer cache and SMP-threaded the</span>
<span class="cm"> * page-cache, 21.05.1999, Ingo Molnar &lt;mingo@redhat.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * SMP-threaded pagemap-LRU 1999, Andrea Arcangeli &lt;andrea@suse.de&gt;</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Lock ordering:</span>
<span class="cm"> *</span>
<span class="cm"> *  -&gt;i_mmap_mutex		(truncate_pagecache)</span>
<span class="cm"> *    -&gt;private_lock		(__free_pte-&gt;__set_page_dirty_buffers)</span>
<span class="cm"> *      -&gt;swap_lock		(exclusive_swap_page, others)</span>
<span class="cm"> *        -&gt;mapping-&gt;tree_lock</span>
<span class="cm"> *</span>
<span class="cm"> *  -&gt;i_mutex</span>
<span class="cm"> *    -&gt;i_mmap_mutex		(truncate-&gt;unmap_mapping_range)</span>
<span class="cm"> *</span>
<span class="cm"> *  -&gt;mmap_sem</span>
<span class="cm"> *    -&gt;i_mmap_mutex</span>
<span class="cm"> *      -&gt;page_table_lock or pte_lock	(various, mainly in memory.c)</span>
<span class="cm"> *        -&gt;mapping-&gt;tree_lock	(arch-dependent flush_dcache_mmap_lock)</span>
<span class="cm"> *</span>
<span class="cm"> *  -&gt;mmap_sem</span>
<span class="cm"> *    -&gt;lock_page		(access_process_vm)</span>
<span class="cm"> *</span>
<span class="cm"> *  -&gt;i_mutex			(generic_file_buffered_write)</span>
<span class="cm"> *    -&gt;mmap_sem		(fault_in_pages_readable-&gt;do_page_fault)</span>
<span class="cm"> *</span>
<span class="cm"> *  bdi-&gt;wb.list_lock</span>
<span class="cm"> *    sb_lock			(fs/fs-writeback.c)</span>
<span class="cm"> *    -&gt;mapping-&gt;tree_lock	(__sync_single_inode)</span>
<span class="cm"> *</span>
<span class="cm"> *  -&gt;i_mmap_mutex</span>
<span class="cm"> *    -&gt;anon_vma.lock		(vma_adjust)</span>
<span class="cm"> *</span>
<span class="cm"> *  -&gt;anon_vma.lock</span>
<span class="cm"> *    -&gt;page_table_lock or pte_lock	(anon_vma_prepare and various)</span>
<span class="cm"> *</span>
<span class="cm"> *  -&gt;page_table_lock or pte_lock</span>
<span class="cm"> *    -&gt;swap_lock		(try_to_unmap_one)</span>
<span class="cm"> *    -&gt;private_lock		(try_to_unmap_one)</span>
<span class="cm"> *    -&gt;tree_lock		(try_to_unmap_one)</span>
<span class="cm"> *    -&gt;zone.lru_lock		(follow_page-&gt;mark_page_accessed)</span>
<span class="cm"> *    -&gt;zone.lru_lock		(check_pte_range-&gt;isolate_lru_page)</span>
<span class="cm"> *    -&gt;private_lock		(page_remove_rmap-&gt;set_page_dirty)</span>
<span class="cm"> *    -&gt;tree_lock		(page_remove_rmap-&gt;set_page_dirty)</span>
<span class="cm"> *    bdi.wb-&gt;list_lock		(page_remove_rmap-&gt;set_page_dirty)</span>
<span class="cm"> *    -&gt;inode-&gt;i_lock		(page_remove_rmap-&gt;set_page_dirty)</span>
<span class="cm"> *    bdi.wb-&gt;list_lock		(zap_pte_range-&gt;set_page_dirty)</span>
<span class="cm"> *    -&gt;inode-&gt;i_lock		(zap_pte_range-&gt;set_page_dirty)</span>
<span class="cm"> *    -&gt;private_lock		(zap_pte_range-&gt;__set_page_dirty_buffers)</span>
<span class="cm"> *</span>
<span class="cm"> * -&gt;i_mmap_mutex</span>
<span class="cm"> *   -&gt;tasklist_lock            (memory_failure, collect_procs_ao)</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Delete a page from the page cache and free it. Caller has to make</span>
<span class="cm"> * sure the page is locked and that nobody else uses it - or that usage</span>
<span class="cm"> * is safe.  The caller must hold the mapping&#39;s tree_lock.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__delete_from_page_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * if we&#39;re uptodate, flush out into the cleancache, otherwise</span>
<span class="cm">	 * invalidate any existing cleancache entries.  We can&#39;t leave</span>
<span class="cm">	 * stale data around in the cleancache once our page is gone</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">PageMappedToDisk</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">cleancache_put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">cleancache_invalidate_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>

	<span class="n">radix_tree_delete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">page_tree</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
	<span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/* Leave page-&gt;index set: truncation lookup relies upon it */</span>
	<span class="n">mapping</span><span class="o">-&gt;</span><span class="n">nrpages</span><span class="o">--</span><span class="p">;</span>
	<span class="n">__dec_zone_page_state</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">NR_FILE_PAGES</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageSwapBacked</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">__dec_zone_page_state</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">NR_SHMEM</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">page_mapped</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some filesystems seem to re-dirty the page even after</span>
<span class="cm">	 * the VM has canceled the dirty bit (eg ext3 journaling).</span>
<span class="cm">	 *</span>
<span class="cm">	 * Fix it up by doing a final dirty accounting check after</span>
<span class="cm">	 * having removed the page entirely.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">mapping_cap_account_dirty</span><span class="p">(</span><span class="n">mapping</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dec_zone_page_state</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">NR_FILE_DIRTY</span><span class="p">);</span>
		<span class="n">dec_bdi_stat</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">,</span> <span class="n">BDI_RECLAIMABLE</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * delete_from_page_cache - delete page from page cache</span>
<span class="cm"> * @page: the page which the kernel is trying to remove from page cache</span>
<span class="cm"> *</span>
<span class="cm"> * This must be called only on pages that have been verified to be in the page</span>
<span class="cm"> * cache and locked.  It will never put the page into the free list, the caller</span>
<span class="cm"> * has a reference on the page.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">delete_from_page_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">freepage</span><span class="p">)(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="n">freepage</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">freepage</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">tree_lock</span><span class="p">);</span>
	<span class="n">__delete_from_page_cache</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">tree_lock</span><span class="p">);</span>
	<span class="n">mem_cgroup_uncharge_cache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">freepage</span><span class="p">)</span>
		<span class="n">freepage</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">delete_from_page_cache</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sleep_on_page</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">word</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">io_schedule</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sleep_on_page_killable</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">word</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sleep_on_page</span><span class="p">(</span><span class="n">word</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">fatal_signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="n">EINTR</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __filemap_fdatawrite_range - start writeback on mapping dirty pages in range</span>
<span class="cm"> * @mapping:	address space structure to write</span>
<span class="cm"> * @start:	offset in bytes where the range starts</span>
<span class="cm"> * @end:	offset in bytes where the range ends (inclusive)</span>
<span class="cm"> * @sync_mode:	enable synchronous operation</span>
<span class="cm"> *</span>
<span class="cm"> * Start writeback against all of a mapping&#39;s dirty pages that lie</span>
<span class="cm"> * within the byte offsets &lt;start, end&gt; inclusive.</span>
<span class="cm"> *</span>
<span class="cm"> * If sync_mode is WB_SYNC_ALL then this is a &quot;data integrity&quot; operation, as</span>
<span class="cm"> * opposed to a regular memory cleansing writeback.  The difference between</span>
<span class="cm"> * these two operations is that if a dirty page/buffer is encountered, it must</span>
<span class="cm"> * be waited upon, and not just skipped over.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__filemap_fdatawrite_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">start</span><span class="p">,</span>
				<span class="n">loff_t</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sync_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">writeback_control</span> <span class="n">wbc</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">sync_mode</span> <span class="o">=</span> <span class="n">sync_mode</span><span class="p">,</span>
		<span class="p">.</span><span class="n">nr_to_write</span> <span class="o">=</span> <span class="n">LONG_MAX</span><span class="p">,</span>
		<span class="p">.</span><span class="n">range_start</span> <span class="o">=</span> <span class="n">start</span><span class="p">,</span>
		<span class="p">.</span><span class="n">range_end</span> <span class="o">=</span> <span class="n">end</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapping_cap_writeback_dirty</span><span class="p">(</span><span class="n">mapping</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">do_writepages</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wbc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__filemap_fdatawrite</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">sync_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__filemap_fdatawrite_range</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">LLONG_MAX</span><span class="p">,</span> <span class="n">sync_mode</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">filemap_fdatawrite</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__filemap_fdatawrite</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">WB_SYNC_ALL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">filemap_fdatawrite</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">filemap_fdatawrite_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">start</span><span class="p">,</span>
				<span class="n">loff_t</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__filemap_fdatawrite_range</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">WB_SYNC_ALL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">filemap_fdatawrite_range</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * filemap_flush - mostly a non-blocking flush</span>
<span class="cm"> * @mapping:	target address_space</span>
<span class="cm"> *</span>
<span class="cm"> * This is a mostly non-blocking flush.  Not suitable for data-integrity</span>
<span class="cm"> * purposes - I/O may not be started against all dirty pages.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">filemap_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__filemap_fdatawrite</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">WB_SYNC_NONE</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">filemap_flush</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * filemap_fdatawait_range - wait for writeback to complete</span>
<span class="cm"> * @mapping:		address space structure to wait for</span>
<span class="cm"> * @start_byte:		offset in bytes where the range starts</span>
<span class="cm"> * @end_byte:		offset in bytes where the range ends (inclusive)</span>
<span class="cm"> *</span>
<span class="cm"> * Walk the list of under-writeback pages of the given address space</span>
<span class="cm"> * in the given range and wait for all of them.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">filemap_fdatawait_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">start_byte</span><span class="p">,</span>
			    <span class="n">loff_t</span> <span class="n">end_byte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgoff_t</span> <span class="n">index</span> <span class="o">=</span> <span class="n">start_byte</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">end</span> <span class="o">=</span> <span class="n">end_byte</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pagevec</span> <span class="n">pvec</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_pages</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">end_byte</span> <span class="o">&lt;</span> <span class="n">start_byte</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pagevec_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">index</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">nr_pages</span> <span class="o">=</span> <span class="n">pagevec_lookup_tag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">index</span><span class="p">,</span>
			<span class="n">PAGECACHE_TAG_WRITEBACK</span><span class="p">,</span>
			<span class="n">min</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">pgoff_t</span><span class="p">)</span><span class="n">PAGEVEC_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">pvec</span><span class="p">.</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="cm">/* until radix tree lookup accepts end_index */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">wait_on_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">TestClearPageError</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pagevec_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">);</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/* Check for outstanding write errors */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">AS_ENOSPC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">AS_EIO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">filemap_fdatawait_range</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * filemap_fdatawait - wait for all under-writeback pages to complete</span>
<span class="cm"> * @mapping: address space structure to wait for</span>
<span class="cm"> *</span>
<span class="cm"> * Walk the list of under-writeback pages of the given address space</span>
<span class="cm"> * and wait for all of them.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">filemap_fdatawait</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">loff_t</span> <span class="n">i_size</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">filemap_fdatawait_range</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">filemap_fdatawait</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">filemap_write_and_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">nrpages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">filemap_fdatawrite</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Even if the above returned error, the pages may be</span>
<span class="cm">		 * written partially (e.g. -ENOSPC), so we wait for it.</span>
<span class="cm">		 * But the -EIO is special case, it may indicate the worst</span>
<span class="cm">		 * thing (e.g. bug) happened, so we avoid waiting for it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">err2</span> <span class="o">=</span> <span class="n">filemap_fdatawait</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">err2</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">filemap_write_and_wait</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * filemap_write_and_wait_range - write out &amp; wait on a file range</span>
<span class="cm"> * @mapping:	the address_space for the pages</span>
<span class="cm"> * @lstart:	offset in bytes where the range starts</span>
<span class="cm"> * @lend:	offset in bytes where the range ends (inclusive)</span>
<span class="cm"> *</span>
<span class="cm"> * Write out and wait upon file offsets lstart-&gt;lend, inclusive.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that `lend&#39; is inclusive (describes the last byte to be written) so</span>
<span class="cm"> * that this function can be used to write to the very end-of-file (end = -1).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">filemap_write_and_wait_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				 <span class="n">loff_t</span> <span class="n">lstart</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">lend</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">nrpages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">__filemap_fdatawrite_range</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">lstart</span><span class="p">,</span> <span class="n">lend</span><span class="p">,</span>
						 <span class="n">WB_SYNC_ALL</span><span class="p">);</span>
		<span class="cm">/* See comment of filemap_write_and_wait() */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">err2</span> <span class="o">=</span> <span class="n">filemap_fdatawait_range</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span>
						<span class="n">lstart</span><span class="p">,</span> <span class="n">lend</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">err2</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">filemap_write_and_wait_range</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * replace_page_cache_page - replace a pagecache page with a new one</span>
<span class="cm"> * @old:	page to be replaced</span>
<span class="cm"> * @new:	page to replace with</span>
<span class="cm"> * @gfp_mask:	allocation mode</span>
<span class="cm"> *</span>
<span class="cm"> * This function replaces a page in the pagecache with a new one.  On</span>
<span class="cm"> * success it acquires the pagecache reference for the new page and</span>
<span class="cm"> * drops it for the old page.  Both the old and new pages must be</span>
<span class="cm"> * locked.  This function does not add the new page to the LRU, the</span>
<span class="cm"> * caller must do that.</span>
<span class="cm"> *</span>
<span class="cm"> * The remove + add is atomic.  The only way this function can fail is</span>
<span class="cm"> * memory allocation failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">replace_page_cache_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">old</span><span class="p">));</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">new</span><span class="p">));</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">radix_tree_preload</span><span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">__GFP_HIGHMEM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">;</span>
		<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">freepage</span><span class="p">)(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">);</span>

		<span class="n">pgoff_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
		<span class="n">freepage</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">freepage</span><span class="p">;</span>

		<span class="n">page_cache_get</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
		<span class="n">new</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">;</span>
		<span class="n">new</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">tree_lock</span><span class="p">);</span>
		<span class="n">__delete_from_page_cache</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">radix_tree_insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">page_tree</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
		<span class="n">mapping</span><span class="o">-&gt;</span><span class="n">nrpages</span><span class="o">++</span><span class="p">;</span>
		<span class="n">__inc_zone_page_state</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">NR_FILE_PAGES</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageSwapBacked</span><span class="p">(</span><span class="n">new</span><span class="p">))</span>
			<span class="n">__inc_zone_page_state</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">NR_SHMEM</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">tree_lock</span><span class="p">);</span>
		<span class="cm">/* mem_cgroup codes must not be called under tree_lock */</span>
		<span class="n">mem_cgroup_replace_page_cache</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
		<span class="n">radix_tree_preload_end</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">freepage</span><span class="p">)</span>
			<span class="n">freepage</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">replace_page_cache_page</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * add_to_page_cache_locked - add a locked page to the pagecache</span>
<span class="cm"> * @page:	page to add</span>
<span class="cm"> * @mapping:	the page&#39;s address_space</span>
<span class="cm"> * @offset:	page index</span>
<span class="cm"> * @gfp_mask:	page allocation mode</span>
<span class="cm"> *</span>
<span class="cm"> * This function is used to add a page to the pagecache. It must be locked.</span>
<span class="cm"> * This function does not add the page to the LRU.  The caller must do that.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">add_to_page_cache_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
		<span class="n">pgoff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">PageSwapBacked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">mem_cgroup_cache_charge</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span>
					<span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">GFP_RECLAIM_MASK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">radix_tree_preload</span><span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">__GFP_HIGHMEM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page_cache_get</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">;</span>
		<span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">tree_lock</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">radix_tree_insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">page_tree</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mapping</span><span class="o">-&gt;</span><span class="n">nrpages</span><span class="o">++</span><span class="p">;</span>
			<span class="n">__inc_zone_page_state</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">NR_FILE_PAGES</span><span class="p">);</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">tree_lock</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="cm">/* Leave page-&gt;index set: truncation relies upon it */</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">tree_lock</span><span class="p">);</span>
			<span class="n">mem_cgroup_uncharge_cache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">radix_tree_preload_end</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">mem_cgroup_uncharge_cache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">add_to_page_cache_locked</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">add_to_page_cache_lru</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				<span class="n">pgoff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">add_to_page_cache</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">lru_cache_add_file</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">add_to_page_cache_lru</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_NUMA</span>
<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">__page_cache_alloc</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpuset_do_page_mem_spread</span><span class="p">())</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpuset_mems_cookie</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">cpuset_mems_cookie</span> <span class="o">=</span> <span class="n">get_mems_allowed</span><span class="p">();</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">cpuset_mem_spread_node</span><span class="p">();</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_pages_exact_node</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">gfp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">put_mems_allowed</span><span class="p">(</span><span class="n">cpuset_mems_cookie</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">page</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">alloc_pages</span><span class="p">(</span><span class="n">gfp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__page_cache_alloc</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * In order to wait for pages to become available there must be</span>
<span class="cm"> * waitqueues associated with pages. By using a hash table of</span>
<span class="cm"> * waitqueues where the bucket discipline is to maintain all</span>
<span class="cm"> * waiters on the same queue and wake all when any of the pages</span>
<span class="cm"> * become available, and for the woken contexts to check to be</span>
<span class="cm"> * sure the appropriate page became available, this saves space</span>
<span class="cm"> * at a cost of &quot;thundering herd&quot; phenomena during rare hash</span>
<span class="cm"> * collisions.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="nf">page_waitqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span> <span class="o">=</span> <span class="n">page_zone</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">wait_table</span><span class="p">[</span><span class="n">hash_ptr</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">zone</span><span class="o">-&gt;</span><span class="n">wait_table_bits</span><span class="p">)];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">wake_up_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__wake_up_bit</span><span class="p">(</span><span class="n">page_waitqueue</span><span class="p">(</span><span class="n">page</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">bit</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">wait_on_page_bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bit_nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DEFINE_WAIT_BIT</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">bit_nr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">bit_nr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">__wait_on_bit</span><span class="p">(</span><span class="n">page_waitqueue</span><span class="p">(</span><span class="n">page</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">sleep_on_page</span><span class="p">,</span>
							<span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">wait_on_page_bit</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">wait_on_page_bit_killable</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bit_nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DEFINE_WAIT_BIT</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">bit_nr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">bit_nr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">__wait_on_bit</span><span class="p">(</span><span class="n">page_waitqueue</span><span class="p">(</span><span class="n">page</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span>
			     <span class="n">sleep_on_page_killable</span><span class="p">,</span> <span class="n">TASK_KILLABLE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * add_page_wait_queue - Add an arbitrary waiter to a page&#39;s wait queue</span>
<span class="cm"> * @page: Page defining the wait queue of interest</span>
<span class="cm"> * @waiter: Waiter to add to the queue</span>
<span class="cm"> *</span>
<span class="cm"> * Add an arbitrary @waiter to the wait queue for the nominated @page.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">add_page_wait_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">wait_queue_t</span> <span class="o">*</span><span class="n">waiter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">page_waitqueue</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__add_wait_queue</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">waiter</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">add_page_wait_queue</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * unlock_page - unlock a locked page</span>
<span class="cm"> * @page: the page</span>
<span class="cm"> *</span>
<span class="cm"> * Unlocks the page and wakes up sleepers in ___wait_on_page_locked().</span>
<span class="cm"> * Also wakes sleepers in wait_on_page_writeback() because the wakeup</span>
<span class="cm"> * mechananism between PageLocked pages and PageWriteback pages is shared.</span>
<span class="cm"> * But that&#39;s OK - sleepers in wait_on_page_writeback() just go back to sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * The mb is necessary to enforce ordering between the clear_bit and the read</span>
<span class="cm"> * of the waitqueue (to avoid SMP races with a parallel wait_on_page_locked()).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">unlock_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">clear_bit_unlock</span><span class="p">(</span><span class="n">PG_locked</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">smp_mb__after_clear_bit</span><span class="p">();</span>
	<span class="n">wake_up_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">PG_locked</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">unlock_page</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * end_page_writeback - end writeback against a page</span>
<span class="cm"> * @page: the page</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">end_page_writeback</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TestClearPageReclaim</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">rotate_reclaimable_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_clear_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="n">smp_mb__after_clear_bit</span><span class="p">();</span>
	<span class="n">wake_up_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">PG_writeback</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">end_page_writeback</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __lock_page - get a lock on the page, assuming we need to sleep to get it</span>
<span class="cm"> * @page: the page to lock</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__lock_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DEFINE_WAIT_BIT</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">PG_locked</span><span class="p">);</span>

	<span class="n">__wait_on_bit_lock</span><span class="p">(</span><span class="n">page_waitqueue</span><span class="p">(</span><span class="n">page</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">sleep_on_page</span><span class="p">,</span>
							<span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__lock_page</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">__lock_page_killable</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DEFINE_WAIT_BIT</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">PG_locked</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">__wait_on_bit_lock</span><span class="p">(</span><span class="n">page_waitqueue</span><span class="p">(</span><span class="n">page</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span>
					<span class="n">sleep_on_page_killable</span><span class="p">,</span> <span class="n">TASK_KILLABLE</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__lock_page_killable</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">__lock_page_or_retry</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FAULT_FLAG_ALLOW_RETRY</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * CAUTION! In this case, mmap_sem is not released</span>
<span class="cm">		 * even though return 0.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FAULT_FLAG_RETRY_NOWAIT</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FAULT_FLAG_KILLABLE</span><span class="p">)</span>
			<span class="n">wait_on_page_locked_killable</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">wait_on_page_locked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FAULT_FLAG_KILLABLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">__lock_page_killable</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">__lock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * find_get_page - find and get a page reference</span>
<span class="cm"> * @mapping: the address_space to search</span>
<span class="cm"> * @offset: the page index</span>
<span class="cm"> *</span>
<span class="cm"> * Is there a pagecache struct page at the given (mapping, offset) tuple?</span>
<span class="cm"> * If yes, increment its refcount and return it; if no, return NULL.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">find_get_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">**</span><span class="n">pagep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="nl">repeat:</span>
	<span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">pagep</span> <span class="o">=</span> <span class="n">radix_tree_lookup_slot</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">page_tree</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pagep</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">radix_tree_deref_slot</span><span class="p">(</span><span class="n">pagep</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">radix_tree_exception</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">radix_tree_deref_retry</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Otherwise, shmem/tmpfs must be storing a swap entry</span>
<span class="cm">			 * here as an exceptional entry: so return it without</span>
<span class="cm">			 * attempting to raise page count.</span>
<span class="cm">			 */</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_cache_get_speculative</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Has the page moved?</span>
<span class="cm">		 * This is part of the lockless pagecache protocol. See</span>
<span class="cm">		 * include/linux/pagemap.h for details.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">page</span> <span class="o">!=</span> <span class="o">*</span><span class="n">pagep</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">find_get_page</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * find_lock_page - locate, pin and lock a pagecache page</span>
<span class="cm"> * @mapping: the address_space to search</span>
<span class="cm"> * @offset: the page index</span>
<span class="cm"> *</span>
<span class="cm"> * Locates the desired pagecache page, locks it, increments its reference</span>
<span class="cm"> * count and returns its address.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero if the page was not present. find_lock_page() may sleep.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">find_lock_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

<span class="nl">repeat:</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">find_get_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">radix_tree_exception</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="cm">/* Has the page been truncated? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">!=</span> <span class="n">mapping</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">!=</span> <span class="n">offset</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">find_lock_page</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * find_or_create_page - locate or add a pagecache page</span>
<span class="cm"> * @mapping: the page&#39;s address_space</span>
<span class="cm"> * @index: the page&#39;s index into the mapping</span>
<span class="cm"> * @gfp_mask: page allocation mode</span>
<span class="cm"> *</span>
<span class="cm"> * Locates a page in the pagecache.  If the page is not present, a new page</span>
<span class="cm"> * is allocated using @gfp_mask and is added to the pagecache and to the VM&#39;s</span>
<span class="cm"> * LRU list.  The returned page is locked and has its reference count</span>
<span class="cm"> * incremented.</span>
<span class="cm"> *</span>
<span class="cm"> * find_or_create_page() may sleep, even if @gfp_flags specifies an atomic</span>
<span class="cm"> * allocation!</span>
<span class="cm"> *</span>
<span class="cm"> * find_or_create_page() returns the desired page&#39;s address, or zero on</span>
<span class="cm"> * memory exhaustion.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">find_or_create_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
		<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
<span class="nl">repeat:</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">find_lock_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">__page_cache_alloc</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * We want a regular kernel memory (not highmem or DMA etc)</span>
<span class="cm">		 * allocation for the radix tree nodes, but we need to honour</span>
<span class="cm">		 * the context-specific requirements the caller has asked for.</span>
<span class="cm">		 * GFP_RECLAIM_MASK collects those requirements.</span>
<span class="cm">		 */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">add_to_page_cache_lru</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
			<span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">GFP_RECLAIM_MASK</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">find_or_create_page</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * find_get_pages - gang pagecache lookup</span>
<span class="cm"> * @mapping:	The address_space to search</span>
<span class="cm"> * @start:	The starting page index</span>
<span class="cm"> * @nr_pages:	The maximum number of pages</span>
<span class="cm"> * @pages:	Where the resulting pages are placed</span>
<span class="cm"> *</span>
<span class="cm"> * find_get_pages() will search for and return a group of up to</span>
<span class="cm"> * @nr_pages pages in the mapping.  The pages are placed at @pages.</span>
<span class="cm"> * find_get_pages() takes a reference against the returned pages.</span>
<span class="cm"> *</span>
<span class="cm"> * The search returns a group of mapping-contiguous pages with ascending</span>
<span class="cm"> * indexes.  There may be holes in the indices due to not-present pages.</span>
<span class="cm"> *</span>
<span class="cm"> * find_get_pages() returns the number of pages which were found.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="nf">find_get_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">start</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">radix_tree_iter</span> <span class="n">iter</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">**</span><span class="n">slot</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">nr_pages</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="nl">restart:</span>
	<span class="n">radix_tree_for_each_slot</span><span class="p">(</span><span class="n">slot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">page_tree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
<span class="nl">repeat:</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">radix_tree_deref_slot</span><span class="p">(</span><span class="n">slot</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">radix_tree_exception</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">radix_tree_deref_retry</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Transient condition which can only trigger</span>
<span class="cm">				 * when entry at index 0 moves out of or back</span>
<span class="cm">				 * to root: none yet gotten, safe to restart.</span>
<span class="cm">				 */</span>
				<span class="n">WARN_ON</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">index</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * Otherwise, shmem/tmpfs must be storing a swap entry</span>
<span class="cm">			 * here as an exceptional entry: so skip over it -</span>
<span class="cm">			 * we only reach this from invalidate_mapping_pages().</span>
<span class="cm">			 */</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_cache_get_speculative</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>

		<span class="cm">/* Has the page moved? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">page</span> <span class="o">!=</span> <span class="o">*</span><span class="n">slot</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pages</span><span class="p">[</span><span class="n">ret</span><span class="p">]</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">ret</span> <span class="o">==</span> <span class="n">nr_pages</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * find_get_pages_contig - gang contiguous pagecache lookup</span>
<span class="cm"> * @mapping:	The address_space to search</span>
<span class="cm"> * @index:	The starting page index</span>
<span class="cm"> * @nr_pages:	The maximum number of pages</span>
<span class="cm"> * @pages:	Where the resulting pages are placed</span>
<span class="cm"> *</span>
<span class="cm"> * find_get_pages_contig() works exactly like find_get_pages(), except</span>
<span class="cm"> * that the returned number of pages are guaranteed to be contiguous.</span>
<span class="cm"> *</span>
<span class="cm"> * find_get_pages_contig() returns the number of pages which were found.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="nf">find_get_pages_contig</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">radix_tree_iter</span> <span class="n">iter</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">**</span><span class="n">slot</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">nr_pages</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="nl">restart:</span>
	<span class="n">radix_tree_for_each_contig</span><span class="p">(</span><span class="n">slot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">page_tree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
<span class="nl">repeat:</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">radix_tree_deref_slot</span><span class="p">(</span><span class="n">slot</span><span class="p">);</span>
		<span class="cm">/* The hole, there no reason to continue */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">radix_tree_exception</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">radix_tree_deref_retry</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Transient condition which can only trigger</span>
<span class="cm">				 * when entry at index 0 moves out of or back</span>
<span class="cm">				 * to root: none yet gotten, safe to restart.</span>
<span class="cm">				 */</span>
				<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * Otherwise, shmem/tmpfs must be storing a swap entry</span>
<span class="cm">			 * here as an exceptional entry: so stop looking for</span>
<span class="cm">			 * contiguous pages.</span>
<span class="cm">			 */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_cache_get_speculative</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>

		<span class="cm">/* Has the page moved? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">page</span> <span class="o">!=</span> <span class="o">*</span><span class="n">slot</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * must check mapping and index after taking the ref.</span>
<span class="cm">		 * otherwise we can get both false positives and false</span>
<span class="cm">		 * negatives, which is just confusing to the caller.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">!=</span> <span class="n">iter</span><span class="p">.</span><span class="n">index</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pages</span><span class="p">[</span><span class="n">ret</span><span class="p">]</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">ret</span> <span class="o">==</span> <span class="n">nr_pages</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">find_get_pages_contig</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * find_get_pages_tag - find and return pages that match @tag</span>
<span class="cm"> * @mapping:	the address_space to search</span>
<span class="cm"> * @index:	the starting page index</span>
<span class="cm"> * @tag:	the tag index</span>
<span class="cm"> * @nr_pages:	the maximum number of pages</span>
<span class="cm"> * @pages:	where the resulting pages are placed</span>
<span class="cm"> *</span>
<span class="cm"> * Like find_get_pages, except we only return pages which are tagged with</span>
<span class="cm"> * @tag.   We update @index to index the next page for the traversal.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="nf">find_get_pages_tag</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="o">*</span><span class="n">index</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">tag</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">radix_tree_iter</span> <span class="n">iter</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">**</span><span class="n">slot</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">nr_pages</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="nl">restart:</span>
	<span class="n">radix_tree_for_each_tagged</span><span class="p">(</span><span class="n">slot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">page_tree</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">iter</span><span class="p">,</span> <span class="o">*</span><span class="n">index</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
<span class="nl">repeat:</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">radix_tree_deref_slot</span><span class="p">(</span><span class="n">slot</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">radix_tree_exception</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">radix_tree_deref_retry</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Transient condition which can only trigger</span>
<span class="cm">				 * when entry at index 0 moves out of or back</span>
<span class="cm">				 * to root: none yet gotten, safe to restart.</span>
<span class="cm">				 */</span>
				<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * This function is never used on a shmem/tmpfs</span>
<span class="cm">			 * mapping, so a swap entry won&#39;t be found here.</span>
<span class="cm">			 */</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_cache_get_speculative</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>

		<span class="cm">/* Has the page moved? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">page</span> <span class="o">!=</span> <span class="o">*</span><span class="n">slot</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pages</span><span class="p">[</span><span class="n">ret</span><span class="p">]</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">ret</span> <span class="o">==</span> <span class="n">nr_pages</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="o">*</span><span class="n">index</span> <span class="o">=</span> <span class="n">pages</span><span class="p">[</span><span class="n">ret</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">find_get_pages_tag</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * grab_cache_page_nowait - returns locked page at given index in given cache</span>
<span class="cm"> * @mapping: target address_space</span>
<span class="cm"> * @index: the page index</span>
<span class="cm"> *</span>
<span class="cm"> * Same as grab_cache_page(), but do not wait if the page is unavailable.</span>
<span class="cm"> * This is intended for speculative data generators, where the data can</span>
<span class="cm"> * be regenerated if the page couldn&#39;t be grabbed.  This routine should</span>
<span class="cm"> * be safe to call while holding the lock for another page.</span>
<span class="cm"> *</span>
<span class="cm"> * Clear __GFP_FS when allocating the page to avoid recursion into the fs</span>
<span class="cm"> * and deadlock against the caller&#39;s locked page.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span>
<span class="nf">grab_cache_page_nowait</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">find_get_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">trylock_page</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">__page_cache_alloc</span><span class="p">(</span><span class="n">mapping_gfp_mask</span><span class="p">(</span><span class="n">mapping</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">__GFP_FS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">&amp;&amp;</span> <span class="n">add_to_page_cache_lru</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">grab_cache_page_nowait</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * CD/DVDs are error prone. When a medium error occurs, the driver may fail</span>
<span class="cm"> * a _large_ part of the i/o request. Imagine the worst scenario:</span>
<span class="cm"> *</span>
<span class="cm"> *      ---R__________________________________________B__________</span>
<span class="cm"> *         ^ reading here                             ^ bad block(assume 4k)</span>
<span class="cm"> *</span>
<span class="cm"> * read(R) =&gt; miss =&gt; readahead(R...B) =&gt; media error =&gt; frustrating retries</span>
<span class="cm"> * =&gt; failing the whole request =&gt; read(R) =&gt; read(R+1) =&gt;</span>
<span class="cm"> * readahead(R+1...B+1) =&gt; bang =&gt; read(R+2) =&gt; read(R+3) =&gt;</span>
<span class="cm"> * readahead(R+3...B+2) =&gt; bang =&gt; read(R+3) =&gt; read(R+4) =&gt;</span>
<span class="cm"> * readahead(R+4...B+3) =&gt; bang =&gt; read(R+4) =&gt; read(R+5) =&gt; ......</span>
<span class="cm"> *</span>
<span class="cm"> * It is going insane. Fix it by quickly scaling down the readahead size.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">shrink_readahead_size_eio</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">file_ra_state</span> <span class="o">*</span><span class="n">ra</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ra</span><span class="o">-&gt;</span><span class="n">ra_pages</span> <span class="o">/=</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * do_generic_file_read - generic file read routine</span>
<span class="cm"> * @filp:	the file to read</span>
<span class="cm"> * @ppos:	current file position</span>
<span class="cm"> * @desc:	read_descriptor</span>
<span class="cm"> * @actor:	read method</span>
<span class="cm"> *</span>
<span class="cm"> * This is a generic file read routine, and uses the</span>
<span class="cm"> * mapping-&gt;a_ops-&gt;readpage() function for the actual low-level stuff.</span>
<span class="cm"> *</span>
<span class="cm"> * This is really ugly. But the goto&#39;s actually try to clarify some</span>
<span class="cm"> * of the logic when it comes to error handling etc.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_generic_file_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span>
		<span class="n">read_descriptor_t</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="n">read_actor_t</span> <span class="n">actor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file_ra_state</span> <span class="o">*</span><span class="n">ra</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_ra</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">last_index</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">prev_index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>      <span class="cm">/* offset into pagecache page */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">prev_offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">index</span> <span class="o">=</span> <span class="o">*</span><span class="n">ppos</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="n">prev_index</span> <span class="o">=</span> <span class="n">ra</span><span class="o">-&gt;</span><span class="n">prev_pos</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="n">prev_offset</span> <span class="o">=</span> <span class="n">ra</span><span class="o">-&gt;</span><span class="n">prev_pos</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">last_index</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">ppos</span> <span class="o">+</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">+</span> <span class="n">PAGE_CACHE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="o">*</span><span class="n">ppos</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_CACHE_MASK</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
		<span class="n">pgoff_t</span> <span class="n">end_index</span><span class="p">;</span>
		<span class="n">loff_t</span> <span class="n">isize</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">cond_resched</span><span class="p">();</span>
<span class="nl">find_page:</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">find_get_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">page_cache_sync_readahead</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span>
					<span class="n">ra</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span>
					<span class="n">index</span><span class="p">,</span> <span class="n">last_index</span> <span class="o">-</span> <span class="n">index</span><span class="p">);</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">find_get_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">no_cached_page</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageReadahead</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">page_cache_async_readahead</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span>
					<span class="n">ra</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span>
					<span class="n">index</span><span class="p">,</span> <span class="n">last_index</span> <span class="o">-</span> <span class="n">index</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span> <span class="o">==</span> <span class="n">PAGE_CACHE_SHIFT</span> <span class="o">||</span>
					<span class="o">!</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">is_partially_uptodate</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">page_not_up_to_date</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trylock_page</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">page_not_up_to_date</span><span class="p">;</span>
			<span class="cm">/* Did it get truncated before we got the lock? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">page_not_up_to_date_locked</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">is_partially_uptodate</span><span class="p">(</span><span class="n">page</span><span class="p">,</span>
								<span class="n">desc</span><span class="p">,</span> <span class="n">offset</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">page_not_up_to_date_locked</span><span class="p">;</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>
<span class="nl">page_ok:</span>
		<span class="cm">/*</span>
<span class="cm">		 * i_size must be checked after we know the page is Uptodate.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Checking i_size after the check allows us to calculate</span>
<span class="cm">		 * the correct value for &quot;nr&quot;, which means the zero-filled</span>
<span class="cm">		 * part of the page is not copied back to userspace (unless</span>
<span class="cm">		 * another truncate extends the file - this is desired though).</span>
<span class="cm">		 */</span>

		<span class="n">isize</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">end_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">isize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">isize</span> <span class="o">||</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="n">end_index</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* nr is the maximum number of bytes to copy from this page */</span>
		<span class="n">nr</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">end_index</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nr</span> <span class="o">=</span> <span class="p">((</span><span class="n">isize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_CACHE_MASK</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&lt;=</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">nr</span> <span class="o">=</span> <span class="n">nr</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>

		<span class="cm">/* If users can be writing to this page using arbitrary</span>
<span class="cm">		 * virtual addresses, take care about potential aliasing</span>
<span class="cm">		 * before reading the page on the kernel side.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mapping_writably_mapped</span><span class="p">(</span><span class="n">mapping</span><span class="p">))</span>
			<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * When a sequential read accesses a page several times,</span>
<span class="cm">		 * only mark it as accessed the first time.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prev_index</span> <span class="o">!=</span> <span class="n">index</span> <span class="o">||</span> <span class="n">offset</span> <span class="o">!=</span> <span class="n">prev_offset</span><span class="p">)</span>
			<span class="n">mark_page_accessed</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">prev_index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Ok, we have the page, and it&#39;s up-to-date, so</span>
<span class="cm">		 * now we can copy it to user space...</span>
<span class="cm">		 *</span>
<span class="cm">		 * The actor routine returns how many bytes were actually used..</span>
<span class="cm">		 * NOTE! This may not be the same as how much of a user buffer</span>
<span class="cm">		 * we filled up (we may be padding etc), so we can only update</span>
<span class="cm">		 * &quot;pos&quot; here (the actor routine has to update the user buffer</span>
<span class="cm">		 * pointers and the remaining count).</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">actor</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">index</span> <span class="o">+=</span> <span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PAGE_CACHE_MASK</span><span class="p">;</span>
		<span class="n">prev_offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>

		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">nr</span> <span class="o">&amp;&amp;</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">page_not_up_to_date:</span>
		<span class="cm">/* Get exclusive access to the page ... */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">lock_page_killable</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">readpage_error</span><span class="p">;</span>

<span class="nl">page_not_up_to_date_locked:</span>
		<span class="cm">/* Did it get truncated before we got the lock? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Did somebody else fill it already? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">page_ok</span><span class="p">;</span>
		<span class="p">}</span>

<span class="nl">readpage:</span>
		<span class="cm">/*</span>
<span class="cm">		 * A previous I/O error may have been due to temporary</span>
<span class="cm">		 * failures, eg. multipath errors.</span>
<span class="cm">		 * PG_error will be set again if readpage fails.</span>
<span class="cm">		 */</span>
		<span class="n">ClearPageError</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="cm">/* Start the actual read. The read will unlock the page. */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">readpage</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="n">AOP_TRUNCATED_PAGE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">find_page</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">goto</span> <span class="n">readpage_error</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">lock_page_killable</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">readpage_error</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/*</span>
<span class="cm">					 * invalidate_mapping_pages got it</span>
<span class="cm">					 */</span>
					<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
					<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">find_page</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="n">shrink_readahead_size_eio</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">ra</span><span class="p">);</span>
				<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">readpage_error</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">goto</span> <span class="n">page_ok</span><span class="p">;</span>

<span class="nl">readpage_error:</span>
		<span class="cm">/* UHHUH! A synchronous read error occurred. Report it */</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">no_cached_page:</span>
		<span class="cm">/*</span>
<span class="cm">		 * Ok, it wasn&#39;t cached, so we need to create a new</span>
<span class="cm">		 * page..</span>
<span class="cm">		 */</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">page_cache_alloc_cold</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">desc</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">add_to_page_cache_lru</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span>
						<span class="n">index</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">find_page</span><span class="p">;</span>
			<span class="n">desc</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="n">error</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">readpage</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">ra</span><span class="o">-&gt;</span><span class="n">prev_pos</span> <span class="o">=</span> <span class="n">prev_index</span><span class="p">;</span>
	<span class="n">ra</span><span class="o">-&gt;</span><span class="n">prev_pos</span> <span class="o">&lt;&lt;=</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="n">ra</span><span class="o">-&gt;</span><span class="n">prev_pos</span> <span class="o">|=</span> <span class="n">prev_offset</span><span class="p">;</span>

	<span class="o">*</span><span class="n">ppos</span> <span class="o">=</span> <span class="p">((</span><span class="n">loff_t</span><span class="p">)</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">file_accessed</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">file_read_actor</span><span class="p">(</span><span class="n">read_descriptor_t</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">kaddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">left</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">count</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Faults on the destination of a read are common, so do it before</span>
<span class="cm">	 * taking the kmap.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fault_in_pages_writeable</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">arg</span><span class="p">.</span><span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kaddr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">left</span> <span class="o">=</span> <span class="n">__copy_to_user_inatomic</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">arg</span><span class="p">.</span><span class="n">buf</span><span class="p">,</span>
						<span class="n">kaddr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">kaddr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">success</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Do it the slow way */</span>
	<span class="n">kaddr</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">left</span> <span class="o">=</span> <span class="n">__copy_to_user</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">arg</span><span class="p">.</span><span class="n">buf</span><span class="p">,</span> <span class="n">kaddr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">size</span> <span class="o">-=</span> <span class="n">left</span><span class="p">;</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">success:</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">-</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">written</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">arg</span><span class="p">.</span><span class="n">buf</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Performs necessary checks before doing a write</span>
<span class="cm"> * @iov:	io vector request</span>
<span class="cm"> * @nr_segs:	number of segments in the iovec</span>
<span class="cm"> * @count:	number of bytes to write</span>
<span class="cm"> * @access_flags: type of access: %VERIFY_READ or %VERIFY_WRITE</span>
<span class="cm"> *</span>
<span class="cm"> * Adjust number of segments and amount of bytes to write (nr_segs should be</span>
<span class="cm"> * properly initialized first). Returns appropriate error code that caller</span>
<span class="cm"> * should return or zero in case that write should be allowed.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">generic_segment_checks</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">nr_segs</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">access_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>   <span class="n">seg</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">seg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">seg</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">nr_segs</span><span class="p">;</span> <span class="n">seg</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iov</span><span class="p">[</span><span class="n">seg</span><span class="p">];</span>

		<span class="cm">/*</span>
<span class="cm">		 * If any segment has a negative length, or the cumulative</span>
<span class="cm">		 * length ever wraps negative then return -EINVAL.</span>
<span class="cm">		 */</span>
		<span class="n">cnt</span> <span class="o">+=</span> <span class="n">iv</span><span class="o">-&gt;</span><span class="n">iov_len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="kt">ssize_t</span><span class="p">)(</span><span class="n">cnt</span><span class="o">|</span><span class="n">iv</span><span class="o">-&gt;</span><span class="n">iov_len</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">access_ok</span><span class="p">(</span><span class="n">access_flags</span><span class="p">,</span> <span class="n">iv</span><span class="o">-&gt;</span><span class="n">iov_base</span><span class="p">,</span> <span class="n">iv</span><span class="o">-&gt;</span><span class="n">iov_len</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">seg</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="o">*</span><span class="n">nr_segs</span> <span class="o">=</span> <span class="n">seg</span><span class="p">;</span>
		<span class="n">cnt</span> <span class="o">-=</span> <span class="n">iv</span><span class="o">-&gt;</span><span class="n">iov_len</span><span class="p">;</span>	<span class="cm">/* This segment is no good */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">generic_segment_checks</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * generic_file_aio_read - generic filesystem read routine</span>
<span class="cm"> * @iocb:	kernel I/O control block</span>
<span class="cm"> * @iov:	io vector request</span>
<span class="cm"> * @nr_segs:	number of segments in the iovec</span>
<span class="cm"> * @pos:	current file position</span>
<span class="cm"> *</span>
<span class="cm"> * This is the &quot;read()&quot; routine for all filesystems</span>
<span class="cm"> * that can use the page cache directly.</span>
<span class="cm"> */</span>
<span class="kt">ssize_t</span>
<span class="nf">generic_file_aio_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">seg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span><span class="p">;</span>

	<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">generic_segment_checks</span><span class="p">(</span><span class="n">iov</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr_segs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="n">VERIFY_WRITE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="cm">/* coalesce the iovecs and go direct-to-BIO for O_DIRECT */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_DIRECT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">loff_t</span> <span class="n">size</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

		<span class="n">mapping</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>
		<span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span> <span class="cm">/* skip atime */</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">filemap_write_and_wait_range</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span>
					<span class="n">pos</span> <span class="o">+</span> <span class="n">iov_length</span><span class="p">(</span><span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">blk_plug</span> <span class="n">plug</span><span class="p">;</span>

				<span class="n">blk_start_plug</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plug</span><span class="p">);</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">direct_IO</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span> <span class="n">iocb</span><span class="p">,</span>
							<span class="n">iov</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">);</span>
				<span class="n">blk_finish_plug</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plug</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">ppos</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">retval</span><span class="p">;</span>
				<span class="n">count</span> <span class="o">-=</span> <span class="n">retval</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * Btrfs can have a short DIO read if we encounter</span>
<span class="cm">			 * compressed extents, so if there was an error, or if</span>
<span class="cm">			 * we&#39;ve already read everything we wanted to, or if</span>
<span class="cm">			 * there was a short read because we hit EOF, go ahead</span>
<span class="cm">			 * and return.  Otherwise fallthrough to buffered io for</span>
<span class="cm">			 * the rest of the read.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">count</span> <span class="o">||</span> <span class="o">*</span><span class="n">ppos</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">file_accessed</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">count</span> <span class="o">=</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">seg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">seg</span> <span class="o">&lt;</span> <span class="n">nr_segs</span><span class="p">;</span> <span class="n">seg</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">read_descriptor_t</span> <span class="n">desc</span><span class="p">;</span>
		<span class="n">loff_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If we did a short DIO read we need to skip the section of the</span>
<span class="cm">		 * iov that we&#39;ve already read data into.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">iov</span><span class="p">[</span><span class="n">seg</span><span class="p">].</span><span class="n">iov_len</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">count</span> <span class="o">-=</span> <span class="n">iov</span><span class="p">[</span><span class="n">seg</span><span class="p">].</span><span class="n">iov_len</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
			<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">desc</span><span class="p">.</span><span class="n">written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">desc</span><span class="p">.</span><span class="n">arg</span><span class="p">.</span><span class="n">buf</span> <span class="o">=</span> <span class="n">iov</span><span class="p">[</span><span class="n">seg</span><span class="p">].</span><span class="n">iov_base</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">desc</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">iov</span><span class="p">[</span><span class="n">seg</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="p">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">desc</span><span class="p">.</span><span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">do_generic_file_read</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span> <span class="n">file_read_actor</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">+=</span> <span class="n">desc</span><span class="p">.</span><span class="n">written</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="p">.</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">retval</span> <span class="o">?:</span> <span class="n">desc</span><span class="p">.</span><span class="n">error</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="p">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">generic_file_aio_read</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_MMU</span>
<span class="cm">/**</span>
<span class="cm"> * page_cache_read - adds requested page to the page cache if not already there</span>
<span class="cm"> * @file:	file to read</span>
<span class="cm"> * @offset:	page index</span>
<span class="cm"> *</span>
<span class="cm"> * This adds the requested page to the page cache if it isn&#39;t already there,</span>
<span class="cm"> * and schedules an I/O to read in its contents from disk.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">page_cache_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span> 
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">page_cache_alloc_cold</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">add_to_page_cache_lru</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">readpage</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* losing race to add is OK */</span>

		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">AOP_TRUNCATED_PAGE</span><span class="p">);</span>
		
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define MMAP_LOTSAMISS  (100)</span>

<span class="cm">/*</span>
<span class="cm"> * Synchronous readahead happens when we don&#39;t even find</span>
<span class="cm"> * a page in the page cache at all.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_sync_mmap_readahead</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">file_ra_state</span> <span class="o">*</span><span class="n">ra</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
				   <span class="n">pgoff_t</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ra_pages</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>

	<span class="cm">/* If we don&#39;t want any read-ahead, don&#39;t bother */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">VM_RandomReadHint</span><span class="p">(</span><span class="n">vma</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ra</span><span class="o">-&gt;</span><span class="n">ra_pages</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">VM_SequentialReadHint</span><span class="p">(</span><span class="n">vma</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">page_cache_sync_readahead</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">ra</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
					  <span class="n">ra</span><span class="o">-&gt;</span><span class="n">ra_pages</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Avoid banging the cache line if not needed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ra</span><span class="o">-&gt;</span><span class="n">mmap_miss</span> <span class="o">&lt;</span> <span class="n">MMAP_LOTSAMISS</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span>
		<span class="n">ra</span><span class="o">-&gt;</span><span class="n">mmap_miss</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do we miss much more than hit in this file? If so,</span>
<span class="cm">	 * stop bothering with read-ahead. It will only hurt.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ra</span><span class="o">-&gt;</span><span class="n">mmap_miss</span> <span class="o">&gt;</span> <span class="n">MMAP_LOTSAMISS</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * mmap read-around</span>
<span class="cm">	 */</span>
	<span class="n">ra_pages</span> <span class="o">=</span> <span class="n">max_sane_readahead</span><span class="p">(</span><span class="n">ra</span><span class="o">-&gt;</span><span class="n">ra_pages</span><span class="p">);</span>
	<span class="n">ra</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">long</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">ra_pages</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">ra</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">ra_pages</span><span class="p">;</span>
	<span class="n">ra</span><span class="o">-&gt;</span><span class="n">async_size</span> <span class="o">=</span> <span class="n">ra_pages</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">ra_submit</span><span class="p">(</span><span class="n">ra</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Asynchronous readahead happens when we find the page and PG_readahead,</span>
<span class="cm"> * so we want to possibly extend the readahead further..</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_async_mmap_readahead</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">file_ra_state</span> <span class="o">*</span><span class="n">ra</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
				    <span class="n">pgoff_t</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>

	<span class="cm">/* If we don&#39;t want any read-ahead, don&#39;t bother */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">VM_RandomReadHint</span><span class="p">(</span><span class="n">vma</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ra</span><span class="o">-&gt;</span><span class="n">mmap_miss</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ra</span><span class="o">-&gt;</span><span class="n">mmap_miss</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageReadahead</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">page_cache_async_readahead</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">ra</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span>
					   <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">ra</span><span class="o">-&gt;</span><span class="n">ra_pages</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * filemap_fault - read in file data for page fault handling</span>
<span class="cm"> * @vma:	vma in which the fault was taken</span>
<span class="cm"> * @vmf:	struct vm_fault containing details of the fault</span>
<span class="cm"> *</span>
<span class="cm"> * filemap_fault() is invoked via the vma operations vector for a</span>
<span class="cm"> * mapped memory region to read in file data during a page fault.</span>
<span class="cm"> *</span>
<span class="cm"> * The goto&#39;s are kind of ugly, but this streamlines the normal case of having</span>
<span class="cm"> * it in the page cache, and handles the special cases reasonably without</span>
<span class="cm"> * having a lot of duplicated code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">filemap_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file_ra_state</span> <span class="o">*</span><span class="n">ra</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_ra</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">vmf</span><span class="o">-&gt;</span><span class="n">pgoff</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">+</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">VM_FAULT_SIGBUS</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do we have something in the page cache already?</span>
<span class="cm">	 */</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">find_get_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We found the page, so try async readahead before</span>
<span class="cm">		 * waiting for the lock.</span>
<span class="cm">		 */</span>
		<span class="n">do_async_mmap_readahead</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">ra</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* No page in the page cache at all */</span>
		<span class="n">do_sync_mmap_readahead</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">ra</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="n">count_vm_event</span><span class="p">(</span><span class="n">PGMAJFAULT</span><span class="p">);</span>
		<span class="n">mem_cgroup_count_vm_event</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">PGMAJFAULT</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">VM_FAULT_MAJOR</span><span class="p">;</span>
<span class="nl">retry_find:</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">find_get_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">no_cached_page</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lock_page_or_retry</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">vmf</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span> <span class="o">|</span> <span class="n">VM_FAULT_RETRY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Did it get truncated? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">!=</span> <span class="n">mapping</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">retry_find</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">!=</span> <span class="n">offset</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We have a locked page in the page cache, now we need to check</span>
<span class="cm">	 * that it&#39;s up-to-date. If not, it is going to be due to an error.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">page_not_uptodate</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Found the page and have a reference on it.</span>
<span class="cm">	 * We must recheck i_size under page lock.</span>
<span class="cm">	 */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">+</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">VM_FAULT_SIGBUS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vmf</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span> <span class="o">|</span> <span class="n">VM_FAULT_LOCKED</span><span class="p">;</span>

<span class="nl">no_cached_page:</span>
	<span class="cm">/*</span>
<span class="cm">	 * We&#39;re only likely to ever get here if MADV_RANDOM is in</span>
<span class="cm">	 * effect.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">page_cache_read</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The page we want has now been added to the page cache.</span>
<span class="cm">	 * In the unlikely event that someone removed it in the</span>
<span class="cm">	 * meantime, we&#39;ll just come back here and read it again.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">retry_find</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * An error return from page_cache_read can result if the</span>
<span class="cm">	 * system is low on memory, or a problem occurs while trying</span>
<span class="cm">	 * to schedule I/O.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">VM_FAULT_OOM</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">VM_FAULT_SIGBUS</span><span class="p">;</span>

<span class="nl">page_not_uptodate:</span>
	<span class="cm">/*</span>
<span class="cm">	 * Umm, take care of errors if the page isn&#39;t up-to-date.</span>
<span class="cm">	 * Try to re-read it _once_. We do this synchronously,</span>
<span class="cm">	 * because there really aren&#39;t any performance issues here</span>
<span class="cm">	 * and we need to check for errors.</span>
<span class="cm">	 */</span>
	<span class="n">ClearPageError</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">readpage</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wait_on_page_locked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span> <span class="o">||</span> <span class="n">error</span> <span class="o">==</span> <span class="n">AOP_TRUNCATED_PAGE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">retry_find</span><span class="p">;</span>

	<span class="cm">/* Things didn&#39;t work out. Return zero to tell the mm layer so. */</span>
	<span class="n">shrink_readahead_size_eio</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">ra</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">VM_FAULT_SIGBUS</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">filemap_fault</span><span class="p">);</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">vm_operations_struct</span> <span class="n">generic_file_vm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">fault</span>		<span class="o">=</span> <span class="n">filemap_fault</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* This is used for a general mmap of a disk file */</span>

<span class="kt">int</span> <span class="nf">generic_file_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span> <span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">readpage</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
	<span class="n">file_accessed</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">generic_file_vm_ops</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_CAN_NONLINEAR</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is for filesystems which do not implement -&gt;writepage.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">generic_file_readonly_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_SHARED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_MAYWRITE</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">generic_file_mmap</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="kt">int</span> <span class="nf">generic_file_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span> <span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">generic_file_readonly_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span> <span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MMU */</span><span class="cp"></span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">generic_file_mmap</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">generic_file_readonly_mmap</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">__read_cache_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span>
				<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">filler</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">),</span>
				<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				<span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
<span class="nl">repeat:</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">find_get_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">__page_cache_alloc</span><span class="p">(</span><span class="n">gfp</span> <span class="o">|</span> <span class="n">__GFP_COLD</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">add_to_page_cache_lru</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
			<span class="cm">/* Presumably ENOMEM for radix tree node */</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">filler</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">do_read_cache_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span>
				<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">filler</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">),</span>
				<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				<span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>

<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">retry:</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">__read_cache_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">filler</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">lock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">filler</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">mark_page_accessed</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * read_cache_page_async - read into page cache, fill it if needed</span>
<span class="cm"> * @mapping:	the page&#39;s address_space</span>
<span class="cm"> * @index:	the page index</span>
<span class="cm"> * @filler:	function to perform the read</span>
<span class="cm"> * @data:	first arg to filler(data, page) function, often left as NULL</span>
<span class="cm"> *</span>
<span class="cm"> * Same as read_cache_page, but don&#39;t wait for page to become unlocked</span>
<span class="cm"> * after submitting it to the filler.</span>
<span class="cm"> *</span>
<span class="cm"> * Read into the page cache. If a page already exists, and PageUptodate() is</span>
<span class="cm"> * not set, try to fill the page but don&#39;t wait for it to become unlocked.</span>
<span class="cm"> *</span>
<span class="cm"> * If the page does not get brought uptodate, return -EIO.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">read_cache_page_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span>
				<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">filler</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">),</span>
				<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">do_read_cache_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">filler</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">mapping_gfp_mask</span><span class="p">(</span><span class="n">mapping</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">read_cache_page_async</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">wait_on_page_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">wait_on_page_locked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * read_cache_page_gfp - read into page cache, using specified page allocation flags.</span>
<span class="cm"> * @mapping:	the page&#39;s address_space</span>
<span class="cm"> * @index:	the page index</span>
<span class="cm"> * @gfp:	the page allocator flags to use if allocating</span>
<span class="cm"> *</span>
<span class="cm"> * This is the same as &quot;read_mapping_page(mapping, index, NULL)&quot;, but with</span>
<span class="cm"> * any new page allocations done using the specified allocation flags.</span>
<span class="cm"> *</span>
<span class="cm"> * If the page does not get brought uptodate, return -EIO.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">read_cache_page_gfp</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span>
				<span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">filler_t</span> <span class="o">*</span><span class="n">filler</span> <span class="o">=</span> <span class="p">(</span><span class="n">filler_t</span> <span class="o">*</span><span class="p">)</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">readpage</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">wait_on_page_read</span><span class="p">(</span><span class="n">do_read_cache_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">filler</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">gfp</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">read_cache_page_gfp</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * read_cache_page - read into page cache, fill it if needed</span>
<span class="cm"> * @mapping:	the page&#39;s address_space</span>
<span class="cm"> * @index:	the page index</span>
<span class="cm"> * @filler:	function to perform the read</span>
<span class="cm"> * @data:	first arg to filler(data, page) function, often left as NULL</span>
<span class="cm"> *</span>
<span class="cm"> * Read into the page cache. If a page already exists, and PageUptodate() is</span>
<span class="cm"> * not set, try to fill the page then wait for it to become unlocked.</span>
<span class="cm"> *</span>
<span class="cm"> * If the page does not get brought uptodate, return -EIO.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">read_cache_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span>
				<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">filler</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">),</span>
				<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">wait_on_page_read</span><span class="p">(</span><span class="n">read_cache_page_async</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">filler</span><span class="p">,</span> <span class="n">data</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">read_cache_page</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">__iovec_copy_from_user_inatomic</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">base</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">copied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">bytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_base</span> <span class="o">+</span> <span class="n">base</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">copy</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_len</span> <span class="o">-</span> <span class="n">base</span><span class="p">);</span>

		<span class="n">base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">left</span> <span class="o">=</span> <span class="n">__copy_from_user_inatomic</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">copy</span><span class="p">);</span>
		<span class="n">copied</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="n">bytes</span> <span class="o">-=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="n">vaddr</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="n">iov</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">left</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">copied</span> <span class="o">-</span> <span class="n">left</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Copy as much as we can into the page and return the number of bytes which</span>
<span class="cm"> * were successfully copied.  If a fault is encountered then return the number of</span>
<span class="cm"> * bytes which were copied.</span>
<span class="cm"> */</span>
<span class="kt">size_t</span> <span class="nf">iov_iter_copy_from_user_atomic</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">iov_iter</span> <span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">kaddr</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">copied</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">in_atomic</span><span class="p">());</span>
	<span class="n">kaddr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">nr_segs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">left</span><span class="p">;</span>
		<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_base</span> <span class="o">+</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">iov_offset</span><span class="p">;</span>
		<span class="n">left</span> <span class="o">=</span> <span class="n">__copy_from_user_inatomic</span><span class="p">(</span><span class="n">kaddr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
		<span class="n">copied</span> <span class="o">=</span> <span class="n">bytes</span> <span class="o">-</span> <span class="n">left</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">copied</span> <span class="o">=</span> <span class="n">__iovec_copy_from_user_inatomic</span><span class="p">(</span><span class="n">kaddr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span>
						<span class="n">i</span><span class="o">-&gt;</span><span class="n">iov</span><span class="p">,</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">iov_offset</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">kaddr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">copied</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">iov_iter_copy_from_user_atomic</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * This has the same sideeffects and return value as</span>
<span class="cm"> * iov_iter_copy_from_user_atomic().</span>
<span class="cm"> * The difference is that it attempts to resolve faults.</span>
<span class="cm"> * Page must not be locked.</span>
<span class="cm"> */</span>
<span class="kt">size_t</span> <span class="nf">iov_iter_copy_from_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">iov_iter</span> <span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">kaddr</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">copied</span><span class="p">;</span>

	<span class="n">kaddr</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">nr_segs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">left</span><span class="p">;</span>
		<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_base</span> <span class="o">+</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">iov_offset</span><span class="p">;</span>
		<span class="n">left</span> <span class="o">=</span> <span class="n">__copy_from_user</span><span class="p">(</span><span class="n">kaddr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
		<span class="n">copied</span> <span class="o">=</span> <span class="n">bytes</span> <span class="o">-</span> <span class="n">left</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">copied</span> <span class="o">=</span> <span class="n">__iovec_copy_from_user_inatomic</span><span class="p">(</span><span class="n">kaddr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span>
						<span class="n">i</span><span class="o">-&gt;</span><span class="n">iov</span><span class="p">,</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">iov_offset</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">copied</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">iov_iter_copy_from_user</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">iov_iter_advance</span><span class="p">(</span><span class="k">struct</span> <span class="n">iov_iter</span> <span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">bytes</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">nr_segs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">i</span><span class="o">-&gt;</span><span class="n">iov_offset</span> <span class="o">+=</span> <span class="n">bytes</span><span class="p">;</span>
		<span class="n">i</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">-=</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">iov</span><span class="p">;</span>
		<span class="kt">size_t</span> <span class="n">base</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">iov_offset</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">nr_segs</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * The !iov-&gt;iov_len check ensures we skip over unlikely</span>
<span class="cm">		 * zero-length segments (without overruning the iovec).</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">||</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_len</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">copy</span><span class="p">;</span>

			<span class="n">copy</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_len</span> <span class="o">-</span> <span class="n">base</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">||</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">copy</span><span class="p">);</span>
			<span class="n">i</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">-=</span> <span class="n">copy</span><span class="p">;</span>
			<span class="n">bytes</span> <span class="o">-=</span> <span class="n">copy</span><span class="p">;</span>
			<span class="n">base</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_len</span> <span class="o">==</span> <span class="n">base</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">iov</span><span class="o">++</span><span class="p">;</span>
				<span class="n">nr_segs</span><span class="o">--</span><span class="p">;</span>
				<span class="n">base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">i</span><span class="o">-&gt;</span><span class="n">iov</span> <span class="o">=</span> <span class="n">iov</span><span class="p">;</span>
		<span class="n">i</span><span class="o">-&gt;</span><span class="n">iov_offset</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
		<span class="n">i</span><span class="o">-&gt;</span><span class="n">nr_segs</span> <span class="o">=</span> <span class="n">nr_segs</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">iov_iter_advance</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Fault in the first iovec of the given iov_iter, to a maximum length</span>
<span class="cm"> * of bytes. Returns 0 on success, or non-zero if the memory could not be</span>
<span class="cm"> * accessed (ie. because it is an invalid address).</span>
<span class="cm"> *</span>
<span class="cm"> * writev-intensive code may want this to prefault several iovecs -- that</span>
<span class="cm"> * would be possible (callers must not rely on the fact that _only_ the</span>
<span class="cm"> * first iovec will be faulted with the current implementation).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">iov_iter_fault_in_readable</span><span class="p">(</span><span class="k">struct</span> <span class="n">iov_iter</span> <span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_base</span> <span class="o">+</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">iov_offset</span><span class="p">;</span>
	<span class="n">bytes</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_len</span> <span class="o">-</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">iov_offset</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">fault_in_pages_readable</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">iov_iter_fault_in_readable</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Return the count of just the current iov_iter segment.</span>
<span class="cm"> */</span>
<span class="kt">size_t</span> <span class="nf">iov_iter_single_seg_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">iov_iter</span> <span class="o">*</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">iov</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">nr_segs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">min</span><span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_len</span> <span class="o">-</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">iov_offset</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">iov_iter_single_seg_count</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Performs necessary checks before doing a write</span>
<span class="cm"> *</span>
<span class="cm"> * Can adjust writing position or amount of bytes to write.</span>
<span class="cm"> * Returns appropriate error code that caller should return or</span>
<span class="cm"> * zero in case that write should be allowed.</span>
<span class="cm"> */</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">generic_write_checks</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">isblk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">rlimit</span><span class="p">(</span><span class="n">RLIMIT_FSIZE</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">*</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isblk</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* FIXME: this is for backwards compatibility with 2.4 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_APPEND</span><span class="p">)</span>
                        <span class="o">*</span><span class="n">pos</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">limit</span> <span class="o">!=</span> <span class="n">RLIM_INFINITY</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pos</span> <span class="o">&gt;=</span> <span class="n">limit</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">send_sig</span><span class="p">(</span><span class="n">SIGXFSZ</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EFBIG</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">limit</span> <span class="o">-</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">limit</span><span class="p">))</span><span class="o">*</span><span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="n">limit</span> <span class="o">-</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">limit</span><span class="p">))</span><span class="o">*</span><span class="n">pos</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * LFS rule</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">*</span><span class="n">pos</span> <span class="o">+</span> <span class="o">*</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">MAX_NON_LFS</span> <span class="o">&amp;&amp;</span>
				<span class="o">!</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_LARGEFILE</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pos</span> <span class="o">&gt;=</span> <span class="n">MAX_NON_LFS</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFBIG</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">MAX_NON_LFS</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">*</span><span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="n">MAX_NON_LFS</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">*</span><span class="n">pos</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Are we about to exceed the fs block limit ?</span>
<span class="cm">	 *</span>
<span class="cm">	 * If we have written data it becomes a short write.  If we have</span>
<span class="cm">	 * exceeded without writing data we send a signal and return EFBIG.</span>
<span class="cm">	 * Linus frestrict idea will clean these up nicely..</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">isblk</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">*</span><span class="n">pos</span> <span class="o">&gt;=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_maxbytes</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">count</span> <span class="o">||</span> <span class="o">*</span><span class="n">pos</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_maxbytes</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EFBIG</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* zero-length writes at -&gt;s_maxbytes are OK */</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">*</span><span class="n">pos</span> <span class="o">+</span> <span class="o">*</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_maxbytes</span><span class="p">))</span>
			<span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_maxbytes</span> <span class="o">-</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_BLOCK</span>
		<span class="n">loff_t</span> <span class="n">isize</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bdev_read_only</span><span class="p">(</span><span class="n">I_BDEV</span><span class="p">(</span><span class="n">inode</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="n">isize</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pos</span> <span class="o">&gt;=</span> <span class="n">isize</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">count</span> <span class="o">||</span> <span class="o">*</span><span class="n">pos</span> <span class="o">&gt;</span> <span class="n">isize</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pos</span> <span class="o">+</span> <span class="o">*</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">isize</span><span class="p">)</span>
			<span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="n">isize</span> <span class="o">-</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
<span class="cp">#else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">generic_write_checks</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">pagecache_write_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				<span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pagep</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">fsdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="o">*</span><span class="n">aops</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">aops</span><span class="o">-&gt;</span><span class="n">write_begin</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span>
							<span class="n">pagep</span><span class="p">,</span> <span class="n">fsdata</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pagecache_write_begin</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">pagecache_write_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				<span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">copied</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fsdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="o">*</span><span class="n">aops</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="p">;</span>

	<span class="n">mark_page_accessed</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">aops</span><span class="o">-&gt;</span><span class="n">write_end</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">copied</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">fsdata</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pagecache_write_end</span><span class="p">);</span>

<span class="kt">ssize_t</span>
<span class="nf">generic_file_direct_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">nr_segs</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ocount</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span>	<span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">ssize_t</span>		<span class="n">written</span><span class="p">;</span>
	<span class="kt">size_t</span>		<span class="n">write_len</span><span class="p">;</span>
	<span class="n">pgoff_t</span>		<span class="n">end</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">!=</span> <span class="n">ocount</span><span class="p">)</span>
		<span class="o">*</span><span class="n">nr_segs</span> <span class="o">=</span> <span class="n">iov_shorten</span><span class="p">((</span><span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="p">)</span><span class="n">iov</span><span class="p">,</span> <span class="o">*</span><span class="n">nr_segs</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

	<span class="n">write_len</span> <span class="o">=</span> <span class="n">iov_length</span><span class="p">(</span><span class="n">iov</span><span class="p">,</span> <span class="o">*</span><span class="n">nr_segs</span><span class="p">);</span>
	<span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">write_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>

	<span class="n">written</span> <span class="o">=</span> <span class="n">filemap_write_and_wait_range</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">write_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">written</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * After a write we want buffered reads to be sure to go to disk to get</span>
<span class="cm">	 * the new data.  We invalidate clean cached page from the region we&#39;re</span>
<span class="cm">	 * about to write.  We do this *before* the write so that we can return</span>
<span class="cm">	 * without clobbering -EIOCBQUEUED from -&gt;direct_IO().</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">nrpages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">written</span> <span class="o">=</span> <span class="n">invalidate_inode_pages2_range</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span>
					<span class="n">pos</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If a page can not be invalidated, return 0 to fall back</span>
<span class="cm">		 * to buffered write.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">written</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">written</span> <span class="o">==</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">written</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">direct_IO</span><span class="p">(</span><span class="n">WRITE</span><span class="p">,</span> <span class="n">iocb</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="o">*</span><span class="n">nr_segs</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Finally, try again to invalidate clean pages which might have been</span>
<span class="cm">	 * cached by non-direct readahead, or faulted in by get_user_pages()</span>
<span class="cm">	 * if the source of the write was an mmap&#39;ed region of the file</span>
<span class="cm">	 * we&#39;re writing.  Either one is a pretty crazy thing to do,</span>
<span class="cm">	 * so we don&#39;t support it 100%.  If this invalidation</span>
<span class="cm">	 * fails, tough, the write still worked...</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">nrpages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">invalidate_inode_pages2_range</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span>
					      <span class="n">pos</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">written</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">written</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&gt;</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">S_ISBLK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">i_size_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
			<span class="n">mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">ppos</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">written</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">generic_file_direct_write</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Find or create a page at the given pagecache position. Return the locked</span>
<span class="cm"> * page. This function is specifically for buffered writes.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">grab_cache_page_write_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
					<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="n">gfp_t</span> <span class="n">gfp_notmask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">gfp_mask</span> <span class="o">=</span> <span class="n">mapping_gfp_mask</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mapping_cap_account_dirty</span><span class="p">(</span><span class="n">mapping</span><span class="p">))</span>
		<span class="n">gfp_mask</span> <span class="o">|=</span> <span class="n">__GFP_WRITE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AOP_FLAG_NOFS</span><span class="p">)</span>
		<span class="n">gfp_notmask</span> <span class="o">=</span> <span class="n">__GFP_FS</span><span class="p">;</span>
<span class="nl">repeat:</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">find_lock_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">__page_cache_alloc</span><span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">gfp_notmask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">add_to_page_cache_lru</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
						<span class="n">GFP_KERNEL</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">gfp_notmask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">found:</span>
	<span class="n">wait_on_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">grab_cache_page_write_begin</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">generic_perform_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">iov_iter</span> <span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="o">*</span><span class="n">a_ops</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Copies from kernel address space cannot fail (NFSD is a big user).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">segment_eq</span><span class="p">(</span><span class="n">get_fs</span><span class="p">(),</span> <span class="n">KERNEL_DS</span><span class="p">))</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">AOP_FLAG_UNINTERRUPTIBLE</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>	<span class="cm">/* Offset into pagecache page */</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bytes</span><span class="p">;</span>	<span class="cm">/* Bytes to write to page */</span>
		<span class="kt">size_t</span> <span class="n">copied</span><span class="p">;</span>		<span class="cm">/* Bytes copied from user */</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">fsdata</span><span class="p">;</span>

		<span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
		<span class="n">bytes</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="n">offset</span><span class="p">,</span>
						<span class="n">iov_iter_count</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>

<span class="nl">again:</span>
		<span class="cm">/*</span>
<span class="cm">		 * Bring in the user page that we will copy from _first_.</span>
<span class="cm">		 * Otherwise there&#39;s a nasty deadlock on copying from the</span>
<span class="cm">		 * same page as we&#39;re writing to, without it being marked</span>
<span class="cm">		 * up-to-date.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Not only is this an optimisation, but it is also required</span>
<span class="cm">		 * to check that the address is actually valid, when atomic</span>
<span class="cm">		 * usercopies are used, below.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">iov_iter_fault_in_readable</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">bytes</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">write_begin</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsdata</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">status</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mapping_writably_mapped</span><span class="p">(</span><span class="n">mapping</span><span class="p">))</span>
			<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="n">pagefault_disable</span><span class="p">();</span>
		<span class="n">copied</span> <span class="o">=</span> <span class="n">iov_iter_copy_from_user_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
		<span class="n">pagefault_enable</span><span class="p">();</span>
		<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="n">mark_page_accessed</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">write_end</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">copied</span><span class="p">,</span>
						<span class="n">page</span><span class="p">,</span> <span class="n">fsdata</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">copied</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>

		<span class="n">cond_resched</span><span class="p">();</span>

		<span class="n">iov_iter_advance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">copied</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">copied</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If we were unable to copy any data at all, we must</span>
<span class="cm">			 * fall back to a single segment length write.</span>
<span class="cm">			 *</span>
<span class="cm">			 * If we didn&#39;t fallback here, we could livelock</span>
<span class="cm">			 * because not all segments in the iov can be copied at</span>
<span class="cm">			 * once without a pagefault.</span>
<span class="cm">			 */</span>
			<span class="n">bytes</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="n">offset</span><span class="p">,</span>
						<span class="n">iov_iter_single_seg_count</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">copied</span><span class="p">;</span>
		<span class="n">written</span> <span class="o">+=</span> <span class="n">copied</span><span class="p">;</span>

		<span class="n">balance_dirty_pages_ratelimited</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fatal_signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">iov_iter_count</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">written</span> <span class="o">?</span> <span class="n">written</span> <span class="o">:</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">ssize_t</span>
<span class="nf">generic_file_buffered_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">ssize_t</span> <span class="n">written</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iov_iter</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">iov_iter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">written</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">generic_perform_write</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">written</span> <span class="o">+=</span> <span class="n">status</span><span class="p">;</span>
		<span class="o">*</span><span class="n">ppos</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">status</span><span class="p">;</span>
  	<span class="p">}</span>
	
	<span class="k">return</span> <span class="n">written</span> <span class="o">?</span> <span class="n">written</span> <span class="o">:</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">generic_file_buffered_write</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __generic_file_aio_write - write data to a file</span>
<span class="cm"> * @iocb:	IO state structure (file, offset, etc.)</span>
<span class="cm"> * @iov:	vector with data to write</span>
<span class="cm"> * @nr_segs:	number of segments in the vector</span>
<span class="cm"> * @ppos:	position where to write</span>
<span class="cm"> *</span>
<span class="cm"> * This function does all the work needed for actually writing data to a</span>
<span class="cm"> * file. It does all basic checks, removes SUID from the file, updates</span>
<span class="cm"> * modification times and calls proper subroutines depending on whether we</span>
<span class="cm"> * do direct IO or a standard buffered write.</span>
<span class="cm"> *</span>
<span class="cm"> * It expects i_mutex to be grabbed unless we work on a block device or similar</span>
<span class="cm"> * object which does not need locking at all.</span>
<span class="cm"> *</span>
<span class="cm"> * This function does *not* take care of syncing data in case of O_SYNC write.</span>
<span class="cm"> * A caller has to handle it. This is mainly due to the fact that we want to</span>
<span class="cm"> * avoid syncing under i_mutex.</span>
<span class="cm"> */</span>
<span class="kt">ssize_t</span> <span class="nf">__generic_file_aio_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span> <span class="n">mapping</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">ocount</span><span class="p">;</span>		<span class="cm">/* original count */</span>
	<span class="kt">size_t</span> <span class="n">count</span><span class="p">;</span>		<span class="cm">/* after file limit checks */</span>
	<span class="k">struct</span> <span class="n">inode</span> 	<span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">loff_t</span>		<span class="n">pos</span><span class="p">;</span>
	<span class="kt">ssize_t</span>		<span class="n">written</span><span class="p">;</span>
	<span class="kt">ssize_t</span>		<span class="n">err</span><span class="p">;</span>

	<span class="n">ocount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">generic_segment_checks</span><span class="p">(</span><span class="n">iov</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr_segs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ocount</span><span class="p">,</span> <span class="n">VERIFY_READ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">count</span> <span class="o">=</span> <span class="n">ocount</span><span class="p">;</span>
	<span class="n">pos</span> <span class="o">=</span> <span class="o">*</span><span class="n">ppos</span><span class="p">;</span>

	<span class="n">vfs_check_frozen</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">SB_FREEZE_WRITE</span><span class="p">);</span>

	<span class="cm">/* We can write back this queue in page reclaim */</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">;</span>
	<span class="n">written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">generic_write_checks</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="n">S_ISBLK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">file_remove_suid</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">file_update_time</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* coalesce the iovecs and go direct-to-BIO for O_DIRECT */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_DIRECT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">loff_t</span> <span class="n">endbyte</span><span class="p">;</span>
		<span class="kt">ssize_t</span> <span class="n">written_buffered</span><span class="p">;</span>

		<span class="n">written</span> <span class="o">=</span> <span class="n">generic_file_direct_write</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr_segs</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span>
							<span class="n">ppos</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ocount</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">written</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">written</span> <span class="o">==</span> <span class="n">count</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * direct-io write to a hole: fall through to buffered I/O</span>
<span class="cm">		 * for completing the rest of the request.</span>
<span class="cm">		 */</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">written</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="n">written</span><span class="p">;</span>
		<span class="n">written_buffered</span> <span class="o">=</span> <span class="n">generic_file_buffered_write</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span>
						<span class="n">nr_segs</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span>
						<span class="n">written</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If generic_file_buffered_write() retuned a synchronous error</span>
<span class="cm">		 * then we want to return the number of bytes which were</span>
<span class="cm">		 * direct-written, or the error code if that was zero.  Note</span>
<span class="cm">		 * that this differs from normal direct-io semantics, which</span>
<span class="cm">		 * will return -EFOO even if some bytes were written.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">written_buffered</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">written_buffered</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * We need to ensure that the page cache pages are written to</span>
<span class="cm">		 * disk and invalidated to preserve the expected O_DIRECT</span>
<span class="cm">		 * semantics.</span>
<span class="cm">		 */</span>
		<span class="n">endbyte</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">written_buffered</span> <span class="o">-</span> <span class="n">written</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">filemap_write_and_wait_range</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">endbyte</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">written</span> <span class="o">=</span> <span class="n">written_buffered</span><span class="p">;</span>
			<span class="n">invalidate_mapping_pages</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span>
						 <span class="n">pos</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">,</span>
						 <span class="n">endbyte</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We don&#39;t know how much we wrote, so just return</span>
<span class="cm">			 * the number of bytes which were direct-written</span>
<span class="cm">			 */</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">written</span> <span class="o">=</span> <span class="n">generic_file_buffered_write</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">,</span>
				<span class="n">pos</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">written</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">written</span> <span class="o">?</span> <span class="n">written</span> <span class="o">:</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__generic_file_aio_write</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * generic_file_aio_write - write data to a file</span>
<span class="cm"> * @iocb:	IO state structure</span>
<span class="cm"> * @iov:	vector with data to write</span>
<span class="cm"> * @nr_segs:	number of segments in the vector</span>
<span class="cm"> * @pos:	position in file where to write</span>
<span class="cm"> *</span>
<span class="cm"> * This is a wrapper around __generic_file_aio_write() to be used by most</span>
<span class="cm"> * filesystems. It takes care of syncing the file in case of O_SYNC file</span>
<span class="cm"> * and acquires i_mutex as needed.</span>
<span class="cm"> */</span>
<span class="kt">ssize_t</span> <span class="nf">generic_file_aio_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">blk_plug</span> <span class="n">plug</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span> <span class="o">!=</span> <span class="n">pos</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="n">blk_start_plug</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plug</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__generic_file_aio_write</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EIOCBQUEUED</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">ssize_t</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">generic_write_sync</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">blk_finish_plug</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plug</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">generic_file_aio_write</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * try_to_release_page() - release old fs-specific metadata on a page</span>
<span class="cm"> *</span>
<span class="cm"> * @page: the page which the kernel is trying to free</span>
<span class="cm"> * @gfp_mask: memory allocation flags (and I/O mode)</span>
<span class="cm"> *</span>
<span class="cm"> * The address_space is to try to release any data against the page</span>
<span class="cm"> * (presumably at page-&gt;private).  If the release was successful, return `1&#39;.</span>
<span class="cm"> * Otherwise return zero.</span>
<span class="cm"> *</span>
<span class="cm"> * This may also be called if PG_fscache is set on a page, indicating that the</span>
<span class="cm"> * page is known to the local caching routines.</span>
<span class="cm"> *</span>
<span class="cm"> * The @gfp_mask argument specifies whether I/O may be performed to release</span>
<span class="cm"> * this page (__GFP_IO), and whether the call may block (__GFP_WAIT &amp; __GFP_FS).</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">try_to_release_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span> <span class="k">const</span> <span class="n">mapping</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mapping</span> <span class="o">&amp;&amp;</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">releasepage</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">releasepage</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">try_to_free_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">try_to_release_page</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
