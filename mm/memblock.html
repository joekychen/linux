<!DOCTYPE html>
<html><head><title>joekychen/linux » mm › memblock.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>memblock.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Procedures for maintaining information about logical memory blocks.</span>
<span class="cm"> *</span>
<span class="cm"> * Peter Bergner, IBM Corp.	June 2001.</span>
<span class="cm"> * Copyright (C) 2001 Peter Bergner.</span>
<span class="cm"> *</span>
<span class="cm"> *      This program is free software; you can redistribute it and/or</span>
<span class="cm"> *      modify it under the terms of the GNU General Public License</span>
<span class="cm"> *      as published by the Free Software Foundation; either version</span>
<span class="cm"> *      2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/poison.h&gt;</span>
<span class="cp">#include &lt;linux/pfn.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/memblock.h&gt;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">memblock_region</span> <span class="n">memblock_memory_init_regions</span><span class="p">[</span><span class="n">INIT_MEMBLOCK_REGIONS</span><span class="p">]</span> <span class="n">__initdata_memblock</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">memblock_region</span> <span class="n">memblock_reserved_init_regions</span><span class="p">[</span><span class="n">INIT_MEMBLOCK_REGIONS</span><span class="p">]</span> <span class="n">__initdata_memblock</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">memblock</span> <span class="n">memblock</span> <span class="n">__initdata_memblock</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">memory</span><span class="p">.</span><span class="n">regions</span>		<span class="o">=</span> <span class="n">memblock_memory_init_regions</span><span class="p">,</span>
	<span class="p">.</span><span class="n">memory</span><span class="p">.</span><span class="n">cnt</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>	<span class="cm">/* empty dummy entry */</span>
	<span class="p">.</span><span class="n">memory</span><span class="p">.</span><span class="n">max</span>		<span class="o">=</span> <span class="n">INIT_MEMBLOCK_REGIONS</span><span class="p">,</span>

	<span class="p">.</span><span class="n">reserved</span><span class="p">.</span><span class="n">regions</span>	<span class="o">=</span> <span class="n">memblock_reserved_init_regions</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reserved</span><span class="p">.</span><span class="n">cnt</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>	<span class="cm">/* empty dummy entry */</span>
	<span class="p">.</span><span class="n">reserved</span><span class="p">.</span><span class="n">max</span>		<span class="o">=</span> <span class="n">INIT_MEMBLOCK_REGIONS</span><span class="p">,</span>

	<span class="p">.</span><span class="n">current_limit</span>		<span class="o">=</span> <span class="n">MEMBLOCK_ALLOC_ANYWHERE</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">memblock_debug</span> <span class="n">__initdata_memblock</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">memblock_can_resize</span> <span class="n">__initdata_memblock</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">memblock_memory_in_slab</span> <span class="n">__initdata_memblock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">memblock_reserved_in_slab</span> <span class="n">__initdata_memblock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/* inline so we don&#39;t get a warning when pr_debug is compiled out */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">memblock_type_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">memblock_type</span> <span class="o">*</span><span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">memblock</span><span class="p">.</span><span class="n">memory</span><span class="p">)</span>
		<span class="k">return</span> <span class="s">&quot;memory&quot;</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">memblock</span><span class="p">.</span><span class="n">reserved</span><span class="p">)</span>
		<span class="k">return</span> <span class="s">&quot;reserved&quot;</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="s">&quot;unknown&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* adjust *@size so that (@base + *@size) doesn&#39;t overflow, return new size */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">phys_addr_t</span> <span class="nf">memblock_cap_size</span><span class="p">(</span><span class="n">phys_addr_t</span> <span class="n">base</span><span class="p">,</span> <span class="n">phys_addr_t</span> <span class="o">*</span><span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">*</span><span class="n">size</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="o">*</span><span class="n">size</span><span class="p">,</span> <span class="p">(</span><span class="n">phys_addr_t</span><span class="p">)</span><span class="n">ULLONG_MAX</span> <span class="o">-</span> <span class="n">base</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Address comparison utilities</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__init_memblock</span> <span class="nf">memblock_addrs_overlap</span><span class="p">(</span><span class="n">phys_addr_t</span> <span class="n">base1</span><span class="p">,</span> <span class="n">phys_addr_t</span> <span class="n">size1</span><span class="p">,</span>
				       <span class="n">phys_addr_t</span> <span class="n">base2</span><span class="p">,</span> <span class="n">phys_addr_t</span> <span class="n">size2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">base1</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">base2</span> <span class="o">+</span> <span class="n">size2</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">base2</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">base1</span> <span class="o">+</span> <span class="n">size1</span><span class="p">)));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="n">__init_memblock</span> <span class="nf">memblock_overlaps_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">memblock_type</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span>
					<span class="n">phys_addr_t</span> <span class="n">base</span><span class="p">,</span> <span class="n">phys_addr_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phys_addr_t</span> <span class="n">rgnbase</span> <span class="o">=</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">base</span><span class="p">;</span>
		<span class="n">phys_addr_t</span> <span class="n">rgnsize</span> <span class="o">=</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memblock_addrs_overlap</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">rgnbase</span><span class="p">,</span> <span class="n">rgnsize</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">)</span> <span class="o">?</span> <span class="n">i</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * memblock_find_in_range_node - find free area in given range and node</span>
<span class="cm"> * @start: start of candidate range</span>
<span class="cm"> * @end: end of candidate range, can be %MEMBLOCK_ALLOC_{ANYWHERE|ACCESSIBLE}</span>
<span class="cm"> * @size: size of free area to find</span>
<span class="cm"> * @align: alignment of free area to find</span>
<span class="cm"> * @nid: nid of the free area to find, %MAX_NUMNODES for any node</span>
<span class="cm"> *</span>
<span class="cm"> * Find @size free area aligned to @align in the specified range and node.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * Found address on success, %0 on failure.</span>
<span class="cm"> */</span>
<span class="n">phys_addr_t</span> <span class="n">__init_memblock</span> <span class="nf">memblock_find_in_range_node</span><span class="p">(</span><span class="n">phys_addr_t</span> <span class="n">start</span><span class="p">,</span>
					<span class="n">phys_addr_t</span> <span class="n">end</span><span class="p">,</span> <span class="n">phys_addr_t</span> <span class="n">size</span><span class="p">,</span>
					<span class="n">phys_addr_t</span> <span class="n">align</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">phys_addr_t</span> <span class="n">this_start</span><span class="p">,</span> <span class="n">this_end</span><span class="p">,</span> <span class="n">cand</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* pump up @end */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">==</span> <span class="n">MEMBLOCK_ALLOC_ACCESSIBLE</span><span class="p">)</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">memblock</span><span class="p">.</span><span class="n">current_limit</span><span class="p">;</span>

	<span class="cm">/* avoid allocating the first page */</span>
	<span class="n">start</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="n">phys_addr_t</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>

	<span class="n">for_each_free_mem_range_reverse</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">this_start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">this_end</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">this_start</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">(</span><span class="n">this_start</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="n">this_end</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">(</span><span class="n">this_end</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">this_end</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">cand</span> <span class="o">=</span> <span class="n">round_down</span><span class="p">(</span><span class="n">this_end</span> <span class="o">-</span> <span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cand</span> <span class="o">&gt;=</span> <span class="n">this_start</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">cand</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * memblock_find_in_range - find free area in given range</span>
<span class="cm"> * @start: start of candidate range</span>
<span class="cm"> * @end: end of candidate range, can be %MEMBLOCK_ALLOC_{ANYWHERE|ACCESSIBLE}</span>
<span class="cm"> * @size: size of free area to find</span>
<span class="cm"> * @align: alignment of free area to find</span>
<span class="cm"> *</span>
<span class="cm"> * Find @size free area aligned to @align in the specified range.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * Found address on success, %0 on failure.</span>
<span class="cm"> */</span>
<span class="n">phys_addr_t</span> <span class="n">__init_memblock</span> <span class="nf">memblock_find_in_range</span><span class="p">(</span><span class="n">phys_addr_t</span> <span class="n">start</span><span class="p">,</span>
					<span class="n">phys_addr_t</span> <span class="n">end</span><span class="p">,</span> <span class="n">phys_addr_t</span> <span class="n">size</span><span class="p">,</span>
					<span class="n">phys_addr_t</span> <span class="n">align</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">memblock_find_in_range_node</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span>
					   <span class="n">MAX_NUMNODES</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free memblock.reserved.regions</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init_memblock</span> <span class="nf">memblock_free_reserved_regions</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memblock</span><span class="p">.</span><span class="n">reserved</span><span class="p">.</span><span class="n">regions</span> <span class="o">==</span> <span class="n">memblock_reserved_init_regions</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">memblock_free</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">memblock</span><span class="p">.</span><span class="n">reserved</span><span class="p">.</span><span class="n">regions</span><span class="p">),</span>
		 <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">memblock_region</span><span class="p">)</span> <span class="o">*</span> <span class="n">memblock</span><span class="p">.</span><span class="n">reserved</span><span class="p">.</span><span class="n">max</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Reserve memblock.reserved.regions</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init_memblock</span> <span class="nf">memblock_reserve_reserved_regions</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memblock</span><span class="p">.</span><span class="n">reserved</span><span class="p">.</span><span class="n">regions</span> <span class="o">==</span> <span class="n">memblock_reserved_init_regions</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">memblock_reserve</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">memblock</span><span class="p">.</span><span class="n">reserved</span><span class="p">.</span><span class="n">regions</span><span class="p">),</span>
		 <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">memblock_region</span><span class="p">)</span> <span class="o">*</span> <span class="n">memblock</span><span class="p">.</span><span class="n">reserved</span><span class="p">.</span><span class="n">max</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init_memblock</span> <span class="nf">memblock_remove_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">memblock_type</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">type</span><span class="o">-&gt;</span><span class="n">total_size</span> <span class="o">-=</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">[</span><span class="n">r</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>
	<span class="n">memmove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">[</span><span class="n">r</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">[</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
		<span class="p">(</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">-</span> <span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">[</span><span class="n">r</span><span class="p">]));</span>
	<span class="n">type</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="o">--</span><span class="p">;</span>

	<span class="cm">/* Special case for empty arrays */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">total_size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">type</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">type</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">type</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">memblock_set_region_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">MAX_NUMNODES</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * memblock_double_array - double the size of the memblock regions array</span>
<span class="cm"> * @type: memblock type of the regions array being doubled</span>
<span class="cm"> * @new_area_start: starting address of memory range to avoid overlap with</span>
<span class="cm"> * @new_area_size: size of memory range to avoid overlap with</span>
<span class="cm"> *</span>
<span class="cm"> * Double the size of the @type regions array. If memblock is being used to</span>
<span class="cm"> * allocate memory for a new reserved regions array and there is a previously</span>
<span class="cm"> * allocated memory range [@new_area_start,@new_area_start+@new_area_size]</span>
<span class="cm"> * waiting to be reserved, ensure the memory used by the new array does</span>
<span class="cm"> * not overlap.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * 0 on success, -1 on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init_memblock</span> <span class="nf">memblock_double_array</span><span class="p">(</span><span class="k">struct</span> <span class="n">memblock_type</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span>
						<span class="n">phys_addr_t</span> <span class="n">new_area_start</span><span class="p">,</span>
						<span class="n">phys_addr_t</span> <span class="n">new_area_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">memblock_region</span> <span class="o">*</span><span class="n">new_array</span><span class="p">,</span> <span class="o">*</span><span class="n">old_array</span><span class="p">;</span>
	<span class="n">phys_addr_t</span> <span class="n">old_size</span><span class="p">,</span> <span class="n">new_size</span><span class="p">,</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">use_slab</span> <span class="o">=</span> <span class="n">slab_is_available</span><span class="p">();</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">in_slab</span><span class="p">;</span>

	<span class="cm">/* We don&#39;t allow resizing until we know about the reserved regions</span>
<span class="cm">	 * of memory that aren&#39;t suitable for allocation</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memblock_can_resize</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Calculate new doubled size */</span>
	<span class="n">old_size</span> <span class="o">=</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">memblock_region</span><span class="p">);</span>
	<span class="n">new_size</span> <span class="o">=</span> <span class="n">old_size</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Retrieve the slab flag */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">memblock</span><span class="p">.</span><span class="n">memory</span><span class="p">)</span>
		<span class="n">in_slab</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">memblock_memory_in_slab</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">in_slab</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">memblock_reserved_in_slab</span><span class="p">;</span>

	<span class="cm">/* Try to find some space for it.</span>
<span class="cm">	 *</span>
<span class="cm">	 * WARNING: We assume that either slab_is_available() and we use it or</span>
<span class="cm">	 * we use MEMBLOCK for allocations. That means that this is unsafe to use</span>
<span class="cm">	 * when bootmem is currently active (unless bootmem itself is implemented</span>
<span class="cm">	 * on top of MEMBLOCK which isn&#39;t the case yet)</span>
<span class="cm">	 *</span>
<span class="cm">	 * This should however not be an issue for now, as we currently only</span>
<span class="cm">	 * call into MEMBLOCK while it&#39;s still active, or much later when slab is</span>
<span class="cm">	 * active for memory hotplug operations</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">use_slab</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new_array</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">new_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">new_array</span> <span class="o">?</span> <span class="n">__pa</span><span class="p">(</span><span class="n">new_array</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* only exclude range when trying to double reserved.regions */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">memblock</span><span class="p">.</span><span class="n">reserved</span><span class="p">)</span>
			<span class="n">new_area_start</span> <span class="o">=</span> <span class="n">new_area_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">addr</span> <span class="o">=</span> <span class="n">memblock_find_in_range</span><span class="p">(</span><span class="n">new_area_start</span> <span class="o">+</span> <span class="n">new_area_size</span><span class="p">,</span>
						<span class="n">memblock</span><span class="p">.</span><span class="n">current_limit</span><span class="p">,</span>
						<span class="n">new_size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">phys_addr_t</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addr</span> <span class="o">&amp;&amp;</span> <span class="n">new_area_size</span><span class="p">)</span>
			<span class="n">addr</span> <span class="o">=</span> <span class="n">memblock_find_in_range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>
					<span class="n">min</span><span class="p">(</span><span class="n">new_area_start</span><span class="p">,</span> <span class="n">memblock</span><span class="p">.</span><span class="n">current_limit</span><span class="p">),</span>
					<span class="n">new_size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">phys_addr_t</span><span class="p">));</span>

		<span class="n">new_array</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">?</span> <span class="n">__va</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;memblock: Failed to double %s array from %ld to %ld entries !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">memblock_type_name</span><span class="p">(</span><span class="n">type</span><span class="p">),</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">,</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memblock_dbg</span><span class="p">(</span><span class="s">&quot;memblock: %s array is doubled to %ld at [%#010llx-%#010llx]&quot;</span><span class="p">,</span>
		 <span class="n">memblock_type_name</span><span class="p">(</span><span class="n">type</span><span class="p">),</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">addr</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">addr</span> <span class="o">+</span> <span class="n">new_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Found space, we now need to move the array over before</span>
<span class="cm">	 * we add the reserved region since it may be our reserved</span>
<span class="cm">	 * array itself that is full.</span>
<span class="cm">	 */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">new_array</span><span class="p">,</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">,</span> <span class="n">old_size</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">new_array</span> <span class="o">+</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">old_size</span><span class="p">);</span>
	<span class="n">old_array</span> <span class="o">=</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">;</span>
	<span class="n">type</span><span class="o">-&gt;</span><span class="n">regions</span> <span class="o">=</span> <span class="n">new_array</span><span class="p">;</span>
	<span class="n">type</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Free old array. We needn&#39;t free it if the array is the</span>
<span class="cm">	 * static one</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">in_slab</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">old_array</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">old_array</span> <span class="o">!=</span> <span class="n">memblock_memory_init_regions</span> <span class="o">&amp;&amp;</span>
		 <span class="n">old_array</span> <span class="o">!=</span> <span class="n">memblock_reserved_init_regions</span><span class="p">)</span>
		<span class="n">memblock_free</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">old_array</span><span class="p">),</span> <span class="n">old_size</span><span class="p">);</span>

	<span class="cm">/* Reserve the new array if that comes from the memblock.</span>
<span class="cm">	 * Otherwise, we needn&#39;t do it</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">use_slab</span><span class="p">)</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">memblock_reserve</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">new_size</span><span class="p">));</span>

	<span class="cm">/* Update slab flag */</span>
	<span class="o">*</span><span class="n">in_slab</span> <span class="o">=</span> <span class="n">use_slab</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * memblock_merge_regions - merge neighboring compatible regions</span>
<span class="cm"> * @type: memblock type to scan</span>
<span class="cm"> *</span>
<span class="cm"> * Scan @type and merge neighboring compatible regions.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init_memblock</span> <span class="nf">memblock_merge_regions</span><span class="p">(</span><span class="k">struct</span> <span class="n">memblock_type</span> <span class="o">*</span><span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* cnt never goes below 1 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">memblock_region</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">memblock_region</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">!=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">||</span>
		    <span class="n">memblock_get_region_node</span><span class="p">(</span><span class="n">this</span><span class="p">)</span> <span class="o">!=</span>
		    <span class="n">memblock_get_region_node</span><span class="p">(</span><span class="n">next</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">this</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">+=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="n">memmove</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">next</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">next</span><span class="p">));</span>
		<span class="n">type</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * memblock_insert_region - insert new memblock region</span>
<span class="cm"> * @type: memblock type to insert into</span>
<span class="cm"> * @idx: index for the insertion point</span>
<span class="cm"> * @base: base address of the new region</span>
<span class="cm"> * @size: size of the new region</span>
<span class="cm"> *</span>
<span class="cm"> * Insert new memblock region [@base,@base+@size) into @type at @idx.</span>
<span class="cm"> * @type must already have extra room to accomodate the new region.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init_memblock</span> <span class="nf">memblock_insert_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">memblock_type</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span>
						   <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">phys_addr_t</span> <span class="n">base</span><span class="p">,</span>
						   <span class="n">phys_addr_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">memblock_region</span> <span class="o">*</span><span class="n">rgn</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">&gt;=</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">);</span>
	<span class="n">memmove</span><span class="p">(</span><span class="n">rgn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">rgn</span><span class="p">,</span> <span class="p">(</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">-</span> <span class="n">idx</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rgn</span><span class="p">));</span>
	<span class="n">rgn</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
	<span class="n">rgn</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">memblock_set_region_node</span><span class="p">(</span><span class="n">rgn</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
	<span class="n">type</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
	<span class="n">type</span><span class="o">-&gt;</span><span class="n">total_size</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * memblock_add_region - add new memblock region</span>
<span class="cm"> * @type: memblock type to add new region into</span>
<span class="cm"> * @base: base address of the new region</span>
<span class="cm"> * @size: size of the new region</span>
<span class="cm"> * @nid: nid of the new region</span>
<span class="cm"> *</span>
<span class="cm"> * Add new memblock region [@base,@base+@size) into @type.  The new region</span>
<span class="cm"> * is allowed to overlap with existing ones - overlaps don&#39;t affect already</span>
<span class="cm"> * existing regions.  @type is guaranteed to be minimal (all neighbouring</span>
<span class="cm"> * compatible regions are merged) after the addition.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * 0 on success, -errno on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init_memblock</span> <span class="nf">memblock_add_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">memblock_type</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span>
				<span class="n">phys_addr_t</span> <span class="n">base</span><span class="p">,</span> <span class="n">phys_addr_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">insert</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">phys_addr_t</span> <span class="n">obase</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
	<span class="n">phys_addr_t</span> <span class="n">end</span> <span class="o">=</span> <span class="n">base</span> <span class="o">+</span> <span class="n">memblock_cap_size</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">nr_new</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">size</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* special case for empty array */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">total_size</span><span class="p">);</span>
		<span class="n">type</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">base</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
		<span class="n">type</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">memblock_set_region_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nid</span><span class="p">);</span>
		<span class="n">type</span><span class="o">-&gt;</span><span class="n">total_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">repeat:</span>
	<span class="cm">/*</span>
<span class="cm">	 * The following is executed twice.  Once with %false @insert and</span>
<span class="cm">	 * then with %true.  The first counts the number of regions needed</span>
<span class="cm">	 * to accomodate the new area.  The second actually inserts them.</span>
<span class="cm">	 */</span>
	<span class="n">base</span> <span class="o">=</span> <span class="n">obase</span><span class="p">;</span>
	<span class="n">nr_new</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">memblock_region</span> <span class="o">*</span><span class="n">rgn</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">phys_addr_t</span> <span class="n">rbase</span> <span class="o">=</span> <span class="n">rgn</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
		<span class="n">phys_addr_t</span> <span class="n">rend</span> <span class="o">=</span> <span class="n">rbase</span> <span class="o">+</span> <span class="n">rgn</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rbase</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rend</span> <span class="o">&lt;=</span> <span class="n">base</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * @rgn overlaps.  If it separates the lower part of new</span>
<span class="cm">		 * area, insert that portion.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rbase</span> <span class="o">&gt;</span> <span class="n">base</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nr_new</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">insert</span><span class="p">)</span>
				<span class="n">memblock_insert_region</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span>
						       <span class="n">rbase</span> <span class="o">-</span> <span class="n">base</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* area below @rend is dealt with, forget about it */</span>
		<span class="n">base</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">rend</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* insert the remaining portion */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nr_new</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">insert</span><span class="p">)</span>
			<span class="n">memblock_insert_region</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">base</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this was the first round, resize array and repeat for actual</span>
<span class="cm">	 * insertions; otherwise, merge and return.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">insert</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">+</span> <span class="n">nr_new</span> <span class="o">&gt;</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">memblock_double_array</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">obase</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">insert</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">memblock_merge_regions</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__init_memblock</span> <span class="nf">memblock_add_node</span><span class="p">(</span><span class="n">phys_addr_t</span> <span class="n">base</span><span class="p">,</span> <span class="n">phys_addr_t</span> <span class="n">size</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">memblock_add_region</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memblock</span><span class="p">.</span><span class="n">memory</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__init_memblock</span> <span class="nf">memblock_add</span><span class="p">(</span><span class="n">phys_addr_t</span> <span class="n">base</span><span class="p">,</span> <span class="n">phys_addr_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">memblock_add_region</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memblock</span><span class="p">.</span><span class="n">memory</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">MAX_NUMNODES</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * memblock_isolate_range - isolate given range into disjoint memblocks</span>
<span class="cm"> * @type: memblock type to isolate range for</span>
<span class="cm"> * @base: base of range to isolate</span>
<span class="cm"> * @size: size of range to isolate</span>
<span class="cm"> * @start_rgn: out parameter for the start of isolated region</span>
<span class="cm"> * @end_rgn: out parameter for the end of isolated region</span>
<span class="cm"> *</span>
<span class="cm"> * Walk @type and ensure that regions don&#39;t cross the boundaries defined by</span>
<span class="cm"> * [@base,@base+@size).  Crossing regions are split at the boundaries,</span>
<span class="cm"> * which may create at most two more regions.  The index of the first</span>
<span class="cm"> * region inside the range is returned in *@start_rgn and end in *@end_rgn.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * 0 on success, -errno on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init_memblock</span> <span class="nf">memblock_isolate_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">memblock_type</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span>
					<span class="n">phys_addr_t</span> <span class="n">base</span><span class="p">,</span> <span class="n">phys_addr_t</span> <span class="n">size</span><span class="p">,</span>
					<span class="kt">int</span> <span class="o">*</span><span class="n">start_rgn</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">end_rgn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">phys_addr_t</span> <span class="n">end</span> <span class="o">=</span> <span class="n">base</span> <span class="o">+</span> <span class="n">memblock_cap_size</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="o">*</span><span class="n">start_rgn</span> <span class="o">=</span> <span class="o">*</span><span class="n">end_rgn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">size</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* we&#39;ll create at most two more regions */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memblock_double_array</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">memblock_region</span> <span class="o">*</span><span class="n">rgn</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">phys_addr_t</span> <span class="n">rbase</span> <span class="o">=</span> <span class="n">rgn</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
		<span class="n">phys_addr_t</span> <span class="n">rend</span> <span class="o">=</span> <span class="n">rbase</span> <span class="o">+</span> <span class="n">rgn</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rbase</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rend</span> <span class="o">&lt;=</span> <span class="n">base</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rbase</span> <span class="o">&lt;</span> <span class="n">base</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * @rgn intersects from below.  Split and continue</span>
<span class="cm">			 * to process the next region - the new top half.</span>
<span class="cm">			 */</span>
			<span class="n">rgn</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
			<span class="n">rgn</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-=</span> <span class="n">base</span> <span class="o">-</span> <span class="n">rbase</span><span class="p">;</span>
			<span class="n">type</span><span class="o">-&gt;</span><span class="n">total_size</span> <span class="o">-=</span> <span class="n">base</span> <span class="o">-</span> <span class="n">rbase</span><span class="p">;</span>
			<span class="n">memblock_insert_region</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">rbase</span><span class="p">,</span> <span class="n">base</span> <span class="o">-</span> <span class="n">rbase</span><span class="p">,</span>
					       <span class="n">memblock_get_region_node</span><span class="p">(</span><span class="n">rgn</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rend</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * @rgn intersects from above.  Split and redo the</span>
<span class="cm">			 * current region - the new bottom half.</span>
<span class="cm">			 */</span>
			<span class="n">rgn</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
			<span class="n">rgn</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">rbase</span><span class="p">;</span>
			<span class="n">type</span><span class="o">-&gt;</span><span class="n">total_size</span> <span class="o">-=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">rbase</span><span class="p">;</span>
			<span class="n">memblock_insert_region</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">i</span><span class="o">--</span><span class="p">,</span> <span class="n">rbase</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">rbase</span><span class="p">,</span>
					       <span class="n">memblock_get_region_node</span><span class="p">(</span><span class="n">rgn</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* @rgn is fully contained, record it */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">end_rgn</span><span class="p">)</span>
				<span class="o">*</span><span class="n">start_rgn</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="o">*</span><span class="n">end_rgn</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init_memblock</span> <span class="nf">__memblock_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">memblock_type</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span>
					     <span class="n">phys_addr_t</span> <span class="n">base</span><span class="p">,</span> <span class="n">phys_addr_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">start_rgn</span><span class="p">,</span> <span class="n">end_rgn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">memblock_isolate_range</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start_rgn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end_rgn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">end_rgn</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">start_rgn</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
		<span class="n">memblock_remove_region</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__init_memblock</span> <span class="nf">memblock_remove</span><span class="p">(</span><span class="n">phys_addr_t</span> <span class="n">base</span><span class="p">,</span> <span class="n">phys_addr_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__memblock_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memblock</span><span class="p">.</span><span class="n">memory</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__init_memblock</span> <span class="nf">memblock_free</span><span class="p">(</span><span class="n">phys_addr_t</span> <span class="n">base</span><span class="p">,</span> <span class="n">phys_addr_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memblock_dbg</span><span class="p">(</span><span class="s">&quot;   memblock_free: [%#016llx-%#016llx] %pF</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">base</span><span class="p">,</span>
		     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">base</span> <span class="o">+</span> <span class="n">size</span><span class="p">,</span>
		     <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">_RET_IP_</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">__memblock_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memblock</span><span class="p">.</span><span class="n">reserved</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__init_memblock</span> <span class="nf">memblock_reserve</span><span class="p">(</span><span class="n">phys_addr_t</span> <span class="n">base</span><span class="p">,</span> <span class="n">phys_addr_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">memblock_type</span> <span class="o">*</span><span class="n">_rgn</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">memblock</span><span class="p">.</span><span class="n">reserved</span><span class="p">;</span>

	<span class="n">memblock_dbg</span><span class="p">(</span><span class="s">&quot;memblock_reserve: [%#016llx-%#016llx] %pF</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">base</span><span class="p">,</span>
		     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">base</span> <span class="o">+</span> <span class="n">size</span><span class="p">,</span>
		     <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">_RET_IP_</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">memblock_add_region</span><span class="p">(</span><span class="n">_rgn</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">MAX_NUMNODES</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __next_free_mem_range - next function for for_each_free_mem_range()</span>
<span class="cm"> * @idx: pointer to u64 loop variable</span>
<span class="cm"> * @nid: nid: node selector, %MAX_NUMNODES for all nodes</span>
<span class="cm"> * @out_start: ptr to phys_addr_t for start address of the range, can be %NULL</span>
<span class="cm"> * @out_end: ptr to phys_addr_t for end address of the range, can be %NULL</span>
<span class="cm"> * @out_nid: ptr to int for nid of the range, can be %NULL</span>
<span class="cm"> *</span>
<span class="cm"> * Find the first free area from *@idx which matches @nid, fill the out</span>
<span class="cm"> * parameters, and update *@idx for the next iteration.  The lower 32bit of</span>
<span class="cm"> * *@idx contains index into memory region and the upper 32bit indexes the</span>
<span class="cm"> * areas before each reserved region.  For example, if reserved regions</span>
<span class="cm"> * look like the following,</span>
<span class="cm"> *</span>
<span class="cm"> *	0:[0-16), 1:[32-48), 2:[128-130)</span>
<span class="cm"> *</span>
<span class="cm"> * The upper 32bit indexes the following regions.</span>
<span class="cm"> *</span>
<span class="cm"> *	0:[0-0), 1:[16-32), 2:[48-128), 3:[130-MAX)</span>
<span class="cm"> *</span>
<span class="cm"> * As both region arrays are sorted, the function advances the two indices</span>
<span class="cm"> * in lockstep and returns each intersection.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init_memblock</span> <span class="nf">__next_free_mem_range</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nid</span><span class="p">,</span>
					   <span class="n">phys_addr_t</span> <span class="o">*</span><span class="n">out_start</span><span class="p">,</span>
					   <span class="n">phys_addr_t</span> <span class="o">*</span><span class="n">out_end</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">out_nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">memblock_type</span> <span class="o">*</span><span class="n">mem</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">memblock</span><span class="p">.</span><span class="n">memory</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">memblock_type</span> <span class="o">*</span><span class="n">rsv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">memblock</span><span class="p">.</span><span class="n">reserved</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mi</span> <span class="o">=</span> <span class="o">*</span><span class="n">idx</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ri</span> <span class="o">=</span> <span class="o">*</span><span class="n">idx</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">mi</span> <span class="o">&lt;</span> <span class="n">mem</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">;</span> <span class="n">mi</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">memblock_region</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">[</span><span class="n">mi</span><span class="p">];</span>
		<span class="n">phys_addr_t</span> <span class="n">m_start</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
		<span class="n">phys_addr_t</span> <span class="n">m_end</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>

		<span class="cm">/* only memory regions are associated with nodes, check it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nid</span> <span class="o">!=</span> <span class="n">MAX_NUMNODES</span> <span class="o">&amp;&amp;</span> <span class="n">nid</span> <span class="o">!=</span> <span class="n">memblock_get_region_node</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* scan areas before each reservation for intersection */</span>
		<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">ri</span> <span class="o">&lt;</span> <span class="n">rsv</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">ri</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">memblock_region</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rsv</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">[</span><span class="n">ri</span><span class="p">];</span>
			<span class="n">phys_addr_t</span> <span class="n">r_start</span> <span class="o">=</span> <span class="n">ri</span> <span class="o">?</span> <span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">base</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">size</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">phys_addr_t</span> <span class="n">r_end</span> <span class="o">=</span> <span class="n">ri</span> <span class="o">&lt;</span> <span class="n">rsv</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">?</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">:</span> <span class="n">ULLONG_MAX</span><span class="p">;</span>

			<span class="cm">/* if ri advanced past mi, break out to advance mi */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">r_start</span> <span class="o">&gt;=</span> <span class="n">m_end</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="cm">/* if the two regions intersect, we&#39;re done */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">m_start</span> <span class="o">&lt;</span> <span class="n">r_end</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">out_start</span><span class="p">)</span>
					<span class="o">*</span><span class="n">out_start</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">m_start</span><span class="p">,</span> <span class="n">r_start</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">out_end</span><span class="p">)</span>
					<span class="o">*</span><span class="n">out_end</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">m_end</span><span class="p">,</span> <span class="n">r_end</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">out_nid</span><span class="p">)</span>
					<span class="o">*</span><span class="n">out_nid</span> <span class="o">=</span> <span class="n">memblock_get_region_node</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
				<span class="cm">/*</span>
<span class="cm">				 * The region which ends first is advanced</span>
<span class="cm">				 * for the next iteration.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">m_end</span> <span class="o">&lt;=</span> <span class="n">r_end</span><span class="p">)</span>
					<span class="n">mi</span><span class="o">++</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">ri</span><span class="o">++</span><span class="p">;</span>
				<span class="o">*</span><span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">mi</span> <span class="o">|</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">ri</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">;</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* signal end of iteration */</span>
	<span class="o">*</span><span class="n">idx</span> <span class="o">=</span> <span class="n">ULLONG_MAX</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __next_free_mem_range_rev - next function for for_each_free_mem_range_reverse()</span>
<span class="cm"> * @idx: pointer to u64 loop variable</span>
<span class="cm"> * @nid: nid: node selector, %MAX_NUMNODES for all nodes</span>
<span class="cm"> * @out_start: ptr to phys_addr_t for start address of the range, can be %NULL</span>
<span class="cm"> * @out_end: ptr to phys_addr_t for end address of the range, can be %NULL</span>
<span class="cm"> * @out_nid: ptr to int for nid of the range, can be %NULL</span>
<span class="cm"> *</span>
<span class="cm"> * Reverse of __next_free_mem_range().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init_memblock</span> <span class="nf">__next_free_mem_range_rev</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nid</span><span class="p">,</span>
					   <span class="n">phys_addr_t</span> <span class="o">*</span><span class="n">out_start</span><span class="p">,</span>
					   <span class="n">phys_addr_t</span> <span class="o">*</span><span class="n">out_end</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">out_nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">memblock_type</span> <span class="o">*</span><span class="n">mem</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">memblock</span><span class="p">.</span><span class="n">memory</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">memblock_type</span> <span class="o">*</span><span class="n">rsv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">memblock</span><span class="p">.</span><span class="n">reserved</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mi</span> <span class="o">=</span> <span class="o">*</span><span class="n">idx</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ri</span> <span class="o">=</span> <span class="o">*</span><span class="n">idx</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">idx</span> <span class="o">==</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">ULLONG_MAX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mi</span> <span class="o">=</span> <span class="n">mem</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ri</span> <span class="o">=</span> <span class="n">rsv</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">mi</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">mi</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">memblock_region</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">[</span><span class="n">mi</span><span class="p">];</span>
		<span class="n">phys_addr_t</span> <span class="n">m_start</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
		<span class="n">phys_addr_t</span> <span class="n">m_end</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>

		<span class="cm">/* only memory regions are associated with nodes, check it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nid</span> <span class="o">!=</span> <span class="n">MAX_NUMNODES</span> <span class="o">&amp;&amp;</span> <span class="n">nid</span> <span class="o">!=</span> <span class="n">memblock_get_region_node</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* scan areas before each reservation for intersection */</span>
		<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">ri</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ri</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">memblock_region</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rsv</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">[</span><span class="n">ri</span><span class="p">];</span>
			<span class="n">phys_addr_t</span> <span class="n">r_start</span> <span class="o">=</span> <span class="n">ri</span> <span class="o">?</span> <span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">base</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">size</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">phys_addr_t</span> <span class="n">r_end</span> <span class="o">=</span> <span class="n">ri</span> <span class="o">&lt;</span> <span class="n">rsv</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">?</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">:</span> <span class="n">ULLONG_MAX</span><span class="p">;</span>

			<span class="cm">/* if ri advanced past mi, break out to advance mi */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">r_end</span> <span class="o">&lt;=</span> <span class="n">m_start</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="cm">/* if the two regions intersect, we&#39;re done */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">m_end</span> <span class="o">&gt;</span> <span class="n">r_start</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">out_start</span><span class="p">)</span>
					<span class="o">*</span><span class="n">out_start</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">m_start</span><span class="p">,</span> <span class="n">r_start</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">out_end</span><span class="p">)</span>
					<span class="o">*</span><span class="n">out_end</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">m_end</span><span class="p">,</span> <span class="n">r_end</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">out_nid</span><span class="p">)</span>
					<span class="o">*</span><span class="n">out_nid</span> <span class="o">=</span> <span class="n">memblock_get_region_node</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">m_start</span> <span class="o">&gt;=</span> <span class="n">r_start</span><span class="p">)</span>
					<span class="n">mi</span><span class="o">--</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">ri</span><span class="o">--</span><span class="p">;</span>
				<span class="o">*</span><span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">mi</span> <span class="o">|</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">ri</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">;</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">idx</span> <span class="o">=</span> <span class="n">ULLONG_MAX</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HAVE_MEMBLOCK_NODE_MAP</span>
<span class="cm">/*</span>
<span class="cm"> * Common iterator interface used to define for_each_mem_range().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init_memblock</span> <span class="nf">__next_mem_pfn_range</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nid</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">out_start_pfn</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">out_end_pfn</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">out_nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">memblock_type</span> <span class="o">*</span><span class="n">type</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">memblock</span><span class="p">.</span><span class="n">memory</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">memblock_region</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">++*</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">[</span><span class="o">*</span><span class="n">idx</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">PFN_UP</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nid</span> <span class="o">==</span> <span class="n">MAX_NUMNODES</span> <span class="o">||</span> <span class="n">nid</span> <span class="o">==</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">out_start_pfn</span><span class="p">)</span>
		<span class="o">*</span><span class="n">out_start_pfn</span> <span class="o">=</span> <span class="n">PFN_UP</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">out_end_pfn</span><span class="p">)</span>
		<span class="o">*</span><span class="n">out_end_pfn</span> <span class="o">=</span> <span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">out_nid</span><span class="p">)</span>
		<span class="o">*</span><span class="n">out_nid</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * memblock_set_node - set node ID on memblock regions</span>
<span class="cm"> * @base: base of area to set node ID for</span>
<span class="cm"> * @size: size of area to set node ID for</span>
<span class="cm"> * @nid: node ID to set</span>
<span class="cm"> *</span>
<span class="cm"> * Set the nid of memblock memory regions in [@base,@base+@size) to @nid.</span>
<span class="cm"> * Regions which cross the area boundaries are split as necessary.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * 0 on success, -errno on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init_memblock</span> <span class="nf">memblock_set_node</span><span class="p">(</span><span class="n">phys_addr_t</span> <span class="n">base</span><span class="p">,</span> <span class="n">phys_addr_t</span> <span class="n">size</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">memblock_type</span> <span class="o">*</span><span class="n">type</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">memblock</span><span class="p">.</span><span class="n">memory</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">start_rgn</span><span class="p">,</span> <span class="n">end_rgn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">memblock_isolate_range</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start_rgn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end_rgn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">start_rgn</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end_rgn</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">type</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nid</span> <span class="o">=</span> <span class="n">nid</span><span class="p">;</span>

	<span class="n">memblock_merge_regions</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HAVE_MEMBLOCK_NODE_MAP */</span><span class="cp"></span>

<span class="k">static</span> <span class="n">phys_addr_t</span> <span class="n">__init</span> <span class="nf">memblock_alloc_base_nid</span><span class="p">(</span><span class="n">phys_addr_t</span> <span class="n">size</span><span class="p">,</span>
					<span class="n">phys_addr_t</span> <span class="n">align</span><span class="p">,</span> <span class="n">phys_addr_t</span> <span class="n">max_addr</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">phys_addr_t</span> <span class="n">found</span><span class="p">;</span>

	<span class="cm">/* align @size to avoid excessive fragmentation on reserved array */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">round_up</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">);</span>

	<span class="n">found</span> <span class="o">=</span> <span class="n">memblock_find_in_range_node</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">memblock_reserve</span><span class="p">(</span><span class="n">found</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">found</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">phys_addr_t</span> <span class="n">__init</span> <span class="nf">memblock_alloc_nid</span><span class="p">(</span><span class="n">phys_addr_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">phys_addr_t</span> <span class="n">align</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">memblock_alloc_base_nid</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">MEMBLOCK_ALLOC_ACCESSIBLE</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">phys_addr_t</span> <span class="n">__init</span> <span class="nf">__memblock_alloc_base</span><span class="p">(</span><span class="n">phys_addr_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">phys_addr_t</span> <span class="n">align</span><span class="p">,</span> <span class="n">phys_addr_t</span> <span class="n">max_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">memblock_alloc_base_nid</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">max_addr</span><span class="p">,</span> <span class="n">MAX_NUMNODES</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">phys_addr_t</span> <span class="n">__init</span> <span class="nf">memblock_alloc_base</span><span class="p">(</span><span class="n">phys_addr_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">phys_addr_t</span> <span class="n">align</span><span class="p">,</span> <span class="n">phys_addr_t</span> <span class="n">max_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">phys_addr_t</span> <span class="n">alloc</span><span class="p">;</span>

	<span class="n">alloc</span> <span class="o">=</span> <span class="n">__memblock_alloc_base</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">max_addr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">alloc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;ERROR: Failed to allocate 0x%llx bytes below 0x%llx.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">size</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">max_addr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">alloc</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">phys_addr_t</span> <span class="n">__init</span> <span class="nf">memblock_alloc</span><span class="p">(</span><span class="n">phys_addr_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">phys_addr_t</span> <span class="n">align</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">memblock_alloc_base</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">MEMBLOCK_ALLOC_ACCESSIBLE</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">phys_addr_t</span> <span class="n">__init</span> <span class="nf">memblock_alloc_try_nid</span><span class="p">(</span><span class="n">phys_addr_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">phys_addr_t</span> <span class="n">align</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">phys_addr_t</span> <span class="n">res</span> <span class="o">=</span> <span class="n">memblock_alloc_nid</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">memblock_alloc_base</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">MEMBLOCK_ALLOC_ACCESSIBLE</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Remaining API functions</span>
<span class="cm"> */</span>

<span class="n">phys_addr_t</span> <span class="n">__init</span> <span class="nf">memblock_phys_mem_size</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">memblock</span><span class="p">.</span><span class="n">memory</span><span class="p">.</span><span class="n">total_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* lowest address */</span>
<span class="n">phys_addr_t</span> <span class="n">__init_memblock</span> <span class="nf">memblock_start_of_DRAM</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">memblock</span><span class="p">.</span><span class="n">memory</span><span class="p">.</span><span class="n">regions</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">base</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">phys_addr_t</span> <span class="n">__init_memblock</span> <span class="nf">memblock_end_of_DRAM</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">memblock</span><span class="p">.</span><span class="n">memory</span><span class="p">.</span><span class="n">cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">memblock</span><span class="p">.</span><span class="n">memory</span><span class="p">.</span><span class="n">regions</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">base</span> <span class="o">+</span> <span class="n">memblock</span><span class="p">.</span><span class="n">memory</span><span class="p">.</span><span class="n">regions</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">memblock_enforce_memory_limit</span><span class="p">(</span><span class="n">phys_addr_t</span> <span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">phys_addr_t</span> <span class="n">max_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">phys_addr_t</span><span class="p">)</span><span class="n">ULLONG_MAX</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">limit</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* find out max address */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">memblock</span><span class="p">.</span><span class="n">memory</span><span class="p">.</span><span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">memblock_region</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">memblock</span><span class="p">.</span><span class="n">memory</span><span class="p">.</span><span class="n">regions</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">limit</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">max_addr</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">limit</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">limit</span> <span class="o">-=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* truncate both memory and reserved regions */</span>
	<span class="n">__memblock_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memblock</span><span class="p">.</span><span class="n">memory</span><span class="p">,</span> <span class="n">max_addr</span><span class="p">,</span> <span class="p">(</span><span class="n">phys_addr_t</span><span class="p">)</span><span class="n">ULLONG_MAX</span><span class="p">);</span>
	<span class="n">__memblock_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memblock</span><span class="p">.</span><span class="n">reserved</span><span class="p">,</span> <span class="n">max_addr</span><span class="p">,</span> <span class="p">(</span><span class="n">phys_addr_t</span><span class="p">)</span><span class="n">ULLONG_MAX</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init_memblock</span> <span class="nf">memblock_search</span><span class="p">(</span><span class="k">struct</span> <span class="n">memblock_type</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="n">phys_addr_t</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">right</span> <span class="o">+</span> <span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">[</span><span class="n">mid</span><span class="p">].</span><span class="n">base</span><span class="p">)</span>
			<span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">[</span><span class="n">mid</span><span class="p">].</span><span class="n">base</span> <span class="o">+</span>
				  <span class="n">type</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">[</span><span class="n">mid</span><span class="p">].</span><span class="n">size</span><span class="p">))</span>
			<span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">mid</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">memblock_is_reserved</span><span class="p">(</span><span class="n">phys_addr_t</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">memblock_search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memblock</span><span class="p">.</span><span class="n">reserved</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__init_memblock</span> <span class="nf">memblock_is_memory</span><span class="p">(</span><span class="n">phys_addr_t</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">memblock_search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memblock</span><span class="p">.</span><span class="n">memory</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * memblock_is_region_memory - check if a region is a subset of memory</span>
<span class="cm"> * @base: base of region to check</span>
<span class="cm"> * @size: size of region to check</span>
<span class="cm"> *</span>
<span class="cm"> * Check if the region [@base, @base+@size) is a subset of a memory block.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * 0 if false, non-zero if true</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init_memblock</span> <span class="nf">memblock_is_region_memory</span><span class="p">(</span><span class="n">phys_addr_t</span> <span class="n">base</span><span class="p">,</span> <span class="n">phys_addr_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">memblock_search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memblock</span><span class="p">.</span><span class="n">memory</span><span class="p">,</span> <span class="n">base</span><span class="p">);</span>
	<span class="n">phys_addr_t</span> <span class="n">end</span> <span class="o">=</span> <span class="n">base</span> <span class="o">+</span> <span class="n">memblock_cap_size</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">memblock</span><span class="p">.</span><span class="n">memory</span><span class="p">.</span><span class="n">regions</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">base</span> <span class="o">&lt;=</span> <span class="n">base</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">memblock</span><span class="p">.</span><span class="n">memory</span><span class="p">.</span><span class="n">regions</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">base</span> <span class="o">+</span>
		 <span class="n">memblock</span><span class="p">.</span><span class="n">memory</span><span class="p">.</span><span class="n">regions</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * memblock_is_region_reserved - check if a region intersects reserved memory</span>
<span class="cm"> * @base: base of region to check</span>
<span class="cm"> * @size: size of region to check</span>
<span class="cm"> *</span>
<span class="cm"> * Check if the region [@base, @base+@size) intersects a reserved memory block.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * 0 if false, non-zero if true</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init_memblock</span> <span class="nf">memblock_is_region_reserved</span><span class="p">(</span><span class="n">phys_addr_t</span> <span class="n">base</span><span class="p">,</span> <span class="n">phys_addr_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memblock_cap_size</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">memblock_overlaps_region</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memblock</span><span class="p">.</span><span class="n">reserved</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">__init_memblock</span> <span class="nf">memblock_set_current_limit</span><span class="p">(</span><span class="n">phys_addr_t</span> <span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memblock</span><span class="p">.</span><span class="n">current_limit</span> <span class="o">=</span> <span class="n">limit</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init_memblock</span> <span class="nf">memblock_dump</span><span class="p">(</span><span class="k">struct</span> <span class="n">memblock_type</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot; %s.cnt  = 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">memblock_region</span> <span class="o">*</span><span class="n">rgn</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="kt">char</span> <span class="n">nid_buf</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>

		<span class="n">base</span> <span class="o">=</span> <span class="n">rgn</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">rgn</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_HAVE_MEMBLOCK_NODE_MAP</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memblock_get_region_node</span><span class="p">(</span><span class="n">rgn</span><span class="p">)</span> <span class="o">!=</span> <span class="n">MAX_NUMNODES</span><span class="p">)</span>
			<span class="n">snprintf</span><span class="p">(</span><span class="n">nid_buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nid_buf</span><span class="p">),</span> <span class="s">&quot; on node %d&quot;</span><span class="p">,</span>
				 <span class="n">memblock_get_region_node</span><span class="p">(</span><span class="n">rgn</span><span class="p">));</span>
<span class="cp">#endif</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot; %s[%#x]</span><span class="se">\t</span><span class="s">[%#016llx-%#016llx], %#llx bytes%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">nid_buf</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init_memblock</span> <span class="nf">__memblock_dump_all</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;MEMBLOCK configuration:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot; memory size = %#llx reserved size = %#llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">memblock</span><span class="p">.</span><span class="n">memory</span><span class="p">.</span><span class="n">total_size</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">memblock</span><span class="p">.</span><span class="n">reserved</span><span class="p">.</span><span class="n">total_size</span><span class="p">);</span>

	<span class="n">memblock_dump</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memblock</span><span class="p">.</span><span class="n">memory</span><span class="p">,</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
	<span class="n">memblock_dump</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memblock</span><span class="p">.</span><span class="n">reserved</span><span class="p">,</span> <span class="s">&quot;reserved&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">memblock_allow_resize</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memblock_can_resize</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">early_memblock</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">strstr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;debug&quot;</span><span class="p">))</span>
		<span class="n">memblock_debug</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;memblock&quot;</span><span class="p">,</span> <span class="n">early_memblock</span><span class="p">);</span>

<span class="cp">#if defined(CONFIG_DEBUG_FS) &amp;&amp; !defined(CONFIG_ARCH_DISCARD_MEMBLOCK)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">memblock_debug_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">private</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">memblock_type</span> <span class="o">*</span><span class="n">type</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">memblock_region</span> <span class="o">*</span><span class="n">reg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%4d: &quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">phys_addr_t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;0x%08lx..0x%08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span>
				   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
		<span class="k">else</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;0x%016llx..0x%016llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span>
				   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">memblock_debug_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">memblock_debug_show</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">memblock_debug_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">memblock_debug_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">memblock_init_debugfs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="s">&quot;memblock&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="n">debugfs_create_file</span><span class="p">(</span><span class="s">&quot;memory&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">memblock</span><span class="p">.</span><span class="n">memory</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">memblock_debug_fops</span><span class="p">);</span>
	<span class="n">debugfs_create_file</span><span class="p">(</span><span class="s">&quot;reserved&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">memblock</span><span class="p">.</span><span class="n">reserved</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">memblock_debug_fops</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__initcall</span><span class="p">(</span><span class="n">memblock_init_debugfs</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_DEBUG_FS */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
