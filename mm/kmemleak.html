<!DOCTYPE html>
<html><head><title>joekychen/linux » mm › kmemleak.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>kmemleak.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * mm/kmemleak.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2008 ARM Limited</span>
<span class="cm"> * Written by Catalin Marinas &lt;catalin.marinas@arm.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * For more information on the algorithm and kmemleak usage, please see</span>
<span class="cm"> * Documentation/kmemleak.txt.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes on locking</span>
<span class="cm"> * ----------------</span>
<span class="cm"> *</span>
<span class="cm"> * The following locks and mutexes are used by kmemleak:</span>
<span class="cm"> *</span>
<span class="cm"> * - kmemleak_lock (rwlock): protects the object_list modifications and</span>
<span class="cm"> *   accesses to the object_tree_root. The object_list is the main list</span>
<span class="cm"> *   holding the metadata (struct kmemleak_object) for the allocated memory</span>
<span class="cm"> *   blocks. The object_tree_root is a priority search tree used to look-up</span>
<span class="cm"> *   metadata based on a pointer to the corresponding memory block.  The</span>
<span class="cm"> *   kmemleak_object structures are added to the object_list and</span>
<span class="cm"> *   object_tree_root in the create_object() function called from the</span>
<span class="cm"> *   kmemleak_alloc() callback and removed in delete_object() called from the</span>
<span class="cm"> *   kmemleak_free() callback</span>
<span class="cm"> * - kmemleak_object.lock (spinlock): protects a kmemleak_object. Accesses to</span>
<span class="cm"> *   the metadata (e.g. count) are protected by this lock. Note that some</span>
<span class="cm"> *   members of this structure may be protected by other means (atomic or</span>
<span class="cm"> *   kmemleak_lock). This lock is also held when scanning the corresponding</span>
<span class="cm"> *   memory block to avoid the kernel freeing it via the kmemleak_free()</span>
<span class="cm"> *   callback. This is less heavyweight than holding a global lock like</span>
<span class="cm"> *   kmemleak_lock during scanning</span>
<span class="cm"> * - scan_mutex (mutex): ensures that only one thread may scan the memory for</span>
<span class="cm"> *   unreferenced objects at a time. The gray_list contains the objects which</span>
<span class="cm"> *   are already referenced or marked as false positives and need to be</span>
<span class="cm"> *   scanned. This list is only modified during a scanning episode when the</span>
<span class="cm"> *   scan_mutex is held. At the end of a scan, the gray_list is always empty.</span>
<span class="cm"> *   Note that the kmemleak_object.use_count is incremented when an object is</span>
<span class="cm"> *   added to the gray_list and therefore cannot be freed. This mutex also</span>
<span class="cm"> *   prevents multiple users of the &quot;kmemleak&quot; debugfs file together with</span>
<span class="cm"> *   modifications to the memory scanning parameters including the scan_thread</span>
<span class="cm"> *   pointer</span>
<span class="cm"> *</span>
<span class="cm"> * The kmemleak_object structures have a use_count incremented or decremented</span>
<span class="cm"> * using the get_object()/put_object() functions. When the use_count becomes</span>
<span class="cm"> * 0, this count can no longer be incremented and put_object() schedules the</span>
<span class="cm"> * kmemleak_object freeing via an RCU callback. All calls to the get_object()</span>
<span class="cm"> * function must be protected by rcu_read_lock() to avoid accessing a freed</span>
<span class="cm"> * structure.</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/jiffies.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/prio_tree.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/cpumask.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>
<span class="cp">#include &lt;linux/stacktrace.h&gt;</span>
<span class="cp">#include &lt;linux/cache.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/hardirq.h&gt;</span>
<span class="cp">#include &lt;linux/mmzone.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/thread_info.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/nodemask.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/crc32.h&gt;</span>

<span class="cp">#include &lt;asm/sections.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>

<span class="cp">#include &lt;linux/kmemcheck.h&gt;</span>
<span class="cp">#include &lt;linux/kmemleak.h&gt;</span>
<span class="cp">#include &lt;linux/memory_hotplug.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Kmemleak configuration and common defines.</span>
<span class="cm"> */</span>
<span class="cp">#define MAX_TRACE		16	</span><span class="cm">/* stack trace length */</span><span class="cp"></span>
<span class="cp">#define MSECS_MIN_AGE		5000	</span><span class="cm">/* minimum object age for reporting */</span><span class="cp"></span>
<span class="cp">#define SECS_FIRST_SCAN		60	</span><span class="cm">/* delay before the first scan */</span><span class="cp"></span>
<span class="cp">#define SECS_SCAN_WAIT		600	</span><span class="cm">/* subsequent auto scanning delay */</span><span class="cp"></span>
<span class="cp">#define MAX_SCAN_SIZE		4096	</span><span class="cm">/* maximum size of a scanned block */</span><span class="cp"></span>

<span class="cp">#define BYTES_PER_POINTER	sizeof(void *)</span>

<span class="cm">/* GFP bitmask for kmemleak internal allocations */</span>
<span class="cp">#define gfp_kmemleak_mask(gfp)	(((gfp) &amp; (GFP_KERNEL | GFP_ATOMIC)) | \</span>
<span class="cp">				 __GFP_NORETRY | __GFP_NOMEMALLOC | \</span>
<span class="cp">				 __GFP_NOWARN)</span>

<span class="cm">/* scanning area inside a memory block */</span>
<span class="k">struct</span> <span class="n">kmemleak_scan_area</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">node</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define KMEMLEAK_GREY	0</span>
<span class="cp">#define KMEMLEAK_BLACK	-1</span>

<span class="cm">/*</span>
<span class="cm"> * Structure holding the metadata for each allocated memory block.</span>
<span class="cm"> * Modifications to such objects should be made while holding the</span>
<span class="cm"> * object-&gt;lock. Insertions or deletions from object_list, gray_list or</span>
<span class="cm"> * tree_node are already protected by the corresponding locks or mutex (see</span>
<span class="cm"> * the notes on locking above). These objects are reference-counted</span>
<span class="cm"> * (use_count) and freed using the RCU mechanism.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">kmemleak_object</span> <span class="p">{</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>		<span class="cm">/* object status flags */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">object_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">gray_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">prio_tree_node</span> <span class="n">tree_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">rcu</span><span class="p">;</span>		<span class="cm">/* object_list lockless traversal */</span>
	<span class="cm">/* object usage count; object freed when use_count == 0 */</span>
	<span class="n">atomic_t</span> <span class="n">use_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pointer</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="cm">/* minimum number of a pointers found before it is considered leak */</span>
	<span class="kt">int</span> <span class="n">min_count</span><span class="p">;</span>
	<span class="cm">/* the total number of pointers found pointing to this object */</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="cm">/* checksum for detecting modified objects */</span>
	<span class="n">u32</span> <span class="n">checksum</span><span class="p">;</span>
	<span class="cm">/* memory ranges to be scanned inside an object (empty for all) */</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="n">area_list</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">trace</span><span class="p">[</span><span class="n">MAX_TRACE</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">trace_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">jiffies</span><span class="p">;</span>		<span class="cm">/* creation timestamp */</span>
	<span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>			<span class="cm">/* pid of the current task */</span>
	<span class="kt">char</span> <span class="n">comm</span><span class="p">[</span><span class="n">TASK_COMM_LEN</span><span class="p">];</span>	<span class="cm">/* executable name */</span>
<span class="p">};</span>

<span class="cm">/* flag representing the memory block allocation status */</span>
<span class="cp">#define OBJECT_ALLOCATED	(1 &lt;&lt; 0)</span>
<span class="cm">/* flag set after the first reporting of an unreference object */</span>
<span class="cp">#define OBJECT_REPORTED		(1 &lt;&lt; 1)</span>
<span class="cm">/* flag set to not scan the object */</span>
<span class="cp">#define OBJECT_NO_SCAN		(1 &lt;&lt; 2)</span>

<span class="cm">/* number of bytes to print per line; must be 16 or 32 */</span>
<span class="cp">#define HEX_ROW_SIZE		16</span>
<span class="cm">/* number of bytes to print at a time (1, 2, 4, 8) */</span>
<span class="cp">#define HEX_GROUP_SIZE		1</span>
<span class="cm">/* include ASCII after the hex output */</span>
<span class="cp">#define HEX_ASCII		1</span>
<span class="cm">/* max number of lines to be printed */</span>
<span class="cp">#define HEX_MAX_LINES		2</span>

<span class="cm">/* the list of all allocated objects */</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">object_list</span><span class="p">);</span>
<span class="cm">/* the list of gray-colored objects (see color_gray comment below) */</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">gray_list</span><span class="p">);</span>
<span class="cm">/* prio search tree for object boundaries */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">prio_tree_root</span> <span class="n">object_tree_root</span><span class="p">;</span>
<span class="cm">/* rw_lock protecting the access to object_list and prio_tree_root */</span>
<span class="k">static</span> <span class="n">DEFINE_RWLOCK</span><span class="p">(</span><span class="n">kmemleak_lock</span><span class="p">);</span>

<span class="cm">/* allocation caches for kmemleak internal data */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">object_cache</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">scan_area_cache</span><span class="p">;</span>

<span class="cm">/* set if tracing memory operations is enabled */</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">kmemleak_enabled</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="cm">/* set in the late_initcall if there were no errors */</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">kmemleak_initialized</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="cm">/* enables or disables early logging of the memory operations */</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">kmemleak_early_log</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="cm">/* set if a kmemleak warning was issued */</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">kmemleak_warning</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="cm">/* set if a fatal kmemleak error has occurred */</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">kmemleak_error</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="cm">/* minimum and maximum address that may be valid pointers */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">min_addr</span> <span class="o">=</span> <span class="n">ULONG_MAX</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_addr</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">scan_thread</span><span class="p">;</span>
<span class="cm">/* used to avoid reporting of recently allocated objects */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">jiffies_min_age</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">jiffies_last_scan</span><span class="p">;</span>
<span class="cm">/* delay between automatic memory scannings */</span>
<span class="k">static</span> <span class="kt">signed</span> <span class="kt">long</span> <span class="n">jiffies_scan_wait</span><span class="p">;</span>
<span class="cm">/* enables or disables the task stacks scanning */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">kmemleak_stack_scan</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cm">/* protects the memory scanning, parameters and debug/kmemleak file access */</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">scan_mutex</span><span class="p">);</span>
<span class="cm">/* setting kmemleak=on, will set this var, skipping the disable */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">kmemleak_skip_disable</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * Early object allocation/freeing logging. Kmemleak is initialized after the</span>
<span class="cm"> * kernel allocator. However, both the kernel allocator and kmemleak may</span>
<span class="cm"> * allocate memory blocks which need to be tracked. Kmemleak defines an</span>
<span class="cm"> * arbitrary buffer to hold the allocation/freeing information before it is</span>
<span class="cm"> * fully initialized.</span>
<span class="cm"> */</span>

<span class="cm">/* kmemleak operation type for early logging */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">KMEMLEAK_ALLOC</span><span class="p">,</span>
	<span class="n">KMEMLEAK_ALLOC_PERCPU</span><span class="p">,</span>
	<span class="n">KMEMLEAK_FREE</span><span class="p">,</span>
	<span class="n">KMEMLEAK_FREE_PART</span><span class="p">,</span>
	<span class="n">KMEMLEAK_FREE_PERCPU</span><span class="p">,</span>
	<span class="n">KMEMLEAK_NOT_LEAK</span><span class="p">,</span>
	<span class="n">KMEMLEAK_IGNORE</span><span class="p">,</span>
	<span class="n">KMEMLEAK_SCAN_AREA</span><span class="p">,</span>
	<span class="n">KMEMLEAK_NO_SCAN</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Structure holding the information passed to kmemleak callbacks during the</span>
<span class="cm"> * early logging.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">early_log</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">op_type</span><span class="p">;</span>			<span class="cm">/* kmemleak operation type */</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>		<span class="cm">/* allocated/freed memory block */</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>			<span class="cm">/* memory block size */</span>
	<span class="kt">int</span> <span class="n">min_count</span><span class="p">;</span>			<span class="cm">/* minimum reference count */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">trace</span><span class="p">[</span><span class="n">MAX_TRACE</span><span class="p">];</span>	<span class="cm">/* stack trace */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">trace_len</span><span class="p">;</span>		<span class="cm">/* stack trace length */</span>
<span class="p">};</span>

<span class="cm">/* early logging buffer and current position */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">early_log</span>
	<span class="n">early_log</span><span class="p">[</span><span class="n">CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE</span><span class="p">]</span> <span class="n">__initdata</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">crt_early_log</span> <span class="n">__initdata</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">kmemleak_disable</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Print a warning and dump the stack trace.</span>
<span class="cm"> */</span>
<span class="cp">#define kmemleak_warn(x...)	do {		\</span>
<span class="cp">	pr_warning(x);				\</span>
<span class="cp">	dump_stack();				\</span>
<span class="cp">	atomic_set(&amp;kmemleak_warning, 1);	\</span>
<span class="cp">} while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * Macro invoked when a serious kmemleak condition occurred and cannot be</span>
<span class="cm"> * recovered from. Kmemleak will be disabled and further allocation/freeing</span>
<span class="cm"> * tracing no longer available.</span>
<span class="cm"> */</span>
<span class="cp">#define kmemleak_stop(x...)	do {	\</span>
<span class="cp">	kmemleak_warn(x);		\</span>
<span class="cp">	kmemleak_disable();		\</span>
<span class="cp">} while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * Printing of the objects hex dump to the seq file. The number of lines to be</span>
<span class="cm"> * printed is limited to HEX_MAX_LINES to prevent seq file spamming. The</span>
<span class="cm"> * actual number of printed bytes depends on HEX_ROW_SIZE. It must be called</span>
<span class="cm"> * with the object-&gt;lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hex_dump_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">kmemleak_object</span> <span class="o">*</span><span class="n">object</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">pointer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">remaining</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">linebuf</span><span class="p">[</span><span class="n">HEX_ROW_SIZE</span> <span class="o">*</span> <span class="mi">5</span><span class="p">];</span>

	<span class="cm">/* limit the number of lines to HEX_MAX_LINES */</span>
	<span class="n">remaining</span> <span class="o">=</span> <span class="n">len</span> <span class="o">=</span>
		<span class="n">min</span><span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">HEX_MAX_LINES</span> <span class="o">*</span> <span class="n">HEX_ROW_SIZE</span><span class="p">));</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;  hex dump (first %d bytes):</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">HEX_ROW_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">linelen</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">remaining</span><span class="p">,</span> <span class="n">HEX_ROW_SIZE</span><span class="p">);</span>

		<span class="n">remaining</span> <span class="o">-=</span> <span class="n">HEX_ROW_SIZE</span><span class="p">;</span>
		<span class="n">hex_dump_to_buffer</span><span class="p">(</span><span class="n">ptr</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">linelen</span><span class="p">,</span> <span class="n">HEX_ROW_SIZE</span><span class="p">,</span>
				   <span class="n">HEX_GROUP_SIZE</span><span class="p">,</span> <span class="n">linebuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">linebuf</span><span class="p">),</span>
				   <span class="n">HEX_ASCII</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;    %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">linebuf</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Object colors, encoded with count and min_count:</span>
<span class="cm"> * - white - orphan object, not enough references to it (count &lt; min_count)</span>
<span class="cm"> * - gray  - not orphan, not marked as false positive (min_count == 0) or</span>
<span class="cm"> *		sufficient references to it (count &gt;= min_count)</span>
<span class="cm"> * - black - ignore, it doesn&#39;t contain references (e.g. text section)</span>
<span class="cm"> *		(min_count == -1). No function defined for this color.</span>
<span class="cm"> * Newly created objects don&#39;t have any color assigned (object-&gt;count == -1)</span>
<span class="cm"> * before the next memory scan when they become white.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">color_white</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">kmemleak_object</span> <span class="o">*</span><span class="n">object</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">!=</span> <span class="n">KMEMLEAK_BLACK</span> <span class="o">&amp;&amp;</span>
		<span class="n">object</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">min_count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">color_gray</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">kmemleak_object</span> <span class="o">*</span><span class="n">object</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">min_count</span> <span class="o">!=</span> <span class="n">KMEMLEAK_BLACK</span> <span class="o">&amp;&amp;</span>
		<span class="n">object</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">min_count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Objects are considered unreferenced only if their color is white, they have</span>
<span class="cm"> * not be deleted and have a minimum age to avoid false positives caused by</span>
<span class="cm"> * pointers temporarily stored in CPU registers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">unreferenced_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmemleak_object</span> <span class="o">*</span><span class="n">object</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">color_white</span><span class="p">(</span><span class="n">object</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OBJECT_ALLOCATED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">time_before_eq</span><span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">jiffies</span> <span class="o">+</span> <span class="n">jiffies_min_age</span><span class="p">,</span>
			       <span class="n">jiffies_last_scan</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Printing of the unreferenced objects information to the seq file. The</span>
<span class="cm"> * print_unreferenced function must be called with the object-&gt;lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_unreferenced</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">kmemleak_object</span> <span class="o">*</span><span class="n">object</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">msecs_age</span> <span class="o">=</span> <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">jiffies</span> <span class="o">-</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">jiffies</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;unreferenced object 0x%08lx (size %zu):</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">object</span><span class="o">-&gt;</span><span class="n">pointer</span><span class="p">,</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;  comm </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s">, pid %d, jiffies %lu (age %d.%03ds)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">object</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">jiffies</span><span class="p">,</span>
		   <span class="n">msecs_age</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">msecs_age</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="n">hex_dump_object</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">object</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;  backtrace:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">trace_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">trace</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;    [&lt;%p&gt;] %pS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Print the kmemleak_object information. This function is used mainly for</span>
<span class="cm"> * debugging special cases when kmemleak operations. It must be called with</span>
<span class="cm"> * the object-&gt;lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dump_object_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmemleak_object</span> <span class="o">*</span><span class="n">object</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">stack_trace</span> <span class="n">trace</span><span class="p">;</span>

	<span class="n">trace</span><span class="p">.</span><span class="n">nr_entries</span> <span class="o">=</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">trace_len</span><span class="p">;</span>
	<span class="n">trace</span><span class="p">.</span><span class="n">entries</span> <span class="o">=</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">trace</span><span class="p">;</span>

	<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;Object 0x%08lx (size %zu):</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">object</span><span class="o">-&gt;</span><span class="n">tree_node</span><span class="p">.</span><span class="n">start</span><span class="p">,</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;  comm </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s">, pid %d, jiffies %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">object</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">jiffies</span><span class="p">);</span>
	<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;  min_count = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">min_count</span><span class="p">);</span>
	<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;  count = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
	<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;  flags = 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;  checksum = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">checksum</span><span class="p">);</span>
	<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;  backtrace:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">print_stack_trace</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Look-up a memory block metadata (kmemleak_object) in the priority search</span>
<span class="cm"> * tree based on a pointer value. If alias is 0, only values pointing to the</span>
<span class="cm"> * beginning of the memory block are allowed. The kmemleak_lock must be held</span>
<span class="cm"> * when calling this function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmemleak_object</span> <span class="o">*</span><span class="nf">lookup_object</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">alias</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">prio_tree_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">prio_tree_iter</span> <span class="n">iter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmemleak_object</span> <span class="o">*</span><span class="n">object</span><span class="p">;</span>

	<span class="n">prio_tree_iter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">object_tree_root</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
	<span class="n">node</span> <span class="o">=</span> <span class="n">prio_tree_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">object</span> <span class="o">=</span> <span class="n">prio_tree_entry</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kmemleak_object</span><span class="p">,</span>
					 <span class="n">tree_node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alias</span> <span class="o">&amp;&amp;</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">pointer</span> <span class="o">!=</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kmemleak_warn</span><span class="p">(</span><span class="s">&quot;Found object by alias at 0x%08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				      <span class="n">ptr</span><span class="p">);</span>
			<span class="n">dump_object_info</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
			<span class="n">object</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">object</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">object</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Increment the object use_count. Return 1 if successful or 0 otherwise. Note</span>
<span class="cm"> * that once an object&#39;s use_count reached 0, the RCU freeing was already</span>
<span class="cm"> * registered and the object should no longer be used. This function must be</span>
<span class="cm"> * called under the protection of rcu_read_lock().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmemleak_object</span> <span class="o">*</span><span class="n">object</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">use_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * RCU callback to free a kmemleak_object.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_object_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">rcu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">elem</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmemleak_scan_area</span> <span class="o">*</span><span class="n">area</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmemleak_object</span> <span class="o">*</span><span class="n">object</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">rcu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kmemleak_object</span><span class="p">,</span> <span class="n">rcu</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Once use_count is 0 (guaranteed by put_object), there is no other</span>
<span class="cm">	 * code accessing this object, hence no need for locking.</span>
<span class="cm">	 */</span>
	<span class="n">hlist_for_each_entry_safe</span><span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="n">elem</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">area_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hlist_del</span><span class="p">(</span><span class="n">elem</span><span class="p">);</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">scan_area_cache</span><span class="p">,</span> <span class="n">area</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">object_cache</span><span class="p">,</span> <span class="n">object</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Decrement the object use_count. Once the count is 0, free the object using</span>
<span class="cm"> * an RCU callback. Since put_object() may be called via the kmemleak_free() -&gt;</span>
<span class="cm"> * delete_object() path, the delayed RCU freeing ensures that there is no</span>
<span class="cm"> * recursive call to the kernel allocator. Lock-less RCU object_list traversal</span>
<span class="cm"> * is also possible.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">put_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmemleak_object</span> <span class="o">*</span><span class="n">object</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">use_count</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* should only get here after delete_object was called */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OBJECT_ALLOCATED</span><span class="p">);</span>

	<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">rcu</span><span class="p">,</span> <span class="n">free_object_rcu</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Look up an object in the prio search tree and increase its use_count.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmemleak_object</span> <span class="o">*</span><span class="nf">find_and_get_object</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">alias</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmemleak_object</span> <span class="o">*</span><span class="n">object</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">read_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmemleak_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">&gt;=</span> <span class="n">min_addr</span> <span class="o">&amp;&amp;</span> <span class="n">ptr</span> <span class="o">&lt;</span> <span class="n">max_addr</span><span class="p">)</span>
		<span class="n">object</span> <span class="o">=</span> <span class="n">lookup_object</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">alias</span><span class="p">);</span>
	<span class="n">read_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmemleak_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* check whether the object is still available */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">object</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">get_object</span><span class="p">(</span><span class="n">object</span><span class="p">))</span>
		<span class="n">object</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">object</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Save stack trace to the given array of MAX_TRACE size.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__save_stack_trace</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">trace</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">stack_trace</span> <span class="n">stack_trace</span><span class="p">;</span>

	<span class="n">stack_trace</span><span class="p">.</span><span class="n">max_entries</span> <span class="o">=</span> <span class="n">MAX_TRACE</span><span class="p">;</span>
	<span class="n">stack_trace</span><span class="p">.</span><span class="n">nr_entries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">stack_trace</span><span class="p">.</span><span class="n">entries</span> <span class="o">=</span> <span class="n">trace</span><span class="p">;</span>
	<span class="n">stack_trace</span><span class="p">.</span><span class="n">skip</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">save_stack_trace</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stack_trace</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">stack_trace</span><span class="p">.</span><span class="n">nr_entries</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Create the metadata (struct kmemleak_object) corresponding to an allocated</span>
<span class="cm"> * memory block and add it to the object_list and object_tree_root.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmemleak_object</span> <span class="o">*</span><span class="nf">create_object</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
					     <span class="kt">int</span> <span class="n">min_count</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmemleak_object</span> <span class="o">*</span><span class="n">object</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">prio_tree_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

	<span class="n">object</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">object_cache</span><span class="p">,</span> <span class="n">gfp_kmemleak_mask</span><span class="p">(</span><span class="n">gfp</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">object</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Cannot allocate a kmemleak_object structure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">kmemleak_disable</span><span class="p">();</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">object_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">gray_list</span><span class="p">);</span>
	<span class="n">INIT_HLIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">area_list</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">use_count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">object</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">OBJECT_ALLOCATED</span><span class="p">;</span>
	<span class="n">object</span><span class="o">-&gt;</span><span class="n">pointer</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="n">object</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">object</span><span class="o">-&gt;</span><span class="n">min_count</span> <span class="o">=</span> <span class="n">min_count</span><span class="p">;</span>
	<span class="n">object</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>			<span class="cm">/* white color initially */</span>
	<span class="n">object</span><span class="o">-&gt;</span><span class="n">jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">object</span><span class="o">-&gt;</span><span class="n">checksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* task information */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in_irq</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">object</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">strncpy</span><span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="s">&quot;hardirq&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">in_softirq</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">object</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">strncpy</span><span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="s">&quot;softirq&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">object</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * There is a small chance of a race with set_task_comm(),</span>
<span class="cm">		 * however using get_task_comm() here may cause locking</span>
<span class="cm">		 * dependency issues with current-&gt;alloc_lock. In the worst</span>
<span class="cm">		 * case, the command line is not correct.</span>
<span class="cm">		 */</span>
		<span class="n">strncpy</span><span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/* kernel backtrace */</span>
	<span class="n">object</span><span class="o">-&gt;</span><span class="n">trace_len</span> <span class="o">=</span> <span class="n">__save_stack_trace</span><span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">trace</span><span class="p">);</span>

	<span class="n">INIT_PRIO_TREE_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">tree_node</span><span class="p">);</span>
	<span class="n">object</span><span class="o">-&gt;</span><span class="n">tree_node</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="n">object</span><span class="o">-&gt;</span><span class="n">tree_node</span><span class="p">.</span><span class="n">last</span> <span class="o">=</span> <span class="n">ptr</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">write_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmemleak_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">min_addr</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">min_addr</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
	<span class="n">max_addr</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">max_addr</span><span class="p">,</span> <span class="n">ptr</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">node</span> <span class="o">=</span> <span class="n">prio_tree_insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object_tree_root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">tree_node</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * The code calling the kernel does not yet have the pointer to the</span>
<span class="cm">	 * memory block to be able to free it.  However, we still hold the</span>
<span class="cm">	 * kmemleak_lock here in case parts of the kernel started freeing</span>
<span class="cm">	 * random memory blocks.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">tree_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmemleak_stop</span><span class="p">(</span><span class="s">&quot;Cannot insert 0x%lx into the object search tree &quot;</span>
			      <span class="s">&quot;(already existing)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
		<span class="n">object</span> <span class="o">=</span> <span class="n">lookup_object</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">dump_object_info</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_add_tail_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">object_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">object_list</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">write_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmemleak_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">object</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove the metadata (struct kmemleak_object) for a memory block from the</span>
<span class="cm"> * object_list and object_tree_root and decrement its use_count.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__delete_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmemleak_object</span> <span class="o">*</span><span class="n">object</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">write_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmemleak_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">prio_tree_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object_tree_root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">tree_node</span><span class="p">);</span>
	<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">object_list</span><span class="p">);</span>
	<span class="n">write_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmemleak_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OBJECT_ALLOCATED</span><span class="p">));</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">use_count</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Locking here also ensures that the corresponding memory block</span>
<span class="cm">	 * cannot be freed when it is being scanned.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">object</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">OBJECT_ALLOCATED</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">put_object</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Look up the metadata (struct kmemleak_object) corresponding to ptr and</span>
<span class="cm"> * delete it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">delete_object_full</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmemleak_object</span> <span class="o">*</span><span class="n">object</span><span class="p">;</span>

	<span class="n">object</span> <span class="o">=</span> <span class="n">find_and_get_object</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">object</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef DEBUG</span>
		<span class="n">kmemleak_warn</span><span class="p">(</span><span class="s">&quot;Freeing unknown object at 0x%08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">ptr</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">__delete_object</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
	<span class="n">put_object</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Look up the metadata (struct kmemleak_object) corresponding to ptr and</span>
<span class="cm"> * delete it. If the memory block is partially freed, the function may create</span>
<span class="cm"> * additional metadata for the remaining parts of the block.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">delete_object_part</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmemleak_object</span> <span class="o">*</span><span class="n">object</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>

	<span class="n">object</span> <span class="o">=</span> <span class="n">find_and_get_object</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">object</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef DEBUG</span>
		<span class="n">kmemleak_warn</span><span class="p">(</span><span class="s">&quot;Partially freeing unknown object at 0x%08lx &quot;</span>
			      <span class="s">&quot;(size %zu)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">__delete_object</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Create one or two objects that may result from the memory block</span>
<span class="cm">	 * split. Note that partial freeing is only done by free_bootmem() and</span>
<span class="cm">	 * this happens before kmemleak_init() is called. The path below is</span>
<span class="cm">	 * only executed during early log recording in kmemleak_init(), so</span>
<span class="cm">	 * GFP_KERNEL is enough.</span>
<span class="cm">	 */</span>
	<span class="n">start</span> <span class="o">=</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">pointer</span><span class="p">;</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">pointer</span> <span class="o">+</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">)</span>
		<span class="n">create_object</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">ptr</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">min_count</span><span class="p">,</span>
			      <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span>
		<span class="n">create_object</span><span class="p">(</span><span class="n">ptr</span> <span class="o">+</span> <span class="n">size</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">ptr</span> <span class="o">-</span> <span class="n">size</span><span class="p">,</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">min_count</span><span class="p">,</span>
			      <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="n">put_object</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__paint_it</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmemleak_object</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span> <span class="kt">int</span> <span class="n">color</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">object</span><span class="o">-&gt;</span><span class="n">min_count</span> <span class="o">=</span> <span class="n">color</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">color</span> <span class="o">==</span> <span class="n">KMEMLEAK_BLACK</span><span class="p">)</span>
		<span class="n">object</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">OBJECT_NO_SCAN</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">paint_it</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmemleak_object</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span> <span class="kt">int</span> <span class="n">color</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__paint_it</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="n">color</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">paint_ptr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">color</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmemleak_object</span> <span class="o">*</span><span class="n">object</span><span class="p">;</span>

	<span class="n">object</span> <span class="o">=</span> <span class="n">find_and_get_object</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">object</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmemleak_warn</span><span class="p">(</span><span class="s">&quot;Trying to color unknown object &quot;</span>
			      <span class="s">&quot;at 0x%08lx as %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span>
			      <span class="p">(</span><span class="n">color</span> <span class="o">==</span> <span class="n">KMEMLEAK_GREY</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;Grey&quot;</span> <span class="o">:</span>
			      <span class="p">(</span><span class="n">color</span> <span class="o">==</span> <span class="n">KMEMLEAK_BLACK</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;Black&quot;</span> <span class="o">:</span> <span class="s">&quot;Unknown&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">paint_it</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="n">color</span><span class="p">);</span>
	<span class="n">put_object</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Mark an object permanently as gray-colored so that it can no longer be</span>
<span class="cm"> * reported as a leak. This is used in general to mark a false positive.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">make_gray_object</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">paint_ptr</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">KMEMLEAK_GREY</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Mark the object as black-colored so that it is ignored from scans and</span>
<span class="cm"> * reporting.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">make_black_object</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">paint_ptr</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">KMEMLEAK_BLACK</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Add a scanning area to the object. If at least one such area is added,</span>
<span class="cm"> * kmemleak will only scan these ranges rather than the whole memory block.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_scan_area</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmemleak_object</span> <span class="o">*</span><span class="n">object</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmemleak_scan_area</span> <span class="o">*</span><span class="n">area</span><span class="p">;</span>

	<span class="n">object</span> <span class="o">=</span> <span class="n">find_and_get_object</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">object</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmemleak_warn</span><span class="p">(</span><span class="s">&quot;Adding scan area to unknown object at 0x%08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">ptr</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">area</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">scan_area_cache</span><span class="p">,</span> <span class="n">gfp_kmemleak_mask</span><span class="p">(</span><span class="n">gfp</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">area</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Cannot allocate a scan area</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">pointer</span> <span class="o">+</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmemleak_warn</span><span class="p">(</span><span class="s">&quot;Scan area larger than object 0x%08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
		<span class="n">dump_object_info</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">scan_area_cache</span><span class="p">,</span> <span class="n">area</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">INIT_HLIST_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="n">area</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="n">area</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">area_list</span><span class="p">);</span>
<span class="nl">out_unlock:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">put_object</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set the OBJECT_NO_SCAN flag for the object corresponding to the give</span>
<span class="cm"> * pointer. Such object will not be scanned by kmemleak but references to it</span>
<span class="cm"> * are searched.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">object_no_scan</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmemleak_object</span> <span class="o">*</span><span class="n">object</span><span class="p">;</span>

	<span class="n">object</span> <span class="o">=</span> <span class="n">find_and_get_object</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">object</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmemleak_warn</span><span class="p">(</span><span class="s">&quot;Not scanning unknown object at 0x%08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">object</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">OBJECT_NO_SCAN</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">put_object</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Log an early kmemleak_* call to the early_log buffer. These calls will be</span>
<span class="cm"> * processed later once kmemleak is fully initialized.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">log_early</span><span class="p">(</span><span class="kt">int</span> <span class="n">op_type</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">min_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">early_log</span> <span class="o">*</span><span class="n">log</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmemleak_error</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* kmemleak stopped recording, just count the requests */</span>
		<span class="n">crt_early_log</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">crt_early_log</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">early_log</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kmemleak_disable</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * There is no need for locking since the kernel is still in UP mode</span>
<span class="cm">	 * at this stage. Disabling the IRQs is enough.</span>
<span class="cm">	 */</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">log</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">early_log</span><span class="p">[</span><span class="n">crt_early_log</span><span class="p">];</span>
	<span class="n">log</span><span class="o">-&gt;</span><span class="n">op_type</span> <span class="o">=</span> <span class="n">op_type</span><span class="p">;</span>
	<span class="n">log</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="n">log</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">log</span><span class="o">-&gt;</span><span class="n">min_count</span> <span class="o">=</span> <span class="n">min_count</span><span class="p">;</span>
	<span class="n">log</span><span class="o">-&gt;</span><span class="n">trace_len</span> <span class="o">=</span> <span class="n">__save_stack_trace</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">trace</span><span class="p">);</span>
	<span class="n">crt_early_log</span><span class="o">++</span><span class="p">;</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Log an early allocated block and populate the stack trace.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">early_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">early_log</span> <span class="o">*</span><span class="n">log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmemleak_object</span> <span class="o">*</span><span class="n">object</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmemleak_enabled</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">||</span> <span class="n">IS_ERR</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * RCU locking needed to ensure object is not freed via put_object().</span>
<span class="cm">	 */</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">object</span> <span class="o">=</span> <span class="n">create_object</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
			       <span class="n">log</span><span class="o">-&gt;</span><span class="n">min_count</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">object</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">trace_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">object</span><span class="o">-&gt;</span><span class="n">trace</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">trace</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">object</span><span class="o">-&gt;</span><span class="n">trace_len</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">trace_len</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Log an early allocated block and populate the stack trace.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">early_alloc_percpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">early_log</span> <span class="o">*</span><span class="n">log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">log</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">early_alloc</span><span class="p">(</span><span class="n">log</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * kmemleak_alloc - register a newly allocated object</span>
<span class="cm"> * @ptr:	pointer to beginning of the object</span>
<span class="cm"> * @size:	size of the object</span>
<span class="cm"> * @min_count:	minimum number of references to this object. If during memory</span>
<span class="cm"> *		scanning a number of references less than @min_count is found,</span>
<span class="cm"> *		the object is reported as a memory leak. If @min_count is 0,</span>
<span class="cm"> *		the object is never reported as a leak. If @min_count is -1,</span>
<span class="cm"> *		the object is ignored (not scanned and not reported as a leak)</span>
<span class="cm"> * @gfp:	kmalloc() flags used for kmemleak internal memory allocations</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called from the kernel allocators when a new object</span>
<span class="cm"> * (memory block) is allocated (kmem_cache_alloc, kmalloc, vmalloc etc.).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__ref</span> <span class="nf">kmemleak_alloc</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">min_count</span><span class="p">,</span>
			  <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s(0x%p, %zu, %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">min_count</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmemleak_enabled</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ptr</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ptr</span><span class="p">))</span>
		<span class="n">create_object</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ptr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">min_count</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmemleak_early_log</span><span class="p">))</span>
		<span class="n">log_early</span><span class="p">(</span><span class="n">KMEMLEAK_ALLOC</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">min_count</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kmemleak_alloc</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * kmemleak_alloc_percpu - register a newly allocated __percpu object</span>
<span class="cm"> * @ptr:	__percpu pointer to beginning of the object</span>
<span class="cm"> * @size:	size of the object</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called from the kernel percpu allocator when a new object</span>
<span class="cm"> * (memory block) is allocated (alloc_percpu). It assumes GFP_KERNEL</span>
<span class="cm"> * allocation.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__ref</span> <span class="nf">kmemleak_alloc_percpu</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s(0x%p, %zu)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Percpu allocations are only scanned and not reported as leaks</span>
<span class="cm">	 * (min_count is set to 0).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmemleak_enabled</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ptr</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ptr</span><span class="p">))</span>
		<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
			<span class="n">create_object</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">cpu</span><span class="p">),</span>
				      <span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmemleak_early_log</span><span class="p">))</span>
		<span class="n">log_early</span><span class="p">(</span><span class="n">KMEMLEAK_ALLOC_PERCPU</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kmemleak_alloc_percpu</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * kmemleak_free - unregister a previously registered object</span>
<span class="cm"> * @ptr:	pointer to beginning of the object</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called from the kernel allocators when an object (memory</span>
<span class="cm"> * block) is freed (kmem_cache_free, kfree, vfree etc.).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__ref</span> <span class="nf">kmemleak_free</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s(0x%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmemleak_enabled</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ptr</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ptr</span><span class="p">))</span>
		<span class="n">delete_object_full</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ptr</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmemleak_early_log</span><span class="p">))</span>
		<span class="n">log_early</span><span class="p">(</span><span class="n">KMEMLEAK_FREE</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kmemleak_free</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * kmemleak_free_part - partially unregister a previously registered object</span>
<span class="cm"> * @ptr:	pointer to the beginning or inside the object. This also</span>
<span class="cm"> *		represents the start of the range to be freed</span>
<span class="cm"> * @size:	size to be unregistered</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called when only a part of a memory block is freed</span>
<span class="cm"> * (usually from the bootmem allocator).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__ref</span> <span class="nf">kmemleak_free_part</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s(0x%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmemleak_enabled</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ptr</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ptr</span><span class="p">))</span>
		<span class="n">delete_object_part</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ptr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmemleak_early_log</span><span class="p">))</span>
		<span class="n">log_early</span><span class="p">(</span><span class="n">KMEMLEAK_FREE_PART</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kmemleak_free_part</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * kmemleak_free_percpu - unregister a previously registered __percpu object</span>
<span class="cm"> * @ptr:	__percpu pointer to beginning of the object</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called from the kernel percpu allocator when an object</span>
<span class="cm"> * (memory block) is freed (free_percpu).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__ref</span> <span class="nf">kmemleak_free_percpu</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s(0x%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmemleak_enabled</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ptr</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ptr</span><span class="p">))</span>
		<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
			<span class="n">delete_object_full</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span>
								      <span class="n">cpu</span><span class="p">));</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmemleak_early_log</span><span class="p">))</span>
		<span class="n">log_early</span><span class="p">(</span><span class="n">KMEMLEAK_FREE_PERCPU</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kmemleak_free_percpu</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * kmemleak_not_leak - mark an allocated object as false positive</span>
<span class="cm"> * @ptr:	pointer to beginning of the object</span>
<span class="cm"> *</span>
<span class="cm"> * Calling this function on an object will cause the memory block to no longer</span>
<span class="cm"> * be reported as leak and always be scanned.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__ref</span> <span class="nf">kmemleak_not_leak</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s(0x%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmemleak_enabled</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ptr</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ptr</span><span class="p">))</span>
		<span class="n">make_gray_object</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ptr</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmemleak_early_log</span><span class="p">))</span>
		<span class="n">log_early</span><span class="p">(</span><span class="n">KMEMLEAK_NOT_LEAK</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kmemleak_not_leak</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * kmemleak_ignore - ignore an allocated object</span>
<span class="cm"> * @ptr:	pointer to beginning of the object</span>
<span class="cm"> *</span>
<span class="cm"> * Calling this function on an object will cause the memory block to be</span>
<span class="cm"> * ignored (not scanned and not reported as a leak). This is usually done when</span>
<span class="cm"> * it is known that the corresponding block is not a leak and does not contain</span>
<span class="cm"> * any references to other allocated memory blocks.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__ref</span> <span class="nf">kmemleak_ignore</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s(0x%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmemleak_enabled</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ptr</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ptr</span><span class="p">))</span>
		<span class="n">make_black_object</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ptr</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmemleak_early_log</span><span class="p">))</span>
		<span class="n">log_early</span><span class="p">(</span><span class="n">KMEMLEAK_IGNORE</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kmemleak_ignore</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * kmemleak_scan_area - limit the range to be scanned in an allocated object</span>
<span class="cm"> * @ptr:	pointer to beginning or inside the object. This also</span>
<span class="cm"> *		represents the start of the scan area</span>
<span class="cm"> * @size:	size of the scan area</span>
<span class="cm"> * @gfp:	kmalloc() flags used for kmemleak internal memory allocations</span>
<span class="cm"> *</span>
<span class="cm"> * This function is used when it is known that only certain parts of an object</span>
<span class="cm"> * contain references to other objects. Kmemleak will only scan these areas</span>
<span class="cm"> * reducing the number false negatives.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__ref</span> <span class="nf">kmemleak_scan_area</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s(0x%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmemleak_enabled</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ptr</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ptr</span><span class="p">))</span>
		<span class="n">add_scan_area</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ptr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmemleak_early_log</span><span class="p">))</span>
		<span class="n">log_early</span><span class="p">(</span><span class="n">KMEMLEAK_SCAN_AREA</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kmemleak_scan_area</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * kmemleak_no_scan - do not scan an allocated object</span>
<span class="cm"> * @ptr:	pointer to beginning of the object</span>
<span class="cm"> *</span>
<span class="cm"> * This function notifies kmemleak not to scan the given memory block. Useful</span>
<span class="cm"> * in situations where it is known that the given object does not contain any</span>
<span class="cm"> * references to other objects. Kmemleak will not scan such objects reducing</span>
<span class="cm"> * the number of false negatives.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__ref</span> <span class="nf">kmemleak_no_scan</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s(0x%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmemleak_enabled</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ptr</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ptr</span><span class="p">))</span>
		<span class="n">object_no_scan</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ptr</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmemleak_early_log</span><span class="p">))</span>
		<span class="n">log_early</span><span class="p">(</span><span class="n">KMEMLEAK_NO_SCAN</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kmemleak_no_scan</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Update an object&#39;s checksum and return true if it was modified.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">update_checksum</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmemleak_object</span> <span class="o">*</span><span class="n">object</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">old_csum</span> <span class="o">=</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">checksum</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kmemcheck_is_obj_initialized</span><span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">pointer</span><span class="p">,</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">object</span><span class="o">-&gt;</span><span class="n">checksum</span> <span class="o">=</span> <span class="n">crc32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">pointer</span><span class="p">,</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">checksum</span> <span class="o">!=</span> <span class="n">old_csum</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Memory scanning is a long process and it needs to be interruptable. This</span>
<span class="cm"> * function checks whether such interrupt condition occurred.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">scan_should_stop</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmemleak_enabled</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This function may be called from either process or kthread context,</span>
<span class="cm">	 * hence the need to check for both stop conditions.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">kthread_should_stop</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Scan a memory block (exclusive range) for valid pointers and add those</span>
<span class="cm"> * found to the gray list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">scan_block</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">_start</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">_end</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">kmemleak_object</span> <span class="o">*</span><span class="n">scanned</span><span class="p">,</span> <span class="kt">int</span> <span class="n">allow_resched</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">PTR_ALIGN</span><span class="p">(</span><span class="n">_start</span><span class="p">,</span> <span class="n">BYTES_PER_POINTER</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="n">_end</span> <span class="o">-</span> <span class="p">(</span><span class="n">BYTES_PER_POINTER</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">ptr</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kmemleak_object</span> <span class="o">*</span><span class="n">object</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pointer</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">allow_resched</span><span class="p">)</span>
			<span class="n">cond_resched</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scan_should_stop</span><span class="p">())</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* don&#39;t scan uninitialized memory */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kmemcheck_is_obj_initialized</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ptr</span><span class="p">,</span>
						  <span class="n">BYTES_PER_POINTER</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">pointer</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

		<span class="n">object</span> <span class="o">=</span> <span class="n">find_and_get_object</span><span class="p">(</span><span class="n">pointer</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">object</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">object</span> <span class="o">==</span> <span class="n">scanned</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* self referenced, ignore */</span>
			<span class="n">put_object</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Avoid the lockdep recursive warning on object-&gt;lock being</span>
<span class="cm">		 * previously acquired in scan_object(). These locks are</span>
<span class="cm">		 * enclosed by scan_mutex.</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock_irqsave_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span>
					 <span class="n">SINGLE_DEPTH_NESTING</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">color_white</span><span class="p">(</span><span class="n">object</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* non-orphan, ignored or new */</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">put_object</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Increase the object&#39;s reference count (number of pointers</span>
<span class="cm">		 * to the memory block). If this count reaches the required</span>
<span class="cm">		 * minimum, the object&#39;s color will become gray and it will be</span>
<span class="cm">		 * added to the gray_list.</span>
<span class="cm">		 */</span>
		<span class="n">object</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">color_gray</span><span class="p">(</span><span class="n">object</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">gray_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gray_list</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">put_object</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Scan a memory block corresponding to a kmemleak_object. A condition is</span>
<span class="cm"> * that object-&gt;use_count &gt;= 1.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">scan_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmemleak_object</span> <span class="o">*</span><span class="n">object</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmemleak_scan_area</span> <span class="o">*</span><span class="n">area</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">elem</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Once the object-&gt;lock is acquired, the corresponding memory block</span>
<span class="cm">	 * cannot be freed (the same lock is acquired in delete_object).</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OBJECT_NO_SCAN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OBJECT_ALLOCATED</span><span class="p">))</span>
		<span class="cm">/* already freed object */</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hlist_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">area_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">pointer</span><span class="p">;</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">pointer</span> <span class="o">+</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OBJECT_ALLOCATED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		       <span class="o">!</span><span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OBJECT_NO_SCAN</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">scan_block</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">min</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">MAX_SCAN_SIZE</span><span class="p">,</span> <span class="n">end</span><span class="p">),</span>
				   <span class="n">object</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">start</span> <span class="o">+=</span> <span class="n">MAX_SCAN_SIZE</span><span class="p">;</span>

			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">cond_resched</span><span class="p">();</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="n">elem</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">area_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
			<span class="n">scan_block</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
				   <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">area</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">),</span>
				   <span class="n">object</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Scan the objects already referenced (gray objects). More objects will be</span>
<span class="cm"> * referenced and, if there are no memory leaks, all the objects are scanned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">scan_gray_list</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmemleak_object</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The list traversal is safe for both tail additions and removals</span>
<span class="cm">	 * from inside the loop. The kmemleak objects cannot be freed from</span>
<span class="cm">	 * outside the loop because their use_count was incremented.</span>
<span class="cm">	 */</span>
	<span class="n">object</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">gray_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">object</span><span class="p">),</span> <span class="n">gray_list</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">gray_list</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">gray_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cond_resched</span><span class="p">();</span>

		<span class="cm">/* may add new objects to the list */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scan_should_stop</span><span class="p">())</span>
			<span class="n">scan_object</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>

		<span class="n">tmp</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">gray_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">object</span><span class="p">),</span>
				 <span class="n">gray_list</span><span class="p">);</span>

		<span class="cm">/* remove the object from the list and release it */</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">gray_list</span><span class="p">);</span>
		<span class="n">put_object</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>

		<span class="n">object</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gray_list</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Scan data sections and all the referenced memory blocks allocated via the</span>
<span class="cm"> * kernel&#39;s standard allocators. This function must be called with the</span>
<span class="cm"> * scan_mutex held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">kmemleak_scan</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmemleak_object</span> <span class="o">*</span><span class="n">object</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">new_leaks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">jiffies_last_scan</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="cm">/* prepare the kmemleak_object&#39;s */</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">object_list</span><span class="p">,</span> <span class="n">object_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="cp">#ifdef DEBUG</span>
		<span class="cm">/*</span>
<span class="cm">		 * With a few exceptions there should be a maximum of</span>
<span class="cm">		 * 1 reference to any object at this point.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">use_count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;object-&gt;use_count = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">use_count</span><span class="p">));</span>
			<span class="n">dump_object_info</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="cm">/* reset the reference count (whiten the object) */</span>
		<span class="n">object</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">color_gray</span><span class="p">(</span><span class="n">object</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">get_object</span><span class="p">(</span><span class="n">object</span><span class="p">))</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">gray_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gray_list</span><span class="p">);</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="cm">/* data/bss scanning */</span>
	<span class="n">scan_block</span><span class="p">(</span><span class="n">_sdata</span><span class="p">,</span> <span class="n">_edata</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">scan_block</span><span class="p">(</span><span class="n">__bss_start</span><span class="p">,</span> <span class="n">__bss_stop</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="cm">/* per-cpu sections scanning */</span>
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="n">scan_block</span><span class="p">(</span><span class="n">__per_cpu_start</span> <span class="o">+</span> <span class="n">per_cpu_offset</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
			   <span class="n">__per_cpu_end</span> <span class="o">+</span> <span class="n">per_cpu_offset</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Struct page scanning for each node.</span>
<span class="cm">	 */</span>
	<span class="n">lock_memory_hotplug</span><span class="p">();</span>
	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pg_data_t</span> <span class="o">*</span><span class="n">pgdat</span> <span class="o">=</span> <span class="n">NODE_DATA</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pfn</span> <span class="o">=</span> <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_start_pfn</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_pfn</span> <span class="o">=</span> <span class="n">start_pfn</span> <span class="o">+</span> <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_spanned_pages</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">=</span> <span class="n">start_pfn</span><span class="p">;</span> <span class="n">pfn</span> <span class="o">&lt;</span> <span class="n">end_pfn</span><span class="p">;</span> <span class="n">pfn</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pfn_valid</span><span class="p">(</span><span class="n">pfn</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
			<span class="cm">/* only scan if page is in use */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page_count</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">scan_block</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">page</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">unlock_memory_hotplug</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Scanning the task stacks (may introduce false negatives).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kmemleak_stack_scan</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">g</span><span class="p">;</span>

		<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
		<span class="n">do_each_thread</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">scan_block</span><span class="p">(</span><span class="n">task_stack_page</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">task_stack_page</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span>
				   <span class="n">THREAD_SIZE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span> <span class="n">while_each_thread</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Scan the objects already referenced from the sections scanned</span>
<span class="cm">	 * above.</span>
<span class="cm">	 */</span>
	<span class="n">scan_gray_list</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check for new or unreferenced objects modified since the previous</span>
<span class="cm">	 * scan and color them gray until the next scan.</span>
<span class="cm">	 */</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">object_list</span><span class="p">,</span> <span class="n">object_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">color_white</span><span class="p">(</span><span class="n">object</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OBJECT_ALLOCATED</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="n">update_checksum</span><span class="p">(</span><span class="n">object</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">get_object</span><span class="p">(</span><span class="n">object</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* color it gray temporarily */</span>
			<span class="n">object</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">min_count</span><span class="p">;</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">gray_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gray_list</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Re-scan the gray list for modified unreferenced objects.</span>
<span class="cm">	 */</span>
	<span class="n">scan_gray_list</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * If scanning was stopped do not report any new unreferenced objects.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scan_should_stop</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Scanning result reporting.</span>
<span class="cm">	 */</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">object_list</span><span class="p">,</span> <span class="n">object_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unreferenced_object</span><span class="p">(</span><span class="n">object</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OBJECT_REPORTED</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">object</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">OBJECT_REPORTED</span><span class="p">;</span>
			<span class="n">new_leaks</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_leaks</span><span class="p">)</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%d new suspected memory leaks (see &quot;</span>
			<span class="s">&quot;/sys/kernel/debug/kmemleak)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">new_leaks</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Thread function performing automatic memory scanning. Unreferenced objects</span>
<span class="cm"> * at the end of a memory scan are reported but only the first time.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">kmemleak_scan_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">first_run</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Automatic memory scanning thread started</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">set_user_nice</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait before the first scan to allow the system to fully initialize.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">first_run</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">first_run</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ssleep</span><span class="p">(</span><span class="n">SECS_FIRST_SCAN</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">())</span> <span class="p">{</span>
		<span class="kt">signed</span> <span class="kt">long</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies_scan_wait</span><span class="p">;</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scan_mutex</span><span class="p">);</span>
		<span class="n">kmemleak_scan</span><span class="p">();</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scan_mutex</span><span class="p">);</span>

		<span class="cm">/* wait before the next scan */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">())</span>
			<span class="n">timeout</span> <span class="o">=</span> <span class="n">schedule_timeout_interruptible</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Automatic memory scanning thread ended</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Start the automatic memory scanning thread. This function must be called</span>
<span class="cm"> * with the scan_mutex held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">start_scan_thread</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scan_thread</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">scan_thread</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">kmemleak_scan_thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;kmemleak&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">scan_thread</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Failed to create the scan thread</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">scan_thread</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Stop the automatic memory scanning thread. This function must be called</span>
<span class="cm"> * with the scan_mutex held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">stop_scan_thread</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scan_thread</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kthread_stop</span><span class="p">(</span><span class="n">scan_thread</span><span class="p">);</span>
		<span class="n">scan_thread</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Iterate over the object_list and return the first valid object at or after</span>
<span class="cm"> * the required position with its use_count incremented. The function triggers</span>
<span class="cm"> * a memory scanning when the pos argument points to the first position.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">kmemleak_seq_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmemleak_object</span> <span class="o">*</span><span class="n">object</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">n</span> <span class="o">=</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">mutex_lock_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scan_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">object_list</span><span class="p">,</span> <span class="n">object_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_object</span><span class="p">(</span><span class="n">object</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">object</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">object</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the next object in the object_list. The function decrements the</span>
<span class="cm"> * use_count of the previous object and increases that of the next one.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">kmemleak_seq_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmemleak_object</span> <span class="o">*</span><span class="n">prev_obj</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmemleak_object</span> <span class="o">*</span><span class="n">next_obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">prev_obj</span><span class="o">-&gt;</span><span class="n">object_list</span><span class="p">;</span>

	<span class="o">++</span><span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">);</span>

	<span class="n">list_for_each_continue_rcu</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">object_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kmemleak_object</span> <span class="o">*</span><span class="n">obj</span> <span class="o">=</span>
			<span class="n">list_entry</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kmemleak_object</span><span class="p">,</span> <span class="n">object_list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_object</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">next_obj</span> <span class="o">=</span> <span class="n">obj</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">put_object</span><span class="p">(</span><span class="n">prev_obj</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">next_obj</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Decrement the use_count of the last object required, if any.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">kmemleak_seq_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * kmemleak_seq_start may return ERR_PTR if the scan_mutex</span>
<span class="cm">		 * waiting was interrupted, so only release it if !IS_ERR.</span>
<span class="cm">		 */</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scan_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="p">)</span>
			<span class="n">put_object</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Print the information for an unreferenced object to the seq file.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">kmemleak_seq_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmemleak_object</span> <span class="o">*</span><span class="n">object</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OBJECT_REPORTED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">unreferenced_object</span><span class="p">(</span><span class="n">object</span><span class="p">))</span>
		<span class="n">print_unreferenced</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">object</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">kmemleak_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">kmemleak_seq_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>  <span class="o">=</span> <span class="n">kmemleak_seq_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>  <span class="o">=</span> <span class="n">kmemleak_seq_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>  <span class="o">=</span> <span class="n">kmemleak_seq_show</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kmemleak_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kmemleak_seq_ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kmemleak_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq_release</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dump_str_object_info</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmemleak_object</span> <span class="o">*</span><span class="n">object</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">addr</span><span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">object</span> <span class="o">=</span> <span class="n">find_and_get_object</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">object</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Unknown object at 0x%08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">dump_object_info</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">put_object</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We use grey instead of black to ensure we can do future scans on the same</span>
<span class="cm"> * objects. If we did not do future scans these black objects could</span>
<span class="cm"> * potentially contain references to newly allocated objects in the future and</span>
<span class="cm"> * we&#39;d end up with false positives.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">kmemleak_clear</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmemleak_object</span> <span class="o">*</span><span class="n">object</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">object_list</span><span class="p">,</span> <span class="n">object_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OBJECT_REPORTED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">unreferenced_object</span><span class="p">(</span><span class="n">object</span><span class="p">))</span>
			<span class="n">__paint_it</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="n">KMEMLEAK_GREY</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * File write operation to configure kmemleak at run-time. The following</span>
<span class="cm"> * commands can be written to the /sys/kernel/debug/kmemleak file:</span>
<span class="cm"> *   off	- disable kmemleak (irreversible)</span>
<span class="cm"> *   stack=on	- enable the task stacks scanning</span>
<span class="cm"> *   stack=off	- disable the tasks stacks scanning</span>
<span class="cm"> *   scan=on	- start the automatic memory scanning thread</span>
<span class="cm"> *   scan=off	- stop the automatic memory scanning thread</span>
<span class="cm"> *   scan=...	- set the automatic memory scanning period in seconds (0 to</span>
<span class="cm"> *		  disable it)</span>
<span class="cm"> *   scan	- trigger a memory scan</span>
<span class="cm"> *   clear	- mark all current reported unreferenced kmemleak objects as</span>
<span class="cm"> *		  grey to ignore printing them</span>
<span class="cm"> *   dump=...	- dump information about the object found at the given address</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">kmemleak_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_buf</span><span class="p">,</span>
			      <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">buf_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmemleak_enabled</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">buf_size</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strncpy_from_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">user_buf</span><span class="p">,</span> <span class="n">buf_size</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">buf_size</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">mutex_lock_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scan_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;off&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">kmemleak_disable</span><span class="p">();</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;stack=on&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">kmemleak_stack_scan</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;stack=off&quot;</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">kmemleak_stack_scan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;scan=on&quot;</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">start_scan_thread</span><span class="p">();</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;scan=off&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">stop_scan_thread</span><span class="p">();</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;scan=&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">secs</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">strict_strtoul</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">secs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">stop_scan_thread</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">secs</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">jiffies_scan_wait</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">secs</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>
			<span class="n">start_scan_thread</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;scan&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">kmemleak_scan</span><span class="p">();</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;clear&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">kmemleak_clear</span><span class="p">();</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;dump=&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">dump_str_object_info</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="mi">5</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scan_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* ignore the rest of the buffer, only one command at a time */</span>
	<span class="o">*</span><span class="n">ppos</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">kmemleak_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">kmemleak_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">kmemleak_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">kmemleak_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Stop the memory scanning thread and free the kmemleak internal objects if</span>
<span class="cm"> * no previous scan thread (otherwise, kmemleak may still have some useful</span>
<span class="cm"> * information on memory leaks).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">kmemleak_do_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmemleak_object</span> <span class="o">*</span><span class="n">object</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">cleanup</span> <span class="o">=</span> <span class="n">scan_thread</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scan_mutex</span><span class="p">);</span>
	<span class="n">stop_scan_thread</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cleanup</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rcu_read_lock</span><span class="p">();</span>
		<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">object_list</span><span class="p">,</span> <span class="n">object_list</span><span class="p">)</span>
			<span class="n">delete_object_full</span><span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">pointer</span><span class="p">);</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scan_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DECLARE_WORK</span><span class="p">(</span><span class="n">cleanup_work</span><span class="p">,</span> <span class="n">kmemleak_do_cleanup</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Disable kmemleak. No memory allocation/freeing will be traced once this</span>
<span class="cm"> * function is called. Disabling kmemleak is an irreversible operation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">kmemleak_disable</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* atomically check whether it was already invoked */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_cmpxchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmemleak_error</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* stop any memory operation tracing */</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmemleak_enabled</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* check whether it is too early for a kernel thread */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmemleak_initialized</span><span class="p">))</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cleanup_work</span><span class="p">);</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Kernel memory leak detector disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allow boot-time kmemleak disabling (enabled by default).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">kmemleak_boot_config</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">str</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;off&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">kmemleak_disable</span><span class="p">();</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;on&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">kmemleak_skip_disable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;kmemleak&quot;</span><span class="p">,</span> <span class="n">kmemleak_boot_config</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">print_log_trace</span><span class="p">(</span><span class="k">struct</span> <span class="n">early_log</span> <span class="o">*</span><span class="n">log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">stack_trace</span> <span class="n">trace</span><span class="p">;</span>

	<span class="n">trace</span><span class="p">.</span><span class="n">nr_entries</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">trace_len</span><span class="p">;</span>
	<span class="n">trace</span><span class="p">.</span><span class="n">entries</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">trace</span><span class="p">;</span>

	<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;Early log backtrace:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">print_stack_trace</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Kmemleak initialization.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">kmemleak_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_DEBUG_KMEMLEAK_DEFAULT_OFF</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kmemleak_skip_disable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmemleak_early_log</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">kmemleak_disable</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">jiffies_min_age</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">MSECS_MIN_AGE</span><span class="p">);</span>
	<span class="n">jiffies_scan_wait</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">SECS_SCAN_WAIT</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>

	<span class="n">object_cache</span> <span class="o">=</span> <span class="n">KMEM_CACHE</span><span class="p">(</span><span class="n">kmemleak_object</span><span class="p">,</span> <span class="n">SLAB_NOLEAKTRACE</span><span class="p">);</span>
	<span class="n">scan_area_cache</span> <span class="o">=</span> <span class="n">KMEM_CACHE</span><span class="p">(</span><span class="n">kmemleak_scan_area</span><span class="p">,</span> <span class="n">SLAB_NOLEAKTRACE</span><span class="p">);</span>
	<span class="n">INIT_PRIO_TREE_ROOT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object_tree_root</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">crt_early_log</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">early_log</span><span class="p">))</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Early log buffer exceeded (%d), please increase &quot;</span>
			   <span class="s">&quot;DEBUG_KMEMLEAK_EARLY_LOG_SIZE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">crt_early_log</span><span class="p">);</span>

	<span class="cm">/* the kernel is still in UP mode, so disabling the IRQs is enough */</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmemleak_early_log</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmemleak_error</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmemleak_enabled</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is the point where tracking allocations is safe. Automatic</span>
<span class="cm">	 * scanning is started during the late initcall. Add the early logged</span>
<span class="cm">	 * callbacks to the kmemleak infrastructure.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">crt_early_log</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">early_log</span> <span class="o">*</span><span class="n">log</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">early_log</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">op_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">KMEMLEAK_ALLOC</span>:
			<span class="n">early_alloc</span><span class="p">(</span><span class="n">log</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">KMEMLEAK_ALLOC_PERCPU</span>:
			<span class="n">early_alloc_percpu</span><span class="p">(</span><span class="n">log</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">KMEMLEAK_FREE</span>:
			<span class="n">kmemleak_free</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">KMEMLEAK_FREE_PART</span>:
			<span class="n">kmemleak_free_part</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">KMEMLEAK_FREE_PERCPU</span>:
			<span class="n">kmemleak_free_percpu</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">KMEMLEAK_NOT_LEAK</span>:
			<span class="n">kmemleak_not_leak</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">KMEMLEAK_IGNORE</span>:
			<span class="n">kmemleak_ignore</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">KMEMLEAK_SCAN_AREA</span>:
			<span class="n">kmemleak_scan_area</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">KMEMLEAK_NO_SCAN</span>:
			<span class="n">kmemleak_no_scan</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">kmemleak_warn</span><span class="p">(</span><span class="s">&quot;Unknown early log operation: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				      <span class="n">log</span><span class="o">-&gt;</span><span class="n">op_type</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmemleak_warning</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">print_log_trace</span><span class="p">(</span><span class="n">log</span><span class="p">);</span>
			<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmemleak_warning</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Late initialization function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">kmemleak_late_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmemleak_initialized</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmemleak_error</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Some error occurred and kmemleak was disabled. There is a</span>
<span class="cm">		 * small chance that kmemleak_disable() was called immediately</span>
<span class="cm">		 * after setting kmemleak_initialized and we may end up with</span>
<span class="cm">		 * two clean-up threads but serialized by scan_mutex.</span>
<span class="cm">		 */</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cleanup_work</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dentry</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="s">&quot;kmemleak&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">kmemleak_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dentry</span><span class="p">)</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Failed to create the debugfs kmemleak file</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scan_mutex</span><span class="p">);</span>
	<span class="n">start_scan_thread</span><span class="p">();</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scan_mutex</span><span class="p">);</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Kernel memory leak detector initialized</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">late_initcall</span><span class="p">(</span><span class="n">kmemleak_late_init</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
