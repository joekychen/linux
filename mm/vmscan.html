<!DOCTYPE html>
<html><head><title>joekychen/linux » mm › vmscan.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>vmscan.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/mm/vmscan.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds</span>
<span class="cm"> *</span>
<span class="cm"> *  Swap reorganised 29.12.95, Stephen Tweedie.</span>
<span class="cm"> *  kswapd added: 7.1.96  sct</span>
<span class="cm"> *  Removed kswapd_ctl limits, and swap out as many pages as needed</span>
<span class="cm"> *  to bring the system back to freepages.high: 2.4.97, Rik van Riel.</span>
<span class="cm"> *  Zone aware kswapd started 02/00, Kanoj Sarcar (kanoj@sgi.com).</span>
<span class="cm"> *  Multiqueue VM started 5.8.00, Rik van Riel.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;linux/kernel_stat.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/vmstat.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/buffer_head.h&gt;	</span><span class="cm">/* for try_to_release_page(),</span>
<span class="cm">					buffer_heads_over_limit */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/mm_inline.h&gt;</span>
<span class="cp">#include &lt;linux/backing-dev.h&gt;</span>
<span class="cp">#include &lt;linux/rmap.h&gt;</span>
<span class="cp">#include &lt;linux/topology.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/cpuset.h&gt;</span>
<span class="cp">#include &lt;linux/compaction.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/rwsem.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/freezer.h&gt;</span>
<span class="cp">#include &lt;linux/memcontrol.h&gt;</span>
<span class="cp">#include &lt;linux/delayacct.h&gt;</span>
<span class="cp">#include &lt;linux/sysctl.h&gt;</span>
<span class="cp">#include &lt;linux/oom.h&gt;</span>
<span class="cp">#include &lt;linux/prefetch.h&gt;</span>

<span class="cp">#include &lt;asm/tlbflush.h&gt;</span>
<span class="cp">#include &lt;asm/div64.h&gt;</span>

<span class="cp">#include &lt;linux/swapops.h&gt;</span>

<span class="cp">#include &quot;internal.h&quot;</span>

<span class="cp">#define CREATE_TRACE_POINTS</span>
<span class="cp">#include &lt;trace/events/vmscan.h&gt;</span>

<span class="k">struct</span> <span class="n">scan_control</span> <span class="p">{</span>
	<span class="cm">/* Incremented by the number of inactive pages that were scanned */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_scanned</span><span class="p">;</span>

	<span class="cm">/* Number of pages freed so far during a call to shrink_zones() */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_reclaimed</span><span class="p">;</span>

	<span class="cm">/* How many pages shrink_list() should reclaim */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_to_reclaim</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hibernation_mode</span><span class="p">;</span>

	<span class="cm">/* This context&#39;s GFP mask */</span>
	<span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">may_writepage</span><span class="p">;</span>

	<span class="cm">/* Can mapped pages be reclaimed? */</span>
	<span class="kt">int</span> <span class="n">may_unmap</span><span class="p">;</span>

	<span class="cm">/* Can pages be swapped as part of reclaim? */</span>
	<span class="kt">int</span> <span class="n">may_swap</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">order</span><span class="p">;</span>

	<span class="cm">/* Scan (total_size &gt;&gt; priority) pages at once */</span>
	<span class="kt">int</span> <span class="n">priority</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The memory cgroup that hit its limit and as a result is the</span>
<span class="cm">	 * primary target of this reclaim invocation.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">target_mem_cgroup</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Nodemask of nodes allowed by the caller. If NULL, all nodes</span>
<span class="cm">	 * are scanned.</span>
<span class="cm">	 */</span>
	<span class="n">nodemask_t</span>	<span class="o">*</span><span class="n">nodemask</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define lru_to_page(_head) (list_entry((_head)-&gt;prev, struct page, lru))</span>

<span class="cp">#ifdef ARCH_HAS_PREFETCH</span>
<span class="cp">#define prefetch_prev_lru_page(_page, _base, _field)			\</span>
<span class="cp">	do {								\</span>
<span class="cp">		if ((_page)-&gt;lru.prev != _base) {			\</span>
<span class="cp">			struct page *prev;				\</span>
<span class="cp">									\</span>
<span class="cp">			prev = lru_to_page(&amp;(_page-&gt;lru));		\</span>
<span class="cp">			prefetch(&amp;prev-&gt;_field);			\</span>
<span class="cp">		}							\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#else</span>
<span class="cp">#define prefetch_prev_lru_page(_page, _base, _field) do { } while (0)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef ARCH_HAS_PREFETCHW</span>
<span class="cp">#define prefetchw_prev_lru_page(_page, _base, _field)			\</span>
<span class="cp">	do {								\</span>
<span class="cp">		if ((_page)-&gt;lru.prev != _base) {			\</span>
<span class="cp">			struct page *prev;				\</span>
<span class="cp">									\</span>
<span class="cp">			prev = lru_to_page(&amp;(_page-&gt;lru));		\</span>
<span class="cp">			prefetchw(&amp;prev-&gt;_field);			\</span>
<span class="cp">		}							\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#else</span>
<span class="cp">#define prefetchw_prev_lru_page(_page, _base, _field) do { } while (0)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * From 0 .. 100.  Higher means more swappy.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">vm_swappiness</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span>
<span class="kt">long</span> <span class="n">vm_total_pages</span><span class="p">;</span>	<span class="cm">/* The total number of pages which the VM controls */</span>

<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">shrinker_list</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DECLARE_RWSEM</span><span class="p">(</span><span class="n">shrinker_rwsem</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_CGROUP_MEM_RES_CTLR</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">global_reclaim</span><span class="p">(</span><span class="k">struct</span> <span class="n">scan_control</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">target_mem_cgroup</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">global_reclaim</span><span class="p">(</span><span class="k">struct</span> <span class="n">scan_control</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">get_lru_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">lruvec</span> <span class="o">*</span><span class="n">lruvec</span><span class="p">,</span> <span class="k">enum</span> <span class="n">lru_list</span> <span class="n">lru</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mem_cgroup_disabled</span><span class="p">())</span>
		<span class="k">return</span> <span class="n">mem_cgroup_get_lru_size</span><span class="p">(</span><span class="n">lruvec</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">zone_page_state</span><span class="p">(</span><span class="n">lruvec_zone</span><span class="p">(</span><span class="n">lruvec</span><span class="p">),</span> <span class="n">NR_LRU_BASE</span> <span class="o">+</span> <span class="n">lru</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Add a shrinker callback to be called from the vm</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">register_shrinker</span><span class="p">(</span><span class="k">struct</span> <span class="n">shrinker</span> <span class="o">*</span><span class="n">shrinker</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_long_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shrinker</span><span class="o">-&gt;</span><span class="n">nr_in_batch</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shrinker_rwsem</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shrinker</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shrinker_list</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shrinker_rwsem</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">register_shrinker</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Remove one</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">unregister_shrinker</span><span class="p">(</span><span class="k">struct</span> <span class="n">shrinker</span> <span class="o">*</span><span class="n">shrinker</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shrinker_rwsem</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shrinker</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shrinker_rwsem</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">unregister_shrinker</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">do_shrinker_shrink</span><span class="p">(</span><span class="k">struct</span> <span class="n">shrinker</span> <span class="o">*</span><span class="n">shrinker</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">shrink_control</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_to_scan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">nr_to_scan</span> <span class="o">=</span> <span class="n">nr_to_scan</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">shrinker</span><span class="o">-&gt;</span><span class="n">shrink</span><span class="p">)(</span><span class="n">shrinker</span><span class="p">,</span> <span class="n">sc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define SHRINK_BATCH 128</span>
<span class="cm">/*</span>
<span class="cm"> * Call the shrink functions to age shrinkable caches</span>
<span class="cm"> *</span>
<span class="cm"> * Here we assume it costs one seek to replace a lru page and that it also</span>
<span class="cm"> * takes a seek to recreate a cache object.  With this in mind we age equal</span>
<span class="cm"> * percentages of the lru and ageable caches.  This should balance the seeks</span>
<span class="cm"> * generated by these structures.</span>
<span class="cm"> *</span>
<span class="cm"> * If the vm encountered mapped pages on the LRU it increase the pressure on</span>
<span class="cm"> * slab to avoid swapping.</span>
<span class="cm"> *</span>
<span class="cm"> * We do weird things to avoid (scanned*seeks*entries) overflowing 32 bits.</span>
<span class="cm"> *</span>
<span class="cm"> * `lru_pages&#39; represents the number of on-LRU pages in all the zones which</span>
<span class="cm"> * are eligible for the caller&#39;s allocation attempt.  It is used for balancing</span>
<span class="cm"> * slab reclaim versus page reclaim.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of slab objects which we shrunk.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">shrink_slab</span><span class="p">(</span><span class="k">struct</span> <span class="n">shrink_control</span> <span class="o">*</span><span class="n">shrink</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_pages_scanned</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lru_pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">shrinker</span> <span class="o">*</span><span class="n">shrinker</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr_pages_scanned</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">nr_pages_scanned</span> <span class="o">=</span> <span class="n">SWAP_CLUSTER_MAX</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">down_read_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shrinker_rwsem</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Assume we&#39;ll be able to shrink next time */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">shrinker</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shrinker_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">delta</span><span class="p">;</span>
		<span class="kt">long</span> <span class="n">total_scan</span><span class="p">;</span>
		<span class="kt">long</span> <span class="n">max_pass</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">shrink_ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="kt">long</span> <span class="n">nr</span><span class="p">;</span>
		<span class="kt">long</span> <span class="n">new_nr</span><span class="p">;</span>
		<span class="kt">long</span> <span class="n">batch_size</span> <span class="o">=</span> <span class="n">shrinker</span><span class="o">-&gt;</span><span class="n">batch</span> <span class="o">?</span> <span class="n">shrinker</span><span class="o">-&gt;</span><span class="n">batch</span>
						  <span class="o">:</span> <span class="n">SHRINK_BATCH</span><span class="p">;</span>

		<span class="n">max_pass</span> <span class="o">=</span> <span class="n">do_shrinker_shrink</span><span class="p">(</span><span class="n">shrinker</span><span class="p">,</span> <span class="n">shrink</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">max_pass</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * copy the current shrinker scan count into a local variable</span>
<span class="cm">		 * and zero it so that other concurrent shrinker invocations</span>
<span class="cm">		 * don&#39;t also do this scanning work.</span>
<span class="cm">		 */</span>
		<span class="n">nr</span> <span class="o">=</span> <span class="n">atomic_long_xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shrinker</span><span class="o">-&gt;</span><span class="n">nr_in_batch</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">total_scan</span> <span class="o">=</span> <span class="n">nr</span><span class="p">;</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">nr_pages_scanned</span><span class="p">)</span> <span class="o">/</span> <span class="n">shrinker</span><span class="o">-&gt;</span><span class="n">seeks</span><span class="p">;</span>
		<span class="n">delta</span> <span class="o">*=</span> <span class="n">max_pass</span><span class="p">;</span>
		<span class="n">do_div</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">lru_pages</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">total_scan</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">total_scan</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;shrink_slab: %pF negative objects to &quot;</span>
			       <span class="s">&quot;delete nr=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">shrinker</span><span class="o">-&gt;</span><span class="n">shrink</span><span class="p">,</span> <span class="n">total_scan</span><span class="p">);</span>
			<span class="n">total_scan</span> <span class="o">=</span> <span class="n">max_pass</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * We need to avoid excessive windup on filesystem shrinkers</span>
<span class="cm">		 * due to large numbers of GFP_NOFS allocations causing the</span>
<span class="cm">		 * shrinkers to return -1 all the time. This results in a large</span>
<span class="cm">		 * nr being built up so when a shrink that can do some work</span>
<span class="cm">		 * comes along it empties the entire cache due to nr &gt;&gt;&gt;</span>
<span class="cm">		 * max_pass.  This is bad for sustaining a working set in</span>
<span class="cm">		 * memory.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Hence only allow the shrinker to scan the entire cache when</span>
<span class="cm">		 * a large delta change is calculated directly.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="n">max_pass</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>
			<span class="n">total_scan</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">total_scan</span><span class="p">,</span> <span class="n">max_pass</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Avoid risking looping forever due to too large nr value:</span>
<span class="cm">		 * never try to free more than twice the estimate number of</span>
<span class="cm">		 * freeable entries.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">total_scan</span> <span class="o">&gt;</span> <span class="n">max_pass</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">total_scan</span> <span class="o">=</span> <span class="n">max_pass</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>

		<span class="n">trace_mm_shrink_slab_start</span><span class="p">(</span><span class="n">shrinker</span><span class="p">,</span> <span class="n">shrink</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span>
					<span class="n">nr_pages_scanned</span><span class="p">,</span> <span class="n">lru_pages</span><span class="p">,</span>
					<span class="n">max_pass</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">total_scan</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">total_scan</span> <span class="o">&gt;=</span> <span class="n">batch_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">nr_before</span><span class="p">;</span>

			<span class="n">nr_before</span> <span class="o">=</span> <span class="n">do_shrinker_shrink</span><span class="p">(</span><span class="n">shrinker</span><span class="p">,</span> <span class="n">shrink</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">shrink_ret</span> <span class="o">=</span> <span class="n">do_shrinker_shrink</span><span class="p">(</span><span class="n">shrinker</span><span class="p">,</span> <span class="n">shrink</span><span class="p">,</span>
							<span class="n">batch_size</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">shrink_ret</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">shrink_ret</span> <span class="o">&lt;</span> <span class="n">nr_before</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">+=</span> <span class="n">nr_before</span> <span class="o">-</span> <span class="n">shrink_ret</span><span class="p">;</span>
			<span class="n">count_vm_events</span><span class="p">(</span><span class="n">SLABS_SCANNED</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">);</span>
			<span class="n">total_scan</span> <span class="o">-=</span> <span class="n">batch_size</span><span class="p">;</span>

			<span class="n">cond_resched</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * move the unused scan count back into the shrinker in a</span>
<span class="cm">		 * manner that handles concurrent updates. If we exhausted the</span>
<span class="cm">		 * scan, there is no need to do an update.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">total_scan</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">new_nr</span> <span class="o">=</span> <span class="n">atomic_long_add_return</span><span class="p">(</span><span class="n">total_scan</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">shrinker</span><span class="o">-&gt;</span><span class="n">nr_in_batch</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">new_nr</span> <span class="o">=</span> <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shrinker</span><span class="o">-&gt;</span><span class="n">nr_in_batch</span><span class="p">);</span>

		<span class="n">trace_mm_shrink_slab_end</span><span class="p">(</span><span class="n">shrinker</span><span class="p">,</span> <span class="n">shrink_ret</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">new_nr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shrinker_rwsem</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">cond_resched</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_page_cache_freeable</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * A freeable page cache page is referenced only by the caller</span>
<span class="cm">	 * that isolated the page, the page cache radix tree and</span>
<span class="cm">	 * optional buffer heads at page-&gt;private.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">page_count</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">-</span> <span class="n">page_has_private</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">may_write_to_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">scan_control</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_SWAPWRITE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bdi_write_congested</span><span class="p">(</span><span class="n">bdi</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bdi</span> <span class="o">==</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We detected a synchronous write error writing a page out.  Probably</span>
<span class="cm"> * -ENOSPC.  We need to propagate that into the address_space for a subsequent</span>
<span class="cm"> * fsync(), msync() or close().</span>
<span class="cm"> *</span>
<span class="cm"> * The tricky part is that after writepage we cannot touch the mapping: nothing</span>
<span class="cm"> * prevents it from being freed up.  But we have a ref on the page and once</span>
<span class="cm"> * that page is locked, the mapping is pinned.</span>
<span class="cm"> *</span>
<span class="cm"> * We&#39;re allowed to run sleeping lock_page() here because we know the caller has</span>
<span class="cm"> * __GFP_FS.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_write_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page_mapping</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">==</span> <span class="n">mapping</span><span class="p">)</span>
		<span class="n">mapping_set_error</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* possible outcome of pageout() */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="cm">/* failed to write page out, page is locked */</span>
	<span class="n">PAGE_KEEP</span><span class="p">,</span>
	<span class="cm">/* move page to the active list, page is locked */</span>
	<span class="n">PAGE_ACTIVATE</span><span class="p">,</span>
	<span class="cm">/* page has been sent to the disk successfully, page is unlocked */</span>
	<span class="n">PAGE_SUCCESS</span><span class="p">,</span>
	<span class="cm">/* page is clean and locked */</span>
	<span class="n">PAGE_CLEAN</span><span class="p">,</span>
<span class="p">}</span> <span class="n">pageout_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * pageout is called by shrink_page_list() for each dirty page.</span>
<span class="cm"> * Calls -&gt;writepage().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">pageout_t</span> <span class="nf">pageout</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">scan_control</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the page is dirty, only perform writeback if that write</span>
<span class="cm">	 * will be non-blocking.  To prevent this allocation from being</span>
<span class="cm">	 * stalled by pagecache activity.  But note that there may be</span>
<span class="cm">	 * stalls if we need to run get_block().  We could test</span>
<span class="cm">	 * PagePrivate for that.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If this process is currently in __generic_file_aio_write() against</span>
<span class="cm">	 * this page&#39;s queue, we can perform writeback even if that</span>
<span class="cm">	 * will block.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If the page is swapcache, write it back even if that would</span>
<span class="cm">	 * block, for some throttling. This happens by accident, because</span>
<span class="cm">	 * swap_backing_dev_info is bust: it doesn&#39;t reflect the</span>
<span class="cm">	 * congestion state of the swapdevs.  Easy to fix, if needed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_page_cache_freeable</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PAGE_KEEP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapping</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Some data journaling orphaned pages can have</span>
<span class="cm">		 * page-&gt;mapping == NULL while being dirty with clean buffers.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_has_private</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">try_to_free_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ClearPageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: orphaned page</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">PAGE_CLEAN</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">PAGE_KEEP</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">writepage</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">PAGE_ACTIVATE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">may_write_to_queue</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">,</span> <span class="n">sc</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PAGE_KEEP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clear_page_dirty_for_io</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">writeback_control</span> <span class="n">wbc</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">sync_mode</span> <span class="o">=</span> <span class="n">WB_SYNC_NONE</span><span class="p">,</span>
			<span class="p">.</span><span class="n">nr_to_write</span> <span class="o">=</span> <span class="n">SWAP_CLUSTER_MAX</span><span class="p">,</span>
			<span class="p">.</span><span class="n">range_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
			<span class="p">.</span><span class="n">range_end</span> <span class="o">=</span> <span class="n">LLONG_MAX</span><span class="p">,</span>
			<span class="p">.</span><span class="n">for_reclaim</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">};</span>

		<span class="n">SetPageReclaim</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">writepage</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wbc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">handle_write_error</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">AOP_WRITEPAGE_ACTIVATE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ClearPageReclaim</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">PAGE_ACTIVATE</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* synchronous write or broken a_ops? */</span>
			<span class="n">ClearPageReclaim</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">trace_mm_vmscan_writepage</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">trace_reclaim_flags</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
		<span class="n">inc_zone_page_state</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">NR_VMSCAN_WRITE</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">PAGE_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">PAGE_CLEAN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Same as remove_mapping, but if the page is removed from the mapping, it</span>
<span class="cm"> * gets returned with a refcount of 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__remove_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">mapping</span> <span class="o">!=</span> <span class="n">page_mapping</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">tree_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * The non racy check for a busy page.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Must be careful with the order of the tests. When someone has</span>
<span class="cm">	 * a ref to the page, it may be possible that they dirty it then</span>
<span class="cm">	 * drop the reference. So if PageDirty is tested before page_count</span>
<span class="cm">	 * here, then the following race may occur:</span>
<span class="cm">	 *</span>
<span class="cm">	 * get_user_pages(&amp;page);</span>
<span class="cm">	 * [user mapping goes away]</span>
<span class="cm">	 * write_to(page);</span>
<span class="cm">	 *				!PageDirty(page)    [good]</span>
<span class="cm">	 * SetPageDirty(page);</span>
<span class="cm">	 * put_page(page);</span>
<span class="cm">	 *				!page_count(page)   [good, discard it]</span>
<span class="cm">	 *</span>
<span class="cm">	 * [oops, our write_to data is lost]</span>
<span class="cm">	 *</span>
<span class="cm">	 * Reversing the order of the tests ensures such a situation cannot</span>
<span class="cm">	 * escape unnoticed. The smp_rmb is needed to ensure the page-&gt;flags</span>
<span class="cm">	 * load is not satisfied before that of page-&gt;_count.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note that if SetPageDirty is always performed via set_page_dirty,</span>
<span class="cm">	 * and thus under tree_lock, then this ordering is not required.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_freeze_refs</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">cannot_free</span><span class="p">;</span>
	<span class="cm">/* note: atomic_cmpxchg in page_freeze_refs provides the smp_rmb */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">PageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">page_unfreeze_refs</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">cannot_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PageSwapCache</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">swp_entry_t</span> <span class="n">swap</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">page_private</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">};</span>
		<span class="n">__delete_from_swap_cache</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">tree_lock</span><span class="p">);</span>
		<span class="n">swapcache_free</span><span class="p">(</span><span class="n">swap</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">freepage</span><span class="p">)(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">);</span>

		<span class="n">freepage</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">freepage</span><span class="p">;</span>

		<span class="n">__delete_from_page_cache</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">tree_lock</span><span class="p">);</span>
		<span class="n">mem_cgroup_uncharge_cache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">freepage</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">freepage</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">cannot_free:</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">tree_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Attempt to detach a locked page from its -&gt;mapping.  If it is dirty or if</span>
<span class="cm"> * someone else has a ref on the page, abort and return 0.  If it was</span>
<span class="cm"> * successfully detached, return 1.  Assumes the caller has a single ref on</span>
<span class="cm"> * this page.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">remove_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__remove_mapping</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Unfreezing the refcount with 1 rather than 2 effectively</span>
<span class="cm">		 * drops the pagecache ref for us without requiring another</span>
<span class="cm">		 * atomic operation.</span>
<span class="cm">		 */</span>
		<span class="n">page_unfreeze_refs</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * putback_lru_page - put previously isolated page onto appropriate LRU list</span>
<span class="cm"> * @page: page to be put back to appropriate lru list</span>
<span class="cm"> *</span>
<span class="cm"> * Add previously isolated @page to appropriate LRU list.</span>
<span class="cm"> * Page may still be unevictable for other reasons.</span>
<span class="cm"> *</span>
<span class="cm"> * lru_lock must not be held, interrupts must be enabled.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">putback_lru_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">lru</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">active</span> <span class="o">=</span> <span class="o">!!</span><span class="n">TestClearPageActive</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">was_unevictable</span> <span class="o">=</span> <span class="n">PageUnevictable</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">PageLRU</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

<span class="nl">redo:</span>
	<span class="n">ClearPageUnevictable</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">page_evictable</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * For evictable pages, we can use the cache.</span>
<span class="cm">		 * In event of a race, worst case is we end up with an</span>
<span class="cm">		 * unevictable page on [in]active list.</span>
<span class="cm">		 * We know how to handle that.</span>
<span class="cm">		 */</span>
		<span class="n">lru</span> <span class="o">=</span> <span class="n">active</span> <span class="o">+</span> <span class="n">page_lru_base_type</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">lru_cache_add_lru</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Put unevictable pages directly on zone&#39;s unevictable</span>
<span class="cm">		 * list.</span>
<span class="cm">		 */</span>
		<span class="n">lru</span> <span class="o">=</span> <span class="n">LRU_UNEVICTABLE</span><span class="p">;</span>
		<span class="n">add_page_to_unevictable_list</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * When racing with an mlock or AS_UNEVICTABLE clearing</span>
<span class="cm">		 * (page is unlocked) make sure that if the other thread</span>
<span class="cm">		 * does not observe our setting of PG_lru and fails</span>
<span class="cm">		 * isolation/check_move_unevictable_pages,</span>
<span class="cm">		 * we see PG_mlocked/AS_UNEVICTABLE cleared below and move</span>
<span class="cm">		 * the page back to the evictable list.</span>
<span class="cm">		 *</span>
<span class="cm">		 * The other side is TestClearPageMlocked() or shmem_lock().</span>
<span class="cm">		 */</span>
		<span class="n">smp_mb</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * page&#39;s status can change while we move it among lru. If an evictable</span>
<span class="cm">	 * page is on unevictable list, it never be freed. To avoid that,</span>
<span class="cm">	 * check after we added it to the list, again.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lru</span> <span class="o">==</span> <span class="n">LRU_UNEVICTABLE</span> <span class="o">&amp;&amp;</span> <span class="n">page_evictable</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isolate_lru_page</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">redo</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* This means someone else dropped this page from LRU</span>
<span class="cm">		 * So, it will be freed or putback to LRU again. There is</span>
<span class="cm">		 * nothing to do here.</span>
<span class="cm">		 */</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">was_unevictable</span> <span class="o">&amp;&amp;</span> <span class="n">lru</span> <span class="o">!=</span> <span class="n">LRU_UNEVICTABLE</span><span class="p">)</span>
		<span class="n">count_vm_event</span><span class="p">(</span><span class="n">UNEVICTABLE_PGRESCUED</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">was_unevictable</span> <span class="o">&amp;&amp;</span> <span class="n">lru</span> <span class="o">==</span> <span class="n">LRU_UNEVICTABLE</span><span class="p">)</span>
		<span class="n">count_vm_event</span><span class="p">(</span><span class="n">UNEVICTABLE_PGCULLED</span><span class="p">);</span>

	<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>		<span class="cm">/* drop ref from isolate */</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">page_references</span> <span class="p">{</span>
	<span class="n">PAGEREF_RECLAIM</span><span class="p">,</span>
	<span class="n">PAGEREF_RECLAIM_CLEAN</span><span class="p">,</span>
	<span class="n">PAGEREF_KEEP</span><span class="p">,</span>
	<span class="n">PAGEREF_ACTIVATE</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">page_references</span> <span class="nf">page_check_references</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">scan_control</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">referenced_ptes</span><span class="p">,</span> <span class="n">referenced_page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vm_flags</span><span class="p">;</span>

	<span class="n">referenced_ptes</span> <span class="o">=</span> <span class="n">page_referenced</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">target_mem_cgroup</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">vm_flags</span><span class="p">);</span>
	<span class="n">referenced_page</span> <span class="o">=</span> <span class="n">TestClearPageReferenced</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Mlock lost the isolation race with us.  Let try_to_unmap()</span>
<span class="cm">	 * move the page to the unevictable list.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_LOCKED</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">PAGEREF_RECLAIM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">referenced_ptes</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageSwapBacked</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PAGEREF_ACTIVATE</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * All mapped pages start out with page table</span>
<span class="cm">		 * references from the instantiating fault, so we need</span>
<span class="cm">		 * to look twice if a mapped file page is used more</span>
<span class="cm">		 * than once.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Mark it and spare it for another trip around the</span>
<span class="cm">		 * inactive list.  Another page table reference will</span>
<span class="cm">		 * lead to its activation.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Note: the mark is set for activated pages as well</span>
<span class="cm">		 * so that recently deactivated but used pages are</span>
<span class="cm">		 * quickly recovered.</span>
<span class="cm">		 */</span>
		<span class="n">SetPageReferenced</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">referenced_page</span> <span class="o">||</span> <span class="n">referenced_ptes</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">PAGEREF_ACTIVATE</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Activate file-backed executable pages after first usage.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_EXEC</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">PAGEREF_ACTIVATE</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">PAGEREF_KEEP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Reclaim if clean, defer dirty pages to writeback */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">referenced_page</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PageSwapBacked</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PAGEREF_RECLAIM_CLEAN</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">PAGEREF_RECLAIM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * shrink_page_list() returns the number of reclaimed pages</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">shrink_page_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">page_list</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">scan_control</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ret_nr_dirty</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ret_nr_writeback</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">ret_pages</span><span class="p">);</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">free_pages</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">pgactivate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_dirty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_congested</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_reclaimed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_writeback</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cond_resched</span><span class="p">();</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">page_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">enum</span> <span class="n">page_references</span> <span class="n">references</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">may_enter_fs</span><span class="p">;</span>

		<span class="n">cond_resched</span><span class="p">();</span>

		<span class="n">page</span> <span class="o">=</span> <span class="n">lru_to_page</span><span class="p">(</span><span class="n">page_list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trylock_page</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">keep</span><span class="p">;</span>

		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">PageActive</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">page_zone</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">!=</span> <span class="n">zone</span><span class="p">);</span>

		<span class="n">sc</span><span class="o">-&gt;</span><span class="n">nr_scanned</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">page_evictable</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">cull_mlocked</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">may_unmap</span> <span class="o">&amp;&amp;</span> <span class="n">page_mapped</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">keep_locked</span><span class="p">;</span>

		<span class="cm">/* Double the slab pressure for mapped and swapcache pages */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_mapped</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">||</span> <span class="n">PageSwapCache</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="n">sc</span><span class="o">-&gt;</span><span class="n">nr_scanned</span><span class="o">++</span><span class="p">;</span>

		<span class="n">may_enter_fs</span> <span class="o">=</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_FS</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">PageSwapCache</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_IO</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">PageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">nr_writeback</span><span class="o">++</span><span class="p">;</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">keep</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">references</span> <span class="o">=</span> <span class="n">page_check_references</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">sc</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">references</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">PAGEREF_ACTIVATE</span>:
			<span class="k">goto</span> <span class="n">activate_locked</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">PAGEREF_KEEP</span>:
			<span class="k">goto</span> <span class="n">keep_locked</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">PAGEREF_RECLAIM</span>:
		<span class="k">case</span> <span class="n">PAGEREF_RECLAIM_CLEAN</span>:
			<span class="p">;</span> <span class="cm">/* try to reclaim the page below */</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Anonymous process memory has backing store?</span>
<span class="cm">		 * Try to allocate it some swap space here.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageAnon</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PageSwapCache</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_IO</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">keep_locked</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">add_to_swap</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">activate_locked</span><span class="p">;</span>
			<span class="n">may_enter_fs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">mapping</span> <span class="o">=</span> <span class="n">page_mapping</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * The page is mapped into the page tables of one or more</span>
<span class="cm">		 * processes. Try to unmap it here.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_mapped</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">mapping</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">try_to_unmap</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">TTU_UNMAP</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">SWAP_FAIL</span>:
				<span class="k">goto</span> <span class="n">activate_locked</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">SWAP_AGAIN</span>:
				<span class="k">goto</span> <span class="n">keep_locked</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">SWAP_MLOCK</span>:
				<span class="k">goto</span> <span class="n">cull_mlocked</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">SWAP_SUCCESS</span>:
				<span class="p">;</span> <span class="cm">/* try to free the page below */</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">PageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">nr_dirty</span><span class="o">++</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Only kswapd can writeback filesystem pages to</span>
<span class="cm">			 * avoid risk of stack overflow but do not writeback</span>
<span class="cm">			 * unless under significant pressure.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page_is_file_cache</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					<span class="p">(</span><span class="o">!</span><span class="n">current_is_kswapd</span><span class="p">()</span> <span class="o">||</span>
					 <span class="n">sc</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">&gt;=</span> <span class="n">DEF_PRIORITY</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Immediately reclaim when written back.</span>
<span class="cm">				 * Similar in principal to deactivate_page()</span>
<span class="cm">				 * except we already have the page isolated</span>
<span class="cm">				 * and know it&#39;s dirty</span>
<span class="cm">				 */</span>
				<span class="n">inc_zone_page_state</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">NR_VMSCAN_IMMEDIATE</span><span class="p">);</span>
				<span class="n">SetPageReclaim</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

				<span class="k">goto</span> <span class="n">keep_locked</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">references</span> <span class="o">==</span> <span class="n">PAGEREF_RECLAIM_CLEAN</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">keep_locked</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">may_enter_fs</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">keep_locked</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">may_writepage</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">keep_locked</span><span class="p">;</span>

			<span class="cm">/* Page is dirty, try to write it out here */</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">pageout</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">sc</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">PAGE_KEEP</span>:
				<span class="n">nr_congested</span><span class="o">++</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">keep_locked</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">PAGE_ACTIVATE</span>:
				<span class="k">goto</span> <span class="n">activate_locked</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">PAGE_SUCCESS</span>:
				<span class="k">if</span> <span class="p">(</span><span class="n">PageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">keep</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">PageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">keep</span><span class="p">;</span>

				<span class="cm">/*</span>
<span class="cm">				 * A synchronous write - probably a ramdisk.  Go</span>
<span class="cm">				 * ahead and try to reclaim the page.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trylock_page</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">keep</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">PageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">||</span> <span class="n">PageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">keep_locked</span><span class="p">;</span>
				<span class="n">mapping</span> <span class="o">=</span> <span class="n">page_mapping</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">case</span> <span class="n">PAGE_CLEAN</span>:
				<span class="p">;</span> <span class="cm">/* try to free the page below */</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * If the page has buffers, try to free the buffer mappings</span>
<span class="cm">		 * associated with this page. If we succeed we try to free</span>
<span class="cm">		 * the page as well.</span>
<span class="cm">		 *</span>
<span class="cm">		 * We do this even if the page is PageDirty().</span>
<span class="cm">		 * try_to_release_page() does not perform I/O, but it is</span>
<span class="cm">		 * possible for a page to have PageDirty set, but it is actually</span>
<span class="cm">		 * clean (all its buffers are clean).  This happens if the</span>
<span class="cm">		 * buffers were written out directly, with submit_bh(). ext3</span>
<span class="cm">		 * will do this, as well as the blockdev mapping.</span>
<span class="cm">		 * try_to_release_page() will discover that cleanness and will</span>
<span class="cm">		 * drop the buffers and mark the page clean - it can be freed.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Rarely, pages can have buffers and no -&gt;mapping.  These are</span>
<span class="cm">		 * the pages which were not successfully invalidated in</span>
<span class="cm">		 * truncate_complete_page().  We try to drop those buffers here</span>
<span class="cm">		 * and if that worked, and the page is no longer mapped into</span>
<span class="cm">		 * process address space (page_count == 1) it can be freed.</span>
<span class="cm">		 * Otherwise, leave the page on the LRU so it is swappable.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_has_private</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">try_to_release_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">gfp_mask</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">activate_locked</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapping</span> <span class="o">&amp;&amp;</span> <span class="n">page_count</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">put_page_testzero</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">free_it</span><span class="p">;</span>
				<span class="k">else</span> <span class="p">{</span>
					<span class="cm">/*</span>
<span class="cm">					 * rare race with speculative reference.</span>
<span class="cm">					 * the speculative reference will free</span>
<span class="cm">					 * this page shortly, so we may</span>
<span class="cm">					 * increment nr_reclaimed here (and</span>
<span class="cm">					 * leave it off the LRU).</span>
<span class="cm">					 */</span>
					<span class="n">nr_reclaimed</span><span class="o">++</span><span class="p">;</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapping</span> <span class="o">||</span> <span class="o">!</span><span class="n">__remove_mapping</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">page</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">keep_locked</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * At this point, we have no other references and there is</span>
<span class="cm">		 * no way to pick any more up (removed from LRU, removed</span>
<span class="cm">		 * from pagecache). Can use non-atomic bitops now (and</span>
<span class="cm">		 * we obviously don&#39;t have to worry about waking up a process</span>
<span class="cm">		 * waiting on the page lock, because there are no references.</span>
<span class="cm">		 */</span>
		<span class="n">__clear_page_locked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="nl">free_it:</span>
		<span class="n">nr_reclaimed</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Is there need to periodically free_page_list? It would</span>
<span class="cm">		 * appear not as the counts should be low</span>
<span class="cm">		 */</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">free_pages</span><span class="p">);</span>
		<span class="k">continue</span><span class="p">;</span>

<span class="nl">cull_mlocked:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageSwapCache</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="n">try_to_free_swap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">putback_lru_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">continue</span><span class="p">;</span>

<span class="nl">activate_locked:</span>
		<span class="cm">/* Not a candidate for swapping, so reclaim swap space. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageSwapCache</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">vm_swap_full</span><span class="p">())</span>
			<span class="n">try_to_free_swap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">PageActive</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
		<span class="n">SetPageActive</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">pgactivate</span><span class="o">++</span><span class="p">;</span>
<span class="nl">keep_locked:</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="nl">keep:</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ret_pages</span><span class="p">);</span>
		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">PageLRU</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">||</span> <span class="n">PageUnevictable</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Tag a zone as congested if all the dirty pages encountered were</span>
<span class="cm">	 * backed by a congested BDI. In this case, reclaimers should just</span>
<span class="cm">	 * back off and wait for congestion to clear because further reclaim</span>
<span class="cm">	 * will encounter the same problem</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_dirty</span> <span class="o">&amp;&amp;</span> <span class="n">nr_dirty</span> <span class="o">==</span> <span class="n">nr_congested</span> <span class="o">&amp;&amp;</span> <span class="n">global_reclaim</span><span class="p">(</span><span class="n">sc</span><span class="p">))</span>
		<span class="n">zone_set_flag</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">ZONE_CONGESTED</span><span class="p">);</span>

	<span class="n">free_hot_cold_page_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free_pages</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">list_splice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ret_pages</span><span class="p">,</span> <span class="n">page_list</span><span class="p">);</span>
	<span class="n">count_vm_events</span><span class="p">(</span><span class="n">PGACTIVATE</span><span class="p">,</span> <span class="n">pgactivate</span><span class="p">);</span>
	<span class="o">*</span><span class="n">ret_nr_dirty</span> <span class="o">+=</span> <span class="n">nr_dirty</span><span class="p">;</span>
	<span class="o">*</span><span class="n">ret_nr_writeback</span> <span class="o">+=</span> <span class="n">nr_writeback</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">nr_reclaimed</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Attempt to remove the specified page from its LRU.  Only take this page</span>
<span class="cm"> * if it is of the appropriate PageActive status.  Pages which are being</span>
<span class="cm"> * freed elsewhere are also ignored.</span>
<span class="cm"> *</span>
<span class="cm"> * page:	page to consider</span>
<span class="cm"> * mode:	one of the LRU isolation modes defined above</span>
<span class="cm"> *</span>
<span class="cm"> * returns 0 on success, -ve errno on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__isolate_lru_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">isolate_mode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Only take pages on the LRU. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageLRU</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Do not give back unevictable pages for compaction */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageUnevictable</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * To minimise LRU disruption, the caller can indicate that it only</span>
<span class="cm">	 * wants to isolate pages it will be able to operate on without</span>
<span class="cm">	 * blocking - clean pages for the most part.</span>
<span class="cm">	 *</span>
<span class="cm">	 * ISOLATE_CLEAN means that only clean pages should be isolated. This</span>
<span class="cm">	 * is used by reclaim when it is cannot write to backing storage</span>
<span class="cm">	 *</span>
<span class="cm">	 * ISOLATE_ASYNC_MIGRATE is used to indicate that it only wants to pages</span>
<span class="cm">	 * that it is possible to migrate without blocking</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ISOLATE_CLEAN</span><span class="o">|</span><span class="n">ISOLATE_ASYNC_MIGRATE</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* All the caller can do on PageWriteback is block */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">PageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">;</span>

			<span class="cm">/* ISOLATE_CLEAN means only clean pages */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">ISOLATE_CLEAN</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Only pages without mappings or that have a</span>
<span class="cm">			 * -&gt;migratepage callback are possible to migrate</span>
<span class="cm">			 * without blocking</span>
<span class="cm">			 */</span>
			<span class="n">mapping</span> <span class="o">=</span> <span class="n">page_mapping</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mapping</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">migratepage</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">ISOLATE_UNMAPPED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">page_mapped</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">get_page_unless_zero</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Be careful not to clear PageLRU until after we&#39;re</span>
<span class="cm">		 * sure the page is not being freed elsewhere -- the</span>
<span class="cm">		 * page release code relies on it.</span>
<span class="cm">		 */</span>
		<span class="n">ClearPageLRU</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * zone-&gt;lru_lock is heavily contended.  Some of the functions that</span>
<span class="cm"> * shrink the lists perform better by taking out a batch of pages</span>
<span class="cm"> * and working on them outside the LRU lock.</span>
<span class="cm"> *</span>
<span class="cm"> * For pagecache intensive workloads, this function is the hottest</span>
<span class="cm"> * spot in the kernel (apart from copy_*_user functions).</span>
<span class="cm"> *</span>
<span class="cm"> * Appropriate locks must be held before calling this function.</span>
<span class="cm"> *</span>
<span class="cm"> * @nr_to_scan:	The number of pages to look through on the list.</span>
<span class="cm"> * @lruvec:	The LRU vector to pull pages from.</span>
<span class="cm"> * @dst:	The temp list to put pages on to.</span>
<span class="cm"> * @nr_scanned:	The number of pages that were scanned.</span>
<span class="cm"> * @sc:		The scan_control struct for this reclaim session</span>
<span class="cm"> * @mode:	One of the LRU isolation modes</span>
<span class="cm"> * @lru:	LRU list id for isolating</span>
<span class="cm"> *</span>
<span class="cm"> * returns how many pages were moved onto *@dst.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">isolate_lru_pages</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_to_scan</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">lruvec</span> <span class="o">*</span><span class="n">lruvec</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">nr_scanned</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scan_control</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span>
		<span class="n">isolate_mode_t</span> <span class="n">mode</span><span class="p">,</span> <span class="k">enum</span> <span class="n">lru_list</span> <span class="n">lru</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">src</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lruvec</span><span class="o">-&gt;</span><span class="n">lists</span><span class="p">[</span><span class="n">lru</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_taken</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">scan</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">scan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">scan</span> <span class="o">&lt;</span> <span class="n">nr_to_scan</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">src</span><span class="p">);</span> <span class="n">scan</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">nr_pages</span><span class="p">;</span>

		<span class="n">page</span> <span class="o">=</span> <span class="n">lru_to_page</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
		<span class="n">prefetchw_prev_lru_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLRU</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">__isolate_lru_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>:
			<span class="n">nr_pages</span> <span class="o">=</span> <span class="n">hpage_nr_pages</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">mem_cgroup_update_lru_size</span><span class="p">(</span><span class="n">lruvec</span><span class="p">,</span> <span class="n">lru</span><span class="p">,</span> <span class="o">-</span><span class="n">nr_pages</span><span class="p">);</span>
			<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="n">dst</span><span class="p">);</span>
			<span class="n">nr_taken</span> <span class="o">+=</span> <span class="n">nr_pages</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="o">-</span><span class="n">EBUSY</span>:
			<span class="cm">/* else it is being freed elsewhere */</span>
			<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">nr_scanned</span> <span class="o">=</span> <span class="n">scan</span><span class="p">;</span>
	<span class="n">trace_mm_vmscan_lru_isolate</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">order</span><span class="p">,</span> <span class="n">nr_to_scan</span><span class="p">,</span> <span class="n">scan</span><span class="p">,</span>
				    <span class="n">nr_taken</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">is_file_lru</span><span class="p">(</span><span class="n">lru</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">nr_taken</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * isolate_lru_page - tries to isolate a page from its LRU list</span>
<span class="cm"> * @page: page to isolate from its LRU list</span>
<span class="cm"> *</span>
<span class="cm"> * Isolates a @page from an LRU list, clears PageLRU and adjusts the</span>
<span class="cm"> * vmstat statistic corresponding to whatever LRU list the page was on.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if the page was removed from an LRU list.</span>
<span class="cm"> * Returns -EBUSY if the page was not on an LRU list.</span>
<span class="cm"> *</span>
<span class="cm"> * The returned page will have PageLRU() cleared.  If it was found on</span>
<span class="cm"> * the active list, it will have PageActive set.  If it was found on</span>
<span class="cm"> * the unevictable list, it will have the PageUnevictable bit set. That flag</span>
<span class="cm"> * may need to be cleared by the caller before letting the page go.</span>
<span class="cm"> *</span>
<span class="cm"> * The vmstat statistic corresponding to the list on which the page was</span>
<span class="cm"> * found will be decremented.</span>
<span class="cm"> *</span>
<span class="cm"> * Restrictions:</span>
<span class="cm"> * (1) Must be called with an elevated refcount on the page. This is a</span>
<span class="cm"> *     fundamentnal difference from isolate_lru_pages (which is called</span>
<span class="cm"> *     without a stable reference).</span>
<span class="cm"> * (2) the lru_lock must not be held.</span>
<span class="cm"> * (3) interrupts must be enabled.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">isolate_lru_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">page_count</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PageLRU</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span> <span class="o">=</span> <span class="n">page_zone</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">lruvec</span> <span class="o">*</span><span class="n">lruvec</span><span class="p">;</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lru_lock</span><span class="p">);</span>
		<span class="n">lruvec</span> <span class="o">=</span> <span class="n">mem_cgroup_page_lruvec</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">zone</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageLRU</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">lru</span> <span class="o">=</span> <span class="n">page_lru</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">get_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">ClearPageLRU</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">del_page_from_lru_list</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">lruvec</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lru_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Are there way too many processes in the direct reclaim path already?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">too_many_isolated</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span> <span class="kt">int</span> <span class="n">file</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">scan_control</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">inactive</span><span class="p">,</span> <span class="n">isolated</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">current_is_kswapd</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">global_reclaim</span><span class="p">(</span><span class="n">sc</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inactive</span> <span class="o">=</span> <span class="n">zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_INACTIVE_FILE</span><span class="p">);</span>
		<span class="n">isolated</span> <span class="o">=</span> <span class="n">zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_ISOLATED_FILE</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">inactive</span> <span class="o">=</span> <span class="n">zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_INACTIVE_ANON</span><span class="p">);</span>
		<span class="n">isolated</span> <span class="o">=</span> <span class="n">zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_ISOLATED_ANON</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">isolated</span> <span class="o">&gt;</span> <span class="n">inactive</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline_for_stack</span> <span class="kt">void</span>
<span class="nf">putback_inactive_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">lruvec</span> <span class="o">*</span><span class="n">lruvec</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">page_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">zone_reclaim_stat</span> <span class="o">*</span><span class="n">reclaim_stat</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lruvec</span><span class="o">-&gt;</span><span class="n">reclaim_stat</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span> <span class="o">=</span> <span class="n">lruvec_zone</span><span class="p">(</span><span class="n">lruvec</span><span class="p">);</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">pages_to_free</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Put back any unfreeable pages.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">page_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">lru_to_page</span><span class="p">(</span><span class="n">page_list</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">lru</span><span class="p">;</span>

		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">PageLRU</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">page_evictable</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lru_lock</span><span class="p">);</span>
			<span class="n">putback_lru_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lru_lock</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">lruvec</span> <span class="o">=</span> <span class="n">mem_cgroup_page_lruvec</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">zone</span><span class="p">);</span>

		<span class="n">SetPageLRU</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">lru</span> <span class="o">=</span> <span class="n">page_lru</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">add_page_to_lru_list</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">lruvec</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_active_lru</span><span class="p">(</span><span class="n">lru</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">file</span> <span class="o">=</span> <span class="n">is_file_lru</span><span class="p">(</span><span class="n">lru</span><span class="p">);</span>
			<span class="kt">int</span> <span class="n">numpages</span> <span class="o">=</span> <span class="n">hpage_nr_pages</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">reclaim_stat</span><span class="o">-&gt;</span><span class="n">recent_rotated</span><span class="p">[</span><span class="n">file</span><span class="p">]</span> <span class="o">+=</span> <span class="n">numpages</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">put_page_testzero</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">__ClearPageLRU</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">__ClearPageActive</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">del_page_from_lru_list</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">lruvec</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">PageCompound</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lru_lock</span><span class="p">);</span>
				<span class="p">(</span><span class="o">*</span><span class="n">get_compound_page_dtor</span><span class="p">(</span><span class="n">page</span><span class="p">))(</span><span class="n">page</span><span class="p">);</span>
				<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lru_lock</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pages_to_free</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * To save our caller&#39;s stack, now use input list for pages to free.</span>
<span class="cm">	 */</span>
	<span class="n">list_splice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pages_to_free</span><span class="p">,</span> <span class="n">page_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * shrink_inactive_list() is a helper for shrink_zone().  It returns the number</span>
<span class="cm"> * of reclaimed pages</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline_for_stack</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">shrink_inactive_list</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_to_scan</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lruvec</span> <span class="o">*</span><span class="n">lruvec</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">scan_control</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">enum</span> <span class="n">lru_list</span> <span class="n">lru</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">page_list</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_scanned</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_reclaimed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_taken</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_dirty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_writeback</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">isolate_mode_t</span> <span class="n">isolate_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">file</span> <span class="o">=</span> <span class="n">is_file_lru</span><span class="p">(</span><span class="n">lru</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span> <span class="o">=</span> <span class="n">lruvec_zone</span><span class="p">(</span><span class="n">lruvec</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">zone_reclaim_stat</span> <span class="o">*</span><span class="n">reclaim_stat</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lruvec</span><span class="o">-&gt;</span><span class="n">reclaim_stat</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">too_many_isolated</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">sc</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">congestion_wait</span><span class="p">(</span><span class="n">BLK_RW_ASYNC</span><span class="p">,</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">10</span><span class="p">);</span>

		<span class="cm">/* We are about to die and free our memory. Return now. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fatal_signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">SWAP_CLUSTER_MAX</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lru_add_drain</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">may_unmap</span><span class="p">)</span>
		<span class="n">isolate_mode</span> <span class="o">|=</span> <span class="n">ISOLATE_UNMAPPED</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">may_writepage</span><span class="p">)</span>
		<span class="n">isolate_mode</span> <span class="o">|=</span> <span class="n">ISOLATE_CLEAN</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lru_lock</span><span class="p">);</span>

	<span class="n">nr_taken</span> <span class="o">=</span> <span class="n">isolate_lru_pages</span><span class="p">(</span><span class="n">nr_to_scan</span><span class="p">,</span> <span class="n">lruvec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page_list</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">nr_scanned</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="n">isolate_mode</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>

	<span class="n">__mod_zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_LRU_BASE</span> <span class="o">+</span> <span class="n">lru</span><span class="p">,</span> <span class="o">-</span><span class="n">nr_taken</span><span class="p">);</span>
	<span class="n">__mod_zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_ISOLATED_ANON</span> <span class="o">+</span> <span class="n">file</span><span class="p">,</span> <span class="n">nr_taken</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">global_reclaim</span><span class="p">(</span><span class="n">sc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">zone</span><span class="o">-&gt;</span><span class="n">pages_scanned</span> <span class="o">+=</span> <span class="n">nr_scanned</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">current_is_kswapd</span><span class="p">())</span>
			<span class="n">__count_zone_vm_events</span><span class="p">(</span><span class="n">PGSCAN_KSWAPD</span><span class="p">,</span> <span class="n">zone</span><span class="p">,</span> <span class="n">nr_scanned</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">__count_zone_vm_events</span><span class="p">(</span><span class="n">PGSCAN_DIRECT</span><span class="p">,</span> <span class="n">zone</span><span class="p">,</span> <span class="n">nr_scanned</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lru_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr_taken</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">nr_reclaimed</span> <span class="o">=</span> <span class="n">shrink_page_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page_list</span><span class="p">,</span> <span class="n">zone</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">nr_dirty</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr_writeback</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lru_lock</span><span class="p">);</span>

	<span class="n">reclaim_stat</span><span class="o">-&gt;</span><span class="n">recent_scanned</span><span class="p">[</span><span class="n">file</span><span class="p">]</span> <span class="o">+=</span> <span class="n">nr_taken</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">global_reclaim</span><span class="p">(</span><span class="n">sc</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">current_is_kswapd</span><span class="p">())</span>
			<span class="n">__count_zone_vm_events</span><span class="p">(</span><span class="n">PGSTEAL_KSWAPD</span><span class="p">,</span> <span class="n">zone</span><span class="p">,</span>
					       <span class="n">nr_reclaimed</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">__count_zone_vm_events</span><span class="p">(</span><span class="n">PGSTEAL_DIRECT</span><span class="p">,</span> <span class="n">zone</span><span class="p">,</span>
					       <span class="n">nr_reclaimed</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">putback_inactive_pages</span><span class="p">(</span><span class="n">lruvec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page_list</span><span class="p">);</span>

	<span class="n">__mod_zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_ISOLATED_ANON</span> <span class="o">+</span> <span class="n">file</span><span class="p">,</span> <span class="o">-</span><span class="n">nr_taken</span><span class="p">);</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lru_lock</span><span class="p">);</span>

	<span class="n">free_hot_cold_page_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page_list</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If reclaim is isolating dirty pages under writeback, it implies</span>
<span class="cm">	 * that the long-lived page allocation rate is exceeding the page</span>
<span class="cm">	 * laundering rate. Either the global limits are not being effective</span>
<span class="cm">	 * at throttling processes due to the page distribution throughout</span>
<span class="cm">	 * zones or there is heavy usage of a slow backing device. The</span>
<span class="cm">	 * only option is to throttle from reclaim context which is not ideal</span>
<span class="cm">	 * as there is no guarantee the dirtying process is throttled in the</span>
<span class="cm">	 * same way balance_dirty_pages() manages.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This scales the number of dirty pages that must be under writeback</span>
<span class="cm">	 * before throttling depending on priority. It is a simple backoff</span>
<span class="cm">	 * function that has the most effect in the range DEF_PRIORITY to</span>
<span class="cm">	 * DEF_PRIORITY-2 which is the priority reclaim is considered to be</span>
<span class="cm">	 * in trouble and reclaim is considered to be in trouble.</span>
<span class="cm">	 *</span>
<span class="cm">	 * DEF_PRIORITY   100% isolated pages must be PageWriteback to throttle</span>
<span class="cm">	 * DEF_PRIORITY-1  50% must be PageWriteback</span>
<span class="cm">	 * DEF_PRIORITY-2  25% must be PageWriteback, kswapd in trouble</span>
<span class="cm">	 * ...</span>
<span class="cm">	 * DEF_PRIORITY-6 For SWAP_CLUSTER_MAX isolated pages, throttle if any</span>
<span class="cm">	 *                     isolated page is PageWriteback</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_writeback</span> <span class="o">&amp;&amp;</span> <span class="n">nr_writeback</span> <span class="o">&gt;=</span>
			<span class="p">(</span><span class="n">nr_taken</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">DEF_PRIORITY</span> <span class="o">-</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">)))</span>
		<span class="n">wait_iff_congested</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">BLK_RW_ASYNC</span><span class="p">,</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">10</span><span class="p">);</span>

	<span class="n">trace_mm_vmscan_lru_shrink_inactive</span><span class="p">(</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">zone_pgdat</span><span class="o">-&gt;</span><span class="n">node_id</span><span class="p">,</span>
		<span class="n">zone_idx</span><span class="p">(</span><span class="n">zone</span><span class="p">),</span>
		<span class="n">nr_scanned</span><span class="p">,</span> <span class="n">nr_reclaimed</span><span class="p">,</span>
		<span class="n">sc</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">,</span>
		<span class="n">trace_shrink_flags</span><span class="p">(</span><span class="n">file</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">nr_reclaimed</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This moves pages from the active list to the inactive list.</span>
<span class="cm"> *</span>
<span class="cm"> * We move them the other way if the page is referenced by one or more</span>
<span class="cm"> * processes, from rmap.</span>
<span class="cm"> *</span>
<span class="cm"> * If the pages are mostly unmapped, the processing is fast and it is</span>
<span class="cm"> * appropriate to hold zone-&gt;lru_lock across the whole operation.  But if</span>
<span class="cm"> * the pages are mapped, the processing is slow (page_referenced()) so we</span>
<span class="cm"> * should drop zone-&gt;lru_lock around each page.  It&#39;s impossible to balance</span>
<span class="cm"> * this, so instead we remove the pages from the LRU while processing them.</span>
<span class="cm"> * It is safe to rely on PG_active against the non-LRU pages in here because</span>
<span class="cm"> * nobody will play with that bit on a non-LRU page.</span>
<span class="cm"> *</span>
<span class="cm"> * The downside is that we have to touch page-&gt;_count against each page.</span>
<span class="cm"> * But we had to alter page-&gt;flags anyway.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">move_active_pages_to_lru</span><span class="p">(</span><span class="k">struct</span> <span class="n">lruvec</span> <span class="o">*</span><span class="n">lruvec</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pages_to_free</span><span class="p">,</span>
				     <span class="k">enum</span> <span class="n">lru_list</span> <span class="n">lru</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span> <span class="o">=</span> <span class="n">lruvec_zone</span><span class="p">(</span><span class="n">lruvec</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pgmoved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_pages</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">lru_to_page</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
		<span class="n">lruvec</span> <span class="o">=</span> <span class="n">mem_cgroup_page_lruvec</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">zone</span><span class="p">);</span>

		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">PageLRU</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
		<span class="n">SetPageLRU</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="n">nr_pages</span> <span class="o">=</span> <span class="n">hpage_nr_pages</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">mem_cgroup_update_lru_size</span><span class="p">(</span><span class="n">lruvec</span><span class="p">,</span> <span class="n">lru</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">);</span>
		<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lruvec</span><span class="o">-&gt;</span><span class="n">lists</span><span class="p">[</span><span class="n">lru</span><span class="p">]);</span>
		<span class="n">pgmoved</span> <span class="o">+=</span> <span class="n">nr_pages</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">put_page_testzero</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">__ClearPageLRU</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">__ClearPageActive</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">del_page_from_lru_list</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">lruvec</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">PageCompound</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lru_lock</span><span class="p">);</span>
				<span class="p">(</span><span class="o">*</span><span class="n">get_compound_page_dtor</span><span class="p">(</span><span class="n">page</span><span class="p">))(</span><span class="n">page</span><span class="p">);</span>
				<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lru_lock</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="n">pages_to_free</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">__mod_zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_LRU_BASE</span> <span class="o">+</span> <span class="n">lru</span><span class="p">,</span> <span class="n">pgmoved</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_active_lru</span><span class="p">(</span><span class="n">lru</span><span class="p">))</span>
		<span class="n">__count_vm_events</span><span class="p">(</span><span class="n">PGDEACTIVATE</span><span class="p">,</span> <span class="n">pgmoved</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">shrink_active_list</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_to_scan</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">lruvec</span> <span class="o">*</span><span class="n">lruvec</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">scan_control</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span>
			       <span class="k">enum</span> <span class="n">lru_list</span> <span class="n">lru</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_taken</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_scanned</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vm_flags</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">l_hold</span><span class="p">);</span>	<span class="cm">/* The pages which were snipped off */</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">l_active</span><span class="p">);</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">l_inactive</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zone_reclaim_stat</span> <span class="o">*</span><span class="n">reclaim_stat</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lruvec</span><span class="o">-&gt;</span><span class="n">reclaim_stat</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_rotated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">isolate_mode_t</span> <span class="n">isolate_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">file</span> <span class="o">=</span> <span class="n">is_file_lru</span><span class="p">(</span><span class="n">lru</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span> <span class="o">=</span> <span class="n">lruvec_zone</span><span class="p">(</span><span class="n">lruvec</span><span class="p">);</span>

	<span class="n">lru_add_drain</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">may_unmap</span><span class="p">)</span>
		<span class="n">isolate_mode</span> <span class="o">|=</span> <span class="n">ISOLATE_UNMAPPED</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">may_writepage</span><span class="p">)</span>
		<span class="n">isolate_mode</span> <span class="o">|=</span> <span class="n">ISOLATE_CLEAN</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lru_lock</span><span class="p">);</span>

	<span class="n">nr_taken</span> <span class="o">=</span> <span class="n">isolate_lru_pages</span><span class="p">(</span><span class="n">nr_to_scan</span><span class="p">,</span> <span class="n">lruvec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l_hold</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">nr_scanned</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="n">isolate_mode</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">global_reclaim</span><span class="p">(</span><span class="n">sc</span><span class="p">))</span>
		<span class="n">zone</span><span class="o">-&gt;</span><span class="n">pages_scanned</span> <span class="o">+=</span> <span class="n">nr_scanned</span><span class="p">;</span>

	<span class="n">reclaim_stat</span><span class="o">-&gt;</span><span class="n">recent_scanned</span><span class="p">[</span><span class="n">file</span><span class="p">]</span> <span class="o">+=</span> <span class="n">nr_taken</span><span class="p">;</span>

	<span class="n">__count_zone_vm_events</span><span class="p">(</span><span class="n">PGREFILL</span><span class="p">,</span> <span class="n">zone</span><span class="p">,</span> <span class="n">nr_scanned</span><span class="p">);</span>
	<span class="n">__mod_zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_LRU_BASE</span> <span class="o">+</span> <span class="n">lru</span><span class="p">,</span> <span class="o">-</span><span class="n">nr_taken</span><span class="p">);</span>
	<span class="n">__mod_zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_ISOLATED_ANON</span> <span class="o">+</span> <span class="n">file</span><span class="p">,</span> <span class="n">nr_taken</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lru_lock</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l_hold</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">lru_to_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l_hold</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">page_evictable</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">putback_lru_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">buffer_heads_over_limit</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page_has_private</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">trylock_page</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">page_has_private</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
					<span class="n">try_to_release_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">page_referenced</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">target_mem_cgroup</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">vm_flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">nr_rotated</span> <span class="o">+=</span> <span class="n">hpage_nr_pages</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Identify referenced, file-backed active pages and</span>
<span class="cm">			 * give them one more trip around the active list. So</span>
<span class="cm">			 * that executable code get better chances to stay in</span>
<span class="cm">			 * memory under moderate memory pressure.  Anon pages</span>
<span class="cm">			 * are not likely to be evicted by use-once streaming</span>
<span class="cm">			 * IO, plus JVM can create lots of anon VM_EXEC pages,</span>
<span class="cm">			 * so we ignore them here.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_EXEC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">page_is_file_cache</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l_active</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">ClearPageActive</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>	<span class="cm">/* we are de-activating */</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l_inactive</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Move pages back to the lru list.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lru_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Count referenced pages from currently used mappings as rotated,</span>
<span class="cm">	 * even though only some of them are actually re-activated.  This</span>
<span class="cm">	 * helps balance scan pressure between file and anonymous pages in</span>
<span class="cm">	 * get_scan_ratio.</span>
<span class="cm">	 */</span>
	<span class="n">reclaim_stat</span><span class="o">-&gt;</span><span class="n">recent_rotated</span><span class="p">[</span><span class="n">file</span><span class="p">]</span> <span class="o">+=</span> <span class="n">nr_rotated</span><span class="p">;</span>

	<span class="n">move_active_pages_to_lru</span><span class="p">(</span><span class="n">lruvec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l_active</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l_hold</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>
	<span class="n">move_active_pages_to_lru</span><span class="p">(</span><span class="n">lruvec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l_inactive</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l_hold</span><span class="p">,</span> <span class="n">lru</span> <span class="o">-</span> <span class="n">LRU_ACTIVE</span><span class="p">);</span>
	<span class="n">__mod_zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_ISOLATED_ANON</span> <span class="o">+</span> <span class="n">file</span><span class="p">,</span> <span class="o">-</span><span class="n">nr_taken</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lru_lock</span><span class="p">);</span>

	<span class="n">free_hot_cold_page_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l_hold</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SWAP</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">inactive_anon_is_low_global</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">active</span><span class="p">,</span> <span class="n">inactive</span><span class="p">;</span>

	<span class="n">active</span> <span class="o">=</span> <span class="n">zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_ACTIVE_ANON</span><span class="p">);</span>
	<span class="n">inactive</span> <span class="o">=</span> <span class="n">zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_INACTIVE_ANON</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inactive</span> <span class="o">*</span> <span class="n">zone</span><span class="o">-&gt;</span><span class="n">inactive_ratio</span> <span class="o">&lt;</span> <span class="n">active</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * inactive_anon_is_low - check if anonymous pages need to be deactivated</span>
<span class="cm"> * @lruvec: LRU vector to check</span>
<span class="cm"> *</span>
<span class="cm"> * Returns true if the zone does not have enough inactive anon pages,</span>
<span class="cm"> * meaning some active anon pages need to be deactivated.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">inactive_anon_is_low</span><span class="p">(</span><span class="k">struct</span> <span class="n">lruvec</span> <span class="o">*</span><span class="n">lruvec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we don&#39;t have swap space, anonymous page deactivation</span>
<span class="cm">	 * is pointless.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">total_swap_pages</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mem_cgroup_disabled</span><span class="p">())</span>
		<span class="k">return</span> <span class="n">mem_cgroup_inactive_anon_is_low</span><span class="p">(</span><span class="n">lruvec</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">inactive_anon_is_low_global</span><span class="p">(</span><span class="n">lruvec_zone</span><span class="p">(</span><span class="n">lruvec</span><span class="p">));</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">inactive_anon_is_low</span><span class="p">(</span><span class="k">struct</span> <span class="n">lruvec</span> <span class="o">*</span><span class="n">lruvec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">inactive_file_is_low_global</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">active</span><span class="p">,</span> <span class="n">inactive</span><span class="p">;</span>

	<span class="n">active</span> <span class="o">=</span> <span class="n">zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_ACTIVE_FILE</span><span class="p">);</span>
	<span class="n">inactive</span> <span class="o">=</span> <span class="n">zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_INACTIVE_FILE</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">active</span> <span class="o">&gt;</span> <span class="n">inactive</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * inactive_file_is_low - check if file pages need to be deactivated</span>
<span class="cm"> * @lruvec: LRU vector to check</span>
<span class="cm"> *</span>
<span class="cm"> * When the system is doing streaming IO, memory pressure here</span>
<span class="cm"> * ensures that active file pages get deactivated, until more</span>
<span class="cm"> * than half of the file pages are on the inactive list.</span>
<span class="cm"> *</span>
<span class="cm"> * Once we get to that situation, protect the system&#39;s working</span>
<span class="cm"> * set from being evicted by disabling active file page aging.</span>
<span class="cm"> *</span>
<span class="cm"> * This uses a different ratio than the anonymous pages, because</span>
<span class="cm"> * the page cache uses a use-once replacement algorithm.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">inactive_file_is_low</span><span class="p">(</span><span class="k">struct</span> <span class="n">lruvec</span> <span class="o">*</span><span class="n">lruvec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mem_cgroup_disabled</span><span class="p">())</span>
		<span class="k">return</span> <span class="n">mem_cgroup_inactive_file_is_low</span><span class="p">(</span><span class="n">lruvec</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">inactive_file_is_low_global</span><span class="p">(</span><span class="n">lruvec_zone</span><span class="p">(</span><span class="n">lruvec</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">inactive_list_is_low</span><span class="p">(</span><span class="k">struct</span> <span class="n">lruvec</span> <span class="o">*</span><span class="n">lruvec</span><span class="p">,</span> <span class="k">enum</span> <span class="n">lru_list</span> <span class="n">lru</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_file_lru</span><span class="p">(</span><span class="n">lru</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">inactive_file_is_low</span><span class="p">(</span><span class="n">lruvec</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">inactive_anon_is_low</span><span class="p">(</span><span class="n">lruvec</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">shrink_list</span><span class="p">(</span><span class="k">enum</span> <span class="n">lru_list</span> <span class="n">lru</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_to_scan</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">lruvec</span> <span class="o">*</span><span class="n">lruvec</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scan_control</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_active_lru</span><span class="p">(</span><span class="n">lru</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inactive_list_is_low</span><span class="p">(</span><span class="n">lruvec</span><span class="p">,</span> <span class="n">lru</span><span class="p">))</span>
			<span class="n">shrink_active_list</span><span class="p">(</span><span class="n">nr_to_scan</span><span class="p">,</span> <span class="n">lruvec</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">shrink_inactive_list</span><span class="p">(</span><span class="n">nr_to_scan</span><span class="p">,</span> <span class="n">lruvec</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vmscan_swappiness</span><span class="p">(</span><span class="k">struct</span> <span class="n">scan_control</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">global_reclaim</span><span class="p">(</span><span class="n">sc</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">vm_swappiness</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">mem_cgroup_swappiness</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">target_mem_cgroup</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Determine how aggressively the anon and file LRU lists should be</span>
<span class="cm"> * scanned.  The relative value of each set of LRU lists is determined</span>
<span class="cm"> * by looking at the fraction of the pages scanned we did rotate back</span>
<span class="cm"> * onto the active list instead of evict.</span>
<span class="cm"> *</span>
<span class="cm"> * nr[0] = anon pages to scan; nr[1] = file pages to scan</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">get_scan_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">lruvec</span> <span class="o">*</span><span class="n">lruvec</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scan_control</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">anon</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">free</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">anon_prio</span><span class="p">,</span> <span class="n">file_prio</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ap</span><span class="p">,</span> <span class="n">fp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zone_reclaim_stat</span> <span class="o">*</span><span class="n">reclaim_stat</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lruvec</span><span class="o">-&gt;</span><span class="n">reclaim_stat</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">fraction</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">denominator</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">lru_list</span> <span class="n">lru</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">noswap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">force_scan</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span> <span class="o">=</span> <span class="n">lruvec_zone</span><span class="p">(</span><span class="n">lruvec</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the zone or memcg is small, nr[l] can be 0.  This</span>
<span class="cm">	 * results in no scanning on this priority and a potential</span>
<span class="cm">	 * priority drop.  Global direct reclaim can go to the next</span>
<span class="cm">	 * zone and tends to have no problems. Global kswapd is for</span>
<span class="cm">	 * zone balancing and it needs to scan a minimum amount. When</span>
<span class="cm">	 * reclaiming for a memcg, a priority drop can cause high</span>
<span class="cm">	 * latencies, so it&#39;s better to scan a minimum amount there as</span>
<span class="cm">	 * well.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current_is_kswapd</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">zone</span><span class="o">-&gt;</span><span class="n">all_unreclaimable</span><span class="p">)</span>
		<span class="n">force_scan</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">global_reclaim</span><span class="p">(</span><span class="n">sc</span><span class="p">))</span>
		<span class="n">force_scan</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* If we have no swap space, do not bother scanning anon pages. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">may_swap</span> <span class="o">||</span> <span class="p">(</span><span class="n">nr_swap_pages</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">noswap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">fraction</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">fraction</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">denominator</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">anon</span>  <span class="o">=</span> <span class="n">get_lru_size</span><span class="p">(</span><span class="n">lruvec</span><span class="p">,</span> <span class="n">LRU_ACTIVE_ANON</span><span class="p">)</span> <span class="o">+</span>
		<span class="n">get_lru_size</span><span class="p">(</span><span class="n">lruvec</span><span class="p">,</span> <span class="n">LRU_INACTIVE_ANON</span><span class="p">);</span>
	<span class="n">file</span>  <span class="o">=</span> <span class="n">get_lru_size</span><span class="p">(</span><span class="n">lruvec</span><span class="p">,</span> <span class="n">LRU_ACTIVE_FILE</span><span class="p">)</span> <span class="o">+</span>
		<span class="n">get_lru_size</span><span class="p">(</span><span class="n">lruvec</span><span class="p">,</span> <span class="n">LRU_INACTIVE_FILE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">global_reclaim</span><span class="p">(</span><span class="n">sc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">free</span>  <span class="o">=</span> <span class="n">zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_FREE_PAGES</span><span class="p">);</span>
		<span class="cm">/* If we have very few page cache pages,</span>
<span class="cm">		   force-scan anon pages. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">file</span> <span class="o">+</span> <span class="n">free</span> <span class="o">&lt;=</span> <span class="n">high_wmark_pages</span><span class="p">(</span><span class="n">zone</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">fraction</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">fraction</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">denominator</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * With swappiness at 100, anonymous and file have the same priority.</span>
<span class="cm">	 * This scanning priority is essentially the inverse of IO cost.</span>
<span class="cm">	 */</span>
	<span class="n">anon_prio</span> <span class="o">=</span> <span class="n">vmscan_swappiness</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="n">file_prio</span> <span class="o">=</span> <span class="mi">200</span> <span class="o">-</span> <span class="n">anon_prio</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * OK, so we have swap space and a fair amount of page cache</span>
<span class="cm">	 * pages.  We use the recently rotated / recently scanned</span>
<span class="cm">	 * ratios to determine how valuable each cache is.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Because workloads change over time (and to avoid overflow)</span>
<span class="cm">	 * we keep these statistics as a floating average, which ends</span>
<span class="cm">	 * up weighing recent references more than old ones.</span>
<span class="cm">	 *</span>
<span class="cm">	 * anon in [0], file in [1]</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lru_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">reclaim_stat</span><span class="o">-&gt;</span><span class="n">recent_scanned</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">anon</span> <span class="o">/</span> <span class="mi">4</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">reclaim_stat</span><span class="o">-&gt;</span><span class="n">recent_scanned</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">reclaim_stat</span><span class="o">-&gt;</span><span class="n">recent_rotated</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">reclaim_stat</span><span class="o">-&gt;</span><span class="n">recent_scanned</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">file</span> <span class="o">/</span> <span class="mi">4</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">reclaim_stat</span><span class="o">-&gt;</span><span class="n">recent_scanned</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">reclaim_stat</span><span class="o">-&gt;</span><span class="n">recent_rotated</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The amount of pressure on anon vs file pages is inversely</span>
<span class="cm">	 * proportional to the fraction of recently scanned pages on</span>
<span class="cm">	 * each list that were recently referenced and in active use.</span>
<span class="cm">	 */</span>
	<span class="n">ap</span> <span class="o">=</span> <span class="n">anon_prio</span> <span class="o">*</span> <span class="p">(</span><span class="n">reclaim_stat</span><span class="o">-&gt;</span><span class="n">recent_scanned</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">ap</span> <span class="o">/=</span> <span class="n">reclaim_stat</span><span class="o">-&gt;</span><span class="n">recent_rotated</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">fp</span> <span class="o">=</span> <span class="n">file_prio</span> <span class="o">*</span> <span class="p">(</span><span class="n">reclaim_stat</span><span class="o">-&gt;</span><span class="n">recent_scanned</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">fp</span> <span class="o">/=</span> <span class="n">reclaim_stat</span><span class="o">-&gt;</span><span class="n">recent_rotated</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lru_lock</span><span class="p">);</span>

	<span class="n">fraction</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ap</span><span class="p">;</span>
	<span class="n">fraction</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
	<span class="n">denominator</span> <span class="o">=</span> <span class="n">ap</span> <span class="o">+</span> <span class="n">fp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">for_each_evictable_lru</span><span class="p">(</span><span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">file</span> <span class="o">=</span> <span class="n">is_file_lru</span><span class="p">(</span><span class="n">lru</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">scan</span><span class="p">;</span>

		<span class="n">scan</span> <span class="o">=</span> <span class="n">get_lru_size</span><span class="p">(</span><span class="n">lruvec</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">||</span> <span class="n">noswap</span> <span class="o">||</span> <span class="o">!</span><span class="n">vmscan_swappiness</span><span class="p">(</span><span class="n">sc</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">scan</span> <span class="o">&gt;&gt;=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scan</span> <span class="o">&amp;&amp;</span> <span class="n">force_scan</span><span class="p">)</span>
				<span class="n">scan</span> <span class="o">=</span> <span class="n">SWAP_CLUSTER_MAX</span><span class="p">;</span>
			<span class="n">scan</span> <span class="o">=</span> <span class="n">div64_u64</span><span class="p">(</span><span class="n">scan</span> <span class="o">*</span> <span class="n">fraction</span><span class="p">[</span><span class="n">file</span><span class="p">],</span> <span class="n">denominator</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">nr</span><span class="p">[</span><span class="n">lru</span><span class="p">]</span> <span class="o">=</span> <span class="n">scan</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Use reclaim/compaction for costly allocs or under memory pressure */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">in_reclaim_compaction</span><span class="p">(</span><span class="k">struct</span> <span class="n">scan_control</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">COMPACTION_BUILD</span> <span class="o">&amp;&amp;</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">order</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">order</span> <span class="o">&gt;</span> <span class="n">PAGE_ALLOC_COSTLY_ORDER</span> <span class="o">||</span>
			 <span class="n">sc</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">&lt;</span> <span class="n">DEF_PRIORITY</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Reclaim/compaction is used for high-order allocation requests. It reclaims</span>
<span class="cm"> * order-0 pages before compacting the zone. should_continue_reclaim() returns</span>
<span class="cm"> * true if more pages should be reclaimed such that when the page allocator</span>
<span class="cm"> * calls try_to_compact_zone() that it will have enough free pages to succeed.</span>
<span class="cm"> * It will give up earlier than that if there is difficulty reclaiming pages.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">should_continue_reclaim</span><span class="p">(</span><span class="k">struct</span> <span class="n">lruvec</span> <span class="o">*</span><span class="n">lruvec</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_reclaimed</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_scanned</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">scan_control</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pages_for_compaction</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">inactive_lru_pages</span><span class="p">;</span>

	<span class="cm">/* If not in reclaim/compaction mode, stop */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_reclaim_compaction</span><span class="p">(</span><span class="n">sc</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Consider stopping depending on scan and reclaim activity */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_REPEAT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * For __GFP_REPEAT allocations, stop reclaiming if the</span>
<span class="cm">		 * full LRU list has been scanned and we are still failing</span>
<span class="cm">		 * to reclaim pages. This full LRU scan is potentially</span>
<span class="cm">		 * expensive but a __GFP_REPEAT caller really wants to succeed</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nr_reclaimed</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">nr_scanned</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * For non-__GFP_REPEAT allocations which can presumably</span>
<span class="cm">		 * fail without consequence, stop if we failed to reclaim</span>
<span class="cm">		 * any pages from the last SWAP_CLUSTER_MAX number of</span>
<span class="cm">		 * pages that were scanned. This will return to the</span>
<span class="cm">		 * caller faster at the risk reclaim/compaction and</span>
<span class="cm">		 * the resulting allocation attempt fails</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nr_reclaimed</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we have not reclaimed enough pages for compaction and the</span>
<span class="cm">	 * inactive lists are large enough, continue reclaiming</span>
<span class="cm">	 */</span>
	<span class="n">pages_for_compaction</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2UL</span> <span class="o">&lt;&lt;</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">order</span><span class="p">);</span>
	<span class="n">inactive_lru_pages</span> <span class="o">=</span> <span class="n">get_lru_size</span><span class="p">(</span><span class="n">lruvec</span><span class="p">,</span> <span class="n">LRU_INACTIVE_FILE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_swap_pages</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">inactive_lru_pages</span> <span class="o">+=</span> <span class="n">get_lru_size</span><span class="p">(</span><span class="n">lruvec</span><span class="p">,</span> <span class="n">LRU_INACTIVE_ANON</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">nr_reclaimed</span> <span class="o">&lt;</span> <span class="n">pages_for_compaction</span> <span class="o">&amp;&amp;</span>
			<span class="n">inactive_lru_pages</span> <span class="o">&gt;</span> <span class="n">pages_for_compaction</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* If compaction would go ahead or the allocation would succeed, stop */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">compaction_suitable</span><span class="p">(</span><span class="n">lruvec_zone</span><span class="p">(</span><span class="n">lruvec</span><span class="p">),</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">order</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">COMPACT_PARTIAL</span>:
	<span class="k">case</span> <span class="n">COMPACT_CONTINUE</span>:
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is a basic per-zone page freer.  Used by both kswapd and direct reclaim.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">shrink_lruvec</span><span class="p">(</span><span class="k">struct</span> <span class="n">lruvec</span> <span class="o">*</span><span class="n">lruvec</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scan_control</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">[</span><span class="n">NR_LRU_LISTS</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_to_scan</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">lru_list</span> <span class="n">lru</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_reclaimed</span><span class="p">,</span> <span class="n">nr_scanned</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_to_reclaim</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">nr_to_reclaim</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">blk_plug</span> <span class="n">plug</span><span class="p">;</span>

<span class="nl">restart:</span>
	<span class="n">nr_reclaimed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">nr_scanned</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">nr_scanned</span><span class="p">;</span>
	<span class="n">get_scan_count</span><span class="p">(</span><span class="n">lruvec</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>

	<span class="n">blk_start_plug</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plug</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">nr</span><span class="p">[</span><span class="n">LRU_INACTIVE_ANON</span><span class="p">]</span> <span class="o">||</span> <span class="n">nr</span><span class="p">[</span><span class="n">LRU_ACTIVE_FILE</span><span class="p">]</span> <span class="o">||</span>
					<span class="n">nr</span><span class="p">[</span><span class="n">LRU_INACTIVE_FILE</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">for_each_evictable_lru</span><span class="p">(</span><span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nr</span><span class="p">[</span><span class="n">lru</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">nr_to_scan</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span>
						   <span class="n">nr</span><span class="p">[</span><span class="n">lru</span><span class="p">],</span> <span class="n">SWAP_CLUSTER_MAX</span><span class="p">);</span>
				<span class="n">nr</span><span class="p">[</span><span class="n">lru</span><span class="p">]</span> <span class="o">-=</span> <span class="n">nr_to_scan</span><span class="p">;</span>

				<span class="n">nr_reclaimed</span> <span class="o">+=</span> <span class="n">shrink_list</span><span class="p">(</span><span class="n">lru</span><span class="p">,</span> <span class="n">nr_to_scan</span><span class="p">,</span>
							    <span class="n">lruvec</span><span class="p">,</span> <span class="n">sc</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * On large memory systems, scan &gt;&gt; priority can become</span>
<span class="cm">		 * really large. This is fine for the starting priority;</span>
<span class="cm">		 * we want to put equal scanning pressure on each zone.</span>
<span class="cm">		 * However, if the VM has a harder time of freeing pages,</span>
<span class="cm">		 * with multiple processes reclaiming pages, the total</span>
<span class="cm">		 * freeing target can get unreasonably large.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr_reclaimed</span> <span class="o">&gt;=</span> <span class="n">nr_to_reclaim</span> <span class="o">&amp;&amp;</span>
		    <span class="n">sc</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">&lt;</span> <span class="n">DEF_PRIORITY</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">blk_finish_plug</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plug</span><span class="p">);</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">nr_reclaimed</span> <span class="o">+=</span> <span class="n">nr_reclaimed</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Even if we did not try to evict anon pages at all, we want to</span>
<span class="cm">	 * rebalance the anon lru active/inactive ratio.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inactive_anon_is_low</span><span class="p">(</span><span class="n">lruvec</span><span class="p">))</span>
		<span class="n">shrink_active_list</span><span class="p">(</span><span class="n">SWAP_CLUSTER_MAX</span><span class="p">,</span> <span class="n">lruvec</span><span class="p">,</span>
				   <span class="n">sc</span><span class="p">,</span> <span class="n">LRU_ACTIVE_ANON</span><span class="p">);</span>

	<span class="cm">/* reclaim/compaction might need reclaim to continue */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">should_continue_reclaim</span><span class="p">(</span><span class="n">lruvec</span><span class="p">,</span> <span class="n">nr_reclaimed</span><span class="p">,</span>
				    <span class="n">sc</span><span class="o">-&gt;</span><span class="n">nr_scanned</span> <span class="o">-</span> <span class="n">nr_scanned</span><span class="p">,</span> <span class="n">sc</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>

	<span class="n">throttle_vm_writeout</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">gfp_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">shrink_zone</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scan_control</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">target_mem_cgroup</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_reclaim_cookie</span> <span class="n">reclaim</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">zone</span> <span class="o">=</span> <span class="n">zone</span><span class="p">,</span>
		<span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">;</span>

	<span class="n">memcg</span> <span class="o">=</span> <span class="n">mem_cgroup_iter</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reclaim</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">lruvec</span> <span class="o">*</span><span class="n">lruvec</span> <span class="o">=</span> <span class="n">mem_cgroup_zone_lruvec</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">memcg</span><span class="p">);</span>

		<span class="n">shrink_lruvec</span><span class="p">(</span><span class="n">lruvec</span><span class="p">,</span> <span class="n">sc</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Limit reclaim has historically picked one memcg and</span>
<span class="cm">		 * scanned it with decreasing priority levels until</span>
<span class="cm">		 * nr_to_reclaim had been reclaimed.  This priority</span>
<span class="cm">		 * cycle is thus over after a single memcg.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Direct reclaim and kswapd, on the other hand, have</span>
<span class="cm">		 * to scan all memory cgroups to fulfill the overall</span>
<span class="cm">		 * scan target for the zone.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">global_reclaim</span><span class="p">(</span><span class="n">sc</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mem_cgroup_iter_break</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">memcg</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">memcg</span> <span class="o">=</span> <span class="n">mem_cgroup_iter</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">memcg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reclaim</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Returns true if compaction should go ahead for a high-order request */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">compaction_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scan_control</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">balance_gap</span><span class="p">,</span> <span class="n">watermark</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">watermark_ok</span><span class="p">;</span>

	<span class="cm">/* Do not consider compaction for orders reclaim is meant to satisfy */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">order</span> <span class="o">&lt;=</span> <span class="n">PAGE_ALLOC_COSTLY_ORDER</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Compaction takes time to run and there are potentially other</span>
<span class="cm">	 * callers using the pages just freed. Continue reclaiming until</span>
<span class="cm">	 * there is a buffer of free pages available to give compaction</span>
<span class="cm">	 * a reasonable chance of completing and allocating the page</span>
<span class="cm">	 */</span>
	<span class="n">balance_gap</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">low_wmark_pages</span><span class="p">(</span><span class="n">zone</span><span class="p">),</span>
		<span class="p">(</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">present_pages</span> <span class="o">+</span> <span class="n">KSWAPD_ZONE_BALANCE_GAP_RATIO</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span>
			<span class="n">KSWAPD_ZONE_BALANCE_GAP_RATIO</span><span class="p">);</span>
	<span class="n">watermark</span> <span class="o">=</span> <span class="n">high_wmark_pages</span><span class="p">(</span><span class="n">zone</span><span class="p">)</span> <span class="o">+</span> <span class="n">balance_gap</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2UL</span> <span class="o">&lt;&lt;</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">order</span><span class="p">);</span>
	<span class="n">watermark_ok</span> <span class="o">=</span> <span class="n">zone_watermark_ok_safe</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">watermark</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If compaction is deferred, reclaim up to a point where</span>
<span class="cm">	 * compaction will have a chance of success when re-enabled</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">compaction_deferred</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">order</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">watermark_ok</span><span class="p">;</span>

	<span class="cm">/* If compaction is not ready to start, keep reclaiming */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">compaction_suitable</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">order</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">watermark_ok</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is the direct reclaim path, for page-allocating processes.  We only</span>
<span class="cm"> * try to reclaim pages from zones which will satisfy the caller&#39;s allocation</span>
<span class="cm"> * request.</span>
<span class="cm"> *</span>
<span class="cm"> * We reclaim from a zone even if that zone is over high_wmark_pages(zone).</span>
<span class="cm"> * Because:</span>
<span class="cm"> * a) The caller may be trying to free *extra* pages to satisfy a higher-order</span>
<span class="cm"> *    allocation or</span>
<span class="cm"> * b) The target zone may be at high_wmark_pages(zone) but the lower zones</span>
<span class="cm"> *    must go *over* high_wmark_pages(zone) to satisfy the `incremental min&#39;</span>
<span class="cm"> *    zone defense algorithm.</span>
<span class="cm"> *</span>
<span class="cm"> * If a zone is deemed to be full of pinned pages then just give it a light</span>
<span class="cm"> * scan then give up on it.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns true if a zone is being reclaimed for a costly</span>
<span class="cm"> * high-order allocation and compaction is ready to begin. This indicates to</span>
<span class="cm"> * the caller that it should consider retrying the allocation instead of</span>
<span class="cm"> * further reclaim.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">shrink_zones</span><span class="p">(</span><span class="k">struct</span> <span class="n">zonelist</span> <span class="o">*</span><span class="n">zonelist</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scan_control</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">zoneref</span> <span class="o">*</span><span class="n">z</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_soft_reclaimed</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_soft_scanned</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">aborted_reclaim</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the number of buffer_heads in the machine exceeds the maximum</span>
<span class="cm">	 * allowed level, force direct reclaim to scan the highmem zone as</span>
<span class="cm">	 * highmem pages could be pinning lowmem pages storing buffer_heads</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_heads_over_limit</span><span class="p">)</span>
		<span class="n">sc</span><span class="o">-&gt;</span><span class="n">gfp_mask</span> <span class="o">|=</span> <span class="n">__GFP_HIGHMEM</span><span class="p">;</span>

	<span class="n">for_each_zone_zonelist_nodemask</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">zonelist</span><span class="p">,</span>
					<span class="n">gfp_zone</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">gfp_mask</span><span class="p">),</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">nodemask</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">populated_zone</span><span class="p">(</span><span class="n">zone</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Take care memory controller reclaiming has small influence</span>
<span class="cm">		 * to global LRU.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">global_reclaim</span><span class="p">(</span><span class="n">sc</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpuset_zone_allowed_hardwall</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">all_unreclaimable</span> <span class="o">&amp;&amp;</span>
					<span class="n">sc</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">!=</span> <span class="n">DEF_PRIORITY</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>	<span class="cm">/* Let kswapd poll it */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">COMPACTION_BUILD</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * If we already have plenty of memory free for</span>
<span class="cm">				 * compaction in this zone, don&#39;t free any more.</span>
<span class="cm">				 * Even though compaction is invoked for any</span>
<span class="cm">				 * non-zero order, only frequent costly order</span>
<span class="cm">				 * reclamation is disruptive enough to become a</span>
<span class="cm">				 * noticeable problem, like transparent huge</span>
<span class="cm">				 * page allocations.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">compaction_ready</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">sc</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">aborted_reclaim</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * This steals pages from memory cgroups over softlimit</span>
<span class="cm">			 * and returns the number of reclaimed pages and</span>
<span class="cm">			 * scanned pages. This works for global memory pressure</span>
<span class="cm">			 * and balancing, not for a memcg&#39;s limit.</span>
<span class="cm">			 */</span>
			<span class="n">nr_soft_scanned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">nr_soft_reclaimed</span> <span class="o">=</span> <span class="n">mem_cgroup_soft_limit_reclaim</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span>
						<span class="n">sc</span><span class="o">-&gt;</span><span class="n">order</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">gfp_mask</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">nr_soft_scanned</span><span class="p">);</span>
			<span class="n">sc</span><span class="o">-&gt;</span><span class="n">nr_reclaimed</span> <span class="o">+=</span> <span class="n">nr_soft_reclaimed</span><span class="p">;</span>
			<span class="n">sc</span><span class="o">-&gt;</span><span class="n">nr_scanned</span> <span class="o">+=</span> <span class="n">nr_soft_scanned</span><span class="p">;</span>
			<span class="cm">/* need some check for avoid more shrink_zone() */</span>
		<span class="p">}</span>

		<span class="n">shrink_zone</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">sc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">aborted_reclaim</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">zone_reclaimable</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">zone</span><span class="o">-&gt;</span><span class="n">pages_scanned</span> <span class="o">&lt;</span> <span class="n">zone_reclaimable_pages</span><span class="p">(</span><span class="n">zone</span><span class="p">)</span> <span class="o">*</span> <span class="mi">6</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* All zones in zonelist are unreclaimable? */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">all_unreclaimable</span><span class="p">(</span><span class="k">struct</span> <span class="n">zonelist</span> <span class="o">*</span><span class="n">zonelist</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">scan_control</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">zoneref</span> <span class="o">*</span><span class="n">z</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">;</span>

	<span class="n">for_each_zone_zonelist_nodemask</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">zonelist</span><span class="p">,</span>
			<span class="n">gfp_zone</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">gfp_mask</span><span class="p">),</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">nodemask</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">populated_zone</span><span class="p">(</span><span class="n">zone</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpuset_zone_allowed_hardwall</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">all_unreclaimable</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is the main entry point to direct page reclaim.</span>
<span class="cm"> *</span>
<span class="cm"> * If a full scan of the inactive list fails to free enough memory then we</span>
<span class="cm"> * are &quot;out of memory&quot; and something needs to be killed.</span>
<span class="cm"> *</span>
<span class="cm"> * If the caller is !__GFP_FS then the probability of a failure is reasonably</span>
<span class="cm"> * high - the zone may be full of dirty or under-writeback pages, which this</span>
<span class="cm"> * caller can&#39;t do much about.  We kick the writeback threads and take explicit</span>
<span class="cm"> * naps in the hope that some of these pages can be written.  But if the</span>
<span class="cm"> * allocating task holds filesystem locks which prevent writeout this might not</span>
<span class="cm"> * work, and the allocation attempt will fail.</span>
<span class="cm"> *</span>
<span class="cm"> * returns:	0, if no pages reclaimed</span>
<span class="cm"> * 		else, the number of pages reclaimed</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">do_try_to_free_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">zonelist</span> <span class="o">*</span><span class="n">zonelist</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">scan_control</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">shrink_control</span> <span class="o">*</span><span class="n">shrink</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total_scanned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reclaim_state</span> <span class="o">*</span><span class="n">reclaim_state</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">reclaim_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zoneref</span> <span class="o">*</span><span class="n">z</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">writeback_threshold</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">aborted_reclaim</span><span class="p">;</span>

	<span class="n">delayacct_freepages_start</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">global_reclaim</span><span class="p">(</span><span class="n">sc</span><span class="p">))</span>
		<span class="n">count_vm_event</span><span class="p">(</span><span class="n">ALLOCSTALL</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">sc</span><span class="o">-&gt;</span><span class="n">nr_scanned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">aborted_reclaim</span> <span class="o">=</span> <span class="n">shrink_zones</span><span class="p">(</span><span class="n">zonelist</span><span class="p">,</span> <span class="n">sc</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Don&#39;t shrink slabs when reclaiming memory from</span>
<span class="cm">		 * over limit cgroups</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">global_reclaim</span><span class="p">(</span><span class="n">sc</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lru_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">for_each_zone_zonelist</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">zonelist</span><span class="p">,</span>
					<span class="n">gfp_zone</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">gfp_mask</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpuset_zone_allowed_hardwall</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
					<span class="k">continue</span><span class="p">;</span>

				<span class="n">lru_pages</span> <span class="o">+=</span> <span class="n">zone_reclaimable_pages</span><span class="p">(</span><span class="n">zone</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">shrink_slab</span><span class="p">(</span><span class="n">shrink</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">nr_scanned</span><span class="p">,</span> <span class="n">lru_pages</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">reclaim_state</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sc</span><span class="o">-&gt;</span><span class="n">nr_reclaimed</span> <span class="o">+=</span> <span class="n">reclaim_state</span><span class="o">-&gt;</span><span class="n">reclaimed_slab</span><span class="p">;</span>
				<span class="n">reclaim_state</span><span class="o">-&gt;</span><span class="n">reclaimed_slab</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">total_scanned</span> <span class="o">+=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">nr_scanned</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">nr_reclaimed</span> <span class="o">&gt;=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">nr_to_reclaim</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Try to write back as many pages as we just scanned.  This</span>
<span class="cm">		 * tends to cause slow streaming writers to write data to the</span>
<span class="cm">		 * disk smoothly, at the dirtying rate, which is nice.   But</span>
<span class="cm">		 * that&#39;s undesirable in laptop mode, where we *want* lumpy</span>
<span class="cm">		 * writeout.  So in laptop mode, write out the whole world.</span>
<span class="cm">		 */</span>
		<span class="n">writeback_threshold</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">nr_to_reclaim</span> <span class="o">+</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">nr_to_reclaim</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">total_scanned</span> <span class="o">&gt;</span> <span class="n">writeback_threshold</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wakeup_flusher_threads</span><span class="p">(</span><span class="n">laptop_mode</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">total_scanned</span><span class="p">,</span>
						<span class="n">WB_REASON_TRY_TO_FREE_PAGES</span><span class="p">);</span>
			<span class="n">sc</span><span class="o">-&gt;</span><span class="n">may_writepage</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Take a nap, wait for some writeback to complete */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">hibernation_mode</span> <span class="o">&amp;&amp;</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">nr_scanned</span> <span class="o">&amp;&amp;</span>
		    <span class="n">sc</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">&lt;</span> <span class="n">DEF_PRIORITY</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">preferred_zone</span><span class="p">;</span>

			<span class="n">first_zones_zonelist</span><span class="p">(</span><span class="n">zonelist</span><span class="p">,</span> <span class="n">gfp_zone</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">gfp_mask</span><span class="p">),</span>
						<span class="o">&amp;</span><span class="n">cpuset_current_mems_allowed</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">preferred_zone</span><span class="p">);</span>
			<span class="n">wait_iff_congested</span><span class="p">(</span><span class="n">preferred_zone</span><span class="p">,</span> <span class="n">BLK_RW_ASYNC</span><span class="p">,</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">10</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">delayacct_freepages_end</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">nr_reclaimed</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">nr_reclaimed</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * As hibernation is going on, kswapd is freezed so that it can&#39;t mark</span>
<span class="cm">	 * the zone into all_unreclaimable. Thus bypassing all_unreclaimable</span>
<span class="cm">	 * check.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oom_killer_disabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Aborted reclaim to try compaction? don&#39;t OOM, then */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">aborted_reclaim</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* top priority shrink_zones still had more to do? don&#39;t OOM, then */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">global_reclaim</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">all_unreclaimable</span><span class="p">(</span><span class="n">zonelist</span><span class="p">,</span> <span class="n">sc</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">try_to_free_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">zonelist</span> <span class="o">*</span><span class="n">zonelist</span><span class="p">,</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span>
				<span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodemask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_reclaimed</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scan_control</span> <span class="n">sc</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">gfp_mask</span> <span class="o">=</span> <span class="n">gfp_mask</span><span class="p">,</span>
		<span class="p">.</span><span class="n">may_writepage</span> <span class="o">=</span> <span class="o">!</span><span class="n">laptop_mode</span><span class="p">,</span>
		<span class="p">.</span><span class="n">nr_to_reclaim</span> <span class="o">=</span> <span class="n">SWAP_CLUSTER_MAX</span><span class="p">,</span>
		<span class="p">.</span><span class="n">may_unmap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">may_swap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">,</span>
		<span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">DEF_PRIORITY</span><span class="p">,</span>
		<span class="p">.</span><span class="n">target_mem_cgroup</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
		<span class="p">.</span><span class="n">nodemask</span> <span class="o">=</span> <span class="n">nodemask</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">shrink_control</span> <span class="n">shrink</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">gfp_mask</span> <span class="o">=</span> <span class="n">sc</span><span class="p">.</span><span class="n">gfp_mask</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="n">trace_mm_vmscan_direct_reclaim_begin</span><span class="p">(</span><span class="n">order</span><span class="p">,</span>
				<span class="n">sc</span><span class="p">.</span><span class="n">may_writepage</span><span class="p">,</span>
				<span class="n">gfp_mask</span><span class="p">);</span>

	<span class="n">nr_reclaimed</span> <span class="o">=</span> <span class="n">do_try_to_free_pages</span><span class="p">(</span><span class="n">zonelist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shrink</span><span class="p">);</span>

	<span class="n">trace_mm_vmscan_direct_reclaim_end</span><span class="p">(</span><span class="n">nr_reclaimed</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">nr_reclaimed</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_CGROUP_MEM_RES_CTLR</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">mem_cgroup_shrink_node_zone</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span>
						<span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">bool</span> <span class="n">noswap</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">nr_scanned</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scan_control</span> <span class="n">sc</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">nr_scanned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">nr_to_reclaim</span> <span class="o">=</span> <span class="n">SWAP_CLUSTER_MAX</span><span class="p">,</span>
		<span class="p">.</span><span class="n">may_writepage</span> <span class="o">=</span> <span class="o">!</span><span class="n">laptop_mode</span><span class="p">,</span>
		<span class="p">.</span><span class="n">may_unmap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">may_swap</span> <span class="o">=</span> <span class="o">!</span><span class="n">noswap</span><span class="p">,</span>
		<span class="p">.</span><span class="n">order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">target_mem_cgroup</span> <span class="o">=</span> <span class="n">memcg</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">lruvec</span> <span class="o">*</span><span class="n">lruvec</span> <span class="o">=</span> <span class="n">mem_cgroup_zone_lruvec</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">memcg</span><span class="p">);</span>

	<span class="n">sc</span><span class="p">.</span><span class="n">gfp_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">GFP_RECLAIM_MASK</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">GFP_HIGHUSER_MOVABLE</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">GFP_RECLAIM_MASK</span><span class="p">);</span>

	<span class="n">trace_mm_vmscan_memcg_softlimit_reclaim_begin</span><span class="p">(</span><span class="n">sc</span><span class="p">.</span><span class="n">order</span><span class="p">,</span>
						      <span class="n">sc</span><span class="p">.</span><span class="n">may_writepage</span><span class="p">,</span>
						      <span class="n">sc</span><span class="p">.</span><span class="n">gfp_mask</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * NOTE: Although we can get the priority field, using it</span>
<span class="cm">	 * here is not a good idea, since it limits the pages we can scan.</span>
<span class="cm">	 * if we don&#39;t reclaim here, the shrink_zone from balance_pgdat</span>
<span class="cm">	 * will pick up pages from other mem cgroup&#39;s as well. We hack</span>
<span class="cm">	 * the priority and make it zero.</span>
<span class="cm">	 */</span>
	<span class="n">shrink_lruvec</span><span class="p">(</span><span class="n">lruvec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="p">);</span>

	<span class="n">trace_mm_vmscan_memcg_softlimit_reclaim_end</span><span class="p">(</span><span class="n">sc</span><span class="p">.</span><span class="n">nr_reclaimed</span><span class="p">);</span>

	<span class="o">*</span><span class="n">nr_scanned</span> <span class="o">=</span> <span class="n">sc</span><span class="p">.</span><span class="n">nr_scanned</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sc</span><span class="p">.</span><span class="n">nr_reclaimed</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">try_to_free_mem_cgroup_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span>
					   <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span>
					   <span class="n">bool</span> <span class="n">noswap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">zonelist</span> <span class="o">*</span><span class="n">zonelist</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_reclaimed</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scan_control</span> <span class="n">sc</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">may_writepage</span> <span class="o">=</span> <span class="o">!</span><span class="n">laptop_mode</span><span class="p">,</span>
		<span class="p">.</span><span class="n">may_unmap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">may_swap</span> <span class="o">=</span> <span class="o">!</span><span class="n">noswap</span><span class="p">,</span>
		<span class="p">.</span><span class="n">nr_to_reclaim</span> <span class="o">=</span> <span class="n">SWAP_CLUSTER_MAX</span><span class="p">,</span>
		<span class="p">.</span><span class="n">order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">DEF_PRIORITY</span><span class="p">,</span>
		<span class="p">.</span><span class="n">target_mem_cgroup</span> <span class="o">=</span> <span class="n">memcg</span><span class="p">,</span>
		<span class="p">.</span><span class="n">nodemask</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="cm">/* we don&#39;t care the placement */</span>
		<span class="p">.</span><span class="n">gfp_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">GFP_RECLAIM_MASK</span><span class="p">)</span> <span class="o">|</span>
				<span class="p">(</span><span class="n">GFP_HIGHUSER_MOVABLE</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">GFP_RECLAIM_MASK</span><span class="p">),</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">shrink_control</span> <span class="n">shrink</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">gfp_mask</span> <span class="o">=</span> <span class="n">sc</span><span class="p">.</span><span class="n">gfp_mask</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="cm">/*</span>
<span class="cm">	 * Unlike direct reclaim via alloc_pages(), memcg&#39;s reclaim doesn&#39;t</span>
<span class="cm">	 * take care of from where we get pages. So the node where we start the</span>
<span class="cm">	 * scan does not need to be the current node.</span>
<span class="cm">	 */</span>
	<span class="n">nid</span> <span class="o">=</span> <span class="n">mem_cgroup_select_victim_node</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>

	<span class="n">zonelist</span> <span class="o">=</span> <span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">node_zonelists</span><span class="p">;</span>

	<span class="n">trace_mm_vmscan_memcg_reclaim_begin</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>
					    <span class="n">sc</span><span class="p">.</span><span class="n">may_writepage</span><span class="p">,</span>
					    <span class="n">sc</span><span class="p">.</span><span class="n">gfp_mask</span><span class="p">);</span>

	<span class="n">nr_reclaimed</span> <span class="o">=</span> <span class="n">do_try_to_free_pages</span><span class="p">(</span><span class="n">zonelist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shrink</span><span class="p">);</span>

	<span class="n">trace_mm_vmscan_memcg_reclaim_end</span><span class="p">(</span><span class="n">nr_reclaimed</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">nr_reclaimed</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">age_active_anon</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scan_control</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">total_swap_pages</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">memcg</span> <span class="o">=</span> <span class="n">mem_cgroup_iter</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">lruvec</span> <span class="o">*</span><span class="n">lruvec</span> <span class="o">=</span> <span class="n">mem_cgroup_zone_lruvec</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">memcg</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">inactive_anon_is_low</span><span class="p">(</span><span class="n">lruvec</span><span class="p">))</span>
			<span class="n">shrink_active_list</span><span class="p">(</span><span class="n">SWAP_CLUSTER_MAX</span><span class="p">,</span> <span class="n">lruvec</span><span class="p">,</span>
					   <span class="n">sc</span><span class="p">,</span> <span class="n">LRU_ACTIVE_ANON</span><span class="p">);</span>

		<span class="n">memcg</span> <span class="o">=</span> <span class="n">mem_cgroup_iter</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">memcg</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * pgdat_balanced is used when checking if a node is balanced for high-order</span>
<span class="cm"> * allocations. Only zones that meet watermarks and are in a zone allowed</span>
<span class="cm"> * by the callers classzone_idx are added to balanced_pages. The total of</span>
<span class="cm"> * balanced pages must be at least 25% of the zones allowed by classzone_idx</span>
<span class="cm"> * for the node to be considered balanced. Forcing all zones to be balanced</span>
<span class="cm"> * for high orders can cause excessive reclaim when there are imbalanced zones.</span>
<span class="cm"> * The choice of 25% is due to</span>
<span class="cm"> *   o a 16M DMA zone that is balanced will not balance a zone on any</span>
<span class="cm"> *     reasonable sized machine</span>
<span class="cm"> *   o On all other machines, the top zone must be at least a reasonable</span>
<span class="cm"> *     percentage of the middle zones. For example, on 32-bit x86, highmem</span>
<span class="cm"> *     would need to be at least 256M for it to be balance a whole node.</span>
<span class="cm"> *     Similarly, on x86-64 the Normal zone would need to be at least 1G</span>
<span class="cm"> *     to balance a node on its own. These seemed like reasonable ratios.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">pgdat_balanced</span><span class="p">(</span><span class="n">pg_data_t</span> <span class="o">*</span><span class="n">pgdat</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">balanced_pages</span><span class="p">,</span>
						<span class="kt">int</span> <span class="n">classzone_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">present_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">classzone_idx</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">present_pages</span> <span class="o">+=</span> <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_zones</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">present_pages</span><span class="p">;</span>

	<span class="cm">/* A special case here: if zone has no page, we think it&#39;s balanced */</span>
	<span class="k">return</span> <span class="n">balanced_pages</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">present_pages</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* is kswapd sleeping prematurely? */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">sleeping_prematurely</span><span class="p">(</span><span class="n">pg_data_t</span> <span class="o">*</span><span class="n">pgdat</span><span class="p">,</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span> <span class="kt">long</span> <span class="n">remaining</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">classzone_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">balanced</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">all_zones_ok</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* If a direct reclaimer woke kswapd within HZ/10, it&#39;s premature */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">remaining</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* Check the watermark levels */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">classzone_idx</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span> <span class="o">=</span> <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_zones</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">populated_zone</span><span class="p">(</span><span class="n">zone</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * balance_pgdat() skips over all_unreclaimable after</span>
<span class="cm">		 * DEF_PRIORITY. Effectively, it considers them balanced so</span>
<span class="cm">		 * they must be considered balanced here as well if kswapd</span>
<span class="cm">		 * is to sleep</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">all_unreclaimable</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">balanced</span> <span class="o">+=</span> <span class="n">zone</span><span class="o">-&gt;</span><span class="n">present_pages</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zone_watermark_ok_safe</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">high_wmark_pages</span><span class="p">(</span><span class="n">zone</span><span class="p">),</span>
							<span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">all_zones_ok</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">balanced</span> <span class="o">+=</span> <span class="n">zone</span><span class="o">-&gt;</span><span class="n">present_pages</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * For high-order requests, the balanced zones must contain at least</span>
<span class="cm">	 * 25% of the nodes pages for kswapd to sleep. For order-0, all zones</span>
<span class="cm">	 * must be balanced</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">order</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">!</span><span class="n">pgdat_balanced</span><span class="p">(</span><span class="n">pgdat</span><span class="p">,</span> <span class="n">balanced</span><span class="p">,</span> <span class="n">classzone_idx</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">!</span><span class="n">all_zones_ok</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * For kswapd, balance_pgdat() will work across all this node&#39;s zones until</span>
<span class="cm"> * they are all at high_wmark_pages(zone).</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the final order kswapd was reclaiming at</span>
<span class="cm"> *</span>
<span class="cm"> * There is special handling here for zones which are full of pinned pages.</span>
<span class="cm"> * This can happen if the pages are all mlocked, or if they are all used by</span>
<span class="cm"> * device drivers (say, ZONE_DMA).  Or if they are all in use by hugetlb.</span>
<span class="cm"> * What we do is to detect the case where all pages in the zone have been</span>
<span class="cm"> * scanned twice and there has been zero successful reclaim.  Mark the zone as</span>
<span class="cm"> * dead and from now on, only perform a short scan.  Basically we&#39;re polling</span>
<span class="cm"> * the zone for when the problem goes away.</span>
<span class="cm"> *</span>
<span class="cm"> * kswapd scans the zones in the highmem-&gt;normal-&gt;dma direction.  It skips</span>
<span class="cm"> * zones which have free_pages &gt; high_wmark_pages(zone), but once a zone is</span>
<span class="cm"> * found to have free_pages &lt;= high_wmark_pages(zone), we scan that zone and the</span>
<span class="cm"> * lower zones regardless of the number of free pages in the lower zones. This</span>
<span class="cm"> * interoperates with the page allocator fallback scheme to ensure that aging</span>
<span class="cm"> * of pages is balanced across the zones.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">balance_pgdat</span><span class="p">(</span><span class="n">pg_data_t</span> <span class="o">*</span><span class="n">pgdat</span><span class="p">,</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span>
							<span class="kt">int</span> <span class="o">*</span><span class="n">classzone_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">all_zones_ok</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">balanced</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">end_zone</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* Inclusive.  0 = ZONE_DMA */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total_scanned</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reclaim_state</span> <span class="o">*</span><span class="n">reclaim_state</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">reclaim_state</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_soft_reclaimed</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_soft_scanned</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scan_control</span> <span class="n">sc</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">gfp_mask</span> <span class="o">=</span> <span class="n">GFP_KERNEL</span><span class="p">,</span>
		<span class="p">.</span><span class="n">may_unmap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">may_swap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="cm">/*</span>
<span class="cm">		 * kswapd doesn&#39;t want to be bailed out while reclaim. because</span>
<span class="cm">		 * we want to put equal scanning pressure on each zone.</span>
<span class="cm">		 */</span>
		<span class="p">.</span><span class="n">nr_to_reclaim</span> <span class="o">=</span> <span class="n">ULONG_MAX</span><span class="p">,</span>
		<span class="p">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">,</span>
		<span class="p">.</span><span class="n">target_mem_cgroup</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">shrink_control</span> <span class="n">shrink</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">gfp_mask</span> <span class="o">=</span> <span class="n">sc</span><span class="p">.</span><span class="n">gfp_mask</span><span class="p">,</span>
	<span class="p">};</span>
<span class="nl">loop_again:</span>
	<span class="n">total_scanned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sc</span><span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">DEF_PRIORITY</span><span class="p">;</span>
	<span class="n">sc</span><span class="p">.</span><span class="n">nr_reclaimed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sc</span><span class="p">.</span><span class="n">may_writepage</span> <span class="o">=</span> <span class="o">!</span><span class="n">laptop_mode</span><span class="p">;</span>
	<span class="n">count_vm_event</span><span class="p">(</span><span class="n">PAGEOUTRUN</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lru_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">has_under_min_watermark_zone</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">all_zones_ok</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">balanced</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Scan in the highmem-&gt;dma direction for the highest</span>
<span class="cm">		 * zone which needs scanning</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">nr_zones</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span> <span class="o">=</span> <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_zones</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">populated_zone</span><span class="p">(</span><span class="n">zone</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">all_unreclaimable</span> <span class="o">&amp;&amp;</span>
			    <span class="n">sc</span><span class="p">.</span><span class="n">priority</span> <span class="o">!=</span> <span class="n">DEF_PRIORITY</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Do some background aging of the anon list, to give</span>
<span class="cm">			 * pages a chance to be referenced before reclaiming.</span>
<span class="cm">			 */</span>
			<span class="n">age_active_anon</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * If the number of buffer_heads in the machine</span>
<span class="cm">			 * exceeds the maximum allowed level and this node</span>
<span class="cm">			 * has a highmem zone, force kswapd to reclaim from</span>
<span class="cm">			 * it to relieve lowmem pressure.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">buffer_heads_over_limit</span> <span class="o">&amp;&amp;</span> <span class="n">is_highmem_idx</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">end_zone</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zone_watermark_ok_safe</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span>
					<span class="n">high_wmark_pages</span><span class="p">(</span><span class="n">zone</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">end_zone</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* If balanced, clear the congested flag */</span>
				<span class="n">zone_clear_flag</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">ZONE_CONGESTED</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">end_zone</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span> <span class="o">=</span> <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_zones</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>

			<span class="n">lru_pages</span> <span class="o">+=</span> <span class="n">zone_reclaimable_pages</span><span class="p">(</span><span class="n">zone</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Now scan the zone in the dma-&gt;highmem direction, stopping</span>
<span class="cm">		 * at the last zone which needs scanning.</span>
<span class="cm">		 *</span>
<span class="cm">		 * We do this because the page allocator works in the opposite</span>
<span class="cm">		 * direction.  This prevents the page allocator from allocating</span>
<span class="cm">		 * pages behind kswapd&#39;s direction of progress, which would</span>
<span class="cm">		 * cause too much scanning of the lower zones.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">end_zone</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span> <span class="o">=</span> <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_zones</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">nr_slab</span><span class="p">,</span> <span class="n">testorder</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">balance_gap</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">populated_zone</span><span class="p">(</span><span class="n">zone</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">all_unreclaimable</span> <span class="o">&amp;&amp;</span>
			    <span class="n">sc</span><span class="p">.</span><span class="n">priority</span> <span class="o">!=</span> <span class="n">DEF_PRIORITY</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">sc</span><span class="p">.</span><span class="n">nr_scanned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">nr_soft_scanned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Call soft limit reclaim before calling shrink_zone.</span>
<span class="cm">			 */</span>
			<span class="n">nr_soft_reclaimed</span> <span class="o">=</span> <span class="n">mem_cgroup_soft_limit_reclaim</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span>
							<span class="n">order</span><span class="p">,</span> <span class="n">sc</span><span class="p">.</span><span class="n">gfp_mask</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">nr_soft_scanned</span><span class="p">);</span>
			<span class="n">sc</span><span class="p">.</span><span class="n">nr_reclaimed</span> <span class="o">+=</span> <span class="n">nr_soft_reclaimed</span><span class="p">;</span>
			<span class="n">total_scanned</span> <span class="o">+=</span> <span class="n">nr_soft_scanned</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * We put equal pressure on every zone, unless</span>
<span class="cm">			 * one zone has way too many pages free</span>
<span class="cm">			 * already. The &quot;too many pages&quot; is defined</span>
<span class="cm">			 * as the high wmark plus a &quot;gap&quot; where the</span>
<span class="cm">			 * gap is either the low watermark or 1%</span>
<span class="cm">			 * of the zone, whichever is smaller.</span>
<span class="cm">			 */</span>
			<span class="n">balance_gap</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">low_wmark_pages</span><span class="p">(</span><span class="n">zone</span><span class="p">),</span>
				<span class="p">(</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">present_pages</span> <span class="o">+</span>
					<span class="n">KSWAPD_ZONE_BALANCE_GAP_RATIO</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span>
				<span class="n">KSWAPD_ZONE_BALANCE_GAP_RATIO</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Kswapd reclaims only single pages with compaction</span>
<span class="cm">			 * enabled. Trying too hard to reclaim until contiguous</span>
<span class="cm">			 * free pages have become available can hurt performance</span>
<span class="cm">			 * by evicting too much useful data from memory.</span>
<span class="cm">			 * Do not reclaim more than needed for compaction.</span>
<span class="cm">			 */</span>
			<span class="n">testorder</span> <span class="o">=</span> <span class="n">order</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">COMPACTION_BUILD</span> <span class="o">&amp;&amp;</span> <span class="n">order</span> <span class="o">&amp;&amp;</span>
					<span class="n">compaction_suitable</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span> <span class="o">!=</span>
						<span class="n">COMPACT_SKIPPED</span><span class="p">)</span>
				<span class="n">testorder</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">buffer_heads_over_limit</span> <span class="o">&amp;&amp;</span> <span class="n">is_highmem_idx</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">||</span>
				    <span class="o">!</span><span class="n">zone_watermark_ok_safe</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">testorder</span><span class="p">,</span>
					<span class="n">high_wmark_pages</span><span class="p">(</span><span class="n">zone</span><span class="p">)</span> <span class="o">+</span> <span class="n">balance_gap</span><span class="p">,</span>
					<span class="n">end_zone</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">shrink_zone</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="p">);</span>

				<span class="n">reclaim_state</span><span class="o">-&gt;</span><span class="n">reclaimed_slab</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">nr_slab</span> <span class="o">=</span> <span class="n">shrink_slab</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shrink</span><span class="p">,</span> <span class="n">sc</span><span class="p">.</span><span class="n">nr_scanned</span><span class="p">,</span> <span class="n">lru_pages</span><span class="p">);</span>
				<span class="n">sc</span><span class="p">.</span><span class="n">nr_reclaimed</span> <span class="o">+=</span> <span class="n">reclaim_state</span><span class="o">-&gt;</span><span class="n">reclaimed_slab</span><span class="p">;</span>
				<span class="n">total_scanned</span> <span class="o">+=</span> <span class="n">sc</span><span class="p">.</span><span class="n">nr_scanned</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">nr_slab</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">zone_reclaimable</span><span class="p">(</span><span class="n">zone</span><span class="p">))</span>
					<span class="n">zone</span><span class="o">-&gt;</span><span class="n">all_unreclaimable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * If we&#39;ve done a decent amount of scanning and</span>
<span class="cm">			 * the reclaim ratio is low, start doing writepage</span>
<span class="cm">			 * even in laptop mode</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">total_scanned</span> <span class="o">&gt;</span> <span class="n">SWAP_CLUSTER_MAX</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span>
			    <span class="n">total_scanned</span> <span class="o">&gt;</span> <span class="n">sc</span><span class="p">.</span><span class="n">nr_reclaimed</span> <span class="o">+</span> <span class="n">sc</span><span class="p">.</span><span class="n">nr_reclaimed</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
				<span class="n">sc</span><span class="p">.</span><span class="n">may_writepage</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">all_unreclaimable</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">end_zone</span> <span class="o">&amp;&amp;</span> <span class="n">end_zone</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
					<span class="n">end_zone</span><span class="o">--</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zone_watermark_ok_safe</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">testorder</span><span class="p">,</span>
					<span class="n">high_wmark_pages</span><span class="p">(</span><span class="n">zone</span><span class="p">),</span> <span class="n">end_zone</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">all_zones_ok</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="cm">/*</span>
<span class="cm">				 * We are still under min water mark.  This</span>
<span class="cm">				 * means that we have a GFP_ATOMIC allocation</span>
<span class="cm">				 * failure risk. Hurry up!</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zone_watermark_ok_safe</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span>
					    <span class="n">min_wmark_pages</span><span class="p">(</span><span class="n">zone</span><span class="p">),</span> <span class="n">end_zone</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
					<span class="n">has_under_min_watermark_zone</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * If a zone reaches its high watermark,</span>
<span class="cm">				 * consider it to be no longer congested. It&#39;s</span>
<span class="cm">				 * possible there are dirty pages backed by</span>
<span class="cm">				 * congested BDIs but as pressure is relieved,</span>
<span class="cm">				 * spectulatively avoid congestion waits</span>
<span class="cm">				 */</span>
				<span class="n">zone_clear_flag</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">ZONE_CONGESTED</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="o">*</span><span class="n">classzone_idx</span><span class="p">)</span>
					<span class="n">balanced</span> <span class="o">+=</span> <span class="n">zone</span><span class="o">-&gt;</span><span class="n">present_pages</span><span class="p">;</span>
			<span class="p">}</span>

		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">all_zones_ok</span> <span class="o">||</span> <span class="p">(</span><span class="n">order</span> <span class="o">&amp;&amp;</span> <span class="n">pgdat_balanced</span><span class="p">(</span><span class="n">pgdat</span><span class="p">,</span> <span class="n">balanced</span><span class="p">,</span> <span class="o">*</span><span class="n">classzone_idx</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>		<span class="cm">/* kswapd: all done */</span>
		<span class="cm">/*</span>
<span class="cm">		 * OK, kswapd is getting into trouble.  Take a nap, then take</span>
<span class="cm">		 * another pass across the zones.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">total_scanned</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sc</span><span class="p">.</span><span class="n">priority</span> <span class="o">&lt;</span> <span class="n">DEF_PRIORITY</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">has_under_min_watermark_zone</span><span class="p">)</span>
				<span class="n">count_vm_event</span><span class="p">(</span><span class="n">KSWAPD_SKIP_CONGESTION_WAIT</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">congestion_wait</span><span class="p">(</span><span class="n">BLK_RW_ASYNC</span><span class="p">,</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">10</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * We do this so kswapd doesn&#39;t build up large priorities for</span>
<span class="cm">		 * example when it is freeing in parallel with allocators. It</span>
<span class="cm">		 * matches the direct reclaim path behaviour in terms of impact</span>
<span class="cm">		 * on zone-&gt;*_priority.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="p">.</span><span class="n">nr_reclaimed</span> <span class="o">&gt;=</span> <span class="n">SWAP_CLUSTER_MAX</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">sc</span><span class="p">.</span><span class="n">priority</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
<span class="nl">out:</span>

	<span class="cm">/*</span>
<span class="cm">	 * order-0: All zones must meet high watermark for a balanced node</span>
<span class="cm">	 * high-order: Balanced zones must make up at least 25% of the node</span>
<span class="cm">	 *             for the node to be balanced</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">all_zones_ok</span> <span class="o">||</span> <span class="p">(</span><span class="n">order</span> <span class="o">&amp;&amp;</span> <span class="n">pgdat_balanced</span><span class="p">(</span><span class="n">pgdat</span><span class="p">,</span> <span class="n">balanced</span><span class="p">,</span> <span class="o">*</span><span class="n">classzone_idx</span><span class="p">))))</span> <span class="p">{</span>
		<span class="n">cond_resched</span><span class="p">();</span>

		<span class="n">try_to_freeze</span><span class="p">();</span>

		<span class="cm">/*</span>
<span class="cm">		 * Fragmentation may mean that the system cannot be</span>
<span class="cm">		 * rebalanced for high-order allocations in all zones.</span>
<span class="cm">		 * At this point, if nr_reclaimed &lt; SWAP_CLUSTER_MAX,</span>
<span class="cm">		 * it means the zones have been fully scanned and are still</span>
<span class="cm">		 * not balanced. For high-order allocations, there is</span>
<span class="cm">		 * little point trying all over again as kswapd may</span>
<span class="cm">		 * infinite loop.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Instead, recheck all watermarks at order-0 as they</span>
<span class="cm">		 * are the most important. If watermarks are ok, kswapd will go</span>
<span class="cm">		 * back to sleep. High-order users can still perform direct</span>
<span class="cm">		 * reclaim if they wish.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="p">.</span><span class="n">nr_reclaimed</span> <span class="o">&lt;</span> <span class="n">SWAP_CLUSTER_MAX</span><span class="p">)</span>
			<span class="n">order</span> <span class="o">=</span> <span class="n">sc</span><span class="p">.</span><span class="n">order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">goto</span> <span class="n">loop_again</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If kswapd was reclaiming at a higher order, it has the option of</span>
<span class="cm">	 * sleeping without all zones being balanced. Before it does, it must</span>
<span class="cm">	 * ensure that the watermarks for order-0 on *all* zones are met and</span>
<span class="cm">	 * that the congestion flags are cleared. The congestion flag must</span>
<span class="cm">	 * be cleared as kswapd is the only mechanism that clears the flag</span>
<span class="cm">	 * and it is potentially going to sleep here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">order</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">zones_need_compaction</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">end_zone</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span> <span class="o">=</span> <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_zones</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">populated_zone</span><span class="p">(</span><span class="n">zone</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">all_unreclaimable</span> <span class="o">&amp;&amp;</span>
			    <span class="n">sc</span><span class="p">.</span><span class="n">priority</span> <span class="o">!=</span> <span class="n">DEF_PRIORITY</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/* Would compaction fail due to lack of free memory? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">COMPACTION_BUILD</span> <span class="o">&amp;&amp;</span>
			    <span class="n">compaction_suitable</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span> <span class="o">==</span> <span class="n">COMPACT_SKIPPED</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">loop_again</span><span class="p">;</span>

			<span class="cm">/* Confirm the zone is balanced for order-0 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zone_watermark_ok</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">high_wmark_pages</span><span class="p">(</span><span class="n">zone</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">order</span> <span class="o">=</span> <span class="n">sc</span><span class="p">.</span><span class="n">order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">loop_again</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Check if the memory needs to be defragmented. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">zone_watermark_ok</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span>
				    <span class="n">low_wmark_pages</span><span class="p">(</span><span class="n">zone</span><span class="p">),</span> <span class="o">*</span><span class="n">classzone_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
				<span class="n">zones_need_compaction</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="cm">/* If balanced, clear the congested flag */</span>
			<span class="n">zone_clear_flag</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">ZONE_CONGESTED</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">zones_need_compaction</span><span class="p">)</span>
			<span class="n">compact_pgdat</span><span class="p">(</span><span class="n">pgdat</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Return the order we were reclaiming at so sleeping_prematurely()</span>
<span class="cm">	 * makes a decision on the order we were last reclaiming at. However,</span>
<span class="cm">	 * if another caller entered the allocator slow path while kswapd</span>
<span class="cm">	 * was awake, order will remain at the higher level</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">classzone_idx</span> <span class="o">=</span> <span class="n">end_zone</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">order</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kswapd_try_to_sleep</span><span class="p">(</span><span class="n">pg_data_t</span> <span class="o">*</span><span class="n">pgdat</span><span class="p">,</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span> <span class="kt">int</span> <span class="n">classzone_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">remaining</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">DEFINE_WAIT</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">freezing</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">||</span> <span class="n">kthread_should_stop</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">prepare_to_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">kswapd_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>

	<span class="cm">/* Try to sleep for a short interval */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sleeping_prematurely</span><span class="p">(</span><span class="n">pgdat</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">remaining</span><span class="p">,</span> <span class="n">classzone_idx</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">remaining</span> <span class="o">=</span> <span class="n">schedule_timeout</span><span class="p">(</span><span class="n">HZ</span><span class="o">/</span><span class="mi">10</span><span class="p">);</span>
		<span class="n">finish_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">kswapd_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
		<span class="n">prepare_to_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">kswapd_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * After a short sleep, check if it was a premature sleep. If not, then</span>
<span class="cm">	 * go fully to sleep until explicitly woken up.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sleeping_prematurely</span><span class="p">(</span><span class="n">pgdat</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">remaining</span><span class="p">,</span> <span class="n">classzone_idx</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">trace_mm_vmscan_kswapd_sleep</span><span class="p">(</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_id</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * vmstat counters are not perfectly accurate and the estimated</span>
<span class="cm">		 * value for counters such as NR_FREE_PAGES can deviate from the</span>
<span class="cm">		 * true value by nr_online_cpus * threshold. To avoid the zone</span>
<span class="cm">		 * watermarks being breached while under pressure, we reduce the</span>
<span class="cm">		 * per-cpu vmstat threshold while kswapd is awake and restore</span>
<span class="cm">		 * them before going back to sleep.</span>
<span class="cm">		 */</span>
		<span class="n">set_pgdat_percpu_threshold</span><span class="p">(</span><span class="n">pgdat</span><span class="p">,</span> <span class="n">calculate_normal_threshold</span><span class="p">);</span>
		<span class="n">schedule</span><span class="p">();</span>
		<span class="n">set_pgdat_percpu_threshold</span><span class="p">(</span><span class="n">pgdat</span><span class="p">,</span> <span class="n">calculate_pressure_threshold</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">remaining</span><span class="p">)</span>
			<span class="n">count_vm_event</span><span class="p">(</span><span class="n">KSWAPD_LOW_WMARK_HIT_QUICKLY</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">count_vm_event</span><span class="p">(</span><span class="n">KSWAPD_HIGH_WMARK_HIT_QUICKLY</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">finish_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">kswapd_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The background pageout daemon, started as a kernel thread</span>
<span class="cm"> * from the init process.</span>
<span class="cm"> *</span>
<span class="cm"> * This basically trickles out pages so that we have _some_</span>
<span class="cm"> * free memory available even if there is no other activity</span>
<span class="cm"> * that frees anything up. This is needed for things like routing</span>
<span class="cm"> * etc, where we otherwise might have all activity going on in</span>
<span class="cm"> * asynchronous contexts that cannot page things out.</span>
<span class="cm"> *</span>
<span class="cm"> * If there are applications that are active memory-allocators</span>
<span class="cm"> * (most normal use), this basically shouldn&#39;t matter.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">kswapd</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">order</span><span class="p">,</span> <span class="n">new_order</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">balanced_order</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">classzone_idx</span><span class="p">,</span> <span class="n">new_classzone_idx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">balanced_classzone_idx</span><span class="p">;</span>
	<span class="n">pg_data_t</span> <span class="o">*</span><span class="n">pgdat</span> <span class="o">=</span> <span class="p">(</span><span class="n">pg_data_t</span><span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">reclaim_state</span> <span class="n">reclaim_state</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">reclaimed_slab</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpumask</span> <span class="o">=</span> <span class="n">cpumask_of_node</span><span class="p">(</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_id</span><span class="p">);</span>

	<span class="n">lockdep_set_current_reclaim_state</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="n">cpumask</span><span class="p">))</span>
		<span class="n">set_cpus_allowed_ptr</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">cpumask</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">reclaim_state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">reclaim_state</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Tell the memory management that we&#39;re a &quot;memory allocator&quot;,</span>
<span class="cm">	 * and that if we need more memory we should get access to it</span>
<span class="cm">	 * regardless (see &quot;__alloc_pages()&quot;). &quot;kswapd&quot; should</span>
<span class="cm">	 * never get caught in the normal page freeing logic.</span>
<span class="cm">	 *</span>
<span class="cm">	 * (Kswapd normally doesn&#39;t need memory anyway, but sometimes</span>
<span class="cm">	 * you need a small amount of memory in order to be able to</span>
<span class="cm">	 * page out something else, and this flag essentially protects</span>
<span class="cm">	 * us from recursively trying to free more memory as we&#39;re</span>
<span class="cm">	 * trying to free the first piece of memory in the first place).</span>
<span class="cm">	 */</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PF_MEMALLOC</span> <span class="o">|</span> <span class="n">PF_SWAPWRITE</span> <span class="o">|</span> <span class="n">PF_KSWAPD</span><span class="p">;</span>
	<span class="n">set_freezable</span><span class="p">();</span>

	<span class="n">order</span> <span class="o">=</span> <span class="n">new_order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">balanced_order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">classzone_idx</span> <span class="o">=</span> <span class="n">new_classzone_idx</span> <span class="o">=</span> <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">nr_zones</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">balanced_classzone_idx</span> <span class="o">=</span> <span class="n">classzone_idx</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If the last balance_pgdat was unsuccessful it&#39;s unlikely a</span>
<span class="cm">		 * new request of a similar or harder type will succeed soon</span>
<span class="cm">		 * so consider going to sleep on the basis we reclaimed at</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">balanced_classzone_idx</span> <span class="o">&gt;=</span> <span class="n">new_classzone_idx</span> <span class="o">&amp;&amp;</span>
					<span class="n">balanced_order</span> <span class="o">==</span> <span class="n">new_order</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">new_order</span> <span class="o">=</span> <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">kswapd_max_order</span><span class="p">;</span>
			<span class="n">new_classzone_idx</span> <span class="o">=</span> <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">classzone_idx</span><span class="p">;</span>
			<span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">kswapd_max_order</span> <span class="o">=</span>  <span class="mi">0</span><span class="p">;</span>
			<span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">classzone_idx</span> <span class="o">=</span> <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">nr_zones</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">order</span> <span class="o">&lt;</span> <span class="n">new_order</span> <span class="o">||</span> <span class="n">classzone_idx</span> <span class="o">&gt;</span> <span class="n">new_classzone_idx</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Don&#39;t sleep if someone wants a larger &#39;order&#39;</span>
<span class="cm">			 * allocation or has tigher zone constraints</span>
<span class="cm">			 */</span>
			<span class="n">order</span> <span class="o">=</span> <span class="n">new_order</span><span class="p">;</span>
			<span class="n">classzone_idx</span> <span class="o">=</span> <span class="n">new_classzone_idx</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">kswapd_try_to_sleep</span><span class="p">(</span><span class="n">pgdat</span><span class="p">,</span> <span class="n">balanced_order</span><span class="p">,</span>
						<span class="n">balanced_classzone_idx</span><span class="p">);</span>
			<span class="n">order</span> <span class="o">=</span> <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">kswapd_max_order</span><span class="p">;</span>
			<span class="n">classzone_idx</span> <span class="o">=</span> <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">classzone_idx</span><span class="p">;</span>
			<span class="n">new_order</span> <span class="o">=</span> <span class="n">order</span><span class="p">;</span>
			<span class="n">new_classzone_idx</span> <span class="o">=</span> <span class="n">classzone_idx</span><span class="p">;</span>
			<span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">kswapd_max_order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">classzone_idx</span> <span class="o">=</span> <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">nr_zones</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">try_to_freeze</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kthread_should_stop</span><span class="p">())</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We can speed up thawing tasks if we don&#39;t call balance_pgdat</span>
<span class="cm">		 * after returning from the refrigerator</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">trace_mm_vmscan_kswapd_wake</span><span class="p">(</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_id</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
			<span class="n">balanced_classzone_idx</span> <span class="o">=</span> <span class="n">classzone_idx</span><span class="p">;</span>
			<span class="n">balanced_order</span> <span class="o">=</span> <span class="n">balance_pgdat</span><span class="p">(</span><span class="n">pgdat</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">balanced_classzone_idx</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * A zone is low on free memory, so wake its kswapd task to service it.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">wakeup_kswapd</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span> <span class="k">enum</span> <span class="n">zone_type</span> <span class="n">classzone_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pg_data_t</span> <span class="o">*</span><span class="n">pgdat</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">populated_zone</span><span class="p">(</span><span class="n">zone</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpuset_zone_allowed_hardwall</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">pgdat</span> <span class="o">=</span> <span class="n">zone</span><span class="o">-&gt;</span><span class="n">zone_pgdat</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">kswapd_max_order</span> <span class="o">&lt;</span> <span class="n">order</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">kswapd_max_order</span> <span class="o">=</span> <span class="n">order</span><span class="p">;</span>
		<span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">classzone_idx</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">classzone_idx</span><span class="p">,</span> <span class="n">classzone_idx</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">kswapd_wait</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">zone_watermark_ok_safe</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">low_wmark_pages</span><span class="p">(</span><span class="n">zone</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">trace_mm_vmscan_wakeup_kswapd</span><span class="p">(</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_id</span><span class="p">,</span> <span class="n">zone_idx</span><span class="p">(</span><span class="n">zone</span><span class="p">),</span> <span class="n">order</span><span class="p">);</span>
	<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">kswapd_wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The reclaimable count would be mostly accurate.</span>
<span class="cm"> * The less reclaimable pages may be</span>
<span class="cm"> * - mlocked pages, which will be moved to unevictable list when encountered</span>
<span class="cm"> * - mapped pages, which may require several travels to be reclaimed</span>
<span class="cm"> * - dirty pages, which is not &quot;instantly&quot; reclaimable</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">global_reclaimable_pages</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nr</span><span class="p">;</span>

	<span class="n">nr</span> <span class="o">=</span> <span class="n">global_page_state</span><span class="p">(</span><span class="n">NR_ACTIVE_FILE</span><span class="p">)</span> <span class="o">+</span>
	     <span class="n">global_page_state</span><span class="p">(</span><span class="n">NR_INACTIVE_FILE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr_swap_pages</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">nr</span> <span class="o">+=</span> <span class="n">global_page_state</span><span class="p">(</span><span class="n">NR_ACTIVE_ANON</span><span class="p">)</span> <span class="o">+</span>
		      <span class="n">global_page_state</span><span class="p">(</span><span class="n">NR_INACTIVE_ANON</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">nr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">zone_reclaimable_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nr</span><span class="p">;</span>

	<span class="n">nr</span> <span class="o">=</span> <span class="n">zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_ACTIVE_FILE</span><span class="p">)</span> <span class="o">+</span>
	     <span class="n">zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_INACTIVE_FILE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr_swap_pages</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">nr</span> <span class="o">+=</span> <span class="n">zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_ACTIVE_ANON</span><span class="p">)</span> <span class="o">+</span>
		      <span class="n">zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_INACTIVE_ANON</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">nr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HIBERNATION</span>
<span class="cm">/*</span>
<span class="cm"> * Try to free `nr_to_reclaim&#39; of memory, system-wide, and return the number of</span>
<span class="cm"> * freed pages.</span>
<span class="cm"> *</span>
<span class="cm"> * Rather than trying to age LRUs the aim is to preserve the overall</span>
<span class="cm"> * LRU order by reclaiming preferentially</span>
<span class="cm"> * inactive &gt; active &gt; active referenced &gt; active mapped</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">shrink_all_memory</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_to_reclaim</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reclaim_state</span> <span class="n">reclaim_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scan_control</span> <span class="n">sc</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">gfp_mask</span> <span class="o">=</span> <span class="n">GFP_HIGHUSER_MOVABLE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">may_swap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">may_unmap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">may_writepage</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">nr_to_reclaim</span> <span class="o">=</span> <span class="n">nr_to_reclaim</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hibernation_mode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">DEF_PRIORITY</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">shrink_control</span> <span class="n">shrink</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">gfp_mask</span> <span class="o">=</span> <span class="n">sc</span><span class="p">.</span><span class="n">gfp_mask</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">zonelist</span> <span class="o">*</span><span class="n">zonelist</span> <span class="o">=</span> <span class="n">node_zonelist</span><span class="p">(</span><span class="n">numa_node_id</span><span class="p">(),</span> <span class="n">sc</span><span class="p">.</span><span class="n">gfp_mask</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_reclaimed</span><span class="p">;</span>

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PF_MEMALLOC</span><span class="p">;</span>
	<span class="n">lockdep_set_current_reclaim_state</span><span class="p">(</span><span class="n">sc</span><span class="p">.</span><span class="n">gfp_mask</span><span class="p">);</span>
	<span class="n">reclaim_state</span><span class="p">.</span><span class="n">reclaimed_slab</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">reclaim_state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">reclaim_state</span><span class="p">;</span>

	<span class="n">nr_reclaimed</span> <span class="o">=</span> <span class="n">do_try_to_free_pages</span><span class="p">(</span><span class="n">zonelist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shrink</span><span class="p">);</span>

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">reclaim_state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">lockdep_clear_current_reclaim_state</span><span class="p">();</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PF_MEMALLOC</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">nr_reclaimed</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HIBERNATION */</span><span class="cp"></span>

<span class="cm">/* It&#39;s optimal to keep kswapds on the same CPUs as their memory, but</span>
<span class="cm">   not required for correctness.  So if the last cpu in a node goes</span>
<span class="cm">   away, we get changed to run anywhere: as the first one comes back,</span>
<span class="cm">   restore their cpu bindings. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">cpu_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nfb</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">==</span> <span class="n">CPU_ONLINE</span> <span class="o">||</span> <span class="n">action</span> <span class="o">==</span> <span class="n">CPU_ONLINE_FROZEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">for_each_node_state</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">N_HIGH_MEMORY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pg_data_t</span> <span class="o">*</span><span class="n">pgdat</span> <span class="o">=</span> <span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">);</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">;</span>

			<span class="n">mask</span> <span class="o">=</span> <span class="n">cpumask_of_node</span><span class="p">(</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_id</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_any_and</span><span class="p">(</span><span class="n">cpu_online_mask</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">nr_cpu_ids</span><span class="p">)</span>
				<span class="cm">/* One of our CPUs online: restore mask */</span>
				<span class="n">set_cpus_allowed_ptr</span><span class="p">(</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">kswapd</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This kswapd start function will be called by init and node-hot-add.</span>
<span class="cm"> * On node-hot-add, kswapd will moved to proper cpus if cpus are hot-added.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">kswapd_run</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pg_data_t</span> <span class="o">*</span><span class="n">pgdat</span> <span class="o">=</span> <span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">kswapd</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">kswapd</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">kswapd</span><span class="p">,</span> <span class="n">pgdat</span><span class="p">,</span> <span class="s">&quot;kswapd%d&quot;</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">kswapd</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* failure at boot is fatal */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">system_state</span> <span class="o">==</span> <span class="n">SYSTEM_BOOTING</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Failed to start kswapd on node %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">nid</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called by memory hotplug when all memory in a node is offlined.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">kswapd_stop</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">kswapd</span> <span class="o">=</span> <span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">kswapd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kswapd</span><span class="p">)</span>
		<span class="n">kthread_stop</span><span class="p">(</span><span class="n">kswapd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">kswapd_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nid</span><span class="p">;</span>

	<span class="n">swap_setup</span><span class="p">();</span>
	<span class="n">for_each_node_state</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">N_HIGH_MEMORY</span><span class="p">)</span>
 		<span class="n">kswapd_run</span><span class="p">(</span><span class="n">nid</span><span class="p">);</span>
	<span class="n">hotcpu_notifier</span><span class="p">(</span><span class="n">cpu_callback</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">kswapd_init</span><span class="p">)</span>

<span class="cp">#ifdef CONFIG_NUMA</span>
<span class="cm">/*</span>
<span class="cm"> * Zone reclaim mode</span>
<span class="cm"> *</span>
<span class="cm"> * If non-zero call zone_reclaim when the number of free pages falls below</span>
<span class="cm"> * the watermarks.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">zone_reclaim_mode</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cp">#define RECLAIM_OFF 0</span>
<span class="cp">#define RECLAIM_ZONE (1&lt;&lt;0)	</span><span class="cm">/* Run shrink_inactive_list on the zone */</span><span class="cp"></span>
<span class="cp">#define RECLAIM_WRITE (1&lt;&lt;1)	</span><span class="cm">/* Writeout pages during reclaim */</span><span class="cp"></span>
<span class="cp">#define RECLAIM_SWAP (1&lt;&lt;2)	</span><span class="cm">/* Swap pages out during reclaim */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Priority for ZONE_RECLAIM. This determines the fraction of pages</span>
<span class="cm"> * of a node considered for each zone_reclaim. 4 scans 1/16th of</span>
<span class="cm"> * a zone.</span>
<span class="cm"> */</span>
<span class="cp">#define ZONE_RECLAIM_PRIORITY 4</span>

<span class="cm">/*</span>
<span class="cm"> * Percentage of pages in a zone that must be unmapped for zone_reclaim to</span>
<span class="cm"> * occur.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">sysctl_min_unmapped_ratio</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * If the number of slab pages in a zone grows beyond this percentage then</span>
<span class="cm"> * slab reclaim needs to occur.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">sysctl_min_slab_ratio</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">zone_unmapped_file_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">file_mapped</span> <span class="o">=</span> <span class="n">zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_FILE_MAPPED</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">file_lru</span> <span class="o">=</span> <span class="n">zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_INACTIVE_FILE</span><span class="p">)</span> <span class="o">+</span>
		<span class="n">zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_ACTIVE_FILE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * It&#39;s possible for there to be more file mapped pages than</span>
<span class="cm">	 * accounted for by the pages on the file LRU lists because</span>
<span class="cm">	 * tmpfs pages accounted for as ANON can also be FILE_MAPPED</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">file_lru</span> <span class="o">&gt;</span> <span class="n">file_mapped</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">file_lru</span> <span class="o">-</span> <span class="n">file_mapped</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Work out how many page cache pages we can reclaim in this reclaim_mode */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">zone_pagecache_reclaimable</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">nr_pagecache_reclaimable</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">delta</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If RECLAIM_SWAP is set, then all file pages are considered</span>
<span class="cm">	 * potentially reclaimable. Otherwise, we have to worry about</span>
<span class="cm">	 * pages like swapcache and zone_unmapped_file_pages() provides</span>
<span class="cm">	 * a better estimate</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">zone_reclaim_mode</span> <span class="o">&amp;</span> <span class="n">RECLAIM_SWAP</span><span class="p">)</span>
		<span class="n">nr_pagecache_reclaimable</span> <span class="o">=</span> <span class="n">zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_FILE_PAGES</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">nr_pagecache_reclaimable</span> <span class="o">=</span> <span class="n">zone_unmapped_file_pages</span><span class="p">(</span><span class="n">zone</span><span class="p">);</span>

	<span class="cm">/* If we can&#39;t clean pages, remove dirty pages from consideration */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">zone_reclaim_mode</span> <span class="o">&amp;</span> <span class="n">RECLAIM_WRITE</span><span class="p">))</span>
		<span class="n">delta</span> <span class="o">+=</span> <span class="n">zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_FILE_DIRTY</span><span class="p">);</span>

	<span class="cm">/* Watch for any possible underflows due to delta */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="n">nr_pagecache_reclaimable</span><span class="p">))</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="n">nr_pagecache_reclaimable</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">nr_pagecache_reclaimable</span> <span class="o">-</span> <span class="n">delta</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Try to free up some pages from this zone through reclaim.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__zone_reclaim</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Minimum pages needed in order to stay on node */</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_pages</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reclaim_state</span> <span class="n">reclaim_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scan_control</span> <span class="n">sc</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">may_writepage</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">zone_reclaim_mode</span> <span class="o">&amp;</span> <span class="n">RECLAIM_WRITE</span><span class="p">),</span>
		<span class="p">.</span><span class="n">may_unmap</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">zone_reclaim_mode</span> <span class="o">&amp;</span> <span class="n">RECLAIM_SWAP</span><span class="p">),</span>
		<span class="p">.</span><span class="n">may_swap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">nr_to_reclaim</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span>
				       <span class="n">SWAP_CLUSTER_MAX</span><span class="p">),</span>
		<span class="p">.</span><span class="n">gfp_mask</span> <span class="o">=</span> <span class="n">gfp_mask</span><span class="p">,</span>
		<span class="p">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">,</span>
		<span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">ZONE_RECLAIM_PRIORITY</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">shrink_control</span> <span class="n">shrink</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">gfp_mask</span> <span class="o">=</span> <span class="n">sc</span><span class="p">.</span><span class="n">gfp_mask</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_slab_pages0</span><span class="p">,</span> <span class="n">nr_slab_pages1</span><span class="p">;</span>

	<span class="n">cond_resched</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * We need to be able to allocate from the reserves for RECLAIM_SWAP</span>
<span class="cm">	 * and we also need to be able to write out pages for RECLAIM_WRITE</span>
<span class="cm">	 * and RECLAIM_SWAP.</span>
<span class="cm">	 */</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PF_MEMALLOC</span> <span class="o">|</span> <span class="n">PF_SWAPWRITE</span><span class="p">;</span>
	<span class="n">lockdep_set_current_reclaim_state</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">);</span>
	<span class="n">reclaim_state</span><span class="p">.</span><span class="n">reclaimed_slab</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">reclaim_state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">reclaim_state</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">zone_pagecache_reclaimable</span><span class="p">(</span><span class="n">zone</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">zone</span><span class="o">-&gt;</span><span class="n">min_unmapped_pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Free memory by calling shrink zone with increasing</span>
<span class="cm">		 * priorities until we have enough memory freed.</span>
<span class="cm">		 */</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">shrink_zone</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">sc</span><span class="p">.</span><span class="n">nr_reclaimed</span> <span class="o">&lt;</span> <span class="n">nr_pages</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">sc</span><span class="p">.</span><span class="n">priority</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">nr_slab_pages0</span> <span class="o">=</span> <span class="n">zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_SLAB_RECLAIMABLE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_slab_pages0</span> <span class="o">&gt;</span> <span class="n">zone</span><span class="o">-&gt;</span><span class="n">min_slab_pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * shrink_slab() does not currently allow us to determine how</span>
<span class="cm">		 * many pages were freed in this zone. So we take the current</span>
<span class="cm">		 * number of slab pages and shake the slab until it is reduced</span>
<span class="cm">		 * by the same nr_pages that we used for reclaiming unmapped</span>
<span class="cm">		 * pages.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Note that shrink_slab will free memory on all zones and may</span>
<span class="cm">		 * take a long time.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lru_pages</span> <span class="o">=</span> <span class="n">zone_reclaimable_pages</span><span class="p">(</span><span class="n">zone</span><span class="p">);</span>

			<span class="cm">/* No reclaimable slab or very low memory pressure */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shrink_slab</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shrink</span><span class="p">,</span> <span class="n">sc</span><span class="p">.</span><span class="n">nr_scanned</span><span class="p">,</span> <span class="n">lru_pages</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="cm">/* Freed enough memory */</span>
			<span class="n">nr_slab_pages1</span> <span class="o">=</span> <span class="n">zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span>
							<span class="n">NR_SLAB_RECLAIMABLE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nr_slab_pages1</span> <span class="o">+</span> <span class="n">nr_pages</span> <span class="o">&lt;=</span> <span class="n">nr_slab_pages0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Update nr_reclaimed by the number of slab pages we</span>
<span class="cm">		 * reclaimed from this zone.</span>
<span class="cm">		 */</span>
		<span class="n">nr_slab_pages1</span> <span class="o">=</span> <span class="n">zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_SLAB_RECLAIMABLE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr_slab_pages1</span> <span class="o">&lt;</span> <span class="n">nr_slab_pages0</span><span class="p">)</span>
			<span class="n">sc</span><span class="p">.</span><span class="n">nr_reclaimed</span> <span class="o">+=</span> <span class="n">nr_slab_pages0</span> <span class="o">-</span> <span class="n">nr_slab_pages1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">reclaim_state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">PF_MEMALLOC</span> <span class="o">|</span> <span class="n">PF_SWAPWRITE</span><span class="p">);</span>
	<span class="n">lockdep_clear_current_reclaim_state</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">sc</span><span class="p">.</span><span class="n">nr_reclaimed</span> <span class="o">&gt;=</span> <span class="n">nr_pages</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">zone_reclaim</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">node_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Zone reclaim reclaims unmapped file backed pages and</span>
<span class="cm">	 * slab pages if we are over the defined limits.</span>
<span class="cm">	 *</span>
<span class="cm">	 * A small portion of unmapped file backed pages is needed for</span>
<span class="cm">	 * file I/O otherwise pages read by file I/O will be immediately</span>
<span class="cm">	 * thrown out if the zone is overallocated. So we do not reclaim</span>
<span class="cm">	 * if less than a specified percentage of the zone is used by</span>
<span class="cm">	 * unmapped file backed pages.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">zone_pagecache_reclaimable</span><span class="p">(</span><span class="n">zone</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">zone</span><span class="o">-&gt;</span><span class="n">min_unmapped_pages</span> <span class="o">&amp;&amp;</span>
	    <span class="n">zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_SLAB_RECLAIMABLE</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">zone</span><span class="o">-&gt;</span><span class="n">min_slab_pages</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ZONE_RECLAIM_FULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">all_unreclaimable</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ZONE_RECLAIM_FULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do not scan if the allocation should not be delayed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_WAIT</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_MEMALLOC</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ZONE_RECLAIM_NOSCAN</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Only run zone reclaim on the local zone or on zones that do not</span>
<span class="cm">	 * have associated processors. This will favor the local processor</span>
<span class="cm">	 * over remote processors and spread off node memory allocations</span>
<span class="cm">	 * as wide as possible.</span>
<span class="cm">	 */</span>
	<span class="n">node_id</span> <span class="o">=</span> <span class="n">zone_to_nid</span><span class="p">(</span><span class="n">zone</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node_state</span><span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">N_CPU</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">node_id</span> <span class="o">!=</span> <span class="n">numa_node_id</span><span class="p">())</span>
		<span class="k">return</span> <span class="n">ZONE_RECLAIM_NOSCAN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">zone_test_and_set_flag</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">ZONE_RECLAIM_LOCKED</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ZONE_RECLAIM_NOSCAN</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__zone_reclaim</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
	<span class="n">zone_clear_flag</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">ZONE_RECLAIM_LOCKED</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">count_vm_event</span><span class="p">(</span><span class="n">PGSCAN_ZONE_RECLAIM_FAILED</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * page_evictable - test whether a page is evictable</span>
<span class="cm"> * @page: the page to test</span>
<span class="cm"> * @vma: the VMA in which the page is or will be mapped, may be NULL</span>
<span class="cm"> *</span>
<span class="cm"> * Test whether page is evictable--i.e., should be placed on active/inactive</span>
<span class="cm"> * lists vs unevictable list.  The vma argument is !NULL when called from the</span>
<span class="cm"> * fault path to determine how to instantate a new page.</span>
<span class="cm"> *</span>
<span class="cm"> * Reasons page might not be evictable:</span>
<span class="cm"> * (1) page&#39;s mapping marked unevictable</span>
<span class="cm"> * (2) page is part of an mlocked VMA</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">page_evictable</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mapping_unevictable</span><span class="p">(</span><span class="n">page_mapping</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PageMlocked</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">vma</span> <span class="o">&amp;&amp;</span> <span class="n">mlocked_vma_newpage</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">page</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SHMEM</span>
<span class="cm">/**</span>
<span class="cm"> * check_move_unevictable_pages - check pages for evictability and move to appropriate zone lru list</span>
<span class="cm"> * @pages:	array of pages to check</span>
<span class="cm"> * @nr_pages:	number of pages to check</span>
<span class="cm"> *</span>
<span class="cm"> * Checks pages for evictability and moves them to the appropriate lru list.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is only used for SysV IPC SHM_UNLOCK.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">check_move_unevictable_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lruvec</span> <span class="o">*</span><span class="n">lruvec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pgscanned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pgrescued</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">pagezone</span><span class="p">;</span>

		<span class="n">pgscanned</span><span class="o">++</span><span class="p">;</span>
		<span class="n">pagezone</span> <span class="o">=</span> <span class="n">page_zone</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pagezone</span> <span class="o">!=</span> <span class="n">zone</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">zone</span><span class="p">)</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lru_lock</span><span class="p">);</span>
			<span class="n">zone</span> <span class="o">=</span> <span class="n">pagezone</span><span class="p">;</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lru_lock</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">lruvec</span> <span class="o">=</span> <span class="n">mem_cgroup_page_lruvec</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">zone</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageLRU</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">PageUnevictable</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">page_evictable</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">enum</span> <span class="n">lru_list</span> <span class="n">lru</span> <span class="o">=</span> <span class="n">page_lru_base_type</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

			<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">PageActive</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
			<span class="n">ClearPageUnevictable</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">del_page_from_lru_list</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">lruvec</span><span class="p">,</span> <span class="n">LRU_UNEVICTABLE</span><span class="p">);</span>
			<span class="n">add_page_to_lru_list</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">lruvec</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>
			<span class="n">pgrescued</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">zone</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__count_vm_events</span><span class="p">(</span><span class="n">UNEVICTABLE_PGRESCUED</span><span class="p">,</span> <span class="n">pgrescued</span><span class="p">);</span>
		<span class="n">__count_vm_events</span><span class="p">(</span><span class="n">UNEVICTABLE_PGSCANNED</span><span class="p">,</span> <span class="n">pgscanned</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lru_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SHMEM */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">warn_scan_unevictable_pages</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk_once</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		    <span class="s">&quot;%s: The scan_unevictable_pages sysctl/node-interface has been &quot;</span>
		    <span class="s">&quot;disabled for lack of a legitimate use case.  If you have &quot;</span>
		    <span class="s">&quot;one, please send an email to linux-mm@kvack.org.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * scan_unevictable_pages [vm] sysctl handler.  On demand re-scan of</span>
<span class="cm"> * all nodes&#39; unevictable lists for evictable pages</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">scan_unevictable_pages</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">scan_unevictable_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
			   <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
			   <span class="kt">size_t</span> <span class="o">*</span><span class="n">length</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">warn_scan_unevictable_pages</span><span class="p">();</span>
	<span class="n">proc_doulongvec_minmax</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>
	<span class="n">scan_unevictable_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NUMA</span>
<span class="cm">/*</span>
<span class="cm"> * per node &#39;scan_unevictable_pages&#39; attribute.  On demand re-scan of</span>
<span class="cm"> * a specified node&#39;s per zone unevictable lists for evictable pages.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">read_scan_unevictable_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
					  <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">warn_scan_unevictable_pages</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>	<span class="cm">/* always zero; should fit... */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">write_scan_unevictable_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
					<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">warn_scan_unevictable_pages</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">scan_unevictable_pages</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
			<span class="n">read_scan_unevictable_node</span><span class="p">,</span>
			<span class="n">write_scan_unevictable_node</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">scan_unevictable_register_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">device_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_scan_unevictable_pages</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">scan_unevictable_unregister_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">device_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_scan_unevictable_pages</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
