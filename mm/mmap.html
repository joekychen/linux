<!DOCTYPE html>
<html><head><title>joekychen/linux » mm › mmap.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>mmap.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * mm/mmap.c</span>
<span class="cm"> *</span>
<span class="cm"> * Written by obz.</span>
<span class="cm"> *</span>
<span class="cm"> * Address space accounting code	&lt;alan@lxorguk.ukuu.org.uk&gt;</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/backing-dev.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/shm.h&gt;</span>
<span class="cp">#include &lt;linux/mman.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/personality.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/hugetlb.h&gt;</span>
<span class="cp">#include &lt;linux/profile.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &lt;linux/mempolicy.h&gt;</span>
<span class="cp">#include &lt;linux/rmap.h&gt;</span>
<span class="cp">#include &lt;linux/mmu_notifier.h&gt;</span>
<span class="cp">#include &lt;linux/perf_event.h&gt;</span>
<span class="cp">#include &lt;linux/audit.h&gt;</span>
<span class="cp">#include &lt;linux/khugepaged.h&gt;</span>
<span class="cp">#include &lt;linux/uprobes.h&gt;</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;asm/tlb.h&gt;</span>
<span class="cp">#include &lt;asm/mmu_context.h&gt;</span>

<span class="cp">#include &quot;internal.h&quot;</span>

<span class="cp">#ifndef arch_mmap_check</span>
<span class="cp">#define arch_mmap_check(addr, len, flags)	(0)</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef arch_rebalance_pgtables</span>
<span class="cp">#define arch_rebalance_pgtables(addr, len)		(addr)</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">unmap_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * WARNING: the debugging will use recursive algorithms so never enable this</span>
<span class="cm"> * unless you know what you are doing.</span>
<span class="cm"> */</span>
<span class="cp">#undef DEBUG_MM_RB</span>

<span class="cm">/* description of effects of mapping type and prot in current implementation.</span>
<span class="cm"> * this is due to the limited x86 page protection hardware.  The expected</span>
<span class="cm"> * behavior is in parens:</span>
<span class="cm"> *</span>
<span class="cm"> * map_type	prot</span>
<span class="cm"> *		PROT_NONE	PROT_READ	PROT_WRITE	PROT_EXEC</span>
<span class="cm"> * MAP_SHARED	r: (no) no	r: (yes) yes	r: (no) yes	r: (no) yes</span>
<span class="cm"> *		w: (no) no	w: (no) no	w: (yes) yes	w: (no) no</span>
<span class="cm"> *		x: (no) no	x: (no) yes	x: (no) yes	x: (yes) yes</span>
<span class="cm"> *		</span>
<span class="cm"> * MAP_PRIVATE	r: (no) no	r: (yes) yes	r: (no) yes	r: (no) yes</span>
<span class="cm"> *		w: (no) no	w: (no) no	w: (copy) copy	w: (no) no</span>
<span class="cm"> *		x: (no) no	x: (no) yes	x: (no) yes	x: (yes) yes</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="n">pgprot_t</span> <span class="n">protection_map</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">__P000</span><span class="p">,</span> <span class="n">__P001</span><span class="p">,</span> <span class="n">__P010</span><span class="p">,</span> <span class="n">__P011</span><span class="p">,</span> <span class="n">__P100</span><span class="p">,</span> <span class="n">__P101</span><span class="p">,</span> <span class="n">__P110</span><span class="p">,</span> <span class="n">__P111</span><span class="p">,</span>
	<span class="n">__S000</span><span class="p">,</span> <span class="n">__S001</span><span class="p">,</span> <span class="n">__S010</span><span class="p">,</span> <span class="n">__S011</span><span class="p">,</span> <span class="n">__S100</span><span class="p">,</span> <span class="n">__S101</span><span class="p">,</span> <span class="n">__S110</span><span class="p">,</span> <span class="n">__S111</span>
<span class="p">};</span>

<span class="n">pgprot_t</span> <span class="nf">vm_get_page_prot</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vm_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__pgprot</span><span class="p">(</span><span class="n">pgprot_val</span><span class="p">(</span><span class="n">protection_map</span><span class="p">[</span><span class="n">vm_flags</span> <span class="o">&amp;</span>
				<span class="p">(</span><span class="n">VM_READ</span><span class="o">|</span><span class="n">VM_WRITE</span><span class="o">|</span><span class="n">VM_EXEC</span><span class="o">|</span><span class="n">VM_SHARED</span><span class="p">)])</span> <span class="o">|</span>
			<span class="n">pgprot_val</span><span class="p">(</span><span class="n">arch_vm_get_page_prot</span><span class="p">(</span><span class="n">vm_flags</span><span class="p">)));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vm_get_page_prot</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">sysctl_overcommit_memory</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="n">OVERCOMMIT_GUESS</span><span class="p">;</span>  <span class="cm">/* heuristic overcommit */</span>
<span class="kt">int</span> <span class="n">sysctl_overcommit_ratio</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>	<span class="cm">/* default is 50% */</span>
<span class="kt">int</span> <span class="n">sysctl_max_map_count</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="n">DEFAULT_MAX_MAP_COUNT</span><span class="p">;</span>
<span class="cm">/*</span>
<span class="cm"> * Make sure vm_committed_as in one cacheline and not cacheline shared with</span>
<span class="cm"> * other variables. It can be updated by several CPUs frequently.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">percpu_counter</span> <span class="n">vm_committed_as</span> <span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Check that a process has enough memory to allocate a new virtual</span>
<span class="cm"> * mapping. 0 means there is enough memory for the allocation to</span>
<span class="cm"> * succeed and -ENOMEM implies there is not.</span>
<span class="cm"> *</span>
<span class="cm"> * We currently support three overcommit policies, which are set via the</span>
<span class="cm"> * vm.overcommit_memory sysctl.  See Documentation/vm/overcommit-accounting</span>
<span class="cm"> *</span>
<span class="cm"> * Strict overcommit modes added 2002 Feb 26 by Alan Cox.</span>
<span class="cm"> * Additional code 2002 Jul 20 by Robert Love.</span>
<span class="cm"> *</span>
<span class="cm"> * cap_sys_admin is 1 if the process has admin privileges, 0 otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> * Note this is a helper function intended to be used by LSMs which</span>
<span class="cm"> * wish to use this logic.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__vm_enough_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">long</span> <span class="n">pages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cap_sys_admin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">free</span><span class="p">,</span> <span class="n">allowed</span><span class="p">;</span>

	<span class="n">vm_acct_memory</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Sometimes we want to use more memory than we have</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_overcommit_memory</span> <span class="o">==</span> <span class="n">OVERCOMMIT_ALWAYS</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_overcommit_memory</span> <span class="o">==</span> <span class="n">OVERCOMMIT_GUESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free</span> <span class="o">=</span> <span class="n">global_page_state</span><span class="p">(</span><span class="n">NR_FREE_PAGES</span><span class="p">);</span>
		<span class="n">free</span> <span class="o">+=</span> <span class="n">global_page_state</span><span class="p">(</span><span class="n">NR_FILE_PAGES</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * shmem pages shouldn&#39;t be counted as free in this</span>
<span class="cm">		 * case, they can&#39;t be purged, only swapped out, and</span>
<span class="cm">		 * that won&#39;t affect the overall amount of available</span>
<span class="cm">		 * memory in the system.</span>
<span class="cm">		 */</span>
		<span class="n">free</span> <span class="o">-=</span> <span class="n">global_page_state</span><span class="p">(</span><span class="n">NR_SHMEM</span><span class="p">);</span>

		<span class="n">free</span> <span class="o">+=</span> <span class="n">nr_swap_pages</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Any slabs which are created with the</span>
<span class="cm">		 * SLAB_RECLAIM_ACCOUNT flag claim to have contents</span>
<span class="cm">		 * which are reclaimable, under pressure.  The dentry</span>
<span class="cm">		 * cache and most inode caches should fall into this</span>
<span class="cm">		 */</span>
		<span class="n">free</span> <span class="o">+=</span> <span class="n">global_page_state</span><span class="p">(</span><span class="n">NR_SLAB_RECLAIMABLE</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Leave reserved pages. The pages are not for anonymous pages.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">free</span> <span class="o">&lt;=</span> <span class="n">totalreserve_pages</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">free</span> <span class="o">-=</span> <span class="n">totalreserve_pages</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Leave the last 3% for root</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cap_sys_admin</span><span class="p">)</span>
			<span class="n">free</span> <span class="o">-=</span> <span class="n">free</span> <span class="o">/</span> <span class="mi">32</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">free</span> <span class="o">&gt;</span> <span class="n">pages</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">allowed</span> <span class="o">=</span> <span class="p">(</span><span class="n">totalram_pages</span> <span class="o">-</span> <span class="n">hugetlb_total_pages</span><span class="p">())</span>
	       	<span class="o">*</span> <span class="n">sysctl_overcommit_ratio</span> <span class="o">/</span> <span class="mi">100</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Leave the last 3% for root</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cap_sys_admin</span><span class="p">)</span>
		<span class="n">allowed</span> <span class="o">-=</span> <span class="n">allowed</span> <span class="o">/</span> <span class="mi">32</span><span class="p">;</span>
	<span class="n">allowed</span> <span class="o">+=</span> <span class="n">total_swap_pages</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t let a single process grow too big:</span>
<span class="cm">	   leave 3% of the size of this process for other processes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="p">)</span>
		<span class="n">allowed</span> <span class="o">-=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">total_vm</span> <span class="o">/</span> <span class="mi">32</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">percpu_counter_read_positive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vm_committed_as</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">allowed</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">error:</span>
	<span class="n">vm_unacct_memory</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Requires inode-&gt;i_mapping-&gt;i_mmap_mutex</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__remove_shared_vm_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_DENYWRITE</span><span class="p">)</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_writecount</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_SHARED</span><span class="p">)</span>
		<span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_writable</span><span class="o">--</span><span class="p">;</span>

	<span class="n">flush_dcache_mmap_lock</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_NONLINEAR</span><span class="p">))</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">shared</span><span class="p">.</span><span class="n">vm_set</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">vma_prio_tree_remove</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap</span><span class="p">);</span>
	<span class="n">flush_dcache_mmap_unlock</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Unlink a file-based vm structure from its prio_tree, to hide</span>
<span class="cm"> * vma from rmap and vmtruncate before freeing its page tables.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">unlink_file_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_mutex</span><span class="p">);</span>
		<span class="n">__remove_shared_vm_struct</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">mapping</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_mutex</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Close a vm structure and free it, returning the next.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="nf">remove_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">;</span>

	<span class="n">might_sleep</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">&amp;&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="o">-&gt;</span><span class="n">close</span><span class="p">)</span>
		<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="o">-&gt;</span><span class="n">close</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fput</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_EXECUTABLE</span><span class="p">)</span>
			<span class="n">removed_exe_file_vma</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mpol_put</span><span class="p">(</span><span class="n">vma_policy</span><span class="p">(</span><span class="n">vma</span><span class="p">));</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">vm_area_cachep</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">do_brk</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">);</span>

<span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">brk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">brk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rlim</span><span class="p">,</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">newbrk</span><span class="p">,</span> <span class="n">oldbrk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">min_brk</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_COMPAT_BRK</span>
	<span class="cm">/*</span>
<span class="cm">	 * CONFIG_COMPAT_BRK can still be overridden by setting</span>
<span class="cm">	 * randomize_va_space to 2, which will still cause mm-&gt;start_brk</span>
<span class="cm">	 * to be arbitrarily shifted</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">brk_randomized</span><span class="p">)</span>
		<span class="n">min_brk</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">start_brk</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">min_brk</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">end_data</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">min_brk</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">start_brk</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">brk</span> <span class="o">&lt;</span> <span class="n">min_brk</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check against rlimit here. If this check is done later after the test</span>
<span class="cm">	 * of oldbrk with newbrk then it can escape the test and let the data</span>
<span class="cm">	 * segment grow beyond its set limit the in case where the limit is</span>
<span class="cm">	 * not page aligned -Ram Gupta</span>
<span class="cm">	 */</span>
	<span class="n">rlim</span> <span class="o">=</span> <span class="n">rlimit</span><span class="p">(</span><span class="n">RLIMIT_DATA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rlim</span> <span class="o">&lt;</span> <span class="n">RLIM_INFINITY</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">brk</span> <span class="o">-</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">start_brk</span><span class="p">)</span> <span class="o">+</span>
			<span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">end_data</span> <span class="o">-</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">start_data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">rlim</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">newbrk</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">brk</span><span class="p">);</span>
	<span class="n">oldbrk</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">brk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oldbrk</span> <span class="o">==</span> <span class="n">newbrk</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">set_brk</span><span class="p">;</span>

	<span class="cm">/* Always allow shrinking brk. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">brk</span> <span class="o">&lt;=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">brk</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">do_munmap</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">newbrk</span><span class="p">,</span> <span class="n">oldbrk</span><span class="o">-</span><span class="n">newbrk</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">set_brk</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check against existing mmap mappings. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">find_vma_intersection</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">oldbrk</span><span class="p">,</span> <span class="n">newbrk</span><span class="o">+</span><span class="n">PAGE_SIZE</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Ok, looks good - let it rip. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">do_brk</span><span class="p">(</span><span class="n">oldbrk</span><span class="p">,</span> <span class="n">newbrk</span><span class="o">-</span><span class="n">oldbrk</span><span class="p">)</span> <span class="o">!=</span> <span class="n">oldbrk</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="nl">set_brk:</span>
	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">brk</span> <span class="o">=</span> <span class="n">brk</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">brk</span><span class="p">;</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef DEBUG_MM_RB</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">browse_rb</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">nd</span><span class="p">,</span> <span class="o">*</span><span class="n">pn</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pend</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">nd</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="n">root</span><span class="p">);</span> <span class="n">nd</span><span class="p">;</span> <span class="n">nd</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">nd</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
		<span class="n">vma</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span><span class="p">,</span> <span class="n">vm_rb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&lt;</span> <span class="n">prev</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;vm_start %lx prev %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span> <span class="n">prev</span><span class="p">),</span> <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&lt;</span> <span class="n">pend</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;vm_start %lx pend %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span> <span class="n">pend</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&gt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;vm_end %lx &lt; vm_start %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">);</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="n">pn</span> <span class="o">=</span> <span class="n">nd</span><span class="p">;</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
		<span class="n">pend</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">nd</span> <span class="o">=</span> <span class="n">pn</span><span class="p">;</span> <span class="n">nd</span><span class="p">;</span> <span class="n">nd</span> <span class="o">=</span> <span class="n">rb_prev</span><span class="p">(</span><span class="n">nd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">j</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;backwards %d, forwards %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">validate_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bug</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">;</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">map_count</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;map_count %d vm_next %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">map_count</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">bug</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">browse_rb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_rb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">map_count</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;map_count %d rb %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">map_count</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">bug</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">bug</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define validate_mm(mm) do { } while (0)</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span>
<span class="n">find_vma_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">**</span><span class="n">pprev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rb_node</span> <span class="o">***</span><span class="n">rb_link</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span> <span class="n">rb_parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span> <span class="n">vma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span> <span class="n">__rb_link</span><span class="p">,</span> <span class="o">*</span> <span class="n">__rb_parent</span><span class="p">,</span> <span class="o">*</span> <span class="n">rb_prev</span><span class="p">;</span>

	<span class="n">__rb_link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_rb</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="n">rb_prev</span> <span class="o">=</span> <span class="n">__rb_parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">vma</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">__rb_link</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma_tmp</span><span class="p">;</span>

		<span class="n">__rb_parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">__rb_link</span><span class="p">;</span>
		<span class="n">vma_tmp</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">__rb_parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span><span class="p">,</span> <span class="n">vm_rb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vma_tmp</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">&gt;</span> <span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vma</span> <span class="o">=</span> <span class="n">vma_tmp</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vma_tmp</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&lt;=</span> <span class="n">addr</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">__rb_link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__rb_parent</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">rb_prev</span> <span class="o">=</span> <span class="n">__rb_parent</span><span class="p">;</span>
			<span class="n">__rb_link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__rb_parent</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">pprev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rb_prev</span><span class="p">)</span>
		<span class="o">*</span><span class="n">pprev</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">rb_prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span><span class="p">,</span> <span class="n">vm_rb</span><span class="p">);</span>
	<span class="o">*</span><span class="n">rb_link</span> <span class="o">=</span> <span class="n">__rb_link</span><span class="p">;</span>
	<span class="o">*</span><span class="n">rb_parent</span> <span class="o">=</span> <span class="n">__rb_parent</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">vma</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__vma_link_rb</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">rb_link</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">rb_parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_rb</span><span class="p">,</span> <span class="n">rb_parent</span><span class="p">,</span> <span class="n">rb_link</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_rb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__vma_link_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>

	<span class="n">file</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_DENYWRITE</span><span class="p">)</span>
			<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_writecount</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_SHARED</span><span class="p">)</span>
			<span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_writable</span><span class="o">++</span><span class="p">;</span>

		<span class="n">flush_dcache_mmap_lock</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_NONLINEAR</span><span class="p">))</span>
			<span class="n">vma_nonlinear_insert</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_nonlinear</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">vma_prio_tree_insert</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap</span><span class="p">);</span>
		<span class="n">flush_dcache_mmap_unlock</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="n">__vma_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">rb_link</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">rb_parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__vma_link_list</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">rb_parent</span><span class="p">);</span>
	<span class="n">__vma_link_rb</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">rb_link</span><span class="p">,</span> <span class="n">rb_parent</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">vma_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">rb_link</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">rb_parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">)</span>
		<span class="n">mapping</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mapping</span><span class="p">)</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_mutex</span><span class="p">);</span>

	<span class="n">__vma_link</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">rb_link</span><span class="p">,</span> <span class="n">rb_parent</span><span class="p">);</span>
	<span class="n">__vma_link_file</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mapping</span><span class="p">)</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_mutex</span><span class="p">);</span>

	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">map_count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">validate_mm</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Helper for vma_adjust() in the split_vma insert case: insert a vma into the</span>
<span class="cm"> * mm&#39;s list and rbtree.  It has already been inserted into the prio_tree.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__insert_vm_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">__vma</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">rb_link</span><span class="p">,</span> <span class="o">*</span><span class="n">rb_parent</span><span class="p">;</span>

	<span class="n">__vma</span> <span class="o">=</span> <span class="n">find_vma_prepare</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span><span class="o">&amp;</span><span class="n">prev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rb_link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rb_parent</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">__vma</span> <span class="o">&amp;&amp;</span> <span class="n">__vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&lt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">);</span>
	<span class="n">__vma_link</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">rb_link</span><span class="p">,</span> <span class="n">rb_parent</span><span class="p">);</span>
	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">map_count</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="n">__vma_unlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">;</span>

	<span class="n">prev</span><span class="o">-&gt;</span><span class="n">vm_next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="p">)</span>
		<span class="n">next</span><span class="o">-&gt;</span><span class="n">vm_prev</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
	<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_rb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_cache</span> <span class="o">==</span> <span class="n">vma</span><span class="p">)</span>
		<span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_cache</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We cannot adjust vm_start, vm_end, vm_pgoff fields of a vma that</span>
<span class="cm"> * is already present in an i_mmap tree without adjusting the tree.</span>
<span class="cm"> * The following helper function should be used when such adjustments</span>
<span class="cm"> * are necessary.  The &quot;insert&quot; vma (if any) is to be inserted</span>
<span class="cm"> * before we drop the necessary locks.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">vma_adjust</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">pgoff</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">insert</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">importer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">prio_tree_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">adjust_next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">remove_next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">insert</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">exporter</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * vma expands, overlapping all the next, and</span>
<span class="cm">			 * perhaps the one after too (mprotect case 6).</span>
<span class="cm">			 */</span>
<span class="nl">again:</span>			<span class="n">remove_next</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">);</span>
			<span class="n">end</span> <span class="o">=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">;</span>
			<span class="n">exporter</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
			<span class="n">importer</span> <span class="o">=</span> <span class="n">vma</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * vma expands, overlapping part of the next:</span>
<span class="cm">			 * mprotect case 5 shifting the boundary up.</span>
<span class="cm">			 */</span>
			<span class="n">adjust_next</span> <span class="o">=</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
			<span class="n">exporter</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
			<span class="n">importer</span> <span class="o">=</span> <span class="n">vma</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * vma shrinks, and !insert tells it&#39;s not</span>
<span class="cm">			 * split_vma inserting another: so it must be</span>
<span class="cm">			 * mprotect case 4 shifting the boundary down.</span>
<span class="cm">			 */</span>
			<span class="n">adjust_next</span> <span class="o">=</span> <span class="o">-</span> <span class="p">((</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">end</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
			<span class="n">exporter</span> <span class="o">=</span> <span class="n">vma</span><span class="p">;</span>
			<span class="n">importer</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Easily overlooked: when mprotect shifts the boundary,</span>
<span class="cm">		 * make sure the expanding vma has anon_vma set if the</span>
<span class="cm">		 * shrinking vma had, to cover any anon pages imported.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">exporter</span> <span class="o">&amp;&amp;</span> <span class="n">exporter</span><span class="o">-&gt;</span><span class="n">anon_vma</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">importer</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">anon_vma_clone</span><span class="p">(</span><span class="n">importer</span><span class="p">,</span> <span class="n">exporter</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="n">importer</span><span class="o">-&gt;</span><span class="n">anon_vma</span> <span class="o">=</span> <span class="n">exporter</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mapping</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_NONLINEAR</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">root</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap</span><span class="p">;</span>
			<span class="n">uprobe_munmap</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">adjust_next</span><span class="p">)</span>
				<span class="n">uprobe_munmap</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span>
							<span class="n">next</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">insert</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Put into prio_tree now, so instantiated pages</span>
<span class="cm">			 * are visible to arm/parisc __flush_dcache_page</span>
<span class="cm">			 * throughout; but we cannot insert into address</span>
<span class="cm">			 * space until vma start or end is updated.</span>
<span class="cm">			 */</span>
			<span class="n">__vma_link_file</span><span class="p">(</span><span class="n">insert</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">vma_adjust_trans_huge</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">adjust_next</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * When changing only vma-&gt;vm_end, we don&#39;t really need anon_vma</span>
<span class="cm">	 * lock. This is a fairly rare case by itself, but the anon_vma</span>
<span class="cm">	 * lock may be shared between many sibling processes.  Skipping</span>
<span class="cm">	 * the lock for brk adjustments makes a difference sometimes.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">importer</span> <span class="o">||</span> <span class="n">start</span> <span class="o">!=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">anon_vma</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">;</span>
		<span class="n">anon_vma_lock</span><span class="p">(</span><span class="n">anon_vma</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flush_dcache_mmap_lock</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
		<span class="n">vma_prio_tree_remove</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adjust_next</span><span class="p">)</span>
			<span class="n">vma_prio_tree_remove</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">=</span> <span class="n">pgoff</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adjust_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">next</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">+=</span> <span class="n">adjust_next</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="n">next</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">+=</span> <span class="n">adjust_next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adjust_next</span><span class="p">)</span>
			<span class="n">vma_prio_tree_insert</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
		<span class="n">vma_prio_tree_insert</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
		<span class="n">flush_dcache_mmap_unlock</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">remove_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * vma_merge has merged next into vma, and needs</span>
<span class="cm">		 * us to remove next before dropping the locks.</span>
<span class="cm">		 */</span>
		<span class="n">__vma_unlink</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="p">)</span>
			<span class="n">__remove_shared_vm_struct</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">mapping</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">insert</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * split_vma has split insert from vma, and needs</span>
<span class="cm">		 * us to insert it before dropping the locks</span>
<span class="cm">		 * (it may either follow vma or precede it).</span>
<span class="cm">		 */</span>
		<span class="n">__insert_vm_struct</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">insert</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">anon_vma</span><span class="p">)</span>
		<span class="n">anon_vma_unlock</span><span class="p">(</span><span class="n">anon_vma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mapping</span><span class="p">)</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uprobe_mmap</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">adjust_next</span><span class="p">)</span>
			<span class="n">uprobe_mmap</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">remove_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">uprobe_munmap</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">);</span>
			<span class="n">fput</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_EXECUTABLE</span><span class="p">)</span>
				<span class="n">removed_exe_file_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">)</span>
			<span class="n">anon_vma_merge</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
		<span class="n">mm</span><span class="o">-&gt;</span><span class="n">map_count</span><span class="o">--</span><span class="p">;</span>
		<span class="n">mpol_put</span><span class="p">(</span><span class="n">vma_policy</span><span class="p">(</span><span class="n">next</span><span class="p">));</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">vm_area_cachep</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * In mprotect&#39;s case 6 (see comments on vma_merge),</span>
<span class="cm">		 * we must remove another next too. It would clutter</span>
<span class="cm">		 * up the code too much to do both in one go.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">remove_next</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">next</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">insert</span> <span class="o">&amp;&amp;</span> <span class="n">file</span><span class="p">)</span>
		<span class="n">uprobe_mmap</span><span class="p">(</span><span class="n">insert</span><span class="p">);</span>

	<span class="n">validate_mm</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If the vma has a -&gt;close operation then the driver probably needs to release</span>
<span class="cm"> * per-vma resources, so we don&#39;t attempt to merge those.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">is_mergeable_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vm_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* VM_CAN_NONLINEAR may get set later by f_op-&gt;mmap() */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">^</span> <span class="n">vm_flags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">VM_CAN_NONLINEAR</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span> <span class="o">!=</span> <span class="n">file</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">&amp;&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="o">-&gt;</span><span class="n">close</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">is_mergeable_anon_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma1</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma2</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The list_is_singular() test is to avoid merging VMA cloned from</span>
<span class="cm">	 * parents. This can improve scalability caused by anon_vma lock.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">anon_vma1</span> <span class="o">||</span> <span class="o">!</span><span class="n">anon_vma2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span> <span class="o">||</span>
		<span class="n">list_is_singular</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma_chain</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">anon_vma1</span> <span class="o">==</span> <span class="n">anon_vma2</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return true if we can merge this (vm_flags,anon_vma,file,vm_pgoff)</span>
<span class="cm"> * in front of (at a lower virtual address and file offset than) the vma.</span>
<span class="cm"> *</span>
<span class="cm"> * We cannot merge two vmas if they have differently assigned (non-NULL)</span>
<span class="cm"> * anon_vmas, nor if same anon_vma is assigned but offsets incompatible.</span>
<span class="cm"> *</span>
<span class="cm"> * We don&#39;t check here for the merged mmap wrapping around the end of pagecache</span>
<span class="cm"> * indices (16TB on ia32) because do_mmap_pgoff() does not permit mmap&#39;s which</span>
<span class="cm"> * wrap, nor mmaps which cover the final page at index -1UL.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="n">can_vma_merge_before</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vm_flags</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">vm_pgoff</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_mergeable_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">vm_flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">is_mergeable_anon_vma</span><span class="p">(</span><span class="n">anon_vma</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">,</span> <span class="n">vma</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">==</span> <span class="n">vm_pgoff</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return true if we can merge this (vm_flags,anon_vma,file,vm_pgoff)</span>
<span class="cm"> * beyond (at a higher virtual address and file offset than) the vma.</span>
<span class="cm"> *</span>
<span class="cm"> * We cannot merge two vmas if they have differently assigned (non-NULL)</span>
<span class="cm"> * anon_vmas, nor if same anon_vma is assigned but offsets incompatible.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="n">can_vma_merge_after</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vm_flags</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">vm_pgoff</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_mergeable_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">vm_flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">is_mergeable_anon_vma</span><span class="p">(</span><span class="n">anon_vma</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">,</span> <span class="n">vma</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pgoff_t</span> <span class="n">vm_pglen</span><span class="p">;</span>
		<span class="n">vm_pglen</span> <span class="o">=</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">+</span> <span class="n">vm_pglen</span> <span class="o">==</span> <span class="n">vm_pgoff</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Given a mapping request (addr,end,vm_flags,file,pgoff), figure out</span>
<span class="cm"> * whether that can be merged with its predecessor or its successor.</span>
<span class="cm"> * Or both (it neatly fills a hole).</span>
<span class="cm"> *</span>
<span class="cm"> * In most cases - when called for mmap, brk or mremap - [addr,end) is</span>
<span class="cm"> * certain not to be mapped by the time vma_merge is called; but when</span>
<span class="cm"> * called for mprotect, it is certain to be already mapped (either at</span>
<span class="cm"> * an offset within prev, or at the start of next), and the flags of</span>
<span class="cm"> * this area are about to be changed to vm_flags - and the no-change</span>
<span class="cm"> * case has already been eliminated.</span>
<span class="cm"> *</span>
<span class="cm"> * The following mprotect cases have to be considered, where AAAA is</span>
<span class="cm"> * the area passed down from mprotect_fixup, never extending beyond one</span>
<span class="cm"> * vma, PPPPPP is the prev vma specified, and NNNNNN the next vma after:</span>
<span class="cm"> *</span>
<span class="cm"> *     AAAA             AAAA                AAAA          AAAA</span>
<span class="cm"> *    PPPPPPNNNNNN    PPPPPPNNNNNN    PPPPPPNNNNNN    PPPPNNNNXXXX</span>
<span class="cm"> *    cannot merge    might become    might become    might become</span>
<span class="cm"> *                    PPNNNNNNNNNN    PPPPPPPPPPNN    PPPPPPPPPPPP 6 or</span>
<span class="cm"> *    mmap, brk or    case 4 below    case 5 below    PPPPPPPPXXXX 7 or</span>
<span class="cm"> *    mremap move:                                    PPPPNNNNNNNN 8</span>
<span class="cm"> *        AAAA</span>
<span class="cm"> *    PPPP    NNNN    PPPPPPPPPPPP    PPPPPPPPNNNN    PPPPNNNNNNNN</span>
<span class="cm"> *    might become    case 1 below    case 2 below    case 3 below</span>
<span class="cm"> *</span>
<span class="cm"> * Odd one out? Case 8, because it extends NNNN but needs flags of XXXX:</span>
<span class="cm"> * mprotect_fixup updates vm_flags &amp; vm_page_prot on successful return.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma_merge</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vm_flags</span><span class="p">,</span>
		     	<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
			<span class="n">pgoff_t</span> <span class="n">pgoff</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">policy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgoff_t</span> <span class="n">pglen</span> <span class="o">=</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">addr</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">area</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We later require that vma-&gt;vm_flags == vm_flags,</span>
<span class="cm">	 * so this tests vma-&gt;vm_flags &amp; VM_SPECIAL, too.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_SPECIAL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="p">)</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">;</span>
	<span class="n">area</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">&amp;&amp;</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span>		<span class="cm">/* cases 6, 7, 8 */</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Can it merge with the predecessor?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">&amp;&amp;</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">==</span> <span class="n">addr</span> <span class="o">&amp;&amp;</span>
  			<span class="n">mpol_equal</span><span class="p">(</span><span class="n">vma_policy</span><span class="p">(</span><span class="n">prev</span><span class="p">),</span> <span class="n">policy</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">can_vma_merge_after</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">vm_flags</span><span class="p">,</span>
						<span class="n">anon_vma</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">pgoff</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * OK, it can.  Can we now merge in the successor as well?</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">&amp;&amp;</span> <span class="n">end</span> <span class="o">==</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&amp;&amp;</span>
				<span class="n">mpol_equal</span><span class="p">(</span><span class="n">policy</span><span class="p">,</span> <span class="n">vma_policy</span><span class="p">(</span><span class="n">next</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
				<span class="n">can_vma_merge_before</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">vm_flags</span><span class="p">,</span>
					<span class="n">anon_vma</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">pgoff</span><span class="o">+</span><span class="n">pglen</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="n">is_mergeable_anon_vma</span><span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">,</span>
						      <span class="n">next</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
							<span class="cm">/* cases 1, 6 */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">vma_adjust</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span>
				<span class="n">next</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">,</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>					<span class="cm">/* cases 2, 5, 7 */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">vma_adjust</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span>
				<span class="n">end</span><span class="p">,</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">khugepaged_enter_vma_merge</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">prev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Can this new request be merged in front of next?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">&amp;&amp;</span> <span class="n">end</span> <span class="o">==</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&amp;&amp;</span>
 			<span class="n">mpol_equal</span><span class="p">(</span><span class="n">policy</span><span class="p">,</span> <span class="n">vma_policy</span><span class="p">(</span><span class="n">next</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
			<span class="n">can_vma_merge_before</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">vm_flags</span><span class="p">,</span>
					<span class="n">anon_vma</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">pgoff</span><span class="o">+</span><span class="n">pglen</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">&amp;&amp;</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">)</span>	<span class="cm">/* case 4 */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">vma_adjust</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span>
				<span class="n">addr</span><span class="p">,</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">else</span>					<span class="cm">/* cases 3, 8 */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">vma_adjust</span><span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">,</span>
				<span class="n">next</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">-</span> <span class="n">pglen</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">khugepaged_enter_vma_merge</span><span class="p">(</span><span class="n">area</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">area</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Rough compatbility check to quickly see if it&#39;s even worth looking</span>
<span class="cm"> * at sharing an anon_vma.</span>
<span class="cm"> *</span>
<span class="cm"> * They need to have the same vm_file, and the flags can only differ</span>
<span class="cm"> * in things that mprotect may change.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE! The fact that we share an anon_vma doesn&#39;t _have_ to mean that</span>
<span class="cm"> * we can merge the two vma&#39;s. For example, we refuse to merge a vma if</span>
<span class="cm"> * there is a vm_ops-&gt;close() function, because that indicates that the</span>
<span class="cm"> * driver is doing some kind of reference counting. But that doesn&#39;t</span>
<span class="cm"> * really matter for the anon_vma sharing case.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">anon_vma_compatible</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">==</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&amp;&amp;</span>
		<span class="n">mpol_equal</span><span class="p">(</span><span class="n">vma_policy</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">vma_policy</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		<span class="n">a</span><span class="o">-&gt;</span><span class="n">vm_file</span> <span class="o">==</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">vm_file</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="p">((</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">^</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">vm_flags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">VM_READ</span><span class="o">|</span><span class="n">VM_WRITE</span><span class="o">|</span><span class="n">VM_EXEC</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		<span class="n">b</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">==</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">+</span> <span class="p">((</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">-</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Do some basic sanity checking to see if we can re-use the anon_vma</span>
<span class="cm"> * from &#39;old&#39;. The &#39;a&#39;/&#39;b&#39; vma&#39;s are in VM order - one of them will be</span>
<span class="cm"> * the same as &#39;old&#39;, the other will be the new one that is trying</span>
<span class="cm"> * to share the anon_vma.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE! This runs with mm_sem held for reading, so it is possible that</span>
<span class="cm"> * the anon_vma of &#39;old&#39; is concurrently in the process of being set up</span>
<span class="cm"> * by another page fault trying to merge _that_. But that&#39;s ok: if it</span>
<span class="cm"> * is being set up, that automatically means that it will be a singleton</span>
<span class="cm"> * acceptable for merging, so we can do all of this optimistically. But</span>
<span class="cm"> * we do that ACCESS_ONCE() to make sure that we never re-load the pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * IOW: that the &quot;list_is_singular()&quot; test on the anon_vma_chain only</span>
<span class="cm"> * matters for the &#39;stable anon_vma&#39; case (ie the thing we want to avoid</span>
<span class="cm"> * is to return an anon_vma that is &quot;complex&quot; due to having gone through</span>
<span class="cm"> * a fork).</span>
<span class="cm"> *</span>
<span class="cm"> * We also make sure that the two vma&#39;s are compatible (adjacent,</span>
<span class="cm"> * and with the same memory policies). That&#39;s all stable, even with just</span>
<span class="cm"> * a read lock on the mm_sem.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">reusable_anon_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">anon_vma_compatible</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">anon_vma</span> <span class="o">&amp;&amp;</span> <span class="n">list_is_singular</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">anon_vma_chain</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">anon_vma</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * find_mergeable_anon_vma is used by anon_vma_prepare, to check</span>
<span class="cm"> * neighbouring vmas for a suitable anon_vma, before it goes off</span>
<span class="cm"> * to allocate a new anon_vma.  It checks because a repetitive</span>
<span class="cm"> * sequence of mprotects and faults may otherwise lead to distinct</span>
<span class="cm"> * anon_vmas being allocated, preventing vma merge in subsequent</span>
<span class="cm"> * mprotect.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">find_mergeable_anon_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">near</span><span class="p">;</span>

	<span class="n">near</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">near</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">try_prev</span><span class="p">;</span>

	<span class="n">anon_vma</span> <span class="o">=</span> <span class="n">reusable_anon_vma</span><span class="p">(</span><span class="n">near</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">near</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">anon_vma</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">anon_vma</span><span class="p">;</span>
<span class="nl">try_prev:</span>
	<span class="n">near</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_prev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">near</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">none</span><span class="p">;</span>

	<span class="n">anon_vma</span> <span class="o">=</span> <span class="n">reusable_anon_vma</span><span class="p">(</span><span class="n">near</span><span class="p">,</span> <span class="n">near</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">anon_vma</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">anon_vma</span><span class="p">;</span>
<span class="nl">none:</span>
	<span class="cm">/*</span>
<span class="cm">	 * There&#39;s no absolute need to look only at touching neighbours:</span>
<span class="cm">	 * we could search further afield for &quot;compatible&quot; anon_vmas.</span>
<span class="cm">	 * But it would probably just be a waste of time searching,</span>
<span class="cm">	 * or lead to too many vmas hanging off the same anon_vma.</span>
<span class="cm">	 * We&#39;re trying to allow mprotect remerging later on,</span>
<span class="cm">	 * not trying to minimize memory used for anon_vmas.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="kt">void</span> <span class="n">vm_stat_account</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">long</span> <span class="n">pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stack_flags</span>
		<span class="o">=</span> <span class="n">VM_STACK_FLAGS</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_GROWSUP</span><span class="o">|</span><span class="n">VM_GROWSDOWN</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mm</span><span class="o">-&gt;</span><span class="n">shared_vm</span> <span class="o">+=</span> <span class="n">pages</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_EXEC</span><span class="o">|</span><span class="n">VM_WRITE</span><span class="p">))</span> <span class="o">==</span> <span class="n">VM_EXEC</span><span class="p">)</span>
			<span class="n">mm</span><span class="o">-&gt;</span><span class="n">exec_vm</span> <span class="o">+=</span> <span class="n">pages</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">stack_flags</span><span class="p">)</span>
		<span class="n">mm</span><span class="o">-&gt;</span><span class="n">stack_vm</span> <span class="o">+=</span> <span class="n">pages</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_RESERVED</span><span class="o">|</span><span class="n">VM_IO</span><span class="p">))</span>
		<span class="n">mm</span><span class="o">-&gt;</span><span class="n">reserved_vm</span> <span class="o">+=</span> <span class="n">pages</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PROC_FS */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * If a hint addr is less than mmap_min_addr change hint to be as</span>
<span class="cm"> * low as possible but still greater than mmap_min_addr</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">round_hint_to_min</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hint</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hint</span> <span class="o">&amp;=</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">hint</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">hint</span> <span class="o">&lt;</span> <span class="n">mmap_min_addr</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">mmap_min_addr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">hint</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The caller must hold down_write(&amp;current-&gt;mm-&gt;mmap_sem).</span>
<span class="cm"> */</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">do_mmap_pgoff</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prot</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pgoff</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span> <span class="n">mm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="n">vm_flags_t</span> <span class="n">vm_flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Does the application expect PROT_READ to imply PROT_EXEC?</span>
<span class="cm">	 *</span>
<span class="cm">	 * (the exception is when the underlying filesystem is noexec</span>
<span class="cm">	 *  mounted, in which case we dont add PROT_EXEC.)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">prot</span> <span class="o">&amp;</span> <span class="n">PROT_READ</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">personality</span> <span class="o">&amp;</span> <span class="n">READ_IMPLIES_EXEC</span><span class="p">))</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">file</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_flags</span> <span class="o">&amp;</span> <span class="n">MNT_NOEXEC</span><span class="p">)))</span>
			<span class="n">prot</span> <span class="o">|=</span> <span class="n">PROT_EXEC</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MAP_FIXED</span><span class="p">))</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">round_hint_to_min</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>

	<span class="cm">/* Careful about overflows.. */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* offset overflow? */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pgoff</span> <span class="o">+</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">pgoff</span><span class="p">)</span>
               <span class="k">return</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>

	<span class="cm">/* Too many mappings? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">map_count</span> <span class="o">&gt;</span> <span class="n">sysctl_max_map_count</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Obtain the address to map to. we verify (or select) it and ensure</span>
<span class="cm">	 * that it represents a valid section of the address space.</span>
<span class="cm">	 */</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">get_unmapped_area</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">pgoff</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>

	<span class="cm">/* Do simple checking here so the lower-level routines won&#39;t have</span>
<span class="cm">	 * to. we assume access permissions have been handled by the open</span>
<span class="cm">	 * of the memory object, so we don&#39;t do any here.</span>
<span class="cm">	 */</span>
	<span class="n">vm_flags</span> <span class="o">=</span> <span class="n">calc_vm_prot_bits</span><span class="p">(</span><span class="n">prot</span><span class="p">)</span> <span class="o">|</span> <span class="n">calc_vm_flag_bits</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">mm</span><span class="o">-&gt;</span><span class="n">def_flags</span> <span class="o">|</span> <span class="n">VM_MAYREAD</span> <span class="o">|</span> <span class="n">VM_MAYWRITE</span> <span class="o">|</span> <span class="n">VM_MAYEXEC</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MAP_LOCKED</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">can_do_mlock</span><span class="p">())</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="cm">/* mlock MCL_FUTURE? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_LOCKED</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">locked</span><span class="p">,</span> <span class="n">lock_limit</span><span class="p">;</span>
		<span class="n">locked</span> <span class="o">=</span> <span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="n">locked</span> <span class="o">+=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">locked_vm</span><span class="p">;</span>
		<span class="n">lock_limit</span> <span class="o">=</span> <span class="n">rlimit</span><span class="p">(</span><span class="n">RLIMIT_MEMLOCK</span><span class="p">);</span>
		<span class="n">lock_limit</span> <span class="o">&gt;&gt;=</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">locked</span> <span class="o">&gt;</span> <span class="n">lock_limit</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_IPC_LOCK</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">file</span> <span class="o">?</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MAP_TYPE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">MAP_SHARED</span>:
			<span class="k">if</span> <span class="p">((</span><span class="n">prot</span><span class="o">&amp;</span><span class="n">PROT_WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span><span class="o">&amp;</span><span class="n">FMODE_WRITE</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Make sure we don&#39;t allow writing to an append-only</span>
<span class="cm">			 * file..</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_APPEND</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Make sure there are no mandatory locks on the file.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">locks_verify_locked</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

			<span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_SHARED</span> <span class="o">|</span> <span class="n">VM_MAYSHARE</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">))</span>
				<span class="n">vm_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">VM_MAYWRITE</span> <span class="o">|</span> <span class="n">VM_SHARED</span><span class="p">);</span>

			<span class="cm">/* fall through */</span>
		<span class="k">case</span> <span class="n">MAP_PRIVATE</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_READ</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_flags</span> <span class="o">&amp;</span> <span class="n">MNT_NOEXEC</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_EXEC</span><span class="p">)</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
				<span class="n">vm_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">VM_MAYEXEC</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">||</span> <span class="o">!</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MAP_TYPE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">MAP_SHARED</span>:
			<span class="cm">/*</span>
<span class="cm">			 * Ignore pgoff.</span>
<span class="cm">			 */</span>
			<span class="n">pgoff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_SHARED</span> <span class="o">|</span> <span class="n">VM_MAYSHARE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">MAP_PRIVATE</span>:
			<span class="cm">/*</span>
<span class="cm">			 * Set pgoff according to addr for anon_vma.</span>
<span class="cm">			 */</span>
			<span class="n">pgoff</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">mmap_region</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">vm_flags</span><span class="p">,</span> <span class="n">pgoff</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE6</span><span class="p">(</span><span class="n">mmap_pgoff</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">prot</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">pgoff</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MAP_ANONYMOUS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">audit_mmap_fd</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MAP_HUGETLB</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">file</span> <span class="o">=</span> <span class="n">fget</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MAP_HUGETLB</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">user_struct</span> <span class="o">*</span><span class="n">user</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * VM_NORESERVE is used because the reservations will be</span>
<span class="cm">		 * taken when vm_ops-&gt;mmap() is called</span>
<span class="cm">		 * A dummy user value is used because we are not locking</span>
<span class="cm">		 * memory so no accounting is necessary</span>
<span class="cm">		 */</span>
		<span class="n">file</span> <span class="o">=</span> <span class="n">hugetlb_file_setup</span><span class="p">(</span><span class="n">HUGETLB_ANON_FILE</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
						<span class="n">VM_NORESERVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">user</span><span class="p">,</span>
						<span class="n">HUGETLB_ANONHUGE_INODE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">file</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">MAP_EXECUTABLE</span> <span class="o">|</span> <span class="n">MAP_DENYWRITE</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">vm_mmap_pgoff</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">prot</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">pgoff</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="p">)</span>
		<span class="n">fput</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef __ARCH_WANT_SYS_OLD_MMAP</span>
<span class="k">struct</span> <span class="n">mmap_arg_struct</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prot</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">old_mmap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mmap_arg_struct</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mmap_arg_struct</span> <span class="n">a</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sys_mmap_pgoff</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">prot</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">flags</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">fd</span><span class="p">,</span>
			      <span class="n">a</span><span class="p">.</span><span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* __ARCH_WANT_SYS_OLD_MMAP */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Some shared mappigns will want the pages marked read-only</span>
<span class="cm"> * to track write events. If so, we&#39;ll downgrade vm_page_prot</span>
<span class="cm"> * to the private version (using protection_map[] without the</span>
<span class="cm"> * VM_SHARED bit).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">vma_wants_writenotify</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vm_flags_t</span> <span class="n">vm_flags</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span><span class="p">;</span>

	<span class="cm">/* If it was private or non-writable, the write bit is already clear */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_WRITE</span><span class="o">|</span><span class="n">VM_SHARED</span><span class="p">))</span> <span class="o">!=</span> <span class="p">((</span><span class="n">VM_WRITE</span><span class="o">|</span><span class="n">VM_SHARED</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* The backer wishes to know when pages are first written to? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">&amp;&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="o">-&gt;</span><span class="n">page_mkwrite</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* The open routine did something to the protections already? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pgprot_val</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">)</span> <span class="o">!=</span>
	    <span class="n">pgprot_val</span><span class="p">(</span><span class="n">vm_get_page_prot</span><span class="p">(</span><span class="n">vm_flags</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Specialty mapping? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_PFNMAP</span><span class="o">|</span><span class="n">VM_INSERTPAGE</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Can the mapping track the dirty pages? */</span>
	<span class="k">return</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span> <span class="o">&amp;&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_mapping</span> <span class="o">&amp;&amp;</span>
		<span class="n">mapping_cap_account_dirty</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We account for memory if it&#39;s a private writeable mapping,</span>
<span class="cm"> * not hugepages and VM_NORESERVE wasn&#39;t set.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">accountable_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">vm_flags_t</span> <span class="n">vm_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * hugetlb has its own accounting separate from the core VM</span>
<span class="cm">	 * VM_HUGETLB may not be set yet so we cannot check for that flag.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span> <span class="o">&amp;&amp;</span> <span class="n">is_file_hugepages</span><span class="p">(</span><span class="n">file</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_NORESERVE</span> <span class="o">|</span> <span class="n">VM_SHARED</span> <span class="o">|</span> <span class="n">VM_WRITE</span><span class="p">))</span> <span class="o">==</span> <span class="n">VM_WRITE</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmap_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span>
			  <span class="n">vm_flags_t</span> <span class="n">vm_flags</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pgoff</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">correct_wcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">rb_link</span><span class="p">,</span> <span class="o">*</span><span class="n">rb_parent</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">charged</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span>  <span class="n">file</span> <span class="o">?</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Clear old maps */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="nl">munmap_back:</span>
	<span class="n">vma</span> <span class="o">=</span> <span class="n">find_vma_prepare</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rb_link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rb_parent</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span> <span class="o">&amp;&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&lt;</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">do_munmap</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">munmap_back</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check against address space limit. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">may_expand_vm</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set &#39;VM_NORESERVE&#39; if we should not account for the</span>
<span class="cm">	 * memory use of this mapping.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MAP_NORESERVE</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* We honor MAP_NORESERVE if allowed to overcommit */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_overcommit_memory</span> <span class="o">!=</span> <span class="n">OVERCOMMIT_NEVER</span><span class="p">)</span>
			<span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_NORESERVE</span><span class="p">;</span>

		<span class="cm">/* hugetlb applies strict overcommit unless MAP_NORESERVE */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">file</span> <span class="o">&amp;&amp;</span> <span class="n">is_file_hugepages</span><span class="p">(</span><span class="n">file</span><span class="p">))</span>
			<span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_NORESERVE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Private writable mapping: check memory availability</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">accountable_mapping</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">vm_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">charged</span> <span class="o">=</span> <span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">security_vm_enough_memory_mm</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">charged</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_ACCOUNT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Can we just expand an old mapping?</span>
<span class="cm">	 */</span>
	<span class="n">vma</span> <span class="o">=</span> <span class="n">vma_merge</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">vm_flags</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">pgoff</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Determine the object being mapped and call the appropriate</span>
<span class="cm">	 * specific mapper. the address has already been validated, but</span>
<span class="cm">	 * not unmapped, but the maps are removed from the list.</span>
<span class="cm">	 */</span>
	<span class="n">vma</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">vm_area_cachep</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unacct_error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span> <span class="o">=</span> <span class="n">mm</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">=</span> <span class="n">vm_flags</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span> <span class="o">=</span> <span class="n">vm_get_page_prot</span><span class="p">(</span><span class="n">vm_flags</span><span class="p">);</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">=</span> <span class="n">pgoff</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma_chain</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>	<span class="cm">/* when rejecting VM_GROWSDOWN|VM_GROWSUP */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_GROWSDOWN</span><span class="o">|</span><span class="n">VM_GROWSUP</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">free_vma</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_DENYWRITE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">deny_write_access</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">free_vma</span><span class="p">;</span>
			<span class="n">correct_wcount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span> <span class="o">=</span> <span class="n">file</span><span class="p">;</span>
		<span class="n">get_file</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">unmap_and_free_vma</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_EXECUTABLE</span><span class="p">)</span>
			<span class="n">added_exe_file_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>

		<span class="cm">/* Can addr have changed??</span>
<span class="cm">		 *</span>
<span class="cm">		 * Answer: Yes, several device drivers can do it in their</span>
<span class="cm">		 *         f_op-&gt;mmap method. -DaveM</span>
<span class="cm">		 */</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
		<span class="n">pgoff</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span><span class="p">;</span>
		<span class="n">vm_flags</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_SHARED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_GROWSDOWN</span><span class="o">|</span><span class="n">VM_GROWSUP</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">free_vma</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">shmem_zero_setup</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">free_vma</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vma_wants_writenotify</span><span class="p">(</span><span class="n">vma</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pgprot_t</span> <span class="n">pprot</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">;</span>

		<span class="cm">/* Can vma-&gt;vm_page_prot have changed??</span>
<span class="cm">		 *</span>
<span class="cm">		 * Answer: Yes, drivers may have changed it in their</span>
<span class="cm">		 *         f_op-&gt;mmap method.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Ensures that vmas marked as uncached stay that way.</span>
<span class="cm">		 */</span>
		<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span> <span class="o">=</span> <span class="n">vm_get_page_prot</span><span class="p">(</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">VM_SHARED</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pgprot_val</span><span class="p">(</span><span class="n">pprot</span><span class="p">)</span> <span class="o">==</span> <span class="n">pgprot_val</span><span class="p">(</span><span class="n">pgprot_noncached</span><span class="p">(</span><span class="n">pprot</span><span class="p">)))</span>
			<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span> <span class="o">=</span> <span class="n">pgprot_noncached</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">vma_link</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">rb_link</span><span class="p">,</span> <span class="n">rb_parent</span><span class="p">);</span>
	<span class="n">file</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">;</span>

	<span class="cm">/* Once vma denies write, undo our temporary denial count */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">correct_wcount</span><span class="p">)</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_writecount</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">perf_event_mmap</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>

	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">total_vm</span> <span class="o">+=</span> <span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">vm_stat_account</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vm_flags</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_LOCKED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mlock_vma_pages_range</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">len</span><span class="p">))</span>
			<span class="n">mm</span><span class="o">-&gt;</span><span class="n">locked_vm</span> <span class="o">+=</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MAP_POPULATE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MAP_NONBLOCK</span><span class="p">))</span>
		<span class="n">make_pages_present</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span> <span class="o">&amp;&amp;</span> <span class="n">uprobe_mmap</span><span class="p">(</span><span class="n">vma</span><span class="p">))</span>
		<span class="cm">/* matching probes but cannot insert */</span>
		<span class="k">goto</span> <span class="n">unmap_and_free_vma</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>

<span class="nl">unmap_and_free_vma:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">correct_wcount</span><span class="p">)</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_writecount</span><span class="p">);</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">fput</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>

	<span class="cm">/* Undo any partial mapping done by a device driver. */</span>
	<span class="n">unmap_region</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">);</span>
	<span class="n">charged</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">free_vma:</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">vm_area_cachep</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
<span class="nl">unacct_error:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">charged</span><span class="p">)</span>
		<span class="n">vm_unacct_memory</span><span class="p">(</span><span class="n">charged</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Get an address range which is currently unmapped.</span>
<span class="cm"> * For shmat() with addr=0.</span>
<span class="cm"> *</span>
<span class="cm"> * Ugly calling convention alert:</span>
<span class="cm"> * Return value with the low bits set means error value,</span>
<span class="cm"> * ie</span>
<span class="cm"> *	if (ret &amp; ~PAGE_MASK)</span>
<span class="cm"> *		error = ret;</span>
<span class="cm"> *</span>
<span class="cm"> * This function &quot;knows&quot; that -ENOMEM has the bits set.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef HAVE_ARCH_UNMAPPED_AREA</span>
<span class="kt">unsigned</span> <span class="kt">long</span>
<span class="n">arch_get_unmapped_area</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pgoff</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">TASK_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MAP_FIXED</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
		<span class="n">vma</span> <span class="o">=</span> <span class="n">find_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">TASK_SIZE</span> <span class="o">-</span> <span class="n">len</span> <span class="o">&gt;=</span> <span class="n">addr</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="o">!</span><span class="n">vma</span> <span class="o">||</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">cached_hole_size</span><span class="p">)</span> <span class="p">{</span>
	        <span class="n">start_addr</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">free_area_cache</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	        <span class="n">start_addr</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">TASK_UNMAPPED_BASE</span><span class="p">;</span>
	        <span class="n">mm</span><span class="o">-&gt;</span><span class="n">cached_hole_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">full_search:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">vma</span> <span class="o">=</span> <span class="n">find_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span> <span class="p">;</span> <span class="n">vma</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* At this point:  (!vma || addr &lt; vma-&gt;vm_end). */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">TASK_SIZE</span> <span class="o">-</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Start a new search - just in case we missed</span>
<span class="cm">			 * some holes.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">start_addr</span> <span class="o">!=</span> <span class="n">TASK_UNMAPPED_BASE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">addr</span> <span class="o">=</span> <span class="n">TASK_UNMAPPED_BASE</span><span class="p">;</span>
			        <span class="n">start_addr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
				<span class="n">mm</span><span class="o">-&gt;</span><span class="n">cached_hole_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">full_search</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span> <span class="o">||</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Remember the place where we stopped the search:</span>
<span class="cm">			 */</span>
			<span class="n">mm</span><span class="o">-&gt;</span><span class="n">free_area_cache</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">cached_hole_size</span> <span class="o">&lt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span>
		        <span class="n">mm</span><span class="o">-&gt;</span><span class="n">cached_hole_size</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">-</span> <span class="n">addr</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif	</span>

<span class="kt">void</span> <span class="n">arch_unmap_area</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Is this a new hole at the lowest possible address?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">TASK_UNMAPPED_BASE</span> <span class="o">&amp;&amp;</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">free_area_cache</span><span class="p">)</span>
		<span class="n">mm</span><span class="o">-&gt;</span><span class="n">free_area_cache</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This mmap-allocator allocates new areas top-down from below the</span>
<span class="cm"> * stack&#39;s low limit (the base):</span>
<span class="cm"> */</span>
<span class="cp">#ifndef HAVE_ARCH_UNMAPPED_AREA_TOPDOWN</span>
<span class="kt">unsigned</span> <span class="kt">long</span>
<span class="n">arch_get_unmapped_area_topdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr0</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pgoff</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">addr0</span><span class="p">,</span> <span class="n">start_addr</span><span class="p">;</span>

	<span class="cm">/* requested length too big for entire address space */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">TASK_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MAP_FIXED</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>

	<span class="cm">/* requesting a specific address */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
		<span class="n">vma</span> <span class="o">=</span> <span class="n">find_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">TASK_SIZE</span> <span class="o">-</span> <span class="n">len</span> <span class="o">&gt;=</span> <span class="n">addr</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="o">!</span><span class="n">vma</span> <span class="o">||</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* check if free_area_cache is useful for us */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">cached_hole_size</span><span class="p">)</span> <span class="p">{</span>
 	        <span class="n">mm</span><span class="o">-&gt;</span><span class="n">cached_hole_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 		<span class="n">mm</span><span class="o">-&gt;</span><span class="n">free_area_cache</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_base</span><span class="p">;</span>
 	<span class="p">}</span>

<span class="nl">try_again:</span>
	<span class="cm">/* either no address requested or can&#39;t fit in requested address hole */</span>
	<span class="n">start_addr</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">free_area_cache</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Lookup failure means no vma is above this address,</span>
<span class="cm">		 * else if new region fits below vma-&gt;vm_start,</span>
<span class="cm">		 * return with success:</span>
<span class="cm">		 */</span>
		<span class="n">vma</span> <span class="o">=</span> <span class="n">find_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span> <span class="o">||</span> <span class="n">addr</span><span class="o">+</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span>
			<span class="cm">/* remember the address as a hint for next time */</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">free_area_cache</span> <span class="o">=</span> <span class="n">addr</span><span class="p">);</span>

 		<span class="cm">/* remember the largest hole we saw so far */</span>
 		<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">cached_hole_size</span> <span class="o">&lt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span>
 		        <span class="n">mm</span><span class="o">-&gt;</span><span class="n">cached_hole_size</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">-</span> <span class="n">addr</span><span class="p">;</span>

		<span class="cm">/* try just below the current vma-&gt;vm_start */</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="o">-</span><span class="n">len</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">);</span>

<span class="nl">fail:</span>
	<span class="cm">/*</span>
<span class="cm">	 * if hint left us with no space for the requested</span>
<span class="cm">	 * mapping then try again:</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: this is different with the case of bottomup</span>
<span class="cm">	 * which does the fully line-search, but we use find_vma</span>
<span class="cm">	 * here that causes some holes skipped.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start_addr</span> <span class="o">!=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_base</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mm</span><span class="o">-&gt;</span><span class="n">free_area_cache</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_base</span><span class="p">;</span>
		<span class="n">mm</span><span class="o">-&gt;</span><span class="n">cached_hole_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">try_again</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * A failed mmap() very likely causes application failure,</span>
<span class="cm">	 * so fall back to the bottom-up function here. This scenario</span>
<span class="cm">	 * can happen with large stack limits and large mmap()</span>
<span class="cm">	 * allocations.</span>
<span class="cm">	 */</span>
	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">cached_hole_size</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span>
  	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">free_area_cache</span> <span class="o">=</span> <span class="n">TASK_UNMAPPED_BASE</span><span class="p">;</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">arch_get_unmapped_area</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">addr0</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">pgoff</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Restore the topdown base:</span>
<span class="cm">	 */</span>
	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">free_area_cache</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_base</span><span class="p">;</span>
	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">cached_hole_size</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="n">arch_unmap_area_topdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Is this a new hole at the highest possible address?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">free_area_cache</span><span class="p">)</span>
		<span class="n">mm</span><span class="o">-&gt;</span><span class="n">free_area_cache</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>

	<span class="cm">/* dont allow allocations above current base */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">free_area_cache</span> <span class="o">&gt;</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_base</span><span class="p">)</span>
		<span class="n">mm</span><span class="o">-&gt;</span><span class="n">free_area_cache</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_base</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span>
<span class="n">get_unmapped_area</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pgoff</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">get_area</span><span class="p">)(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">error</span> <span class="o">=</span> <span class="n">arch_mmap_check</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* Careful about overflows.. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">TASK_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">get_area</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">get_unmapped_area</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span> <span class="o">&amp;&amp;</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">&amp;&amp;</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">get_unmapped_area</span><span class="p">)</span>
		<span class="n">get_area</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">get_unmapped_area</span><span class="p">;</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">get_area</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">pgoff</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_VALUE</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;</span> <span class="n">TASK_SIZE</span> <span class="o">-</span> <span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">arch_rebalance_pgtables</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">security_mmap_addr</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span> <span class="o">?</span> <span class="n">error</span> <span class="o">:</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">get_unmapped_area</span><span class="p">);</span>

<span class="cm">/* Look up the first VMA which satisfies  addr &lt; vm_end,  NULL if none. */</span>
<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="nf">find_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="p">))</span>		<span class="cm">/* Remove this in linux-3.6 */</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Check the cache first. */</span>
	<span class="cm">/* (Cache hit rate is typically around 35%.) */</span>
	<span class="n">vma</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_cache</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span> <span class="o">&amp;&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">&gt;</span> <span class="n">addr</span> <span class="o">&amp;&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&lt;=</span> <span class="n">addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">rb_node</span><span class="p">;</span>

		<span class="n">rb_node</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_rb</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
		<span class="n">vma</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">rb_node</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma_tmp</span><span class="p">;</span>

			<span class="n">vma_tmp</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">rb_node</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">vm_area_struct</span><span class="p">,</span> <span class="n">vm_rb</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">vma_tmp</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">&gt;</span> <span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">vma</span> <span class="o">=</span> <span class="n">vma_tmp</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">vma_tmp</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&lt;=</span> <span class="n">addr</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="n">rb_node</span> <span class="o">=</span> <span class="n">rb_node</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">rb_node</span> <span class="o">=</span> <span class="n">rb_node</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="p">)</span>
			<span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_cache</span> <span class="o">=</span> <span class="n">vma</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">vma</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">find_vma</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Same as find_vma, but also return a pointer to the previous VMA in *pprev.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span>
<span class="nf">find_vma_prev</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">**</span><span class="n">pprev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>

	<span class="n">vma</span> <span class="o">=</span> <span class="n">find_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">pprev</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_prev</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">rb_node</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_rb</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
		<span class="o">*</span><span class="n">pprev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">rb_node</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">pprev</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">rb_node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span><span class="p">,</span> <span class="n">vm_rb</span><span class="p">);</span>
			<span class="n">rb_node</span> <span class="o">=</span> <span class="n">rb_node</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">vma</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Verify that the stack growth is acceptable and</span>
<span class="cm"> * update accounting. This is shared with both the</span>
<span class="cm"> * grow-up and grow-down cases.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">acct_stack_growth</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">grow</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rlimit</span> <span class="o">*</span><span class="n">rlim</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">rlim</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_start</span><span class="p">;</span>

	<span class="cm">/* address space limit tests */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">may_expand_vm</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">grow</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Stack limit test */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">rlim</span><span class="p">[</span><span class="n">RLIMIT_STACK</span><span class="p">].</span><span class="n">rlim_cur</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* mlock limit tests */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_LOCKED</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">locked</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">limit</span><span class="p">;</span>
		<span class="n">locked</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">locked_vm</span> <span class="o">+</span> <span class="n">grow</span><span class="p">;</span>
		<span class="n">limit</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">rlim</span><span class="p">[</span><span class="n">RLIMIT_MEMLOCK</span><span class="p">].</span><span class="n">rlim_cur</span><span class="p">);</span>
		<span class="n">limit</span> <span class="o">&gt;&gt;=</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">locked</span> <span class="o">&gt;</span> <span class="n">limit</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_IPC_LOCK</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check to ensure the stack will not grow into a hugetlb-only region */</span>
	<span class="n">new_start</span> <span class="o">=</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_GROWSUP</span><span class="p">)</span> <span class="o">?</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">:</span>
			<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_hugepage_only_range</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">new_start</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Overcommit..  This must be the final test, as it will</span>
<span class="cm">	 * update security statistics.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">security_vm_enough_memory_mm</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">grow</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Ok, everything looks good - let it rip */</span>
	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">total_vm</span> <span class="o">+=</span> <span class="n">grow</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_LOCKED</span><span class="p">)</span>
		<span class="n">mm</span><span class="o">-&gt;</span><span class="n">locked_vm</span> <span class="o">+=</span> <span class="n">grow</span><span class="p">;</span>
	<span class="n">vm_stat_account</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">,</span> <span class="n">grow</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if defined(CONFIG_STACK_GROWSUP) || defined(CONFIG_IA64)</span>
<span class="cm">/*</span>
<span class="cm"> * PA-RISC uses this for its stack; IA64 for its Register Backing Store.</span>
<span class="cm"> * vma is the last one with address &gt; vma-&gt;vm_end.  Have to extend vma.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">expand_upwards</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_GROWSUP</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We must make sure the anon_vma is allocated</span>
<span class="cm">	 * so that the anon_vma locking is not a noop.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">anon_vma_prepare</span><span class="p">(</span><span class="n">vma</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">vma_lock_anon_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * vma-&gt;vm_start/vm_end cannot change under us because the caller</span>
<span class="cm">	 * is required to hold the mmap_sem in read mode.  We need the</span>
<span class="cm">	 * anon_vma lock to serialize against concurrent expand_stacks.</span>
<span class="cm">	 * Also guard against wrapping around to address 0.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">&lt;</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">address</span><span class="o">+</span><span class="mi">4</span><span class="p">))</span>
		<span class="n">address</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">address</span><span class="o">+</span><span class="mi">4</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">vma_unlock_anon_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Somebody else might have raced and expanded it already */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">&gt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="n">grow</span><span class="p">;</span>

		<span class="n">size</span> <span class="o">=</span> <span class="n">address</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
		<span class="n">grow</span> <span class="o">=</span> <span class="p">(</span><span class="n">address</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">+</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">acct_stack_growth</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">grow</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">=</span> <span class="n">address</span><span class="p">;</span>
				<span class="n">perf_event_mmap</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">vma_unlock_anon_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
	<span class="n">khugepaged_enter_vma_merge</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_STACK_GROWSUP || CONFIG_IA64 */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * vma is the first one with address &lt; vma-&gt;vm_start.  Have to extend vma.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">expand_downwards</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We must make sure the anon_vma is allocated</span>
<span class="cm">	 * so that the anon_vma locking is not a noop.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">anon_vma_prepare</span><span class="p">(</span><span class="n">vma</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">address</span> <span class="o">&amp;=</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">security_mmap_addr</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">vma_lock_anon_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * vma-&gt;vm_start/vm_end cannot change under us because the caller</span>
<span class="cm">	 * is required to hold the mmap_sem in read mode.  We need the</span>
<span class="cm">	 * anon_vma lock to serialize against concurrent expand_stacks.</span>
<span class="cm">	 */</span>

	<span class="cm">/* Somebody else might have raced and expanded it already */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">&lt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="n">grow</span><span class="p">;</span>

		<span class="n">size</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">address</span><span class="p">;</span>
		<span class="n">grow</span> <span class="o">=</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">-</span> <span class="n">address</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">grow</span> <span class="o">&lt;=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">acct_stack_growth</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">grow</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">=</span> <span class="n">address</span><span class="p">;</span>
				<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">-=</span> <span class="n">grow</span><span class="p">;</span>
				<span class="n">perf_event_mmap</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">vma_unlock_anon_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
	<span class="n">khugepaged_enter_vma_merge</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_STACK_GROWSUP</span>
<span class="kt">int</span> <span class="nf">expand_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">expand_upwards</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span>
<span class="nf">find_extend_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">&amp;=</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="n">vma</span> <span class="o">=</span> <span class="n">find_vma_prev</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&lt;=</span> <span class="n">addr</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">vma</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prev</span> <span class="o">||</span> <span class="n">expand_stack</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">addr</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_LOCKED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlock_vma_pages_range</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">prev</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="kt">int</span> <span class="nf">expand_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">expand_downwards</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span>
<span class="nf">find_extend_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span> <span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span> <span class="n">vma</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">&amp;=</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="n">vma</span> <span class="o">=</span> <span class="n">find_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&lt;=</span> <span class="n">addr</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">vma</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_GROWSDOWN</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">start</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">expand_stack</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_LOCKED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlock_vma_pages_range</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">vma</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Ok - we have the memory areas we should free on the vma list,</span>
<span class="cm"> * so release them, and do the vma updates.</span>
<span class="cm"> *</span>
<span class="cm"> * Called with the mm semaphore held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">remove_vma_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_accounted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Update high watermark before we lower total_vm */</span>
	<span class="n">update_hiwater_vm</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">long</span> <span class="n">nrpages</span> <span class="o">=</span> <span class="n">vma_pages</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_ACCOUNT</span><span class="p">)</span>
			<span class="n">nr_accounted</span> <span class="o">+=</span> <span class="n">nrpages</span><span class="p">;</span>
		<span class="n">mm</span><span class="o">-&gt;</span><span class="n">total_vm</span> <span class="o">-=</span> <span class="n">nrpages</span><span class="p">;</span>
		<span class="n">vm_stat_account</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">,</span> <span class="o">-</span><span class="n">nrpages</span><span class="p">);</span>
		<span class="n">vma</span> <span class="o">=</span> <span class="n">remove_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">vma</span><span class="p">);</span>
	<span class="n">vm_unacct_memory</span><span class="p">(</span><span class="n">nr_accounted</span><span class="p">);</span>
	<span class="n">validate_mm</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get rid of page table information in the indicated region.</span>
<span class="cm"> *</span>
<span class="cm"> * Called with the mm semaphore held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">unmap_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">prev</span><span class="o">?</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="o">:</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mmu_gather</span> <span class="n">tlb</span><span class="p">;</span>

	<span class="n">lru_add_drain</span><span class="p">();</span>
	<span class="n">tlb_gather_mmu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlb</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">update_hiwater_rss</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="n">unmap_vmas</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlb</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="n">free_pgtables</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlb</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">prev</span> <span class="o">?</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">:</span> <span class="n">FIRST_USER_ADDRESS</span><span class="p">,</span>
				 <span class="n">next</span> <span class="o">?</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">tlb_finish_mmu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlb</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Create a list of vma&#39;s touched by the unmap, removing them from the mm&#39;s</span>
<span class="cm"> * vma list as we go..</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">detach_vmas_to_be_unmapped</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">**</span><span class="n">insertion_point</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">tail_vma</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">insertion_point</span> <span class="o">=</span> <span class="p">(</span><span class="n">prev</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">vm_next</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">);</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_rb</span><span class="p">);</span>
		<span class="n">mm</span><span class="o">-&gt;</span><span class="n">map_count</span><span class="o">--</span><span class="p">;</span>
		<span class="n">tail_vma</span> <span class="o">=</span> <span class="n">vma</span><span class="p">;</span>
		<span class="n">vma</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">vma</span> <span class="o">&amp;&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">);</span>
	<span class="o">*</span><span class="n">insertion_point</span> <span class="o">=</span> <span class="n">vma</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="p">)</span>
		<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_prev</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
	<span class="n">tail_vma</span><span class="o">-&gt;</span><span class="n">vm_next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">unmap_area</span> <span class="o">==</span> <span class="n">arch_unmap_area</span><span class="p">)</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">prev</span> <span class="o">?</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">:</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_base</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">vma</span> <span class="o">?</span>  <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">:</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_base</span><span class="p">;</span>
	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">unmap_area</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_cache</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>		<span class="cm">/* Kill the cache. */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * __split_vma() bypasses sysctl_max_map_count checking.  We use this on the</span>
<span class="cm"> * munmap path where it doesn&#39;t make sense to fail.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__split_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span> <span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span> <span class="n">vma</span><span class="p">,</span>
	      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_below</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">pol</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_vm_hugetlb_page</span><span class="p">(</span><span class="n">vma</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span>
					<span class="o">~</span><span class="p">(</span><span class="n">huge_page_mask</span><span class="p">(</span><span class="n">hstate_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">)))))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">new</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">vm_area_cachep</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="cm">/* most fields are the same, copy all, and then fixup */</span>
	<span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">anon_vma_chain</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_below</span><span class="p">)</span>
		<span class="n">new</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">new</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
		<span class="n">new</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">+=</span> <span class="p">((</span><span class="n">addr</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pol</span> <span class="o">=</span> <span class="n">mpol_dup</span><span class="p">(</span><span class="n">vma_policy</span><span class="p">(</span><span class="n">vma</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">pol</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">pol</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_vma</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vma_set_policy</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">pol</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">anon_vma_clone</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">vma</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_free_mpol</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">get_file</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_EXECUTABLE</span><span class="p">)</span>
			<span class="n">added_exe_file_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">&amp;&amp;</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="o">-&gt;</span><span class="n">open</span><span class="p">)</span>
		<span class="n">new</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="o">-&gt;</span><span class="n">open</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_below</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">vma_adjust</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">+</span>
			<span class="p">((</span><span class="n">addr</span> <span class="o">-</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">),</span> <span class="n">new</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">vma_adjust</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>

	<span class="cm">/* Success. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Clean everything up if vma_adjust failed. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">&amp;&amp;</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="o">-&gt;</span><span class="n">close</span><span class="p">)</span>
		<span class="n">new</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="o">-&gt;</span><span class="n">close</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_EXECUTABLE</span><span class="p">)</span>
			<span class="n">removed_exe_file_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
		<span class="n">fput</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">unlink_anon_vmas</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
 <span class="nl">out_free_mpol:</span>
	<span class="n">mpol_put</span><span class="p">(</span><span class="n">pol</span><span class="p">);</span>
 <span class="nl">out_free_vma:</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">vm_area_cachep</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
 <span class="nl">out_err:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Split a vma into two pieces at address &#39;addr&#39;, a new vma is allocated</span>
<span class="cm"> * either for the first part or the tail.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">split_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
	      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_below</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">map_count</span> <span class="o">&gt;=</span> <span class="n">sysctl_max_map_count</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">__split_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">new_below</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Munmap is split into 2 main parts -- this part which finds</span>
<span class="cm"> * what needs doing, and the areas themselves, which do the</span>
<span class="cm"> * work.  This now handles partial unmappings.</span>
<span class="cm"> * Jeremy Fitzhardinge &lt;jeremy@goop.org&gt;</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">do_munmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">start</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">)</span> <span class="o">||</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">TASK_SIZE</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">TASK_SIZE</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">len</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">len</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Find the first overlapping VMA */</span>
	<span class="n">vma</span> <span class="o">=</span> <span class="n">find_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">prev</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_prev</span><span class="p">;</span>
	<span class="cm">/* we have  start &lt; vma-&gt;vm_end  */</span>

	<span class="cm">/* if it doesn&#39;t overlap, we have nothing.. */</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we need to split any vma, do it now to save pain later.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: mremap&#39;s move_vma VM_ACCOUNT handling assumes a partially</span>
<span class="cm">	 * unmapped vm_area_struct will remain in use: so lower split_vma</span>
<span class="cm">	 * places tmp vma above, and higher split_vma places tmp vma below.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Make sure that map_count on return from munmap() will</span>
<span class="cm">		 * not exceed its limit; but let map_count go just above</span>
<span class="cm">		 * its limit temporarily, to help free resources as expected.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">&amp;&amp;</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">map_count</span> <span class="o">&gt;=</span> <span class="n">sysctl_max_map_count</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">__split_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">vma</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Does it split the last one? */</span>
	<span class="n">last</span> <span class="o">=</span> <span class="n">find_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last</span> <span class="o">&amp;&amp;</span> <span class="n">end</span> <span class="o">&gt;</span> <span class="n">last</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="n">__split_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vma</span> <span class="o">=</span> <span class="n">prev</span><span class="o">?</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="o">:</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * unlock any mlock()ed ranges before detaching vmas</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">locked_vm</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">vma</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;&amp;</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_LOCKED</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mm</span><span class="o">-&gt;</span><span class="n">locked_vm</span> <span class="o">-=</span> <span class="n">vma_pages</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
				<span class="n">munlock_vma_pages_all</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Remove the vma&#39;s, and unmap the actual pages</span>
<span class="cm">	 */</span>
	<span class="n">detach_vmas_to_be_unmapped</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="n">unmap_region</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>

	<span class="cm">/* Fix up all other VM information */</span>
	<span class="n">remove_vma_list</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">vm_munmap</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">do_munmap</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vm_munmap</span><span class="p">);</span>

<span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">munmap</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">profile_munmap</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">vm_munmap</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">verify_mm_writelocked</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_DEBUG_VM</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">down_read_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  this is really a simplified &quot;do_mmap&quot;.  it only handles</span>
<span class="cm"> *  anonymous maps.  eventually we may be able to do some</span>
<span class="cm"> *  brk-specific accounting here.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">do_brk</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span> <span class="n">mm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span> <span class="n">vma</span><span class="p">,</span> <span class="o">*</span> <span class="n">prev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span> <span class="n">rb_link</span><span class="p">,</span> <span class="o">*</span> <span class="n">rb_parent</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">pgoff</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">flags</span> <span class="o">=</span> <span class="n">VM_DATA_DEFAULT_FLAGS</span> <span class="o">|</span> <span class="n">VM_ACCOUNT</span> <span class="o">|</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">def_flags</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">get_unmapped_area</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MAP_FIXED</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * mlock MCL_FUTURE?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">def_flags</span> <span class="o">&amp;</span> <span class="n">VM_LOCKED</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">locked</span><span class="p">,</span> <span class="n">lock_limit</span><span class="p">;</span>
		<span class="n">locked</span> <span class="o">=</span> <span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="n">locked</span> <span class="o">+=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">locked_vm</span><span class="p">;</span>
		<span class="n">lock_limit</span> <span class="o">=</span> <span class="n">rlimit</span><span class="p">(</span><span class="n">RLIMIT_MEMLOCK</span><span class="p">);</span>
		<span class="n">lock_limit</span> <span class="o">&gt;&gt;=</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">locked</span> <span class="o">&gt;</span> <span class="n">lock_limit</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_IPC_LOCK</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * mm-&gt;mmap_sem is required to protect against another thread</span>
<span class="cm">	 * changing the mappings in case we sleep.</span>
<span class="cm">	 */</span>
	<span class="n">verify_mm_writelocked</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear old maps.  this also does some error checking for us</span>
<span class="cm">	 */</span>
 <span class="nl">munmap_back:</span>
	<span class="n">vma</span> <span class="o">=</span> <span class="n">find_vma_prepare</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rb_link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rb_parent</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span> <span class="o">&amp;&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&lt;</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">do_munmap</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">munmap_back</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check against address space limits *after* clearing old maps... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">may_expand_vm</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">map_count</span> <span class="o">&gt;</span> <span class="n">sysctl_max_map_count</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">security_vm_enough_memory_mm</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Can we just expand an old private anonymous mapping? */</span>
	<span class="n">vma</span> <span class="o">=</span> <span class="n">vma_merge</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span>
					<span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">pgoff</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * create a vma struct for an anonymous mapping</span>
<span class="cm">	 */</span>
	<span class="n">vma</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">vm_area_cachep</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vm_unacct_memory</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma_chain</span><span class="p">);</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span> <span class="o">=</span> <span class="n">mm</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">=</span> <span class="n">pgoff</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span> <span class="o">=</span> <span class="n">vm_get_page_prot</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">vma_link</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">rb_link</span><span class="p">,</span> <span class="n">rb_parent</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">perf_event_mmap</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">total_vm</span> <span class="o">+=</span> <span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">VM_LOCKED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mlock_vma_pages_range</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">len</span><span class="p">))</span>
			<span class="n">mm</span><span class="o">-&gt;</span><span class="n">locked_vm</span> <span class="o">+=</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vm_brk</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">do_brk</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vm_brk</span><span class="p">);</span>

<span class="cm">/* Release all mmaps. */</span>
<span class="kt">void</span> <span class="nf">exit_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mmu_gather</span> <span class="n">tlb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_accounted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* mm&#39;s last user has gone, and its about to be pulled down */</span>
	<span class="n">mmu_notifier_release</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">locked_vm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vma</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">vma</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_LOCKED</span><span class="p">)</span>
				<span class="n">munlock_vma_pages_all</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
			<span class="n">vma</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">arch_exit_mmap</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>

	<span class="n">vma</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="p">)</span>	<span class="cm">/* Can happen if dup_mmap() received an OOM */</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">lru_add_drain</span><span class="p">();</span>
	<span class="n">flush_cache_mm</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="n">tlb_gather_mmu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlb</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="cm">/* update_hiwater_rss(mm) here? but nobody should be looking */</span>
	<span class="cm">/* Use -1 here to ensure all VMAs in the mm are unmapped */</span>
	<span class="n">unmap_vmas</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlb</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">free_pgtables</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlb</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">FIRST_USER_ADDRESS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">tlb_finish_mmu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Walk the list again, actually closing and freeing it,</span>
<span class="cm">	 * with preemption enabled, without holding any MM locks.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">vma</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_ACCOUNT</span><span class="p">)</span>
			<span class="n">nr_accounted</span> <span class="o">+=</span> <span class="n">vma_pages</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
		<span class="n">vma</span> <span class="o">=</span> <span class="n">remove_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">vm_unacct_memory</span><span class="p">(</span><span class="n">nr_accounted</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">nr_ptes</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">FIRST_USER_ADDRESS</span><span class="o">+</span><span class="n">PMD_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="n">PMD_SHIFT</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Insert vm structure into process list sorted by address</span>
<span class="cm"> * and into the inode&#39;s i_mmap tree.  If vm_file is non-NULL</span>
<span class="cm"> * then i_mmap_mutex is taken here.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">insert_vm_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span> <span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span> <span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span> <span class="n">__vma</span><span class="p">,</span> <span class="o">*</span> <span class="n">prev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span> <span class="n">rb_link</span><span class="p">,</span> <span class="o">*</span> <span class="n">rb_parent</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The vm_pgoff of a purely anonymous vma should be irrelevant</span>
<span class="cm">	 * until its first write fault, when page&#39;s anon_vma and index</span>
<span class="cm">	 * are set.  But now set the vm_pgoff it will almost certainly</span>
<span class="cm">	 * end up with (unless mremap moves it elsewhere before that</span>
<span class="cm">	 * first wfault), so /proc/pid/maps tells a consistent story.</span>
<span class="cm">	 *</span>
<span class="cm">	 * By setting it to reflect the virtual start address of the</span>
<span class="cm">	 * vma, merges and splits can happen in a seamless way, just</span>
<span class="cm">	 * using the existing file pgoff checks and manipulations.</span>
<span class="cm">	 * Similarly in do_mmap_pgoff and in do_brk.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">);</span>
		<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">__vma</span> <span class="o">=</span> <span class="n">find_vma_prepare</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span><span class="o">&amp;</span><span class="n">prev</span><span class="p">,</span><span class="o">&amp;</span><span class="n">rb_link</span><span class="p">,</span><span class="o">&amp;</span><span class="n">rb_parent</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__vma</span> <span class="o">&amp;&amp;</span> <span class="n">__vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&lt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_ACCOUNT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="n">security_vm_enough_memory_mm</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma_pages</span><span class="p">(</span><span class="n">vma</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span> <span class="o">&amp;&amp;</span> <span class="n">uprobe_mmap</span><span class="p">(</span><span class="n">vma</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">vma_link</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">rb_link</span><span class="p">,</span> <span class="n">rb_parent</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Copy the vma structure to a new location in the same mm,</span>
<span class="cm"> * prior to moving page table entries, to effect an mremap move.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="nf">copy_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">**</span><span class="n">vmap</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">pgoff</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span> <span class="o">=</span> <span class="o">*</span><span class="n">vmap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vma_start</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">new_vma</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">rb_link</span><span class="p">,</span> <span class="o">*</span><span class="n">rb_parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">pol</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">faulted_in_anon_vma</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If anonymous vma has not yet been faulted, update new pgoff</span>
<span class="cm">	 * to match new location, to increase its chance of merging.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pgoff</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="n">faulted_in_anon_vma</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">find_vma_prepare</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rb_link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rb_parent</span><span class="p">);</span>
	<span class="n">new_vma</span> <span class="o">=</span> <span class="n">vma_merge</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span><span class="p">,</span>
			<span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">,</span> <span class="n">pgoff</span><span class="p">,</span> <span class="n">vma_policy</span><span class="p">(</span><span class="n">vma</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_vma</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Source vma may have been merged into new_vma</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">vma_start</span> <span class="o">&gt;=</span> <span class="n">new_vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&amp;&amp;</span>
			     <span class="n">vma_start</span> <span class="o">&lt;</span> <span class="n">new_vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The only way we can get a vma_merge with</span>
<span class="cm">			 * self during an mremap is if the vma hasn&#39;t</span>
<span class="cm">			 * been faulted in yet and we were allowed to</span>
<span class="cm">			 * reset the dst vma-&gt;vm_pgoff to the</span>
<span class="cm">			 * destination address of the mremap to allow</span>
<span class="cm">			 * the merge to happen. mremap must change the</span>
<span class="cm">			 * vm_pgoff linearity between src and dst vmas</span>
<span class="cm">			 * (in turn preventing a vma_merge) to be</span>
<span class="cm">			 * safe. It is only safe to keep the vm_pgoff</span>
<span class="cm">			 * linear if there are no pages mapped yet.</span>
<span class="cm">			 */</span>
			<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">faulted_in_anon_vma</span><span class="p">);</span>
			<span class="o">*</span><span class="n">vmap</span> <span class="o">=</span> <span class="n">new_vma</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">anon_vma_moveto_tail</span><span class="p">(</span><span class="n">new_vma</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">new_vma</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">vm_area_cachep</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_vma</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">new_vma</span> <span class="o">=</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
			<span class="n">pol</span> <span class="o">=</span> <span class="n">mpol_dup</span><span class="p">(</span><span class="n">vma_policy</span><span class="p">(</span><span class="n">vma</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">pol</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out_free_vma</span><span class="p">;</span>
			<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_vma</span><span class="o">-&gt;</span><span class="n">anon_vma_chain</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">anon_vma_clone</span><span class="p">(</span><span class="n">new_vma</span><span class="p">,</span> <span class="n">vma</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out_free_mempol</span><span class="p">;</span>
			<span class="n">vma_set_policy</span><span class="p">(</span><span class="n">new_vma</span><span class="p">,</span> <span class="n">pol</span><span class="p">);</span>
			<span class="n">new_vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
			<span class="n">new_vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">new_vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">=</span> <span class="n">pgoff</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">new_vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">get_file</span><span class="p">(</span><span class="n">new_vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">uprobe_mmap</span><span class="p">(</span><span class="n">new_vma</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">out_free_mempol</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_EXECUTABLE</span><span class="p">)</span>
					<span class="n">added_exe_file_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">new_vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">&amp;&amp;</span> <span class="n">new_vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="o">-&gt;</span><span class="n">open</span><span class="p">)</span>
				<span class="n">new_vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="o">-&gt;</span><span class="n">open</span><span class="p">(</span><span class="n">new_vma</span><span class="p">);</span>
			<span class="n">vma_link</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">new_vma</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">rb_link</span><span class="p">,</span> <span class="n">rb_parent</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">new_vma</span><span class="p">;</span>

 <span class="nl">out_free_mempol:</span>
	<span class="n">mpol_put</span><span class="p">(</span><span class="n">pol</span><span class="p">);</span>
 <span class="nl">out_free_vma:</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">vm_area_cachep</span><span class="p">,</span> <span class="n">new_vma</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return true if the calling process may expand its vm space by the passed</span>
<span class="cm"> * number of pages</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">may_expand_vm</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">npages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">total_vm</span><span class="p">;</span>	<span class="cm">/* pages */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lim</span><span class="p">;</span>

	<span class="n">lim</span> <span class="o">=</span> <span class="n">rlimit</span><span class="p">(</span><span class="n">RLIMIT_AS</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cur</span> <span class="o">+</span> <span class="n">npages</span> <span class="o">&gt;</span> <span class="n">lim</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">special_mapping_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgoff_t</span> <span class="n">pgoff</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * special mappings have no vm_file, and in that case, the mm</span>
<span class="cm">	 * uses vm_pgoff internally. So we have to subtract it from here.</span>
<span class="cm">	 * We are allowed to do this because we are the mm; do not copy</span>
<span class="cm">	 * this code into drivers!</span>
<span class="cm">	 */</span>
	<span class="n">pgoff</span> <span class="o">=</span> <span class="n">vmf</span><span class="o">-&gt;</span><span class="n">pgoff</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pages</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_private_data</span><span class="p">;</span> <span class="n">pgoff</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">pages</span><span class="p">;</span> <span class="o">++</span><span class="n">pages</span><span class="p">)</span>
		<span class="n">pgoff</span><span class="o">--</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="o">*</span><span class="n">pages</span><span class="p">;</span>
		<span class="n">get_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">vmf</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">VM_FAULT_SIGBUS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Having a close hook prevents vma merging regardless of flags.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">special_mapping_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">vm_operations_struct</span> <span class="n">special_mapping_vmops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">close</span> <span class="o">=</span> <span class="n">special_mapping_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fault</span> <span class="o">=</span> <span class="n">special_mapping_fault</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Called with mm-&gt;mmap_sem held for writing.</span>
<span class="cm"> * Insert a new vma covering the given region, with the given flags.</span>
<span class="cm"> * Its pages are supplied by the given array of struct page *.</span>
<span class="cm"> * The array can be shorter than len &gt;&gt; PAGE_SHIFT if it&#39;s null-terminated.</span>
<span class="cm"> * The region past the last page supplied will always produce SIGBUS.</span>
<span class="cm"> * The array pointer and the pages it points to are assumed to stay alive</span>
<span class="cm"> * for as long as this mapping might exist.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">install_special_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vm_flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>

	<span class="n">vma</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">vm_area_cachep</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">vma</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma_chain</span><span class="p">);</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span> <span class="o">=</span> <span class="n">mm</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">=</span> <span class="n">vm_flags</span> <span class="o">|</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">def_flags</span> <span class="o">|</span> <span class="n">VM_DONTEXPAND</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span> <span class="o">=</span> <span class="n">vm_get_page_prot</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span><span class="p">);</span>

	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">special_mapping_vmops</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_private_data</span> <span class="o">=</span> <span class="n">pages</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">insert_vm_struct</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">total_vm</span> <span class="o">+=</span> <span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="n">perf_event_mmap</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">vm_area_cachep</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">mm_all_locks_mutex</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vm_lock_anon_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">next</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The LSB of head.next can&#39;t change from under us</span>
<span class="cm">		 * because we hold the mm_all_locks_mutex.</span>
<span class="cm">		 */</span>
		<span class="n">mutex_lock_nest_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * We can safely modify head.next after taking the</span>
<span class="cm">		 * anon_vma-&gt;root-&gt;mutex. If some other vma in this mm shares</span>
<span class="cm">		 * the same anon_vma we won&#39;t take it again.</span>
<span class="cm">		 *</span>
<span class="cm">		 * No need of atomic instructions here, head.next</span>
<span class="cm">		 * can&#39;t change from under us thanks to the</span>
<span class="cm">		 * anon_vma-&gt;root-&gt;mutex.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__test_and_set_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span>
				       <span class="o">&amp;</span><span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">next</span><span class="p">))</span>
			<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vm_lock_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">AS_MM_ALL_LOCKS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * AS_MM_ALL_LOCKS can&#39;t change from under us because</span>
<span class="cm">		 * we hold the mm_all_locks_mutex.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Operations on -&gt;flags have to be atomic because</span>
<span class="cm">		 * even if AS_MM_ALL_LOCKS is stable thanks to the</span>
<span class="cm">		 * mm_all_locks_mutex, there may be other cpus</span>
<span class="cm">		 * changing other bitflags in parallel to us.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">AS_MM_ALL_LOCKS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="n">mutex_lock_nest_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_mutex</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This operation locks against the VM for all pte/vma/mm related</span>
<span class="cm"> * operations that could ever happen on a certain mm. This includes</span>
<span class="cm"> * vmtruncate, try_to_unmap, and all page faults.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must take the mmap_sem in write mode before calling</span>
<span class="cm"> * mm_take_all_locks(). The caller isn&#39;t allowed to release the</span>
<span class="cm"> * mmap_sem until mm_drop_all_locks() returns.</span>
<span class="cm"> *</span>
<span class="cm"> * mmap_sem in write mode is required in order to block all operations</span>
<span class="cm"> * that could modify pagetables and free pages without need of</span>
<span class="cm"> * altering the vma layout (for example populate_range() with</span>
<span class="cm"> * nonlinear vmas). It&#39;s also needed in write mode to avoid new</span>
<span class="cm"> * anon_vmas to be associated with existing vmas.</span>
<span class="cm"> *</span>
<span class="cm"> * A single task can&#39;t take more than one mm_take_all_locks() in a row</span>
<span class="cm"> * or it would deadlock.</span>
<span class="cm"> *</span>
<span class="cm"> * The LSB in anon_vma-&gt;head.next and the AS_MM_ALL_LOCKS bitflag in</span>
<span class="cm"> * mapping-&gt;flags avoid to take the same lock twice, if more than one</span>
<span class="cm"> * vma in this mm is backed by the same anon_vma or address_space.</span>
<span class="cm"> *</span>
<span class="cm"> * We can take all the locks in random order because the VM code</span>
<span class="cm"> * taking i_mmap_mutex or anon_vma-&gt;mutex outside the mmap_sem never</span>
<span class="cm"> * takes more than one of them in a row. Secondly we&#39;re protected</span>
<span class="cm"> * against a concurrent mm_take_all_locks() by the mm_all_locks_mutex.</span>
<span class="cm"> *</span>
<span class="cm"> * mm_take_all_locks() and mm_drop_all_locks are expensive operations</span>
<span class="cm"> * that may have to take thousand of locks.</span>
<span class="cm"> *</span>
<span class="cm"> * mm_take_all_locks() can fail if it&#39;s interrupted by signals.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">mm_take_all_locks</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">anon_vma_chain</span> <span class="o">*</span><span class="n">avc</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">down_read_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">));</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm_all_locks_mutex</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">vma</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">;</span> <span class="n">vma</span><span class="p">;</span> <span class="n">vma</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span> <span class="o">&amp;&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">)</span>
			<span class="n">vm_lock_mapping</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">vma</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">;</span> <span class="n">vma</span><span class="p">;</span> <span class="n">vma</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">)</span>
			<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">avc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma_chain</span><span class="p">,</span> <span class="n">same_vma</span><span class="p">)</span>
				<span class="n">vm_lock_anon_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">avc</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_unlock:</span>
	<span class="n">mm_drop_all_locks</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vm_unlock_anon_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">next</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The LSB of head.next can&#39;t change to 0 from under</span>
<span class="cm">		 * us because we hold the mm_all_locks_mutex.</span>
<span class="cm">		 *</span>
<span class="cm">		 * We must however clear the bitflag before unlocking</span>
<span class="cm">		 * the vma so the users using the anon_vma-&gt;head will</span>
<span class="cm">		 * never see our bitflag.</span>
<span class="cm">		 *</span>
<span class="cm">		 * No need of atomic instructions here, head.next</span>
<span class="cm">		 * can&#39;t change from under us until we release the</span>
<span class="cm">		 * anon_vma-&gt;root-&gt;mutex.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__test_and_clear_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span>
					  <span class="o">&amp;</span><span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">next</span><span class="p">))</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="n">anon_vma_unlock</span><span class="p">(</span><span class="n">anon_vma</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vm_unlock_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">AS_MM_ALL_LOCKS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * AS_MM_ALL_LOCKS can&#39;t change to 0 from under us</span>
<span class="cm">		 * because we hold the mm_all_locks_mutex.</span>
<span class="cm">		 */</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">AS_MM_ALL_LOCKS</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The mmap_sem cannot be released by the caller until</span>
<span class="cm"> * mm_drop_all_locks() returns.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">mm_drop_all_locks</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">anon_vma_chain</span> <span class="o">*</span><span class="n">avc</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">down_read_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm_all_locks_mutex</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">vma</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">;</span> <span class="n">vma</span><span class="p">;</span> <span class="n">vma</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">)</span>
			<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">avc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma_chain</span><span class="p">,</span> <span class="n">same_vma</span><span class="p">)</span>
				<span class="n">vm_unlock_anon_vma</span><span class="p">(</span><span class="n">avc</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span> <span class="o">&amp;&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">)</span>
			<span class="n">vm_unlock_mapping</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm_all_locks_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * initialise the VMA slab</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">mmap_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">percpu_counter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vm_committed_as</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
