<!DOCTYPE html>
<html><head><title>joekychen/linux » mm › mempolicy.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>mempolicy.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Simple NUMA memory policy for the Linux kernel.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2003,2004 Andi Kleen, SuSE Labs.</span>
<span class="cm"> * (C) Copyright 2005 Christoph Lameter, Silicon Graphics, Inc.</span>
<span class="cm"> * Subject to the GNU Public License, version 2.</span>
<span class="cm"> *</span>
<span class="cm"> * NUMA policy allows the user to give hints in which node(s) memory should</span>
<span class="cm"> * be allocated.</span>
<span class="cm"> *</span>
<span class="cm"> * Support four policies per VMA and per process:</span>
<span class="cm"> *</span>
<span class="cm"> * The VMA policy has priority over the process policy for a page fault.</span>
<span class="cm"> *</span>
<span class="cm"> * interleave     Allocate memory interleaved over a set of nodes,</span>
<span class="cm"> *                with normal fallback if it fails.</span>
<span class="cm"> *                For VMA based allocations this interleaves based on the</span>
<span class="cm"> *                offset into the backing object or offset into the mapping</span>
<span class="cm"> *                for anonymous memory. For process policy an process counter</span>
<span class="cm"> *                is used.</span>
<span class="cm"> *</span>
<span class="cm"> * bind           Only allocate memory on a specific set of nodes,</span>
<span class="cm"> *                no fallback.</span>
<span class="cm"> *                FIXME: memory is allocated starting with the first node</span>
<span class="cm"> *                to the last. It would be better if bind would truly restrict</span>
<span class="cm"> *                the allocation to memory nodes instead</span>
<span class="cm"> *</span>
<span class="cm"> * preferred       Try a specific node first before normal fallback.</span>
<span class="cm"> *                As a special case node -1 here means do the allocation</span>
<span class="cm"> *                on the local CPU. This is normally identical to default,</span>
<span class="cm"> *                but useful to set in a VMA when you have a non default</span>
<span class="cm"> *                process policy.</span>
<span class="cm"> *</span>
<span class="cm"> * default        Allocate on the local node first, or when on a VMA</span>
<span class="cm"> *                use the process policy. This is what Linux always did</span>
<span class="cm"> *		  in a NUMA aware kernel and still does by, ahem, default.</span>
<span class="cm"> *</span>
<span class="cm"> * The process policy is applied for most non interrupt memory allocations</span>
<span class="cm"> * in that process&#39; context. Interrupts ignore the policies and always</span>
<span class="cm"> * try to allocate on the local CPU. The VMA policy is only applied for memory</span>
<span class="cm"> * allocations for a VMA in the VM.</span>
<span class="cm"> *</span>
<span class="cm"> * Currently there are a few corner cases in swapping where the policy</span>
<span class="cm"> * is not applied, but the majority should be handled. When process policy</span>
<span class="cm"> * is used it is not remembered over swap outs/swap ins.</span>
<span class="cm"> *</span>
<span class="cm"> * Only the highest zone in the zone hierarchy gets policied. Allocations</span>
<span class="cm"> * requesting a lower zone just use default policy. This implies that</span>
<span class="cm"> * on systems with highmem kernel lowmem allocation don&#39;t get policied.</span>
<span class="cm"> * Same with GFP_DMA allocations.</span>
<span class="cm"> *</span>
<span class="cm"> * For shmfs/tmpfs/hugetlbfs shared memory the policy is shared between</span>
<span class="cm"> * all users and remembered even when nobody has memory mapped.</span>
<span class="cm"> */</span>

<span class="cm">/* Notebook:</span>
<span class="cm">   fix mmap readahead to honour policy and enable policy for any page cache</span>
<span class="cm">   object</span>
<span class="cm">   statistics for bigpages</span>
<span class="cm">   global policy for page cache? currently it uses process policy. Requires</span>
<span class="cm">   first item above.</span>
<span class="cm">   handle mremap for shared memory (currently ignored for the policy)</span>
<span class="cm">   grows down?</span>
<span class="cm">   make bind policy root only? It can trigger oom much faster and the</span>
<span class="cm">   kernel is not always grateful with that.</span>
<span class="cm">*/</span>

<span class="cp">#include &lt;linux/mempolicy.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/hugetlb.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/nodemask.h&gt;</span>
<span class="cp">#include &lt;linux/cpuset.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/nsproxy.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/compat.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/migrate.h&gt;</span>
<span class="cp">#include &lt;linux/ksm.h&gt;</span>
<span class="cp">#include &lt;linux/rmap.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/mm_inline.h&gt;</span>

<span class="cp">#include &lt;asm/tlbflush.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/random.h&gt;</span>

<span class="cp">#include &quot;internal.h&quot;</span>

<span class="cm">/* Internal flags */</span>
<span class="cp">#define MPOL_MF_DISCONTIG_OK (MPOL_MF_INTERNAL &lt;&lt; 0)	</span><span class="cm">/* Skip checks for continuous vmas */</span><span class="cp"></span>
<span class="cp">#define MPOL_MF_INVERT (MPOL_MF_INTERNAL &lt;&lt; 1)		</span><span class="cm">/* Invert check for nodemask */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">policy_cache</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">sn_cache</span><span class="p">;</span>

<span class="cm">/* Highest zone. An specific allocation for a zone below that is not</span>
<span class="cm">   policied. */</span>
<span class="k">enum</span> <span class="n">zone_type</span> <span class="n">policy_zone</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * run-time system-wide default policy =&gt; local allocation</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">mempolicy</span> <span class="n">default_policy</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">refcnt</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="cm">/* never free it */</span>
	<span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">MPOL_PREFERRED</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">MPOL_F_LOCAL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">mempolicy_operations</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">create</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">pol</span><span class="p">,</span> <span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodes</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If read-side task has no lock to protect task-&gt;mempolicy, write-side</span>
<span class="cm">	 * task will rebind the task-&gt;mempolicy by two step. The first step is</span>
<span class="cm">	 * setting all the newly nodes, and the second step is cleaning all the</span>
<span class="cm">	 * disallowed nodes. In this way, we can avoid finding no node to alloc</span>
<span class="cm">	 * page.</span>
<span class="cm">	 * If we have a lock to protect task-&gt;mempolicy in read-side, we do</span>
<span class="cm">	 * rebind directly.</span>
<span class="cm">	 *</span>
<span class="cm">	 * step:</span>
<span class="cm">	 * 	MPOL_REBIND_ONCE - do rebind work at once</span>
<span class="cm">	 * 	MPOL_REBIND_STEP1 - set all the newly nodes</span>
<span class="cm">	 * 	MPOL_REBIND_STEP2 - clean all the disallowed nodes</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">rebind</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">pol</span><span class="p">,</span> <span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodes</span><span class="p">,</span>
			<span class="k">enum</span> <span class="n">mpol_rebind_step</span> <span class="n">step</span><span class="p">);</span>
<span class="p">}</span> <span class="n">mpol_ops</span><span class="p">[</span><span class="n">MPOL_MAX</span><span class="p">];</span>

<span class="cm">/* Check that the nodemask contains at least one populated zone */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_valid_nodemask</span><span class="p">(</span><span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodemask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nd</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>

	<span class="n">for_each_node_mask</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="o">*</span><span class="n">nodemask</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">z</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">policy_zone</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">z</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nd</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">node_zones</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">z</span><span class="o">-&gt;</span><span class="n">present_pages</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mpol_store_user_nodemask</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">pol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pol</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MPOL_MODE_FLAGS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mpol_relative_nodemask</span><span class="p">(</span><span class="n">nodemask_t</span> <span class="o">*</span><span class="n">ret</span><span class="p">,</span> <span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">orig</span><span class="p">,</span>
				   <span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">rel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nodemask_t</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="n">nodes_fold</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">*</span><span class="n">orig</span><span class="p">,</span> <span class="n">nodes_weight</span><span class="p">(</span><span class="o">*</span><span class="n">rel</span><span class="p">));</span>
	<span class="n">nodes_onto</span><span class="p">(</span><span class="o">*</span><span class="n">ret</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">*</span><span class="n">rel</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mpol_new_interleave</span><span class="p">(</span><span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">pol</span><span class="p">,</span> <span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nodes_empty</span><span class="p">(</span><span class="o">*</span><span class="n">nodes</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">pol</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="o">*</span><span class="n">nodes</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mpol_new_preferred</span><span class="p">(</span><span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">pol</span><span class="p">,</span> <span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nodes</span><span class="p">)</span>
		<span class="n">pol</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">MPOL_F_LOCAL</span><span class="p">;</span>	<span class="cm">/* local allocation */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nodes_empty</span><span class="p">(</span><span class="o">*</span><span class="n">nodes</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>			<span class="cm">/*  no allowed nodes */</span>
	<span class="k">else</span>
		<span class="n">pol</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">preferred_node</span> <span class="o">=</span> <span class="n">first_node</span><span class="p">(</span><span class="o">*</span><span class="n">nodes</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mpol_new_bind</span><span class="p">(</span><span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">pol</span><span class="p">,</span> <span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_valid_nodemask</span><span class="p">(</span><span class="n">nodes</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">pol</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="o">*</span><span class="n">nodes</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * mpol_set_nodemask is called after mpol_new() to set up the nodemask, if</span>
<span class="cm"> * any, for the new policy.  mpol_new() has already validated the nodes</span>
<span class="cm"> * parameter with respect to the policy mode and flags.  But, we need to</span>
<span class="cm"> * handle an empty nodemask with MPOL_PREFERRED here.</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called holding task&#39;s alloc_lock to protect task&#39;s mems_allowed</span>
<span class="cm"> * and mempolicy.  May also be called holding the mmap_semaphore for write.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mpol_set_nodemask</span><span class="p">(</span><span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">pol</span><span class="p">,</span>
		     <span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodes</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nodemask_scratch</span> <span class="o">*</span><span class="n">nsc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* if mode is MPOL_DEFAULT, pol is NULL. This is right. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pol</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Check N_HIGH_MEMORY */</span>
	<span class="n">nodes_and</span><span class="p">(</span><span class="n">nsc</span><span class="o">-&gt;</span><span class="n">mask1</span><span class="p">,</span>
		  <span class="n">cpuset_current_mems_allowed</span><span class="p">,</span> <span class="n">node_states</span><span class="p">[</span><span class="n">N_HIGH_MEMORY</span><span class="p">]);</span>

	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">nodes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pol</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MPOL_PREFERRED</span> <span class="o">&amp;&amp;</span> <span class="n">nodes_empty</span><span class="p">(</span><span class="o">*</span><span class="n">nodes</span><span class="p">))</span>
		<span class="n">nodes</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* explicit local allocation */</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pol</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MPOL_F_RELATIVE_NODES</span><span class="p">)</span>
			<span class="n">mpol_relative_nodemask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nsc</span><span class="o">-&gt;</span><span class="n">mask2</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span><span class="o">&amp;</span><span class="n">nsc</span><span class="o">-&gt;</span><span class="n">mask1</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">nodes_and</span><span class="p">(</span><span class="n">nsc</span><span class="o">-&gt;</span><span class="n">mask2</span><span class="p">,</span> <span class="o">*</span><span class="n">nodes</span><span class="p">,</span> <span class="n">nsc</span><span class="o">-&gt;</span><span class="n">mask1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mpol_store_user_nodemask</span><span class="p">(</span><span class="n">pol</span><span class="p">))</span>
			<span class="n">pol</span><span class="o">-&gt;</span><span class="n">w</span><span class="p">.</span><span class="n">user_nodemask</span> <span class="o">=</span> <span class="o">*</span><span class="n">nodes</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">pol</span><span class="o">-&gt;</span><span class="n">w</span><span class="p">.</span><span class="n">cpuset_mems_allowed</span> <span class="o">=</span>
						<span class="n">cpuset_current_mems_allowed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">mpol_ops</span><span class="p">[</span><span class="n">pol</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">].</span><span class="n">create</span><span class="p">(</span><span class="n">pol</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nsc</span><span class="o">-&gt;</span><span class="n">mask2</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">mpol_ops</span><span class="p">[</span><span class="n">pol</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">].</span><span class="n">create</span><span class="p">(</span><span class="n">pol</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function just creates a new policy, does some check and simple</span>
<span class="cm"> * initialization. You must invoke mpol_set_nodemask() to set nodes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="nf">mpol_new</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">flags</span><span class="p">,</span>
				  <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">policy</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;setting mode %d flags %d nodes[0] %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">mode</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">nodes</span> <span class="o">?</span> <span class="n">nodes_addr</span><span class="p">(</span><span class="o">*</span><span class="n">nodes</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MPOL_DEFAULT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nodes</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">nodes_empty</span><span class="p">(</span><span class="o">*</span><span class="n">nodes</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* simply delete any existing policy */</span>
	<span class="p">}</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">nodes</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * MPOL_PREFERRED cannot be used with MPOL_F_STATIC_NODES or</span>
<span class="cm">	 * MPOL_F_RELATIVE_NODES if the nodemask is empty (local allocation).</span>
<span class="cm">	 * All other modes require a valid pointer to a non-empty nodemask.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MPOL_PREFERRED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nodes_empty</span><span class="p">(</span><span class="o">*</span><span class="n">nodes</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MPOL_F_STATIC_NODES</span><span class="p">)</span> <span class="o">||</span>
			     <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MPOL_F_RELATIVE_NODES</span><span class="p">)))</span>
				<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nodes_empty</span><span class="p">(</span><span class="o">*</span><span class="n">nodes</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="n">policy</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">policy_cache</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">policy</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">policy</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
	<span class="n">policy</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">policy</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Slow path of a mpol destructor. */</span>
<span class="kt">void</span> <span class="nf">__mpol_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">policy_cache</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mpol_rebind_default</span><span class="p">(</span><span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">pol</span><span class="p">,</span> <span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodes</span><span class="p">,</span>
				<span class="k">enum</span> <span class="n">mpol_rebind_step</span> <span class="n">step</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * step:</span>
<span class="cm"> * 	MPOL_REBIND_ONCE  - do rebind work at once</span>
<span class="cm"> * 	MPOL_REBIND_STEP1 - set all the newly nodes</span>
<span class="cm"> * 	MPOL_REBIND_STEP2 - clean all the disallowed nodes</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mpol_rebind_nodemask</span><span class="p">(</span><span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">pol</span><span class="p">,</span> <span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodes</span><span class="p">,</span>
				 <span class="k">enum</span> <span class="n">mpol_rebind_step</span> <span class="n">step</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nodemask_t</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pol</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MPOL_F_STATIC_NODES</span><span class="p">)</span>
		<span class="n">nodes_and</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">pol</span><span class="o">-&gt;</span><span class="n">w</span><span class="p">.</span><span class="n">user_nodemask</span><span class="p">,</span> <span class="o">*</span><span class="n">nodes</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pol</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MPOL_F_RELATIVE_NODES</span><span class="p">)</span>
		<span class="n">mpol_relative_nodemask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pol</span><span class="o">-&gt;</span><span class="n">w</span><span class="p">.</span><span class="n">user_nodemask</span><span class="p">,</span> <span class="n">nodes</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * if step == 1, we use -&gt;w.cpuset_mems_allowed to cache the</span>
<span class="cm">		 * result</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">step</span> <span class="o">==</span> <span class="n">MPOL_REBIND_ONCE</span> <span class="o">||</span> <span class="n">step</span> <span class="o">==</span> <span class="n">MPOL_REBIND_STEP1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nodes_remap</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">pol</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">nodes</span><span class="p">,</span>
					<span class="n">pol</span><span class="o">-&gt;</span><span class="n">w</span><span class="p">.</span><span class="n">cpuset_mems_allowed</span><span class="p">,</span> <span class="o">*</span><span class="n">nodes</span><span class="p">);</span>
			<span class="n">pol</span><span class="o">-&gt;</span><span class="n">w</span><span class="p">.</span><span class="n">cpuset_mems_allowed</span> <span class="o">=</span> <span class="n">step</span> <span class="o">?</span> <span class="n">tmp</span> <span class="o">:</span> <span class="o">*</span><span class="n">nodes</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">step</span> <span class="o">==</span> <span class="n">MPOL_REBIND_STEP2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">pol</span><span class="o">-&gt;</span><span class="n">w</span><span class="p">.</span><span class="n">cpuset_mems_allowed</span><span class="p">;</span>
			<span class="n">pol</span><span class="o">-&gt;</span><span class="n">w</span><span class="p">.</span><span class="n">cpuset_mems_allowed</span> <span class="o">=</span> <span class="o">*</span><span class="n">nodes</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nodes_empty</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">nodes</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">step</span> <span class="o">==</span> <span class="n">MPOL_REBIND_STEP1</span><span class="p">)</span>
		<span class="n">nodes_or</span><span class="p">(</span><span class="n">pol</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">pol</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">step</span> <span class="o">==</span> <span class="n">MPOL_REBIND_ONCE</span> <span class="o">||</span> <span class="n">step</span> <span class="o">==</span> <span class="n">MPOL_REBIND_STEP2</span><span class="p">)</span>
		<span class="n">pol</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node_isset</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">il_next</span><span class="p">,</span> <span class="n">tmp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">il_next</span> <span class="o">=</span> <span class="n">next_node</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">il_next</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">il_next</span> <span class="o">&gt;=</span> <span class="n">MAX_NUMNODES</span><span class="p">)</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">il_next</span> <span class="o">=</span> <span class="n">first_node</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">il_next</span> <span class="o">&gt;=</span> <span class="n">MAX_NUMNODES</span><span class="p">)</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">il_next</span> <span class="o">=</span> <span class="n">numa_node_id</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mpol_rebind_preferred</span><span class="p">(</span><span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">pol</span><span class="p">,</span>
				  <span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodes</span><span class="p">,</span>
				  <span class="k">enum</span> <span class="n">mpol_rebind_step</span> <span class="n">step</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nodemask_t</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pol</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MPOL_F_STATIC_NODES</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">node</span> <span class="o">=</span> <span class="n">first_node</span><span class="p">(</span><span class="n">pol</span><span class="o">-&gt;</span><span class="n">w</span><span class="p">.</span><span class="n">user_nodemask</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">node_isset</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">*</span><span class="n">nodes</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pol</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">preferred_node</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
			<span class="n">pol</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MPOL_F_LOCAL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">pol</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">MPOL_F_LOCAL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pol</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MPOL_F_RELATIVE_NODES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mpol_relative_nodemask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pol</span><span class="o">-&gt;</span><span class="n">w</span><span class="p">.</span><span class="n">user_nodemask</span><span class="p">,</span> <span class="n">nodes</span><span class="p">);</span>
		<span class="n">pol</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">preferred_node</span> <span class="o">=</span> <span class="n">first_node</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pol</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MPOL_F_LOCAL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pol</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">preferred_node</span> <span class="o">=</span> <span class="n">node_remap</span><span class="p">(</span><span class="n">pol</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">preferred_node</span><span class="p">,</span>
						   <span class="n">pol</span><span class="o">-&gt;</span><span class="n">w</span><span class="p">.</span><span class="n">cpuset_mems_allowed</span><span class="p">,</span>
						   <span class="o">*</span><span class="n">nodes</span><span class="p">);</span>
		<span class="n">pol</span><span class="o">-&gt;</span><span class="n">w</span><span class="p">.</span><span class="n">cpuset_mems_allowed</span> <span class="o">=</span> <span class="o">*</span><span class="n">nodes</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * mpol_rebind_policy - Migrate a policy to a different set of nodes</span>
<span class="cm"> *</span>
<span class="cm"> * If read-side task has no lock to protect task-&gt;mempolicy, write-side</span>
<span class="cm"> * task will rebind the task-&gt;mempolicy by two step. The first step is</span>
<span class="cm"> * setting all the newly nodes, and the second step is cleaning all the</span>
<span class="cm"> * disallowed nodes. In this way, we can avoid finding no node to alloc</span>
<span class="cm"> * page.</span>
<span class="cm"> * If we have a lock to protect task-&gt;mempolicy in read-side, we do</span>
<span class="cm"> * rebind directly.</span>
<span class="cm"> *</span>
<span class="cm"> * step:</span>
<span class="cm"> * 	MPOL_REBIND_ONCE  - do rebind work at once</span>
<span class="cm"> * 	MPOL_REBIND_STEP1 - set all the newly nodes</span>
<span class="cm"> * 	MPOL_REBIND_STEP2 - clean all the disallowed nodes</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mpol_rebind_policy</span><span class="p">(</span><span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">pol</span><span class="p">,</span> <span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">newmask</span><span class="p">,</span>
				<span class="k">enum</span> <span class="n">mpol_rebind_step</span> <span class="n">step</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pol</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mpol_store_user_nodemask</span><span class="p">(</span><span class="n">pol</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">step</span> <span class="o">==</span> <span class="n">MPOL_REBIND_ONCE</span> <span class="o">&amp;&amp;</span>
	    <span class="n">nodes_equal</span><span class="p">(</span><span class="n">pol</span><span class="o">-&gt;</span><span class="n">w</span><span class="p">.</span><span class="n">cpuset_mems_allowed</span><span class="p">,</span> <span class="o">*</span><span class="n">newmask</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">step</span> <span class="o">==</span> <span class="n">MPOL_REBIND_STEP1</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pol</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MPOL_F_REBINDING</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">step</span> <span class="o">==</span> <span class="n">MPOL_REBIND_STEP2</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">pol</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MPOL_F_REBINDING</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">step</span> <span class="o">==</span> <span class="n">MPOL_REBIND_STEP1</span><span class="p">)</span>
		<span class="n">pol</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">MPOL_F_REBINDING</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">step</span> <span class="o">==</span> <span class="n">MPOL_REBIND_STEP2</span><span class="p">)</span>
		<span class="n">pol</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MPOL_F_REBINDING</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">step</span> <span class="o">&gt;=</span> <span class="n">MPOL_REBIND_NSTEP</span><span class="p">)</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="n">mpol_ops</span><span class="p">[</span><span class="n">pol</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">].</span><span class="n">rebind</span><span class="p">(</span><span class="n">pol</span><span class="p">,</span> <span class="n">newmask</span><span class="p">,</span> <span class="n">step</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Wrapper for mpol_rebind_policy() that just requires task</span>
<span class="cm"> * pointer, and updates task mempolicy.</span>
<span class="cm"> *</span>
<span class="cm"> * Called with task&#39;s alloc_lock held.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">mpol_rebind_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span>
			<span class="k">enum</span> <span class="n">mpol_rebind_step</span> <span class="n">step</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mpol_rebind_policy</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">mempolicy</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">step</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Rebind each vma in mm to new nodemask.</span>
<span class="cm"> *</span>
<span class="cm"> * Call holding a reference to mm.  Takes mm-&gt;mmap_sem during call.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">mpol_rebind_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">vma</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">;</span> <span class="n">vma</span><span class="p">;</span> <span class="n">vma</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">)</span>
		<span class="n">mpol_rebind_policy</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_policy</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">MPOL_REBIND_ONCE</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">mempolicy_operations</span> <span class="n">mpol_ops</span><span class="p">[</span><span class="n">MPOL_MAX</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">MPOL_DEFAULT</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">rebind</span> <span class="o">=</span> <span class="n">mpol_rebind_default</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">[</span><span class="n">MPOL_INTERLEAVE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">create</span> <span class="o">=</span> <span class="n">mpol_new_interleave</span><span class="p">,</span>
		<span class="p">.</span><span class="n">rebind</span> <span class="o">=</span> <span class="n">mpol_rebind_nodemask</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">[</span><span class="n">MPOL_PREFERRED</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">create</span> <span class="o">=</span> <span class="n">mpol_new_preferred</span><span class="p">,</span>
		<span class="p">.</span><span class="n">rebind</span> <span class="o">=</span> <span class="n">mpol_rebind_preferred</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">[</span><span class="n">MPOL_BIND</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">create</span> <span class="o">=</span> <span class="n">mpol_new_bind</span><span class="p">,</span>
		<span class="p">.</span><span class="n">rebind</span> <span class="o">=</span> <span class="n">mpol_rebind_nodemask</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">migrate_page_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pagelist</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>

<span class="cm">/* Scan through pages checking if pages follow certain conditions. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_pte_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
		<span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodes</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">private</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">orig_pte</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">ptl</span><span class="p">;</span>

	<span class="n">orig_pte</span> <span class="o">=</span> <span class="n">pte</span> <span class="o">=</span> <span class="n">pte_offset_map_lock</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptl</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">nid</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_present</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">vm_normal_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="o">*</span><span class="n">pte</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * vm_normal_page() filters out zero pages, but there might</span>
<span class="cm">		 * still be PageReserved pages to skip, perhaps in a VDSO.</span>
<span class="cm">		 * And we cannot move PageKsm pages sensibly or safely yet.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageReserved</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">||</span> <span class="n">PageKsm</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">nid</span> <span class="o">=</span> <span class="n">page_to_nid</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">node_isset</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="o">*</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="o">!!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MPOL_MF_INVERT</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MPOL_MF_MOVE</span> <span class="o">|</span> <span class="n">MPOL_MF_MOVE_ALL</span><span class="p">))</span>
			<span class="n">migrate_page_add</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">private</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">pte</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span>
	<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">orig_pte</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">check_pmd_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
		<span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodes</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">private</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next</span><span class="p">;</span>

	<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">pmd_addr_end</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="n">split_huge_page_pmd</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmd_none_or_trans_huge_or_clear_bad</span><span class="p">(</span><span class="n">pmd</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">check_pte_range</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span>
				    <span class="n">flags</span><span class="p">,</span> <span class="n">private</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">pmd</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">next</span><span class="p">,</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">check_pud_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
		<span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodes</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">private</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next</span><span class="p">;</span>

	<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">pud_addr_end</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pud_none_or_clear_bad</span><span class="p">(</span><span class="n">pud</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">check_pmd_range</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">pud</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span>
				    <span class="n">flags</span><span class="p">,</span> <span class="n">private</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">pud</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">next</span><span class="p">,</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">check_pgd_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
		<span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodes</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">private</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next</span><span class="p">;</span>

	<span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">pgd_addr_end</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pgd_none_or_clear_bad</span><span class="p">(</span><span class="n">pgd</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">check_pud_range</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">pgd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span>
				    <span class="n">flags</span><span class="p">,</span> <span class="n">private</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">pgd</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">next</span><span class="p">,</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check if all pages in a range are on a set of nodes.</span>
<span class="cm"> * If pagelist != NULL then isolate pages from the LRU and</span>
<span class="cm"> * put them on the pagelist.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span>
<span class="nf">check_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
		<span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodes</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">private</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">first</span><span class="p">,</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>


	<span class="n">first</span> <span class="o">=</span> <span class="n">find_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">first</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EFAULT</span><span class="p">);</span>
	<span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">vma</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span> <span class="n">vma</span> <span class="o">&amp;&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">vma</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MPOL_MF_DISCONTIG_OK</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span> <span class="o">&amp;&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EFAULT</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">&amp;&amp;</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">&lt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EFAULT</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_vm_hugetlb_page</span><span class="p">(</span><span class="n">vma</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MPOL_MF_STRICT</span><span class="p">)</span> <span class="o">||</span>
		     <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MPOL_MF_MOVE</span> <span class="o">|</span> <span class="n">MPOL_MF_MOVE_ALL</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
				<span class="n">vma_migratable</span><span class="p">(</span><span class="n">vma</span><span class="p">))))</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">endvma</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">endvma</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span>
				<span class="n">endvma</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">)</span>
				<span class="n">start</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">check_pgd_range</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">endvma</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span>
						<span class="n">flags</span><span class="p">,</span> <span class="n">private</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">first</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">vma</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">first</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Step 2: apply policy to a range and do splits. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mbind_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">new_pol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">pgoff</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vmstart</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vmend</span><span class="p">;</span>

	<span class="n">vma</span> <span class="o">=</span> <span class="n">find_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span> <span class="o">||</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">prev</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_prev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">vma</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">vma</span> <span class="o">&amp;&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">vma</span><span class="p">,</span> <span class="n">vma</span> <span class="o">=</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">;</span>
		<span class="n">vmstart</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">);</span>
		<span class="n">vmend</span>   <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mpol_equal</span><span class="p">(</span><span class="n">vma_policy</span><span class="p">(</span><span class="n">vma</span><span class="p">),</span> <span class="n">new_pol</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">pgoff</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">+</span>
			<span class="p">((</span><span class="n">vmstart</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">vma_merge</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">vmstart</span><span class="p">,</span> <span class="n">vmend</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span><span class="p">,</span>
				  <span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">,</span> <span class="n">pgoff</span><span class="p">,</span>
				  <span class="n">new_pol</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vma</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
			<span class="n">next</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">!=</span> <span class="n">vmstart</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">split_vma</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">vmstart</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">!=</span> <span class="n">vmend</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">split_vma</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">vmend</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Apply policy to a single VMA. The reference counting of</span>
<span class="cm">		 * policy for vma_policy linkages has already been handled by</span>
<span class="cm">		 * vma_merge and split_vma as necessary. If this is a shared</span>
<span class="cm">		 * policy then -&gt;set_policy will increment the reference count</span>
<span class="cm">		 * for an sp node.</span>
<span class="cm">		 */</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;vma %lx-%lx/%lx vm_ops %p vm_file %p set_policy %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span><span class="p">,</span>
			<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">,</span>
			<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">?</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="o">-&gt;</span><span class="n">set_policy</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">&amp;&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="o">-&gt;</span><span class="n">set_policy</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="o">-&gt;</span><span class="n">set_policy</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">new_pol</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Update task-&gt;flags PF_MEMPOLICY bit: set iff non-default</span>
<span class="cm"> * mempolicy.  Allows more rapid checking of this (combined perhaps</span>
<span class="cm"> * with other PF_* flag bits) on memory allocation hot code paths.</span>
<span class="cm"> *</span>
<span class="cm"> * If called from outside this file, the task &#39;p&#39; should -only- be</span>
<span class="cm"> * a newly forked child not yet visible on the task list, because</span>
<span class="cm"> * manipulating the task flags of a visible task is not safe.</span>
<span class="cm"> *</span>
<span class="cm"> * The above limitation is why this routine has the funny name</span>
<span class="cm"> * mpol_fix_fork_child_flag().</span>
<span class="cm"> *</span>
<span class="cm"> * It is also safe to call this with a task pointer of current,</span>
<span class="cm"> * which the static wrapper mpol_set_task_struct_flag() does,</span>
<span class="cm"> * for use within this file.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">mpol_fix_fork_child_flag</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mempolicy</span><span class="p">)</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PF_MEMPOLICY</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PF_MEMPOLICY</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mpol_set_task_struct_flag</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mpol_fix_fork_child_flag</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Set the process memory policy */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">do_set_mempolicy</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">flags</span><span class="p">,</span>
			     <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="o">*</span><span class="n">old</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="n">NODEMASK_SCRATCH</span><span class="p">(</span><span class="n">scratch</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scratch</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">new</span> <span class="o">=</span> <span class="n">mpol_new</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">nodes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">new</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * prevent changing our mempolicy while show_numa_maps()</span>
<span class="cm">	 * is using it.</span>
<span class="cm">	 * Note:  do_set_mempolicy() can be called at init time</span>
<span class="cm">	 * with no &#39;mm&#39;.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="p">)</span>
		<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="n">task_lock</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">mpol_set_nodemask</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">scratch</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">task_unlock</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="p">)</span>
			<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
		<span class="n">mpol_put</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">old</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mempolicy</span><span class="p">;</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">mempolicy</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
	<span class="n">mpol_set_task_struct_flag</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new</span> <span class="o">&amp;&amp;</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MPOL_INTERLEAVE</span> <span class="o">&amp;&amp;</span>
	    <span class="n">nodes_weight</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">nodes</span><span class="p">))</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">il_next</span> <span class="o">=</span> <span class="n">first_node</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">nodes</span><span class="p">);</span>
	<span class="n">task_unlock</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="p">)</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>

	<span class="n">mpol_put</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">NODEMASK_SCRATCH_FREE</span><span class="p">(</span><span class="n">scratch</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return nodemask for policy for get_mempolicy() query</span>
<span class="cm"> *</span>
<span class="cm"> * Called with task&#39;s alloc_lock held</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">get_policy_nodemask</span><span class="p">(</span><span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nodes_clear</span><span class="p">(</span><span class="o">*</span><span class="n">nodes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">default_policy</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MPOL_BIND</span>:
		<span class="cm">/* Fall through */</span>
	<span class="k">case</span> <span class="n">MPOL_INTERLEAVE</span>:
		<span class="o">*</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">nodes</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MPOL_PREFERRED</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MPOL_F_LOCAL</span><span class="p">))</span>
			<span class="n">node_set</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">preferred_node</span><span class="p">,</span> <span class="o">*</span><span class="n">nodes</span><span class="p">);</span>
		<span class="cm">/* else return empty node mask for local allocation */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">lookup_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">get_user_pages</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">addr</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">page_to_nid</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Retrieve NUMA policy */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">do_get_mempolicy</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">policy</span><span class="p">,</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nmask</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">pol</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mempolicy</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span>
		<span class="o">~</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">MPOL_F_NODE</span><span class="o">|</span><span class="n">MPOL_F_ADDR</span><span class="o">|</span><span class="n">MPOL_F_MEMS_ALLOWED</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MPOL_F_MEMS_ALLOWED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MPOL_F_NODE</span><span class="o">|</span><span class="n">MPOL_F_ADDR</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="o">*</span><span class="n">policy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* just so it&#39;s initialized */</span>
		<span class="n">task_lock</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
		<span class="o">*</span><span class="n">nmask</span>  <span class="o">=</span> <span class="n">cpuset_current_mems_allowed</span><span class="p">;</span>
		<span class="n">task_unlock</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MPOL_F_ADDR</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Do NOT fall back to task policy if the</span>
<span class="cm">		 * vma/shared policy at addr is NULL.  We</span>
<span class="cm">		 * want to return MPOL_DEFAULT in this case.</span>
<span class="cm">		 */</span>
		<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
		<span class="n">vma</span> <span class="o">=</span> <span class="n">find_vma_intersection</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">addr</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">&amp;&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="o">-&gt;</span><span class="n">get_policy</span><span class="p">)</span>
			<span class="n">pol</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="o">-&gt;</span><span class="n">get_policy</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">pol</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_policy</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pol</span><span class="p">)</span>
		<span class="n">pol</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">default_policy</span><span class="p">;</span>	<span class="cm">/* indicates default behavior */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MPOL_F_NODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MPOL_F_ADDR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">lookup_node</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="o">*</span><span class="n">policy</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pol</span> <span class="o">==</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mempolicy</span> <span class="o">&amp;&amp;</span>
				<span class="n">pol</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MPOL_INTERLEAVE</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">policy</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">il_next</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">policy</span> <span class="o">=</span> <span class="n">pol</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">default_policy</span> <span class="o">?</span> <span class="n">MPOL_DEFAULT</span> <span class="o">:</span>
						<span class="n">pol</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Internal mempolicy flags must be masked off before exposing</span>
<span class="cm">		 * the policy to userspace.</span>
<span class="cm">		 */</span>
		<span class="o">*</span><span class="n">policy</span> <span class="o">|=</span> <span class="p">(</span><span class="n">pol</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MPOL_MODE_FLAGS</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
		<span class="n">vma</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nmask</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mpol_store_user_nodemask</span><span class="p">(</span><span class="n">pol</span><span class="p">))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">nmask</span> <span class="o">=</span> <span class="n">pol</span><span class="o">-&gt;</span><span class="n">w</span><span class="p">.</span><span class="n">user_nodemask</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">task_lock</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
			<span class="n">get_policy_nodemask</span><span class="p">(</span><span class="n">pol</span><span class="p">,</span> <span class="n">nmask</span><span class="p">);</span>
			<span class="n">task_unlock</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

 <span class="nl">out:</span>
	<span class="n">mpol_cond_put</span><span class="p">(</span><span class="n">pol</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="p">)</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_MIGRATION</span>
<span class="cm">/*</span>
<span class="cm"> * page migration</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">migrate_page_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pagelist</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Avoid migrating a page that is shared with others.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MPOL_MF_MOVE_ALL</span><span class="p">)</span> <span class="o">||</span> <span class="n">page_mapcount</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isolate_lru_page</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="n">pagelist</span><span class="p">);</span>
			<span class="n">inc_zone_page_state</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">NR_ISOLATED_ANON</span> <span class="o">+</span>
					    <span class="n">page_is_file_cache</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">new_node_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="o">**</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">alloc_pages_exact_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">GFP_HIGHUSER_MOVABLE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Migrate pages from one node to a target node.</span>
<span class="cm"> * Returns error or the number of pages not migrated.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">migrate_to_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">source</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dest</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nodemask_t</span> <span class="n">nmask</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">pagelist</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>

	<span class="n">nodes_clear</span><span class="p">(</span><span class="n">nmask</span><span class="p">);</span>
	<span class="n">node_set</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">nmask</span><span class="p">);</span>

	<span class="n">vma</span> <span class="o">=</span> <span class="n">check_range</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">task_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nmask</span><span class="p">,</span>
			<span class="n">flags</span> <span class="o">|</span> <span class="n">MPOL_MF_DISCONTIG_OK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pagelist</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">vma</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pagelist</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">migrate_pages</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pagelist</span><span class="p">,</span> <span class="n">new_node_page</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span>
							<span class="nb">false</span><span class="p">,</span> <span class="n">MIGRATE_SYNC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="n">putback_lru_pages</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pagelist</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Move pages between the two nodesets so as to preserve the physical</span>
<span class="cm"> * layout as much as possible.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of page that could not be moved.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">do_migrate_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span>
		     <span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">busy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">nodemask_t</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">migrate_prep</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">migrate_vmas</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Find a &#39;source&#39; bit set in &#39;tmp&#39; whose corresponding &#39;dest&#39;</span>
<span class="cm">	 * bit in &#39;to&#39; is not also set in &#39;tmp&#39;.  Clear the found &#39;source&#39;</span>
<span class="cm">	 * bit in &#39;tmp&#39;, and return that &lt;source, dest&gt; pair for migration.</span>
<span class="cm">	 * The pair of nodemasks &#39;to&#39; and &#39;from&#39; define the map.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If no pair of bits is found that way, fallback to picking some</span>
<span class="cm">	 * pair of &#39;source&#39; and &#39;dest&#39; bits that are not the same.  If the</span>
<span class="cm">	 * &#39;source&#39; and &#39;dest&#39; bits are the same, this represents a node</span>
<span class="cm">	 * that will be migrating to itself, so no pages need move.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If no bits are left in &#39;tmp&#39;, or if all remaining bits left</span>
<span class="cm">	 * in &#39;tmp&#39; correspond to the same bit in &#39;to&#39;, return false</span>
<span class="cm">	 * (nothing left to migrate).</span>
<span class="cm">	 *</span>
<span class="cm">	 * This lets us pick a pair of nodes to migrate between, such that</span>
<span class="cm">	 * if possible the dest node is not already occupied by some other</span>
<span class="cm">	 * source node, minimizing the risk of overloading the memory on a</span>
<span class="cm">	 * node that would happen if we migrated incoming memory to a node</span>
<span class="cm">	 * before migrating outgoing memory source that same node.</span>
<span class="cm">	 *</span>
<span class="cm">	 * A single scan of tmp is sufficient.  As we go, we remember the</span>
<span class="cm">	 * most recent &lt;s, d&gt; pair that moved (s != d).  If we find a pair</span>
<span class="cm">	 * that not only moved, but what&#39;s better, moved to an empty slot</span>
<span class="cm">	 * (d is not set in tmp), then we break out then, with that pair.</span>
<span class="cm">	 * Otherwise when we finish scanning from_tmp, we at least have the</span>
<span class="cm">	 * most recent &lt;s, d&gt; pair that moved.  If we get all the way through</span>
<span class="cm">	 * the scan of tmp without finding any node that moved, much less</span>
<span class="cm">	 * moved to an empty node, then there is nothing left worth migrating.</span>
<span class="cm">	 */</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">from</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">nodes_empty</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">s</span><span class="p">,</span><span class="n">d</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">source</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">dest</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">for_each_node_mask</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/*</span>
<span class="cm">			 * do_migrate_pages() tries to maintain the relative</span>
<span class="cm">			 * node relationship of the pages established between</span>
<span class="cm">			 * threads and memory areas.</span>
<span class="cm">                         *</span>
<span class="cm">			 * However if the number of source nodes is not equal to</span>
<span class="cm">			 * the number of destination nodes we can not preserve</span>
<span class="cm">			 * this node relative relationship.  In that case, skip</span>
<span class="cm">			 * copying memory from a node that is in the destination</span>
<span class="cm">			 * mask.</span>
<span class="cm">			 *</span>
<span class="cm">			 * Example: [2,3,4] -&gt; [3,4,5] moves everything.</span>
<span class="cm">			 *          [0-7] - &gt; [3,4,5] moves only 0,1,2,6,7.</span>
<span class="cm">			 */</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">nodes_weight</span><span class="p">(</span><span class="o">*</span><span class="n">from</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nodes_weight</span><span class="p">(</span><span class="o">*</span><span class="n">to</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
						<span class="p">(</span><span class="n">node_isset</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">*</span><span class="n">to</span><span class="p">)))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">d</span> <span class="o">=</span> <span class="n">node_remap</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="o">*</span><span class="n">to</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">d</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">source</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>	<span class="cm">/* Node moved. Memorize */</span>
			<span class="n">dest</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>

			<span class="cm">/* dest not in remaining from nodes? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node_isset</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">tmp</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">source</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">node_clear</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">migrate_to_node</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">busy</span> <span class="o">+=</span> <span class="n">err</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">busy</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate a new page for page migration based on vma policy.</span>
<span class="cm"> * Start assuming that page is mapped by vma pointed to by @private.</span>
<span class="cm"> * Search forward from there, if not.  N.B., this assumes that the</span>
<span class="cm"> * list of pages handed to migrate_pages()--which is how we get here--</span>
<span class="cm"> * is in virtual address order.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">new_vma_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">private</span><span class="p">,</span> <span class="kt">int</span> <span class="o">**</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">)</span><span class="n">private</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">vma</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">address</span> <span class="o">=</span> <span class="n">page_address_in_vma</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">vma</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * if !vma, alloc_page_vma() will use task or system default policy</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">alloc_page_vma</span><span class="p">(</span><span class="n">GFP_HIGHUSER_MOVABLE</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">migrate_page_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pagelist</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">do_migrate_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span>
		     <span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">new_vma_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">private</span><span class="p">,</span> <span class="kt">int</span> <span class="o">**</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">do_mbind</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">mode_flags</span><span class="p">,</span>
		     <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nmask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">pagelist</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">MPOL_MF_STRICT</span> <span class="o">|</span>
				     <span class="n">MPOL_MF_MOVE</span> <span class="o">|</span> <span class="n">MPOL_MF_MOVE_ALL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MPOL_MF_MOVE_ALL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_NICE</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MPOL_DEFAULT</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MPOL_MF_STRICT</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">==</span> <span class="n">start</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">new</span> <span class="o">=</span> <span class="n">mpol_new</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">mode_flags</span><span class="p">,</span> <span class="n">nmask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">new</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we are using the default policy then operation</span>
<span class="cm">	 * on discontinuous address spaces is okay after all</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">MPOL_MF_DISCONTIG_OK</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;mbind %lx-%lx mode:%d flags:%d nodes:%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">start</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">mode_flags</span><span class="p">,</span>
		 <span class="n">nmask</span> <span class="o">?</span> <span class="n">nodes_addr</span><span class="p">(</span><span class="o">*</span><span class="n">nmask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MPOL_MF_MOVE</span> <span class="o">|</span> <span class="n">MPOL_MF_MOVE_ALL</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">migrate_prep</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">mpol_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="p">{</span>
		<span class="n">NODEMASK_SCRATCH</span><span class="p">(</span><span class="n">scratch</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scratch</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
			<span class="n">task_lock</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">mpol_set_nodemask</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">nmask</span><span class="p">,</span> <span class="n">scratch</span><span class="p">);</span>
			<span class="n">task_unlock</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">NODEMASK_SCRATCH_FREE</span><span class="p">(</span><span class="n">scratch</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">mpol_out</span><span class="p">;</span>

	<span class="n">vma</span> <span class="o">=</span> <span class="n">check_range</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">nmask</span><span class="p">,</span>
			  <span class="n">flags</span> <span class="o">|</span> <span class="n">MPOL_MF_INVERT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pagelist</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">vma</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">nr_failed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">mbind_range</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pagelist</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">nr_failed</span> <span class="o">=</span> <span class="n">migrate_pages</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pagelist</span><span class="p">,</span> <span class="n">new_vma_page</span><span class="p">,</span>
						<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vma</span><span class="p">,</span>
						<span class="nb">false</span><span class="p">,</span> <span class="n">MIGRATE_SYNC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nr_failed</span><span class="p">)</span>
				<span class="n">putback_lru_pages</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pagelist</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">nr_failed</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MPOL_MF_STRICT</span><span class="p">))</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">putback_lru_pages</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pagelist</span><span class="p">);</span>

	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
 <span class="nl">mpol_out:</span>
	<span class="n">mpol_put</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * User space interface with variable sized bitmaps for nodelists.</span>
<span class="cm"> */</span>

<span class="cm">/* Copy a node mask from user space. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_nodes</span><span class="p">(</span><span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodes</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="n">nmask</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">maxnode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">k</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nlongs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">endmask</span><span class="p">;</span>

	<span class="o">--</span><span class="n">maxnode</span><span class="p">;</span>
	<span class="n">nodes_clear</span><span class="p">(</span><span class="o">*</span><span class="n">nodes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">maxnode</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">nmask</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">maxnode</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="o">*</span><span class="n">BITS_PER_BYTE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">nlongs</span> <span class="o">=</span> <span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">maxnode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">maxnode</span> <span class="o">%</span> <span class="n">BITS_PER_LONG</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">endmask</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">endmask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">maxnode</span> <span class="o">%</span> <span class="n">BITS_PER_LONG</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* When the user specified more nodes than supported just check</span>
<span class="cm">	   if the non supported part is all zero. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nlongs</span> <span class="o">&gt;</span> <span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">MAX_NUMNODES</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nlongs</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">MAX_NUMNODES</span><span class="p">);</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">nlongs</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">t</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">nmask</span> <span class="o">+</span> <span class="n">k</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="n">nlongs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&amp;</span> <span class="n">endmask</span><span class="p">)</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">nlongs</span> <span class="o">=</span> <span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">MAX_NUMNODES</span><span class="p">);</span>
		<span class="n">endmask</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">nodes_addr</span><span class="p">(</span><span class="o">*</span><span class="n">nodes</span><span class="p">),</span> <span class="n">nmask</span><span class="p">,</span> <span class="n">nlongs</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="n">nodes_addr</span><span class="p">(</span><span class="o">*</span><span class="n">nodes</span><span class="p">)[</span><span class="n">nlongs</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="n">endmask</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Copy a kernel node mask to user space */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">copy_nodes_to_user</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">maxnode</span><span class="p">,</span>
			      <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">copy</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">maxnode</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">nbytes</span> <span class="o">=</span> <span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">MAX_NUMNODES</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&gt;</span> <span class="n">nbytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">clear_user</span><span class="p">((</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">mask</span> <span class="o">+</span> <span class="n">nbytes</span><span class="p">,</span> <span class="n">copy</span> <span class="o">-</span> <span class="n">nbytes</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">copy</span> <span class="o">=</span> <span class="n">nbytes</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">nodes_addr</span><span class="p">(</span><span class="o">*</span><span class="n">nodes</span><span class="p">),</span> <span class="n">copy</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="n">EFAULT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE6</span><span class="p">(</span><span class="n">mbind</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">nmask</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">maxnode</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nodemask_t</span> <span class="n">nodes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">mode_flags</span><span class="p">;</span>

	<span class="n">mode_flags</span> <span class="o">=</span> <span class="n">mode</span> <span class="o">&amp;</span> <span class="n">MPOL_MODE_FLAGS</span><span class="p">;</span>
	<span class="n">mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MPOL_MODE_FLAGS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&gt;=</span> <span class="n">MPOL_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">mode_flags</span> <span class="o">&amp;</span> <span class="n">MPOL_F_STATIC_NODES</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">mode_flags</span> <span class="o">&amp;</span> <span class="n">MPOL_F_RELATIVE_NODES</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">get_nodes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nodes</span><span class="p">,</span> <span class="n">nmask</span><span class="p">,</span> <span class="n">maxnode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">do_mbind</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">mode_flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nodes</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Set the process memory policy */</span>
<span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">set_mempolicy</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">nmask</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">maxnode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">nodemask_t</span> <span class="n">nodes</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">flags</span> <span class="o">=</span> <span class="n">mode</span> <span class="o">&amp;</span> <span class="n">MPOL_MODE_FLAGS</span><span class="p">;</span>
	<span class="n">mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MPOL_MODE_FLAGS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">mode</span> <span class="o">&gt;=</span> <span class="n">MPOL_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MPOL_F_STATIC_NODES</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MPOL_F_RELATIVE_NODES</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">get_nodes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nodes</span><span class="p">,</span> <span class="n">nmask</span><span class="p">,</span> <span class="n">maxnode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">do_set_mempolicy</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nodes</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE4</span><span class="p">(</span><span class="n">migrate_pages</span><span class="p">,</span> <span class="n">pid_t</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">maxnode</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">old_nodes</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">new_nodes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">(),</span> <span class="o">*</span><span class="n">tcred</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="n">nodemask_t</span> <span class="n">task_nodes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">nodemask_t</span> <span class="o">*</span><span class="n">old</span><span class="p">;</span>
	<span class="n">nodemask_t</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>
	<span class="n">NODEMASK_SCRATCH</span><span class="p">(</span><span class="n">scratch</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scratch</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">old</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">scratch</span><span class="o">-&gt;</span><span class="n">mask1</span><span class="p">;</span>
	<span class="n">new</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">scratch</span><span class="o">-&gt;</span><span class="n">mask2</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">get_nodes</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">old_nodes</span><span class="p">,</span> <span class="n">maxnode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">get_nodes</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">new_nodes</span><span class="p">,</span> <span class="n">maxnode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Find the mm_struct */</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">task</span> <span class="o">=</span> <span class="n">pid</span> <span class="o">?</span> <span class="n">find_task_by_vpid</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span> <span class="o">:</span> <span class="n">current</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">get_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if this process has the right to modify the specified</span>
<span class="cm">	 * process. The right exists if the process has administrative</span>
<span class="cm">	 * capabilities, superuser privileges or the same</span>
<span class="cm">	 * userid as the target process.</span>
<span class="cm">	 */</span>
	<span class="n">tcred</span> <span class="o">=</span> <span class="n">__task_cred</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">,</span> <span class="n">tcred</span><span class="o">-&gt;</span><span class="n">suid</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">,</span> <span class="n">tcred</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">,</span>  <span class="n">tcred</span><span class="o">-&gt;</span><span class="n">suid</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">,</span>  <span class="n">tcred</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_NICE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="n">task_nodes</span> <span class="o">=</span> <span class="n">cpuset_mems_allowed</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="cm">/* Is the user allowed to access the target nodes? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nodes_subset</span><span class="p">(</span><span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="n">task_nodes</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_NICE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nodes_subset</span><span class="p">(</span><span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="n">node_states</span><span class="p">[</span><span class="n">N_HIGH_MEMORY</span><span class="p">]))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">security_task_movememory</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>

	<span class="n">mm</span> <span class="o">=</span> <span class="n">get_task_mm</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">do_migrate_pages</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span>
		<span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_NICE</span><span class="p">)</span> <span class="o">?</span> <span class="n">MPOL_MF_MOVE_ALL</span> <span class="o">:</span> <span class="n">MPOL_MF_MOVE</span><span class="p">);</span>

	<span class="n">mmput</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">NODEMASK_SCRATCH_FREE</span><span class="p">(</span><span class="n">scratch</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">out_put:</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="p">}</span>


<span class="cm">/* Retrieve NUMA policy */</span>
<span class="n">SYSCALL_DEFINE5</span><span class="p">(</span><span class="n">get_mempolicy</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">policy</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">nmask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">maxnode</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">pval</span><span class="p">);</span>
	<span class="n">nodemask_t</span> <span class="n">nodes</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nmask</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">maxnode</span> <span class="o">&lt;</span> <span class="n">MAX_NUMNODES</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">do_get_mempolicy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nodes</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">policy</span> <span class="o">&amp;&amp;</span> <span class="n">put_user</span><span class="p">(</span><span class="n">pval</span><span class="p">,</span> <span class="n">policy</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nmask</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">copy_nodes_to_user</span><span class="p">(</span><span class="n">nmask</span><span class="p">,</span> <span class="n">maxnode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nodes</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_COMPAT</span>

<span class="n">asmlinkage</span> <span class="kt">long</span> <span class="n">compat_sys_get_mempolicy</span><span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">policy</span><span class="p">,</span>
				     <span class="n">compat_ulong_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">nmask</span><span class="p">,</span>
				     <span class="n">compat_ulong_t</span> <span class="n">maxnode</span><span class="p">,</span>
				     <span class="n">compat_ulong_t</span> <span class="n">addr</span><span class="p">,</span> <span class="n">compat_ulong_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="n">nm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_bits</span><span class="p">,</span> <span class="n">alloc_size</span><span class="p">;</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">bm</span><span class="p">,</span> <span class="n">MAX_NUMNODES</span><span class="p">);</span>

	<span class="n">nr_bits</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">maxnode</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">MAX_NUMNODES</span><span class="p">);</span>
	<span class="n">alloc_size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">nr_bits</span><span class="p">,</span> <span class="n">BITS_PER_LONG</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nmask</span><span class="p">)</span>
		<span class="n">nm</span> <span class="o">=</span> <span class="n">compat_alloc_user_space</span><span class="p">(</span><span class="n">alloc_size</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sys_get_mempolicy</span><span class="p">(</span><span class="n">policy</span><span class="p">,</span> <span class="n">nm</span><span class="p">,</span> <span class="n">nr_bits</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">nmask</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">copy_size</span><span class="p">;</span>
		<span class="n">copy_size</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bm</span><span class="p">),</span> <span class="n">alloc_size</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="n">bm</span><span class="p">,</span> <span class="n">nm</span><span class="p">,</span> <span class="n">copy_size</span><span class="p">);</span>
		<span class="cm">/* ensure entire bitmap is zeroed */</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">clear_user</span><span class="p">(</span><span class="n">nmask</span><span class="p">,</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">maxnode</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">compat_put_bitmap</span><span class="p">(</span><span class="n">nmask</span><span class="p">,</span> <span class="n">bm</span><span class="p">,</span> <span class="n">nr_bits</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">asmlinkage</span> <span class="kt">long</span> <span class="n">compat_sys_set_mempolicy</span><span class="p">(</span><span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="n">compat_ulong_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">nmask</span><span class="p">,</span>
				     <span class="n">compat_ulong_t</span> <span class="n">maxnode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="n">nm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_bits</span><span class="p">,</span> <span class="n">alloc_size</span><span class="p">;</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">bm</span><span class="p">,</span> <span class="n">MAX_NUMNODES</span><span class="p">);</span>

	<span class="n">nr_bits</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">maxnode</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">MAX_NUMNODES</span><span class="p">);</span>
	<span class="n">alloc_size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">nr_bits</span><span class="p">,</span> <span class="n">BITS_PER_LONG</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nmask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">compat_get_bitmap</span><span class="p">(</span><span class="n">bm</span><span class="p">,</span> <span class="n">nmask</span><span class="p">,</span> <span class="n">nr_bits</span><span class="p">);</span>
		<span class="n">nm</span> <span class="o">=</span> <span class="n">compat_alloc_user_space</span><span class="p">(</span><span class="n">alloc_size</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">nm</span><span class="p">,</span> <span class="n">bm</span><span class="p">,</span> <span class="n">alloc_size</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sys_set_mempolicy</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">nm</span><span class="p">,</span> <span class="n">nr_bits</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">asmlinkage</span> <span class="kt">long</span> <span class="n">compat_sys_mbind</span><span class="p">(</span><span class="n">compat_ulong_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">compat_ulong_t</span> <span class="n">len</span><span class="p">,</span>
			     <span class="n">compat_ulong_t</span> <span class="n">mode</span><span class="p">,</span> <span class="n">compat_ulong_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">nmask</span><span class="p">,</span>
			     <span class="n">compat_ulong_t</span> <span class="n">maxnode</span><span class="p">,</span> <span class="n">compat_ulong_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="n">nm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_bits</span><span class="p">,</span> <span class="n">alloc_size</span><span class="p">;</span>
	<span class="n">nodemask_t</span> <span class="n">bm</span><span class="p">;</span>

	<span class="n">nr_bits</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">maxnode</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">MAX_NUMNODES</span><span class="p">);</span>
	<span class="n">alloc_size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">nr_bits</span><span class="p">,</span> <span class="n">BITS_PER_LONG</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nmask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">compat_get_bitmap</span><span class="p">(</span><span class="n">nodes_addr</span><span class="p">(</span><span class="n">bm</span><span class="p">),</span> <span class="n">nmask</span><span class="p">,</span> <span class="n">nr_bits</span><span class="p">);</span>
		<span class="n">nm</span> <span class="o">=</span> <span class="n">compat_alloc_user_space</span><span class="p">(</span><span class="n">alloc_size</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">nm</span><span class="p">,</span> <span class="n">nodes_addr</span><span class="p">(</span><span class="n">bm</span><span class="p">),</span> <span class="n">alloc_size</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sys_mbind</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">nm</span><span class="p">,</span> <span class="n">nr_bits</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * get_vma_policy(@task, @vma, @addr)</span>
<span class="cm"> * @task - task for fallback if vma policy == default</span>
<span class="cm"> * @vma   - virtual memory area whose policy is sought</span>
<span class="cm"> * @addr  - address in @vma for shared policy lookup</span>
<span class="cm"> *</span>
<span class="cm"> * Returns effective policy for a VMA at specified address.</span>
<span class="cm"> * Falls back to @task or system default policy, as necessary.</span>
<span class="cm"> * Current or other task&#39;s task mempolicy and non-shared vma policies</span>
<span class="cm"> * are protected by the task&#39;s mmap_sem, which must be held for read by</span>
<span class="cm"> * the caller.</span>
<span class="cm"> * Shared policies [those marked as MPOL_F_SHARED] require an extra reference</span>
<span class="cm"> * count--added by the get_policy() vm_op, as appropriate--to protect against</span>
<span class="cm"> * freeing by another task.  It is the caller&#39;s responsibility to free the</span>
<span class="cm"> * extra reference for shared policies.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">get_vma_policy</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">pol</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">mempolicy</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">&amp;&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="o">-&gt;</span><span class="n">get_policy</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">vpol</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="o">-&gt;</span><span class="n">get_policy</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span>
									<span class="n">addr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vpol</span><span class="p">)</span>
				<span class="n">pol</span> <span class="o">=</span> <span class="n">vpol</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_policy</span><span class="p">)</span>
			<span class="n">pol</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_policy</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pol</span><span class="p">)</span>
		<span class="n">pol</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">default_policy</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">pol</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return a nodemask representing a mempolicy for filtering nodes for</span>
<span class="cm"> * page allocation</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">policy_nodemask</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">policy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Lower zones don&#39;t get a nodemask applied for MPOL_BIND */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">policy</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MPOL_BIND</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">gfp_zone</span><span class="p">(</span><span class="n">gfp</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">policy_zone</span> <span class="o">&amp;&amp;</span>
			<span class="n">cpuset_nodemask_valid_mems_allowed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">nodes</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">policy</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">nodes</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return a zonelist indicated by gfp for node representing a mempolicy */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">zonelist</span> <span class="o">*</span><span class="n">policy_zonelist</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">policy</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">policy</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MPOL_PREFERRED</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">policy</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MPOL_F_LOCAL</span><span class="p">))</span>
			<span class="n">nd</span> <span class="o">=</span> <span class="n">policy</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">preferred_node</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MPOL_BIND</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Normally, MPOL_BIND allocations are node-local within the</span>
<span class="cm">		 * allowed nodemask.  However, if __GFP_THISNODE is set and the</span>
<span class="cm">		 * current node isn&#39;t part of the mask, we use the zonelist for</span>
<span class="cm">		 * the first node in the mask instead.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">gfp</span> <span class="o">&amp;</span> <span class="n">__GFP_THISNODE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">node_isset</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">policy</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">nodes</span><span class="p">)))</span>
			<span class="n">nd</span> <span class="o">=</span> <span class="n">first_node</span><span class="p">(</span><span class="n">policy</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">nodes</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">node_zonelist</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Do dynamic interleaving for a process */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="n">interleave_nodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">policy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">nid</span><span class="p">,</span> <span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">me</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

	<span class="n">nid</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">il_next</span><span class="p">;</span>
	<span class="n">next</span> <span class="o">=</span> <span class="n">next_node</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">policy</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">nodes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">&gt;=</span> <span class="n">MAX_NUMNODES</span><span class="p">)</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">first_node</span><span class="p">(</span><span class="n">policy</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">nodes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">&lt;</span> <span class="n">MAX_NUMNODES</span><span class="p">)</span>
		<span class="n">me</span><span class="o">-&gt;</span><span class="n">il_next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">nid</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Depending on the memory policy provide a node from which to allocate the</span>
<span class="cm"> * next slab entry.</span>
<span class="cm"> * @policy must be protected by freeing by the caller.  If @policy is</span>
<span class="cm"> * the current task&#39;s mempolicy, this protection is implicit, as only the</span>
<span class="cm"> * task can change it&#39;s policy.  The system default policy requires no</span>
<span class="cm"> * such protection.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="n">slab_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">policy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">policy</span> <span class="o">||</span> <span class="n">policy</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MPOL_F_LOCAL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">numa_node_id</span><span class="p">();</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">policy</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MPOL_PREFERRED</span>:
		<span class="cm">/*</span>
<span class="cm">		 * handled MPOL_F_LOCAL above</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="n">policy</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">preferred_node</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">MPOL_INTERLEAVE</span>:
		<span class="k">return</span> <span class="n">interleave_nodes</span><span class="p">(</span><span class="n">policy</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">MPOL_BIND</span>: <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Follow bind policy behavior and start allocation at the</span>
<span class="cm">		 * first node.</span>
<span class="cm">		 */</span>
		<span class="k">struct</span> <span class="n">zonelist</span> <span class="o">*</span><span class="n">zonelist</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">;</span>
		<span class="k">enum</span> <span class="n">zone_type</span> <span class="n">highest_zoneidx</span> <span class="o">=</span> <span class="n">gfp_zone</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="n">zonelist</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="n">numa_node_id</span><span class="p">())</span><span class="o">-&gt;</span><span class="n">node_zonelists</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">first_zones_zonelist</span><span class="p">(</span><span class="n">zonelist</span><span class="p">,</span> <span class="n">highest_zoneidx</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">policy</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">nodes</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">zone</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">zone</span> <span class="o">?</span> <span class="n">zone</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">:</span> <span class="n">numa_node_id</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Do static interleaving for a VMA with known offset. */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="n">offset_il_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">pol</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">off</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">nnodes</span> <span class="o">=</span> <span class="n">nodes_weight</span><span class="p">(</span><span class="n">pol</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">nodes</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">target</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">c</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nnodes</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">numa_node_id</span><span class="p">();</span>
	<span class="n">target</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">off</span> <span class="o">%</span> <span class="n">nnodes</span><span class="p">;</span>
	<span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">nid</span> <span class="o">=</span> <span class="n">next_node</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">pol</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">nodes</span><span class="p">);</span>
		<span class="n">c</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;=</span> <span class="n">target</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">nid</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Determine a node number for interleave */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="n">interleave_nid</span><span class="p">(</span><span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">pol</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shift</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">off</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * for small pages, there is no difference between</span>
<span class="cm">		 * shift and PAGE_SHIFT, so the bit-shift is safe.</span>
<span class="cm">		 * for huge pages, since vm_pgoff is in units of small</span>
<span class="cm">		 * pages, we need to shift off the always 0 bits to get</span>
<span class="cm">		 * a useful offset.</span>
<span class="cm">		 */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">shift</span> <span class="o">&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
		<span class="n">off</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">shift</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
		<span class="n">off</span> <span class="o">+=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">shift</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">offset_il_node</span><span class="p">(</span><span class="n">pol</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">off</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="n">interleave_nodes</span><span class="p">(</span><span class="n">pol</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the bit number of a random bit set in the nodemask.</span>
<span class="cm"> * (returns -1 if nodemask is empty)</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">node_random</span><span class="p">(</span><span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">maskp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="n">bit</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">w</span> <span class="o">=</span> <span class="n">nodes_weight</span><span class="p">(</span><span class="o">*</span><span class="n">maskp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">w</span><span class="p">)</span>
		<span class="n">bit</span> <span class="o">=</span> <span class="n">bitmap_ord_to_pos</span><span class="p">(</span><span class="n">maskp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span>
			<span class="n">get_random_int</span><span class="p">()</span> <span class="o">%</span> <span class="n">w</span><span class="p">,</span> <span class="n">MAX_NUMNODES</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">bit</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HUGETLBFS</span>
<span class="cm">/*</span>
<span class="cm"> * huge_zonelist(@vma, @addr, @gfp_flags, @mpol)</span>
<span class="cm"> * @vma = virtual memory area whose policy is sought</span>
<span class="cm"> * @addr = address in @vma for shared policy lookup and interleave policy</span>
<span class="cm"> * @gfp_flags = for requested zone</span>
<span class="cm"> * @mpol = pointer to mempolicy pointer for reference counted mempolicy</span>
<span class="cm"> * @nodemask = pointer to nodemask pointer for MPOL_BIND nodemask</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a zonelist suitable for a huge page allocation and a pointer</span>
<span class="cm"> * to the struct mempolicy for conditional unref after allocation.</span>
<span class="cm"> * If the effective policy is &#39;BIND, returns a pointer to the mempolicy&#39;s</span>
<span class="cm"> * @nodemask for filtering the zonelist.</span>
<span class="cm"> *</span>
<span class="cm"> * Must be protected by get_mems_allowed()</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">zonelist</span> <span class="o">*</span><span class="n">huge_zonelist</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
				<span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">**</span><span class="n">mpol</span><span class="p">,</span>
				<span class="n">nodemask_t</span> <span class="o">**</span><span class="n">nodemask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">zonelist</span> <span class="o">*</span><span class="n">zl</span><span class="p">;</span>

	<span class="o">*</span><span class="n">mpol</span> <span class="o">=</span> <span class="n">get_vma_policy</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="o">*</span><span class="n">nodemask</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* assume !MPOL_BIND */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="o">*</span><span class="n">mpol</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MPOL_INTERLEAVE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">zl</span> <span class="o">=</span> <span class="n">node_zonelist</span><span class="p">(</span><span class="n">interleave_nid</span><span class="p">(</span><span class="o">*</span><span class="n">mpol</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span>
				<span class="n">huge_page_shift</span><span class="p">(</span><span class="n">hstate_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">))),</span> <span class="n">gfp_flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">zl</span> <span class="o">=</span> <span class="n">policy_zonelist</span><span class="p">(</span><span class="n">gfp_flags</span><span class="p">,</span> <span class="o">*</span><span class="n">mpol</span><span class="p">,</span> <span class="n">numa_node_id</span><span class="p">());</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">mpol</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MPOL_BIND</span><span class="p">)</span>
			<span class="o">*</span><span class="n">nodemask</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">mpol</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">nodes</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">zl</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * init_nodemask_of_mempolicy</span>
<span class="cm"> *</span>
<span class="cm"> * If the current task&#39;s mempolicy is &quot;default&quot; [NULL], return &#39;false&#39;</span>
<span class="cm"> * to indicate default policy.  Otherwise, extract the policy nodemask</span>
<span class="cm"> * for &#39;bind&#39; or &#39;interleave&#39; policy into the argument nodemask, or</span>
<span class="cm"> * initialize the argument nodemask to contain the single node for</span>
<span class="cm"> * &#39;preferred&#39; or &#39;local&#39; policy and return &#39;true&#39; to indicate presence</span>
<span class="cm"> * of non-default mempolicy.</span>
<span class="cm"> *</span>
<span class="cm"> * We don&#39;t bother with reference counting the mempolicy [mpol_get/put]</span>
<span class="cm"> * because the current task is examining it&#39;s own mempolicy and a task&#39;s</span>
<span class="cm"> * mempolicy is only ever changed by the task itself.</span>
<span class="cm"> *</span>
<span class="cm"> * N.B., it is the caller&#39;s responsibility to free a returned nodemask.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="n">init_nodemask_of_mempolicy</span><span class="p">(</span><span class="n">nodemask_t</span> <span class="o">*</span><span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">mempolicy</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mask</span> <span class="o">&amp;&amp;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mempolicy</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">task_lock</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">mempolicy</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mempolicy</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">mempolicy</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MPOL_PREFERRED</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">mempolicy</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MPOL_F_LOCAL</span><span class="p">)</span>
			<span class="n">nid</span> <span class="o">=</span> <span class="n">numa_node_id</span><span class="p">();</span>
		<span class="k">else</span>
			<span class="n">nid</span> <span class="o">=</span> <span class="n">mempolicy</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">preferred_node</span><span class="p">;</span>
		<span class="n">init_nodemask_of_node</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">MPOL_BIND</span>:
		<span class="cm">/* Fall through */</span>
	<span class="k">case</span> <span class="n">MPOL_INTERLEAVE</span>:
		<span class="o">*</span><span class="n">mask</span> <span class="o">=</span>  <span class="n">mempolicy</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">nodes</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">task_unlock</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * mempolicy_nodemask_intersects</span>
<span class="cm"> *</span>
<span class="cm"> * If tsk&#39;s mempolicy is &quot;default&quot; [NULL], return &#39;true&#39; to indicate default</span>
<span class="cm"> * policy.  Otherwise, check for intersection between mask and the policy</span>
<span class="cm"> * nodemask for &#39;bind&#39; or &#39;interleave&#39; policy.  For &#39;perferred&#39; or &#39;local&#39;</span>
<span class="cm"> * policy, always return true since it may allocate elsewhere on fallback.</span>
<span class="cm"> *</span>
<span class="cm"> * Takes task_lock(tsk) to prevent freeing of its mempolicy.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="n">mempolicy_nodemask_intersects</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">mempolicy</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mask</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">task_lock</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">mempolicy</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">mempolicy</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mempolicy</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">mempolicy</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MPOL_PREFERRED</span>:
		<span class="cm">/*</span>
<span class="cm">		 * MPOL_PREFERRED and MPOL_F_LOCAL are only preferred nodes to</span>
<span class="cm">		 * allocate from, they may fallback to other nodes when oom.</span>
<span class="cm">		 * Thus, it&#39;s possible for tsk to have allocated memory from</span>
<span class="cm">		 * nodes in mask.</span>
<span class="cm">		 */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MPOL_BIND</span>:
	<span class="k">case</span> <span class="n">MPOL_INTERLEAVE</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">nodes_intersects</span><span class="p">(</span><span class="n">mempolicy</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">nodes</span><span class="p">,</span> <span class="o">*</span><span class="n">mask</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">task_unlock</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Allocate a page in interleaved policy.</span>
<span class="cm">   Own path because it needs to do special accounting. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">alloc_page_interleave</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">order</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">zonelist</span> <span class="o">*</span><span class="n">zl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="n">zl</span> <span class="o">=</span> <span class="n">node_zonelist</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">__alloc_pages</span><span class="p">(</span><span class="n">gfp</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">zl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">&amp;&amp;</span> <span class="n">page_zone</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">==</span> <span class="n">zonelist_zone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zl</span><span class="o">-&gt;</span><span class="n">_zonerefs</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
		<span class="n">inc_zone_page_state</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">NUMA_INTERLEAVE_HIT</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * 	alloc_pages_vma	- Allocate a page for a VMA.</span>
<span class="cm"> *</span>
<span class="cm"> * 	@gfp:</span>
<span class="cm"> *      %GFP_USER    user allocation.</span>
<span class="cm"> *      %GFP_KERNEL  kernel allocations,</span>
<span class="cm"> *      %GFP_HIGHMEM highmem/user allocations,</span>
<span class="cm"> *      %GFP_FS      allocation should not call back into a file system.</span>
<span class="cm"> *      %GFP_ATOMIC  don&#39;t sleep.</span>
<span class="cm"> *</span>
<span class="cm"> *	@order:Order of the GFP allocation.</span>
<span class="cm"> * 	@vma:  Pointer to VMA or NULL if not available.</span>
<span class="cm"> *	@addr: Virtual Address of the allocation. Must be inside the VMA.</span>
<span class="cm"> *</span>
<span class="cm"> * 	This function allocates a page from the kernel page pool and applies</span>
<span class="cm"> *	a NUMA policy associated with the VMA or the current process.</span>
<span class="cm"> *	When VMA is not NULL caller must hold down_read on the mmap_sem of the</span>
<span class="cm"> *	mm_struct of the VMA to prevent it from going away. Should be used for</span>
<span class="cm"> *	all allocations for pages that will be mapped into</span>
<span class="cm"> * 	user space. Returns NULL when no page can be allocated.</span>
<span class="cm"> *</span>
<span class="cm"> *	Should be called with the mm_sem of the vma hold.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span>
<span class="n">alloc_pages_vma</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">pol</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zonelist</span> <span class="o">*</span><span class="n">zl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpuset_mems_cookie</span><span class="p">;</span>

<span class="nl">retry_cpuset:</span>
	<span class="n">pol</span> <span class="o">=</span> <span class="n">get_vma_policy</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">cpuset_mems_cookie</span> <span class="o">=</span> <span class="n">get_mems_allowed</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pol</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MPOL_INTERLEAVE</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">nid</span><span class="p">;</span>

		<span class="n">nid</span> <span class="o">=</span> <span class="n">interleave_nid</span><span class="p">(</span><span class="n">pol</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">PAGE_SHIFT</span> <span class="o">+</span> <span class="n">order</span><span class="p">);</span>
		<span class="n">mpol_cond_put</span><span class="p">(</span><span class="n">pol</span><span class="p">);</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page_interleave</span><span class="p">(</span><span class="n">gfp</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">put_mems_allowed</span><span class="p">(</span><span class="n">cpuset_mems_cookie</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">page</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">retry_cpuset</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">zl</span> <span class="o">=</span> <span class="n">policy_zonelist</span><span class="p">(</span><span class="n">gfp</span><span class="p">,</span> <span class="n">pol</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">mpol_needs_cond_ref</span><span class="p">(</span><span class="n">pol</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * slow path: ref counted shared policy</span>
<span class="cm">		 */</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span>  <span class="n">__alloc_pages_nodemask</span><span class="p">(</span><span class="n">gfp</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span>
						<span class="n">zl</span><span class="p">,</span> <span class="n">policy_nodemask</span><span class="p">(</span><span class="n">gfp</span><span class="p">,</span> <span class="n">pol</span><span class="p">));</span>
		<span class="n">__mpol_put</span><span class="p">(</span><span class="n">pol</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">put_mems_allowed</span><span class="p">(</span><span class="n">cpuset_mems_cookie</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">page</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">retry_cpuset</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * fast path:  default or task policy</span>
<span class="cm">	 */</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">__alloc_pages_nodemask</span><span class="p">(</span><span class="n">gfp</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">zl</span><span class="p">,</span>
				      <span class="n">policy_nodemask</span><span class="p">(</span><span class="n">gfp</span><span class="p">,</span> <span class="n">pol</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">put_mems_allowed</span><span class="p">(</span><span class="n">cpuset_mems_cookie</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">page</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">retry_cpuset</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * 	alloc_pages_current - Allocate pages.</span>
<span class="cm"> *</span>
<span class="cm"> *	@gfp:</span>
<span class="cm"> *		%GFP_USER   user allocation,</span>
<span class="cm"> *      	%GFP_KERNEL kernel allocation,</span>
<span class="cm"> *      	%GFP_HIGHMEM highmem allocation,</span>
<span class="cm"> *      	%GFP_FS     don&#39;t call back into a file system.</span>
<span class="cm"> *      	%GFP_ATOMIC don&#39;t sleep.</span>
<span class="cm"> *	@order: Power of two of allocation size in pages. 0 is a single page.</span>
<span class="cm"> *</span>
<span class="cm"> *	Allocate a page from the kernel page pool.  When not in</span>
<span class="cm"> *	interrupt context and apply the current process NUMA policy.</span>
<span class="cm"> *	Returns NULL when no page can be allocated.</span>
<span class="cm"> *</span>
<span class="cm"> *	Don&#39;t call cpuset_update_task_memory_state() unless</span>
<span class="cm"> *	1) it&#39;s ok to take cpuset_sem (can WAIT), and</span>
<span class="cm"> *	2) allocating for current task (not interrupt).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">alloc_pages_current</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">order</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">pol</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mempolicy</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpuset_mems_cookie</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pol</span> <span class="o">||</span> <span class="n">in_interrupt</span><span class="p">()</span> <span class="o">||</span> <span class="p">(</span><span class="n">gfp</span> <span class="o">&amp;</span> <span class="n">__GFP_THISNODE</span><span class="p">))</span>
		<span class="n">pol</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">default_policy</span><span class="p">;</span>

<span class="nl">retry_cpuset:</span>
	<span class="n">cpuset_mems_cookie</span> <span class="o">=</span> <span class="n">get_mems_allowed</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * No reference counting needed for current-&gt;mempolicy</span>
<span class="cm">	 * nor system default_policy</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pol</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MPOL_INTERLEAVE</span><span class="p">)</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page_interleave</span><span class="p">(</span><span class="n">gfp</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">interleave_nodes</span><span class="p">(</span><span class="n">pol</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">__alloc_pages_nodemask</span><span class="p">(</span><span class="n">gfp</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span>
				<span class="n">policy_zonelist</span><span class="p">(</span><span class="n">gfp</span><span class="p">,</span> <span class="n">pol</span><span class="p">,</span> <span class="n">numa_node_id</span><span class="p">()),</span>
				<span class="n">policy_nodemask</span><span class="p">(</span><span class="n">gfp</span><span class="p">,</span> <span class="n">pol</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">put_mems_allowed</span><span class="p">(</span><span class="n">cpuset_mems_cookie</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">page</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">retry_cpuset</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">alloc_pages_current</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * If mpol_dup() sees current-&gt;cpuset == cpuset_being_rebound, then it</span>
<span class="cm"> * rebinds the mempolicy its copying by calling mpol_rebind_policy()</span>
<span class="cm"> * with the mems_allowed returned by cpuset_mems_allowed().  This</span>
<span class="cm"> * keeps mempolicies cpuset relative after its cpuset moves.  See</span>
<span class="cm"> * further kernel/cpuset.c update_nodemask().</span>
<span class="cm"> *</span>
<span class="cm"> * current&#39;s mempolicy may be rebinded by the other task(the task that changes</span>
<span class="cm"> * cpuset&#39;s mems), so we needn&#39;t do rebind work for current task.</span>
<span class="cm"> */</span>

<span class="cm">/* Slow path of a mempolicy duplicate */</span>
<span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="nf">__mpol_dup</span><span class="p">(</span><span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">old</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">policy_cache</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="cm">/* task&#39;s mempolicy is protected by alloc_lock */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old</span> <span class="o">==</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mempolicy</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">task_lock</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
		<span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="o">*</span><span class="n">old</span><span class="p">;</span>
		<span class="n">task_unlock</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="o">*</span><span class="n">old</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current_cpuset_is_being_rebound</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">nodemask_t</span> <span class="n">mems</span> <span class="o">=</span> <span class="n">cpuset_mems_allowed</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MPOL_F_REBINDING</span><span class="p">)</span>
			<span class="n">mpol_rebind_policy</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mems</span><span class="p">,</span> <span class="n">MPOL_REBIND_STEP2</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">mpol_rebind_policy</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mems</span><span class="p">,</span> <span class="n">MPOL_REBIND_ONCE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">new</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If *frompol needs [has] an extra ref, copy *frompol to *tompol ,</span>
<span class="cm"> * eliminate the * MPOL_F_* flags that require conditional ref and</span>
<span class="cm"> * [NOTE!!!] drop the extra ref.  Not safe to reference *frompol directly</span>
<span class="cm"> * after return.  Use the returned value.</span>
<span class="cm"> *</span>
<span class="cm"> * Allows use of a mempolicy for, e.g., multiple allocations with a single</span>
<span class="cm"> * policy lookup, even if the policy needs/has extra ref on lookup.</span>
<span class="cm"> * shmem_readahead needs this.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="nf">__mpol_cond_copy</span><span class="p">(</span><span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">tompol</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">frompol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mpol_needs_cond_ref</span><span class="p">(</span><span class="n">frompol</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">frompol</span><span class="p">;</span>

	<span class="o">*</span><span class="n">tompol</span> <span class="o">=</span> <span class="o">*</span><span class="n">frompol</span><span class="p">;</span>
	<span class="n">tompol</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MPOL_F_SHARED</span><span class="p">;</span>	<span class="cm">/* copy doesn&#39;t need unref */</span>
	<span class="n">__mpol_put</span><span class="p">(</span><span class="n">frompol</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">tompol</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Slow path of a mempolicy comparison */</span>
<span class="n">bool</span> <span class="nf">__mpol_equal</span><span class="p">(</span><span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">a</span> <span class="o">||</span> <span class="o">!</span><span class="n">b</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">!=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">!=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mpol_store_user_nodemask</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nodes_equal</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">w</span><span class="p">.</span><span class="n">user_nodemask</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">w</span><span class="p">.</span><span class="n">user_nodemask</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MPOL_BIND</span>:
		<span class="cm">/* Fall through */</span>
	<span class="k">case</span> <span class="n">MPOL_INTERLEAVE</span>:
		<span class="k">return</span> <span class="o">!!</span><span class="n">nodes_equal</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">nodes</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">MPOL_PREFERRED</span>:
		<span class="k">return</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">preferred_node</span> <span class="o">==</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">preferred_node</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Shared memory backing store policy support.</span>
<span class="cm"> *</span>
<span class="cm"> * Remember policies even when nobody has shared memory mapped.</span>
<span class="cm"> * The policies are kept in Red-Black tree linked from the inode.</span>
<span class="cm"> * They are protected by the sp-&gt;lock spinlock, which should be held</span>
<span class="cm"> * for any accesses to the tree.</span>
<span class="cm"> */</span>

<span class="cm">/* lookup first element intersecting start-end */</span>
<span class="cm">/* Caller holds sp-&gt;lock */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sp_node</span> <span class="o">*</span>
<span class="nf">sp_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">shared_policy</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sp_node</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sp_node</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">)</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&lt;=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">)</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sp_node</span> <span class="o">*</span><span class="n">w</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="n">rb_prev</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prev</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">w</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sp_node</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sp_node</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Insert a new shared policy into the list. */</span>
<span class="cm">/* Caller holds sp-&gt;lock */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sp_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">shared_policy</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sp_node</span> <span class="o">*</span><span class="n">new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sp_node</span> <span class="o">*</span><span class="n">nd</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">nd</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sp_node</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">nd</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">nd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;inserting %lx-%lx: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">,</span>
		 <span class="n">new</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">?</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">policy</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Find shared policy intersecting idx */</span>
<span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span>
<span class="nf">mpol_shared_policy_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">shared_policy</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">pol</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sp_node</span> <span class="o">*</span><span class="n">sn</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">rb_node</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">sn</span> <span class="o">=</span> <span class="n">sp_lookup</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mpol_get</span><span class="p">(</span><span class="n">sn</span><span class="o">-&gt;</span><span class="n">policy</span><span class="p">);</span>
		<span class="n">pol</span> <span class="o">=</span> <span class="n">sn</span><span class="o">-&gt;</span><span class="n">policy</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pol</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sp_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">shared_policy</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sp_node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;deleting %lx-l%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">);</span>
	<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">nd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">);</span>
	<span class="n">mpol_put</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">policy</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">sn_cache</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sp_node</span> <span class="o">*</span><span class="nf">sp_alloc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">pol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sp_node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">sn_cache</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">n</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">n</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
	<span class="n">mpol_get</span><span class="p">(</span><span class="n">pol</span><span class="p">);</span>
	<span class="n">pol</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">MPOL_F_SHARED</span><span class="p">;</span>	<span class="cm">/* for unref */</span>
	<span class="n">n</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">=</span> <span class="n">pol</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Replace a policy range. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">shared_policy_replace</span><span class="p">(</span><span class="k">struct</span> <span class="n">shared_policy</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sp_node</span> <span class="o">*</span><span class="n">new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sp_node</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="o">*</span><span class="n">new2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">restart:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">sp_lookup</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="cm">/* Take care of old policies in the same range. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">nd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">start</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)</span>
				<span class="n">sp_delete</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">n</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Old policy spanning whole new range. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new2</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
					<span class="n">new2</span> <span class="o">=</span> <span class="n">sp_alloc</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">policy</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new2</span><span class="p">)</span>
						<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">n</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
				<span class="n">sp_insert</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">new2</span><span class="p">);</span>
				<span class="n">new2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">n</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sp_node</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="p">)</span>
		<span class="n">sp_insert</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mpol_put</span><span class="p">(</span><span class="n">new2</span><span class="o">-&gt;</span><span class="n">policy</span><span class="p">);</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">sn_cache</span><span class="p">,</span> <span class="n">new2</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * mpol_shared_policy_init - initialize shared policy for inode</span>
<span class="cm"> * @sp: pointer to inode shared policy</span>
<span class="cm"> * @mpol:  struct mempolicy to install</span>
<span class="cm"> *</span>
<span class="cm"> * Install non-NULL @mpol in inode&#39;s shared policy rb-tree.</span>
<span class="cm"> * On entry, the current task has a reference on a non-NULL @mpol.</span>
<span class="cm"> * This must be released on exit.</span>
<span class="cm"> * This is called at get_inode() calls and we can use GFP_KERNEL.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">mpol_shared_policy_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">shared_policy</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">mpol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">RB_ROOT</span><span class="p">;</span>		<span class="cm">/* empty tree == default mempolicy */</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mpol</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="n">pvma</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>
		<span class="n">NODEMASK_SCRATCH</span><span class="p">(</span><span class="n">scratch</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scratch</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">put_mpol</span><span class="p">;</span>
		<span class="cm">/* contextualize the tmpfs mount point mempolicy */</span>
		<span class="n">new</span> <span class="o">=</span> <span class="n">mpol_new</span><span class="p">(</span><span class="n">mpol</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">,</span> <span class="n">mpol</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mpol</span><span class="o">-&gt;</span><span class="n">w</span><span class="p">.</span><span class="n">user_nodemask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">new</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">free_scratch</span><span class="p">;</span> <span class="cm">/* no valid nodemask intersection */</span>

		<span class="n">task_lock</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">mpol_set_nodemask</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mpol</span><span class="o">-&gt;</span><span class="n">w</span><span class="p">.</span><span class="n">user_nodemask</span><span class="p">,</span> <span class="n">scratch</span><span class="p">);</span>
		<span class="n">task_unlock</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">put_new</span><span class="p">;</span>

		<span class="cm">/* Create pseudo-vma that contains just the policy */</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvma</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span><span class="p">));</span>
		<span class="n">pvma</span><span class="p">.</span><span class="n">vm_end</span> <span class="o">=</span> <span class="n">TASK_SIZE</span><span class="p">;</span>	<span class="cm">/* policy covers entire file */</span>
		<span class="n">mpol_set_shared_policy</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pvma</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span> <span class="cm">/* adds ref */</span>

<span class="nl">put_new:</span>
		<span class="n">mpol_put</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>			<span class="cm">/* drop initial ref */</span>
<span class="nl">free_scratch:</span>
		<span class="n">NODEMASK_SCRATCH_FREE</span><span class="p">(</span><span class="n">scratch</span><span class="p">);</span>
<span class="nl">put_mpol:</span>
		<span class="n">mpol_put</span><span class="p">(</span><span class="n">mpol</span><span class="p">);</span>	<span class="cm">/* drop our incoming ref on sb mpol */</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">mpol_set_shared_policy</span><span class="p">(</span><span class="k">struct</span> <span class="n">shared_policy</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">npol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sp_node</span> <span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">vma_pages</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;set_shared_policy %lx sz %lu %d %d %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span><span class="p">,</span>
		 <span class="n">sz</span><span class="p">,</span> <span class="n">npol</span> <span class="o">?</span> <span class="n">npol</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
		 <span class="n">npol</span> <span class="o">?</span> <span class="n">npol</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
		 <span class="n">npol</span> <span class="o">?</span> <span class="n">nodes_addr</span><span class="p">(</span><span class="n">npol</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">nodes</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">npol</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new</span> <span class="o">=</span> <span class="n">sp_alloc</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">+</span> <span class="n">sz</span><span class="p">,</span> <span class="n">npol</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">shared_policy_replace</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span><span class="o">+</span><span class="n">sz</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">new</span><span class="p">)</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">sn_cache</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Free a backing policy store on inode delete. */</span>
<span class="kt">void</span> <span class="nf">mpol_free_shared_policy</span><span class="p">(</span><span class="k">struct</span> <span class="n">shared_policy</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sp_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">rb_node</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">next</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sp_node</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">nd</span><span class="p">);</span>
		<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">nd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">);</span>
		<span class="n">mpol_put</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">policy</span><span class="p">);</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">sn_cache</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* assumes fs == KERNEL_DS */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">numa_policy_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nodemask_t</span> <span class="n">interleave_nodes</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">largest</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="n">prefer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">policy_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;numa_policy&quot;</span><span class="p">,</span>
					 <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mempolicy</span><span class="p">),</span>
					 <span class="mi">0</span><span class="p">,</span> <span class="n">SLAB_PANIC</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">sn_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;shared_policy_node&quot;</span><span class="p">,</span>
				     <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sp_node</span><span class="p">),</span>
				     <span class="mi">0</span><span class="p">,</span> <span class="n">SLAB_PANIC</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set interleaving policy for system init. Interleaving is only</span>
<span class="cm">	 * enabled across suitably sized nodes (default is &gt;= 16MB), or</span>
<span class="cm">	 * fall back to the largest node if they&#39;re all smaller.</span>
<span class="cm">	 */</span>
	<span class="n">nodes_clear</span><span class="p">(</span><span class="n">interleave_nodes</span><span class="p">);</span>
	<span class="n">for_each_node_state</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">N_HIGH_MEMORY</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total_pages</span> <span class="o">=</span> <span class="n">node_present_pages</span><span class="p">(</span><span class="n">nid</span><span class="p">);</span>

		<span class="cm">/* Preserve the largest node */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">largest</span> <span class="o">&lt;</span> <span class="n">total_pages</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">largest</span> <span class="o">=</span> <span class="n">total_pages</span><span class="p">;</span>
			<span class="n">prefer</span> <span class="o">=</span> <span class="n">nid</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Interleave this node? */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">total_pages</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">16</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">))</span>
			<span class="n">node_set</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">interleave_nodes</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* All too small, use the largest */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">nodes_empty</span><span class="p">(</span><span class="n">interleave_nodes</span><span class="p">)))</span>
		<span class="n">node_set</span><span class="p">(</span><span class="n">prefer</span><span class="p">,</span> <span class="n">interleave_nodes</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">do_set_mempolicy</span><span class="p">(</span><span class="n">MPOL_INTERLEAVE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">interleave_nodes</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;numa_policy_init: interleaving failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Reset policy of current process to default */</span>
<span class="kt">void</span> <span class="nf">numa_default_policy</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">do_set_mempolicy</span><span class="p">(</span><span class="n">MPOL_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Parse and format mempolicy from/to strings</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * &quot;local&quot; is pseudo-policy:  MPOL_PREFERRED with MPOL_F_LOCAL flag</span>
<span class="cm"> * Used only for mpol_parse_str() and mpol_to_str()</span>
<span class="cm"> */</span>
<span class="cp">#define MPOL_LOCAL MPOL_MAX</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">policy_modes</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="p">[</span><span class="n">MPOL_DEFAULT</span><span class="p">]</span>    <span class="o">=</span> <span class="s">&quot;default&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">MPOL_PREFERRED</span><span class="p">]</span>  <span class="o">=</span> <span class="s">&quot;prefer&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">MPOL_BIND</span><span class="p">]</span>       <span class="o">=</span> <span class="s">&quot;bind&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">MPOL_INTERLEAVE</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;interleave&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">MPOL_LOCAL</span><span class="p">]</span>      <span class="o">=</span> <span class="s">&quot;local&quot;</span>
<span class="p">};</span>


<span class="cp">#ifdef CONFIG_TMPFS</span>
<span class="cm">/**</span>
<span class="cm"> * mpol_parse_str - parse string to mempolicy</span>
<span class="cm"> * @str:  string containing mempolicy to parse</span>
<span class="cm"> * @mpol:  pointer to struct mempolicy pointer, returned on success.</span>
<span class="cm"> * @no_context:  flag whether to &quot;contextualize&quot; the mempolicy</span>
<span class="cm"> *</span>
<span class="cm"> * Format of input:</span>
<span class="cm"> *	&lt;mode&gt;[=&lt;flags&gt;][:&lt;nodelist&gt;]</span>
<span class="cm"> *</span>
<span class="cm"> * if @no_context is true, save the input nodemask in w.user_nodemask in</span>
<span class="cm"> * the returned mempolicy.  This will be used to &quot;clone&quot; the mempolicy in</span>
<span class="cm"> * a specific context [cpuset] at a later time.  Used to parse tmpfs mpol</span>
<span class="cm"> * mount option.  Note that if &#39;static&#39; or &#39;relative&#39; mode flags were</span>
<span class="cm"> * specified, the input nodemask will already have been saved.  Saving</span>
<span class="cm"> * it again is redundant, but safe.</span>
<span class="cm"> *</span>
<span class="cm"> * On success, returns 0, else 1</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">mpol_parse_str</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">**</span><span class="n">mpol</span><span class="p">,</span> <span class="kt">int</span> <span class="n">no_context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">mode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">mode_flags</span><span class="p">);</span>
	<span class="n">nodemask_t</span> <span class="n">nodes</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">nodelist</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="sc">&#39;:&#39;</span><span class="p">);</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">flags</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="sc">&#39;=&#39;</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nodelist</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* NUL-terminate mode or flags string */</span>
		<span class="o">*</span><span class="n">nodelist</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nodelist_parse</span><span class="p">(</span><span class="n">nodelist</span><span class="p">,</span> <span class="n">nodes</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nodes_subset</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">node_states</span><span class="p">[</span><span class="n">N_HIGH_MEMORY</span><span class="p">]))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">nodes_clear</span><span class="p">(</span><span class="n">nodes</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span><span class="p">)</span>
		<span class="o">*</span><span class="n">flags</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>	<span class="cm">/* terminate mode string */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">mode</span> <span class="o">&lt;=</span> <span class="n">MPOL_LOCAL</span><span class="p">;</span> <span class="n">mode</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">policy_modes</span><span class="p">[</span><span class="n">mode</span><span class="p">]))</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&gt;</span> <span class="n">MPOL_LOCAL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MPOL_PREFERRED</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Insist on a nodelist of one node only</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nodelist</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">nodelist</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">isdigit</span><span class="p">(</span><span class="o">*</span><span class="n">rest</span><span class="p">))</span>
				<span class="n">rest</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">rest</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MPOL_INTERLEAVE</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Default to online nodes with memory if no nodelist</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nodelist</span><span class="p">)</span>
			<span class="n">nodes</span> <span class="o">=</span> <span class="n">node_states</span><span class="p">[</span><span class="n">N_HIGH_MEMORY</span><span class="p">];</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MPOL_LOCAL</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Don&#39;t allow a nodelist;  mpol_new() checks flags</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nodelist</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">mode</span> <span class="o">=</span> <span class="n">MPOL_PREFERRED</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MPOL_DEFAULT</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Insist on a empty nodelist</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nodelist</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MPOL_BIND</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Insist on a nodelist</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nodelist</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mode_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Currently, we only support two mutually exclusive</span>
<span class="cm">		 * mode flags.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="s">&quot;static&quot;</span><span class="p">))</span>
			<span class="n">mode_flags</span> <span class="o">|=</span> <span class="n">MPOL_F_STATIC_NODES</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="s">&quot;relative&quot;</span><span class="p">))</span>
			<span class="n">mode_flags</span> <span class="o">|=</span> <span class="n">MPOL_F_RELATIVE_NODES</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">new</span> <span class="o">=</span> <span class="n">mpol_new</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">mode_flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nodes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">new</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">no_context</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* save for contextualization */</span>
		<span class="n">new</span><span class="o">-&gt;</span><span class="n">w</span><span class="p">.</span><span class="n">user_nodemask</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">NODEMASK_SCRATCH</span><span class="p">(</span><span class="n">scratch</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scratch</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">task_lock</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">mpol_set_nodemask</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nodes</span><span class="p">,</span> <span class="n">scratch</span><span class="p">);</span>
			<span class="n">task_unlock</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">NODEMASK_SCRATCH_FREE</span><span class="p">(</span><span class="n">scratch</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mpol_put</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="cm">/* Restore string for error message */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nodelist</span><span class="p">)</span>
		<span class="o">*--</span><span class="n">nodelist</span> <span class="o">=</span> <span class="sc">&#39;:&#39;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span><span class="p">)</span>
		<span class="o">*--</span><span class="n">flags</span> <span class="o">=</span> <span class="sc">&#39;=&#39;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="o">*</span><span class="n">mpol</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_TMPFS */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * mpol_to_str - format a mempolicy structure for printing</span>
<span class="cm"> * @buffer:  to contain formatted mempolicy string</span>
<span class="cm"> * @maxlen:  length of @buffer</span>
<span class="cm"> * @pol:  pointer to mempolicy to be formatted</span>
<span class="cm"> * @no_context:  &quot;context free&quot; mempolicy - use nodemask in w.user_nodemask</span>
<span class="cm"> *</span>
<span class="cm"> * Convert a mempolicy into a string.</span>
<span class="cm"> * Returns the number of characters in buffer (if positive)</span>
<span class="cm"> * or an error (negative)</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">mpol_to_str</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxlen</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">pol</span><span class="p">,</span> <span class="kt">int</span> <span class="n">no_context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">l</span><span class="p">;</span>
	<span class="n">nodemask_t</span> <span class="n">nodes</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">mode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">pol</span> <span class="o">?</span> <span class="n">pol</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Sanity check:  room for longest mode, flag and some nodes</span>
<span class="cm">	 */</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">maxlen</span> <span class="o">&lt;</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;interleave&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;relative&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">16</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pol</span> <span class="o">||</span> <span class="n">pol</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">default_policy</span><span class="p">)</span>
		<span class="n">mode</span> <span class="o">=</span> <span class="n">MPOL_DEFAULT</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">mode</span> <span class="o">=</span> <span class="n">pol</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MPOL_DEFAULT</span>:
		<span class="n">nodes_clear</span><span class="p">(</span><span class="n">nodes</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">MPOL_PREFERRED</span>:
		<span class="n">nodes_clear</span><span class="p">(</span><span class="n">nodes</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MPOL_F_LOCAL</span><span class="p">)</span>
			<span class="n">mode</span> <span class="o">=</span> <span class="n">MPOL_LOCAL</span><span class="p">;</span>	<span class="cm">/* pseudo-policy */</span>
		<span class="k">else</span>
			<span class="n">node_set</span><span class="p">(</span><span class="n">pol</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">preferred_node</span><span class="p">,</span> <span class="n">nodes</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">MPOL_BIND</span>:
		<span class="cm">/* Fall through */</span>
	<span class="k">case</span> <span class="n">MPOL_INTERLEAVE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">no_context</span><span class="p">)</span>
			<span class="n">nodes</span> <span class="o">=</span> <span class="n">pol</span><span class="o">-&gt;</span><span class="n">w</span><span class="p">.</span><span class="n">user_nodemask</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">nodes</span> <span class="o">=</span> <span class="n">pol</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">nodes</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">l</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">policy_modes</span><span class="p">[</span><span class="n">mode</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">+</span> <span class="n">maxlen</span> <span class="o">&lt;</span> <span class="n">p</span> <span class="o">+</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>

	<span class="n">strcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">policy_modes</span><span class="p">[</span><span class="n">mode</span><span class="p">]);</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="n">l</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MPOL_MODE_FLAGS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">+</span> <span class="n">maxlen</span> <span class="o">&lt;</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;=&#39;</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Currently, the only defined flags are mutually exclusive</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MPOL_F_STATIC_NODES</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">+=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">buffer</span> <span class="o">+</span> <span class="n">maxlen</span> <span class="o">-</span> <span class="n">p</span><span class="p">,</span> <span class="s">&quot;static&quot;</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MPOL_F_RELATIVE_NODES</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">+=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">buffer</span> <span class="o">+</span> <span class="n">maxlen</span> <span class="o">-</span> <span class="n">p</span><span class="p">,</span> <span class="s">&quot;relative&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nodes_empty</span><span class="p">(</span><span class="n">nodes</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">+</span> <span class="n">maxlen</span> <span class="o">&lt;</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;:&#39;</span><span class="p">;</span>
	 	<span class="n">p</span> <span class="o">+=</span> <span class="n">nodelist_scnprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">buffer</span> <span class="o">+</span> <span class="n">maxlen</span> <span class="o">-</span> <span class="n">p</span><span class="p">,</span> <span class="n">nodes</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">p</span> <span class="o">-</span> <span class="n">buffer</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
