<!DOCTYPE html>
<html><head><title>joekychen/linux » mm › rmap.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>rmap.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * mm/rmap.c - physical to virtual reverse mappings</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2001, Rik van Riel &lt;riel@conectiva.com.br&gt;</span>
<span class="cm"> * Released under the General Public License (GPL).</span>
<span class="cm"> *</span>
<span class="cm"> * Simple, low overhead reverse mapping scheme.</span>
<span class="cm"> * Please try to keep this thing as modular as possible.</span>
<span class="cm"> *</span>
<span class="cm"> * Provides methods for unmapping each kind of mapped page:</span>
<span class="cm"> * the anon methods track anonymous pages, and</span>
<span class="cm"> * the file methods track pages belonging to an inode.</span>
<span class="cm"> *</span>
<span class="cm"> * Original design by Rik van Riel &lt;riel@conectiva.com.br&gt; 2001</span>
<span class="cm"> * File methods by Dave McCracken &lt;dmccr@us.ibm.com&gt; 2003, 2004</span>
<span class="cm"> * Anonymous methods by Andrea Arcangeli &lt;andrea@suse.de&gt; 2004</span>
<span class="cm"> * Contributions by Hugh Dickins 2003, 2004</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Lock ordering in mm:</span>
<span class="cm"> *</span>
<span class="cm"> * inode-&gt;i_mutex	(while writing or truncating, not reading or faulting)</span>
<span class="cm"> *   mm-&gt;mmap_sem</span>
<span class="cm"> *     page-&gt;flags PG_locked (lock_page)</span>
<span class="cm"> *       mapping-&gt;i_mmap_mutex</span>
<span class="cm"> *         anon_vma-&gt;mutex</span>
<span class="cm"> *           mm-&gt;page_table_lock or pte_lock</span>
<span class="cm"> *             zone-&gt;lru_lock (in mark_page_accessed, isolate_lru_page)</span>
<span class="cm"> *             swap_lock (in swap_duplicate, swap_info_get)</span>
<span class="cm"> *               mmlist_lock (in mmput, drain_mmlist and others)</span>
<span class="cm"> *               mapping-&gt;private_lock (in __set_page_dirty_buffers)</span>
<span class="cm"> *               inode-&gt;i_lock (in set_page_dirty&#39;s __mark_inode_dirty)</span>
<span class="cm"> *               bdi.wb-&gt;list_lock (in set_page_dirty&#39;s __mark_inode_dirty)</span>
<span class="cm"> *                 sb_lock (within inode_lock in fs/fs-writeback.c)</span>
<span class="cm"> *                 mapping-&gt;tree_lock (widely used, in set_page_dirty,</span>
<span class="cm"> *                           in arch-dependent flush_dcache_mmap_lock,</span>
<span class="cm"> *                           within bdi.wb-&gt;list_lock in __sync_single_inode)</span>
<span class="cm"> *</span>
<span class="cm"> * anon_vma-&gt;mutex,mapping-&gt;i_mutex      (memory_failure, collect_procs_anon)</span>
<span class="cm"> *   -&gt;tasklist_lock</span>
<span class="cm"> *     pte map lock</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/swapops.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/ksm.h&gt;</span>
<span class="cp">#include &lt;linux/rmap.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/memcontrol.h&gt;</span>
<span class="cp">#include &lt;linux/mmu_notifier.h&gt;</span>
<span class="cp">#include &lt;linux/migrate.h&gt;</span>
<span class="cp">#include &lt;linux/hugetlb.h&gt;</span>

<span class="cp">#include &lt;asm/tlbflush.h&gt;</span>

<span class="cp">#include &quot;internal.h&quot;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">anon_vma_cachep</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">anon_vma_chain_cachep</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="nf">anon_vma_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span><span class="p">;</span>

	<span class="n">anon_vma</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">anon_vma_cachep</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">anon_vma</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Initialise the anon_vma root to point to itself. If called</span>
<span class="cm">		 * from fork, the root will be reset to the parents anon_vma.</span>
<span class="cm">		 */</span>
		<span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">anon_vma</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">anon_vma</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">anon_vma_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Synchronize against page_lock_anon_vma() such that</span>
<span class="cm">	 * we can safely hold the lock without the anon_vma getting</span>
<span class="cm">	 * freed.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Relies on the full mb implied by the atomic_dec_and_test() from</span>
<span class="cm">	 * put_anon_vma() against the acquire barrier implied by</span>
<span class="cm">	 * mutex_trylock() from page_lock_anon_vma(). This orders:</span>
<span class="cm">	 *</span>
<span class="cm">	 * page_lock_anon_vma()		VS	put_anon_vma()</span>
<span class="cm">	 *   mutex_trylock()			  atomic_dec_and_test()</span>
<span class="cm">	 *   LOCK				  MB</span>
<span class="cm">	 *   atomic_read()			  mutex_is_locked()</span>
<span class="cm">	 *</span>
<span class="cm">	 * LOCK should suffice since the actual taking of the lock must</span>
<span class="cm">	 * happen _before_ what follows.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">anon_vma_lock</span><span class="p">(</span><span class="n">anon_vma</span><span class="p">);</span>
		<span class="n">anon_vma_unlock</span><span class="p">(</span><span class="n">anon_vma</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">anon_vma_cachep</span><span class="p">,</span> <span class="n">anon_vma</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">anon_vma_chain</span> <span class="o">*</span><span class="nf">anon_vma_chain_alloc</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">anon_vma_chain_cachep</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">anon_vma_chain_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">anon_vma_chain</span> <span class="o">*</span><span class="n">anon_vma_chain</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">anon_vma_chain_cachep</span><span class="p">,</span> <span class="n">anon_vma_chain</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">anon_vma_chain_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">anon_vma_chain</span> <span class="o">*</span><span class="n">avc</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">avc</span><span class="o">-&gt;</span><span class="n">vma</span> <span class="o">=</span> <span class="n">vma</span><span class="p">;</span>
	<span class="n">avc</span><span class="o">-&gt;</span><span class="n">anon_vma</span> <span class="o">=</span> <span class="n">anon_vma</span><span class="p">;</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">avc</span><span class="o">-&gt;</span><span class="n">same_vma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma_chain</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * It&#39;s critical to add new vmas to the tail of the anon_vma,</span>
<span class="cm">	 * see comment in huge_memory.c:__split_huge_page().</span>
<span class="cm">	 */</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">avc</span><span class="o">-&gt;</span><span class="n">same_anon_vma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * anon_vma_prepare - attach an anon_vma to a memory region</span>
<span class="cm"> * @vma: the memory region in question</span>
<span class="cm"> *</span>
<span class="cm"> * This makes sure the memory mapping described by &#39;vma&#39; has</span>
<span class="cm"> * an &#39;anon_vma&#39; attached to it, so that we can associate the</span>
<span class="cm"> * anonymous pages mapped into it with that anon_vma.</span>
<span class="cm"> *</span>
<span class="cm"> * The common case will be that we already have one, but if</span>
<span class="cm"> * not we either need to find an adjacent mapping that we</span>
<span class="cm"> * can re-use the anon_vma from (very common when the only</span>
<span class="cm"> * reason for splitting a vma has been mprotect()), or we</span>
<span class="cm"> * allocate a new one.</span>
<span class="cm"> *</span>
<span class="cm"> * Anon-vma allocations are very subtle, because we may have</span>
<span class="cm"> * optimistically looked up an anon_vma in page_lock_anon_vma()</span>
<span class="cm"> * and that may actually touch the spinlock even in the newly</span>
<span class="cm"> * allocated vma (it depends on RCU to make sure that the</span>
<span class="cm"> * anon_vma isn&#39;t actually destroyed).</span>
<span class="cm"> *</span>
<span class="cm"> * As a result, we need to do proper anon_vma locking even</span>
<span class="cm"> * for the new allocation. At the same time, we do not want</span>
<span class="cm"> * to do any locking for the common case of already having</span>
<span class="cm"> * an anon_vma.</span>
<span class="cm"> *</span>
<span class="cm"> * This must be called with the mmap_sem held for reading.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">anon_vma_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">anon_vma_chain</span> <span class="o">*</span><span class="n">avc</span><span class="p">;</span>

	<span class="n">might_sleep</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">anon_vma</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">allocated</span><span class="p">;</span>

		<span class="n">avc</span> <span class="o">=</span> <span class="n">anon_vma_chain_alloc</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">avc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_enomem</span><span class="p">;</span>

		<span class="n">anon_vma</span> <span class="o">=</span> <span class="n">find_mergeable_anon_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
		<span class="n">allocated</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">anon_vma</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">anon_vma</span> <span class="o">=</span> <span class="n">anon_vma_alloc</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">anon_vma</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out_enomem_free_avc</span><span class="p">;</span>
			<span class="n">allocated</span> <span class="o">=</span> <span class="n">anon_vma</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">anon_vma_lock</span><span class="p">(</span><span class="n">anon_vma</span><span class="p">);</span>
		<span class="cm">/* page_table_lock to protect against threads */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span> <span class="o">=</span> <span class="n">anon_vma</span><span class="p">;</span>
			<span class="n">anon_vma_chain_link</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">avc</span><span class="p">,</span> <span class="n">anon_vma</span><span class="p">);</span>
			<span class="n">allocated</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">avc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
		<span class="n">anon_vma_unlock</span><span class="p">(</span><span class="n">anon_vma</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">allocated</span><span class="p">))</span>
			<span class="n">put_anon_vma</span><span class="p">(</span><span class="n">allocated</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">avc</span><span class="p">))</span>
			<span class="n">anon_vma_chain_free</span><span class="p">(</span><span class="n">avc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">out_enomem_free_avc:</span>
	<span class="n">anon_vma_chain_free</span><span class="p">(</span><span class="n">avc</span><span class="p">);</span>
 <span class="nl">out_enomem:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is a useful helper function for locking the anon_vma root as</span>
<span class="cm"> * we traverse the vma-&gt;anon_vma_chain, looping over anon_vma&#39;s that</span>
<span class="cm"> * have the same vma.</span>
<span class="cm"> *</span>
<span class="cm"> * Such anon_vma&#39;s should have the same root, so you&#39;d expect to see</span>
<span class="cm"> * just a single mutex_lock for the whole traversal.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="nf">lock_anon_vma_root</span><span class="p">(</span><span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">new_root</span> <span class="o">=</span> <span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_root</span> <span class="o">!=</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="n">root</span> <span class="o">=</span> <span class="n">new_root</span><span class="p">;</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">root</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">unlock_anon_vma_root</span><span class="p">(</span><span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="p">)</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Attach the anon_vmas from src to dst.</span>
<span class="cm"> * Returns 0 on success, -ENOMEM on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">anon_vma_clone</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">anon_vma_chain</span> <span class="o">*</span><span class="n">avc</span><span class="p">,</span> <span class="o">*</span><span class="n">pavc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">list_for_each_entry_reverse</span><span class="p">(</span><span class="n">pavc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">anon_vma_chain</span><span class="p">,</span> <span class="n">same_vma</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span><span class="p">;</span>

		<span class="n">avc</span> <span class="o">=</span> <span class="n">anon_vma_chain_alloc</span><span class="p">(</span><span class="n">GFP_NOWAIT</span> <span class="o">|</span> <span class="n">__GFP_NOWARN</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">avc</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">unlock_anon_vma_root</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
			<span class="n">root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">avc</span> <span class="o">=</span> <span class="n">anon_vma_chain_alloc</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">avc</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">enomem_failure</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">anon_vma</span> <span class="o">=</span> <span class="n">pavc</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">;</span>
		<span class="n">root</span> <span class="o">=</span> <span class="n">lock_anon_vma_root</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">anon_vma</span><span class="p">);</span>
		<span class="n">anon_vma_chain_link</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">avc</span><span class="p">,</span> <span class="n">anon_vma</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">unlock_anon_vma_root</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">enomem_failure:</span>
	<span class="n">unlink_anon_vmas</span><span class="p">(</span><span class="n">dst</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Some rmap walk that needs to find all ptes/hugepmds without false</span>
<span class="cm"> * negatives (like migrate and split_huge_page) running concurrent</span>
<span class="cm"> * with operations that copy or move pagetables (like mremap() and</span>
<span class="cm"> * fork()) to be safe. They depend on the anon_vma &quot;same_anon_vma&quot;</span>
<span class="cm"> * list to be in a certain order: the dst_vma must be placed after the</span>
<span class="cm"> * src_vma in the list. This is always guaranteed by fork() but</span>
<span class="cm"> * mremap() needs to call this function to enforce it in case the</span>
<span class="cm"> * dst_vma isn&#39;t newly allocated and chained with the anon_vma_clone()</span>
<span class="cm"> * function but just an extension of a pre-existing vma through</span>
<span class="cm"> * vma_merge.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: the same_anon_vma list can still be changed by other</span>
<span class="cm"> * processes while mremap runs because mremap doesn&#39;t hold the</span>
<span class="cm"> * anon_vma mutex to prevent modifications to the list while it</span>
<span class="cm"> * runs. All we need to enforce is that the relative order of this</span>
<span class="cm"> * process vmas isn&#39;t changing (we don&#39;t care about other vmas</span>
<span class="cm"> * order). Each vma corresponds to an anon_vma_chain structure so</span>
<span class="cm"> * there&#39;s no risk that other processes calling anon_vma_moveto_tail()</span>
<span class="cm"> * and changing the same_anon_vma list under mremap() will screw with</span>
<span class="cm"> * the relative order of this process vmas in the list, because we</span>
<span class="cm"> * they can&#39;t alter the order of any vma that belongs to this</span>
<span class="cm"> * process. And there can&#39;t be another anon_vma_moveto_tail() running</span>
<span class="cm"> * concurrently with mremap() coming from this process because we hold</span>
<span class="cm"> * the mmap_sem for the whole mremap(). fork() ordering dependency</span>
<span class="cm"> * also shouldn&#39;t be affected because fork() only cares that the</span>
<span class="cm"> * parent vmas are placed in the list before the child vmas and</span>
<span class="cm"> * anon_vma_moveto_tail() won&#39;t reorder vmas from either the fork()</span>
<span class="cm"> * parent or child.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">anon_vma_moveto_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">dst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">anon_vma_chain</span> <span class="o">*</span><span class="n">pavc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">list_for_each_entry_reverse</span><span class="p">(</span><span class="n">pavc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">anon_vma_chain</span><span class="p">,</span> <span class="n">same_vma</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span> <span class="o">=</span> <span class="n">pavc</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">;</span>
		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">pavc</span><span class="o">-&gt;</span><span class="n">vma</span> <span class="o">!=</span> <span class="n">dst</span><span class="p">);</span>
		<span class="n">root</span> <span class="o">=</span> <span class="n">lock_anon_vma_root</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">anon_vma</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pavc</span><span class="o">-&gt;</span><span class="n">same_anon_vma</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pavc</span><span class="o">-&gt;</span><span class="n">same_anon_vma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">unlock_anon_vma_root</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Attach vma to its own anon_vma, as well as to the anon_vmas that</span>
<span class="cm"> * the corresponding VMA in the parent process is attached to.</span>
<span class="cm"> * Returns 0 on success, non-zero on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">anon_vma_fork</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">pvma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">anon_vma_chain</span> <span class="o">*</span><span class="n">avc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t bother if the parent process has no anon_vma here. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pvma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * First, attach the new VMA to the parent VMA&#39;s anon_vmas,</span>
<span class="cm">	 * so rmap can find non-COWed pages in child processes.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">anon_vma_clone</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">pvma</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Then add our own anon_vma. */</span>
	<span class="n">anon_vma</span> <span class="o">=</span> <span class="n">anon_vma_alloc</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">anon_vma</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_error</span><span class="p">;</span>
	<span class="n">avc</span> <span class="o">=</span> <span class="n">anon_vma_chain_alloc</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">avc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_error_free_anon_vma</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The root anon_vma&#39;s spinlock is the lock actually used when we</span>
<span class="cm">	 * lock any of the anon_vmas in this anon_vma tree.</span>
<span class="cm">	 */</span>
	<span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">pvma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * With refcounts, an anon_vma can stay around longer than the</span>
<span class="cm">	 * process it belongs to. The root anon_vma needs to be pinned until</span>
<span class="cm">	 * this anon_vma is freed, because the lock lives in the root.</span>
<span class="cm">	 */</span>
	<span class="n">get_anon_vma</span><span class="p">(</span><span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">);</span>
	<span class="cm">/* Mark this anon_vma as the one where our new (COWed) pages go. */</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span> <span class="o">=</span> <span class="n">anon_vma</span><span class="p">;</span>
	<span class="n">anon_vma_lock</span><span class="p">(</span><span class="n">anon_vma</span><span class="p">);</span>
	<span class="n">anon_vma_chain_link</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">avc</span><span class="p">,</span> <span class="n">anon_vma</span><span class="p">);</span>
	<span class="n">anon_vma_unlock</span><span class="p">(</span><span class="n">anon_vma</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">out_error_free_anon_vma:</span>
	<span class="n">put_anon_vma</span><span class="p">(</span><span class="n">anon_vma</span><span class="p">);</span>
 <span class="nl">out_error:</span>
	<span class="n">unlink_anon_vmas</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">unlink_anon_vmas</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">anon_vma_chain</span> <span class="o">*</span><span class="n">avc</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Unlink each anon_vma chained to the VMA.  This list is ordered</span>
<span class="cm">	 * from newest to oldest, ensuring the root anon_vma gets freed last.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">avc</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma_chain</span><span class="p">,</span> <span class="n">same_vma</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span> <span class="o">=</span> <span class="n">avc</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">;</span>

		<span class="n">root</span> <span class="o">=</span> <span class="n">lock_anon_vma_root</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">anon_vma</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">avc</span><span class="o">-&gt;</span><span class="n">same_anon_vma</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Leave empty anon_vmas on the list - we&#39;ll need</span>
<span class="cm">		 * to free them outside the lock.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">avc</span><span class="o">-&gt;</span><span class="n">same_vma</span><span class="p">);</span>
		<span class="n">anon_vma_chain_free</span><span class="p">(</span><span class="n">avc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">unlock_anon_vma_root</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Iterate the list once more, it now only contains empty and unlinked</span>
<span class="cm">	 * anon_vmas, destroy them. Could not do before due to __put_anon_vma()</span>
<span class="cm">	 * needing to acquire the anon_vma-&gt;root-&gt;mutex.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">avc</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma_chain</span><span class="p">,</span> <span class="n">same_vma</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span> <span class="o">=</span> <span class="n">avc</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">;</span>

		<span class="n">put_anon_vma</span><span class="p">(</span><span class="n">anon_vma</span><span class="p">);</span>

		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">avc</span><span class="o">-&gt;</span><span class="n">same_vma</span><span class="p">);</span>
		<span class="n">anon_vma_chain_free</span><span class="p">(</span><span class="n">avc</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">anon_vma_ctor</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">anon_vma_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">anon_vma_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;anon_vma&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">anon_vma</span><span class="p">),</span>
			<span class="mi">0</span><span class="p">,</span> <span class="n">SLAB_DESTROY_BY_RCU</span><span class="o">|</span><span class="n">SLAB_PANIC</span><span class="p">,</span> <span class="n">anon_vma_ctor</span><span class="p">);</span>
	<span class="n">anon_vma_chain_cachep</span> <span class="o">=</span> <span class="n">KMEM_CACHE</span><span class="p">(</span><span class="n">anon_vma_chain</span><span class="p">,</span> <span class="n">SLAB_PANIC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Getting a lock on a stable anon_vma from a page off the LRU is tricky!</span>
<span class="cm"> *</span>
<span class="cm"> * Since there is no serialization what so ever against page_remove_rmap()</span>
<span class="cm"> * the best this function can do is return a locked anon_vma that might</span>
<span class="cm"> * have been relevant to this page.</span>
<span class="cm"> *</span>
<span class="cm"> * The page might have been remapped to a different anon_vma or the anon_vma</span>
<span class="cm"> * returned may already be freed (and even reused).</span>
<span class="cm"> *</span>
<span class="cm"> * In case it was remapped to a different anon_vma, the new anon_vma will be a</span>
<span class="cm"> * child of the old anon_vma, and the anon_vma lifetime rules will therefore</span>
<span class="cm"> * ensure that any anon_vma obtained from the page will still be valid for as</span>
<span class="cm"> * long as we observe page_mapped() [ hence all those page_mapped() tests ].</span>
<span class="cm"> *</span>
<span class="cm"> * All users of this function must be very careful when walking the anon_vma</span>
<span class="cm"> * chain and verify that the page in question is indeed mapped in it</span>
<span class="cm"> * [ something equivalent to page_mapped_in_vma() ].</span>
<span class="cm"> *</span>
<span class="cm"> * Since anon_vma&#39;s slab is DESTROY_BY_RCU and we know from page_remove_rmap()</span>
<span class="cm"> * that the anon_vma pointer from page-&gt;mapping is valid if there is a</span>
<span class="cm"> * mapcount, we can dereference the anon_vma after observing those.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="nf">page_get_anon_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">anon_mapping</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">anon_mapping</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">anon_mapping</span> <span class="o">&amp;</span> <span class="n">PAGE_MAPPING_FLAGS</span><span class="p">)</span> <span class="o">!=</span> <span class="n">PAGE_MAPPING_ANON</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_mapped</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">anon_vma</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">anon_mapping</span> <span class="o">-</span> <span class="n">PAGE_MAPPING_ANON</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">anon_vma</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this page is still mapped, then its anon_vma cannot have been</span>
<span class="cm">	 * freed.  But if it has been unmapped, we have no security against the</span>
<span class="cm">	 * anon_vma structure being freed and reused (for another anon_vma:</span>
<span class="cm">	 * SLAB_DESTROY_BY_RCU guarantees that - so the atomic_inc_not_zero()</span>
<span class="cm">	 * above cannot corrupt).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_mapped</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">put_anon_vma</span><span class="p">(</span><span class="n">anon_vma</span><span class="p">);</span>
		<span class="n">anon_vma</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">anon_vma</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Similar to page_get_anon_vma() except it locks the anon_vma.</span>
<span class="cm"> *</span>
<span class="cm"> * Its a little more complex as it tries to keep the fast path to a single</span>
<span class="cm"> * atomic op -- the trylock. If we fail the trylock, we fall back to getting a</span>
<span class="cm"> * reference like with page_get_anon_vma() and then block on the mutex.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="nf">page_lock_anon_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">root_anon_vma</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">anon_mapping</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">anon_mapping</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">anon_mapping</span> <span class="o">&amp;</span> <span class="n">PAGE_MAPPING_FLAGS</span><span class="p">)</span> <span class="o">!=</span> <span class="n">PAGE_MAPPING_ANON</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_mapped</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">anon_vma</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">anon_mapping</span> <span class="o">-</span> <span class="n">PAGE_MAPPING_ANON</span><span class="p">);</span>
	<span class="n">root_anon_vma</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_anon_vma</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the page is still mapped, then this anon_vma is still</span>
<span class="cm">		 * its anon_vma, and holding the mutex ensures that it will</span>
<span class="cm">		 * not go away, see anon_vma_free().</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_mapped</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_anon_vma</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
			<span class="n">anon_vma</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* trylock failed, we got to sleep */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">anon_vma</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_mapped</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">put_anon_vma</span><span class="p">(</span><span class="n">anon_vma</span><span class="p">);</span>
		<span class="n">anon_vma</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* we pinned the anon_vma, its safe to sleep */</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="n">anon_vma_lock</span><span class="p">(</span><span class="n">anon_vma</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Oops, we held the last refcount, release the lock</span>
<span class="cm">		 * and bail -- can&#39;t simply use put_anon_vma() because</span>
<span class="cm">		 * we&#39;ll deadlock on the anon_vma_lock() recursion.</span>
<span class="cm">		 */</span>
		<span class="n">anon_vma_unlock</span><span class="p">(</span><span class="n">anon_vma</span><span class="p">);</span>
		<span class="n">__put_anon_vma</span><span class="p">(</span><span class="n">anon_vma</span><span class="p">);</span>
		<span class="n">anon_vma</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">anon_vma</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">anon_vma</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">page_unlock_anon_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">anon_vma_unlock</span><span class="p">(</span><span class="n">anon_vma</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * At what user virtual address is page expected in @vma?</span>
<span class="cm"> * Returns virtual address or -EFAULT if page&#39;s index/offset is not</span>
<span class="cm"> * within the range mapped the @vma.</span>
<span class="cm"> */</span>
<span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">vma_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgoff_t</span> <span class="n">pgoff</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SHIFT</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">is_vm_hugetlb_page</span><span class="p">(</span><span class="n">vma</span><span class="p">)))</span>
		<span class="n">pgoff</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="n">huge_page_order</span><span class="p">(</span><span class="n">page_hstate</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">address</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">+</span> <span class="p">((</span><span class="n">pgoff</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">address</span> <span class="o">&lt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">||</span> <span class="n">address</span> <span class="o">&gt;=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* page should be within @vma mapping range */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">address</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * At what user virtual address is page expected in vma?</span>
<span class="cm"> * Caller should check the page is actually part of the vma.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">page_address_in_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageAnon</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">page__anon_vma</span> <span class="o">=</span> <span class="n">page_anon_vma</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Note: swapoff&#39;s unuse_vma() is more efficient with this</span>
<span class="cm">		 * check, and needs it to match anon_vma when KSM is active.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span> <span class="o">||</span> <span class="o">!</span><span class="n">page__anon_vma</span> <span class="o">||</span>
		    <span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">!=</span> <span class="n">page__anon_vma</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_NONLINEAR</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span> <span class="o">||</span>
		    <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_mapping</span> <span class="o">!=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">vma_address</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check that @page is mapped at @address into @mm.</span>
<span class="cm"> *</span>
<span class="cm"> * If @sync is false, page_check_address may perform a racy check to avoid</span>
<span class="cm"> * the page table lock when the pte is not present (helpful when reclaiming</span>
<span class="cm"> * highly shared pages).</span>
<span class="cm"> *</span>
<span class="cm"> * On success returns with pte mapped and locked.</span>
<span class="cm"> */</span>
<span class="n">pte_t</span> <span class="o">*</span><span class="nf">__page_check_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">spinlock_t</span> <span class="o">**</span><span class="n">ptlp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">ptl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">PageHuge</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">pte</span> <span class="o">=</span> <span class="n">huge_pte_offset</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
		<span class="n">ptl</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">check</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pgd_present</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pud_present</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmd_present</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmd_trans_huge</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_offset_map</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="cm">/* Make a quick check before getting the lock */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sync</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pte_present</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pte_unmap</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ptl</span> <span class="o">=</span> <span class="n">pte_lockptr</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">);</span>
<span class="nl">check:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="n">ptl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pte_present</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">==</span> <span class="n">pte_pfn</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">ptlp</span> <span class="o">=</span> <span class="n">ptl</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * page_mapped_in_vma - check whether a page is really mapped in a VMA</span>
<span class="cm"> * @page: the page to test</span>
<span class="cm"> * @vma: the VMA to test</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 if the page is mapped into the page tables of the VMA, 0</span>
<span class="cm"> * if the page is not mapped into the page tables of this VMA.  Only</span>
<span class="cm"> * valid for normal file or anonymous VMAs.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">page_mapped_in_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">ptl</span><span class="p">;</span>

	<span class="n">address</span> <span class="o">=</span> <span class="n">vma_address</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">==</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">)</span>		<span class="cm">/* out of vma range */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pte</span> <span class="o">=</span> <span class="n">page_check_address</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptl</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte</span><span class="p">)</span>			<span class="cm">/* the page is not in this mm */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Subfunctions of page_referenced: page_referenced_one called</span>
<span class="cm"> * repeatedly from either page_referenced_anon or page_referenced_file.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">page_referenced_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">mapcount</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">vm_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">referenced</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">PageTransHuge</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * rmap might return false positives; we must filter</span>
<span class="cm">		 * these out using page_check_address_pmd().</span>
<span class="cm">		 */</span>
		<span class="n">pmd</span> <span class="o">=</span> <span class="n">page_check_address_pmd</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span>
					     <span class="n">PAGE_CHECK_ADDRESS_PMD_FLAG</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_LOCKED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
			<span class="o">*</span><span class="n">mapcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* break early from loop */</span>
			<span class="o">*</span><span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_LOCKED</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* go ahead even if the pmd is pmd_trans_splitting() */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmdp_clear_flush_young_notify</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pmd</span><span class="p">))</span>
			<span class="n">referenced</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
		<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">ptl</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * rmap might return false positives; we must filter</span>
<span class="cm">		 * these out using page_check_address().</span>
<span class="cm">		 */</span>
		<span class="n">pte</span> <span class="o">=</span> <span class="n">page_check_address</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptl</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_LOCKED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
			<span class="o">*</span><span class="n">mapcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* break early from loop */</span>
			<span class="o">*</span><span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_LOCKED</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ptep_clear_flush_young_notify</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Don&#39;t treat a reference through a sequentially read</span>
<span class="cm">			 * mapping as such.  If the page has been used in</span>
<span class="cm">			 * another mapping, we will catch it; if this other</span>
<span class="cm">			 * mapping is already gone, the unmap path will have</span>
<span class="cm">			 * set PG_referenced or activated the page.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">VM_SequentialReadHint</span><span class="p">(</span><span class="n">vma</span><span class="p">)))</span>
				<span class="n">referenced</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="p">(</span><span class="o">*</span><span class="n">mapcount</span><span class="p">)</span><span class="o">--</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">referenced</span><span class="p">)</span>
		<span class="o">*</span><span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">referenced</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">page_referenced_anon</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">vm_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mapcount</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">anon_vma_chain</span> <span class="o">*</span><span class="n">avc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">referenced</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">anon_vma</span> <span class="o">=</span> <span class="n">page_lock_anon_vma</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">anon_vma</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">referenced</span><span class="p">;</span>

	<span class="n">mapcount</span> <span class="o">=</span> <span class="n">page_mapcount</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">avc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">same_anon_vma</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span> <span class="o">=</span> <span class="n">avc</span><span class="o">-&gt;</span><span class="n">vma</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span> <span class="o">=</span> <span class="n">vma_address</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">==</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we are reclaiming on behalf of a cgroup, skip</span>
<span class="cm">		 * counting on behalf of references from different</span>
<span class="cm">		 * cgroups</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memcg</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mm_match_cgroup</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">memcg</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">referenced</span> <span class="o">+=</span> <span class="n">page_referenced_one</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span>
						  <span class="o">&amp;</span><span class="n">mapcount</span><span class="p">,</span> <span class="n">vm_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapcount</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">page_unlock_anon_vma</span><span class="p">(</span><span class="n">anon_vma</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">referenced</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * page_referenced_file - referenced check for object-based rmap</span>
<span class="cm"> * @page: the page we&#39;re checking references on.</span>
<span class="cm"> * @memcg: target memory control group</span>
<span class="cm"> * @vm_flags: collect encountered vma-&gt;vm_flags who actually referenced the page</span>
<span class="cm"> *</span>
<span class="cm"> * For an object-based mapped page, find all the places it is mapped and</span>
<span class="cm"> * check/clear the referenced flag.  This is done by following the page-&gt;mapping</span>
<span class="cm"> * pointer, then walking the chain of vmas it holds.  It returns the number</span>
<span class="cm"> * of references it found.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is only called from page_referenced for object-based pages.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">page_referenced_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">vm_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mapcount</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">pgoff</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SHIFT</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">prio_tree_iter</span> <span class="n">iter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">referenced</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The caller&#39;s checks on page-&gt;mapping and !PageAnon have made</span>
<span class="cm">	 * sure that this is a file page: the check for page-&gt;mapping</span>
<span class="cm">	 * excludes the case just before it gets set on an anon page.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">PageAnon</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * The page lock not only makes sure that page-&gt;mapping cannot</span>
<span class="cm">	 * suddenly be NULLified by truncation, it makes sure that the</span>
<span class="cm">	 * structure at mapping cannot be freed and reused yet,</span>
<span class="cm">	 * so we can safely take mapping-&gt;i_mmap_mutex.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_mutex</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * i_mmap_mutex does not stabilize mapcount at all, but mapcount</span>
<span class="cm">	 * is more likely to be accurate if we note it after spinning.</span>
<span class="cm">	 */</span>
	<span class="n">mapcount</span> <span class="o">=</span> <span class="n">page_mapcount</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">vma_prio_tree_foreach</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap</span><span class="p">,</span> <span class="n">pgoff</span><span class="p">,</span> <span class="n">pgoff</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span> <span class="o">=</span> <span class="n">vma_address</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">==</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we are reclaiming on behalf of a cgroup, skip</span>
<span class="cm">		 * counting on behalf of references from different</span>
<span class="cm">		 * cgroups</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memcg</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mm_match_cgroup</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">memcg</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">referenced</span> <span class="o">+=</span> <span class="n">page_referenced_one</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span>
						  <span class="o">&amp;</span><span class="n">mapcount</span><span class="p">,</span> <span class="n">vm_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapcount</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">referenced</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * page_referenced - test if the page was referenced</span>
<span class="cm"> * @page: the page to test</span>
<span class="cm"> * @is_locked: caller holds lock on the page</span>
<span class="cm"> * @memcg: target memory cgroup</span>
<span class="cm"> * @vm_flags: collect encountered vma-&gt;vm_flags who actually referenced the page</span>
<span class="cm"> *</span>
<span class="cm"> * Quick test_and_clear_referenced for all mappings to a page,</span>
<span class="cm"> * returns the number of ptes which referenced the page.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">page_referenced</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="n">is_locked</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">vm_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">referenced</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">we_locked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="o">*</span><span class="n">vm_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page_mapped</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">page_rmapping</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_locked</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">PageAnon</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">||</span> <span class="n">PageKsm</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">we_locked</span> <span class="o">=</span> <span class="n">trylock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">we_locked</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">referenced</span><span class="o">++</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">PageKsm</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span>
			<span class="n">referenced</span> <span class="o">+=</span> <span class="n">page_referenced_ksm</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">memcg</span><span class="p">,</span>
								<span class="n">vm_flags</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">PageAnon</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="n">referenced</span> <span class="o">+=</span> <span class="n">page_referenced_anon</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">memcg</span><span class="p">,</span>
								<span class="n">vm_flags</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">)</span>
			<span class="n">referenced</span> <span class="o">+=</span> <span class="n">page_referenced_file</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">memcg</span><span class="p">,</span>
								<span class="n">vm_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">we_locked</span><span class="p">)</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">page_test_and_clear_young</span><span class="p">(</span><span class="n">page_to_pfn</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span>
			<span class="n">referenced</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">referenced</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">page_mkclean_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">ptl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pte</span> <span class="o">=</span> <span class="n">page_check_address</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptl</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pte_dirty</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">)</span> <span class="o">||</span> <span class="n">pte_write</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pte_t</span> <span class="n">entry</span><span class="p">;</span>

		<span class="n">flush_cache_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte_pfn</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">));</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">ptep_clear_flush_notify</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">pte_wrprotect</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">pte_mkclean</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
		<span class="n">set_pte_at</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">page_mkclean_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgoff_t</span> <span class="n">pgoff</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SHIFT</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">prio_tree_iter</span> <span class="n">iter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">PageAnon</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_mutex</span><span class="p">);</span>
	<span class="n">vma_prio_tree_foreach</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap</span><span class="p">,</span> <span class="n">pgoff</span><span class="p">,</span> <span class="n">pgoff</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_SHARED</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span> <span class="o">=</span> <span class="n">vma_address</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">==</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">+=</span> <span class="n">page_mkclean_one</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">page_mkclean</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">page_mapped</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">page_mapping</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mapping</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">page_mkclean_file</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page_test_and_clear_dirty</span><span class="p">(</span><span class="n">page_to_pfn</span><span class="p">(</span><span class="n">page</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">page_mkclean</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * page_move_anon_rmap - move a page to our anon_vma</span>
<span class="cm"> * @page:	the page to move to our anon_vma</span>
<span class="cm"> * @vma:	the vma the page belongs to</span>
<span class="cm"> * @address:	the user virtual address mapped</span>
<span class="cm"> *</span>
<span class="cm"> * When a page belongs exclusively to one process after a COW event,</span>
<span class="cm"> * that page can be moved into the anon_vma that belongs to just that</span>
<span class="cm"> * process, so the rmap code will not search the parent or sibling</span>
<span class="cm"> * processes.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">page_move_anon_rmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">;</span>

	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">anon_vma</span><span class="p">);</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">!=</span> <span class="n">linear_page_index</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">));</span>

	<span class="n">anon_vma</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">anon_vma</span> <span class="o">+</span> <span class="n">PAGE_MAPPING_ANON</span><span class="p">;</span>
	<span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="p">)</span> <span class="n">anon_vma</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __page_set_anon_rmap - set up new anonymous rmap</span>
<span class="cm"> * @page:	Page to add to rmap	</span>
<span class="cm"> * @vma:	VM area to add page to.</span>
<span class="cm"> * @address:	User virtual address of the mapping	</span>
<span class="cm"> * @exclusive:	the page is exclusively owned by the current process</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__page_set_anon_rmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="kt">int</span> <span class="n">exclusive</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">anon_vma</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PageAnon</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the page isn&#39;t exclusively mapped into this vma,</span>
<span class="cm">	 * we must use the _oldest_ possible anon_vma for the</span>
<span class="cm">	 * page mapping!</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">exclusive</span><span class="p">)</span>
		<span class="n">anon_vma</span> <span class="o">=</span> <span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>

	<span class="n">anon_vma</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">anon_vma</span> <span class="o">+</span> <span class="n">PAGE_MAPPING_ANON</span><span class="p">;</span>
	<span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="p">)</span> <span class="n">anon_vma</span><span class="p">;</span>
	<span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">linear_page_index</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __page_check_anon_rmap - sanity check anonymous rmap addition</span>
<span class="cm"> * @page:	the page to add the mapping to</span>
<span class="cm"> * @vma:	the vm area in which the mapping is added</span>
<span class="cm"> * @address:	the user virtual address mapped</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__page_check_anon_rmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_DEBUG_VM</span>
	<span class="cm">/*</span>
<span class="cm">	 * The page&#39;s anon-rmap details (mapping and index) are guaranteed to</span>
<span class="cm">	 * be set up correctly at this point.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We have exclusion against page_add_anon_rmap because the caller</span>
<span class="cm">	 * always holds the page locked, except if called from page_dup_rmap,</span>
<span class="cm">	 * in which case the page is already known to be setup.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We have exclusion against page_add_new_anon_rmap because those pages</span>
<span class="cm">	 * are initially only visible via the pagetables, and the pte is locked</span>
<span class="cm">	 * over the call to page_add_new_anon_rmap.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">page_anon_vma</span><span class="p">(</span><span class="n">page</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">!=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">!=</span> <span class="n">linear_page_index</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">));</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * page_add_anon_rmap - add pte mapping to an anonymous page</span>
<span class="cm"> * @page:	the page to add the mapping to</span>
<span class="cm"> * @vma:	the vm area in which the mapping is added</span>
<span class="cm"> * @address:	the user virtual address mapped</span>
<span class="cm"> *</span>
<span class="cm"> * The caller needs to hold the pte lock, and the page must be locked in</span>
<span class="cm"> * the anon_vma case: to serialize mapping,index checking after setting,</span>
<span class="cm"> * and to ensure that PageAnon is not being upgraded racily to PageKsm</span>
<span class="cm"> * (but PageKsm is never downgraded to PageAnon).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">page_add_anon_rmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">do_page_add_anon_rmap</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Special version of the above for do_swap_page, which often runs</span>
<span class="cm"> * into pages that are exclusively owned by the current process.</span>
<span class="cm"> * Everybody else should continue to use page_add_anon_rmap above.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">do_page_add_anon_rmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="kt">int</span> <span class="n">exclusive</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">first</span> <span class="o">=</span> <span class="n">atomic_inc_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">_mapcount</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageTransHuge</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="n">__inc_zone_page_state</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">NR_ANON_PAGES</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">__inc_zone_page_state</span><span class="p">(</span><span class="n">page</span><span class="p">,</span>
					      <span class="n">NR_ANON_TRANSPARENT_HUGEPAGES</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">PageKsm</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="cm">/* address might be in next vma when migration races vma_adjust */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span>
		<span class="n">__page_set_anon_rmap</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">exclusive</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">__page_check_anon_rmap</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * page_add_new_anon_rmap - add pte mapping to a new anonymous page</span>
<span class="cm"> * @page:	the page to add the mapping to</span>
<span class="cm"> * @vma:	the vm area in which the mapping is added</span>
<span class="cm"> * @address:	the user virtual address mapped</span>
<span class="cm"> *</span>
<span class="cm"> * Same as page_add_anon_rmap but must only be called on *new* pages.</span>
<span class="cm"> * This means the inc-and-test can be bypassed.</span>
<span class="cm"> * Page does not have to be locked.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">page_add_new_anon_rmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">address</span> <span class="o">&lt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">||</span> <span class="n">address</span> <span class="o">&gt;=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">);</span>
	<span class="n">SetPageSwapBacked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">_mapcount</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* increment count (starts at -1) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageTransHuge</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">__inc_zone_page_state</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">NR_ANON_PAGES</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">__inc_zone_page_state</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">NR_ANON_TRANSPARENT_HUGEPAGES</span><span class="p">);</span>
	<span class="n">__page_set_anon_rmap</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page_evictable</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">))</span>
		<span class="n">lru_cache_add_lru</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">LRU_ACTIVE_ANON</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">add_page_to_unevictable_list</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * page_add_file_rmap - add pte mapping to a file page</span>
<span class="cm"> * @page: the page to add the mapping to</span>
<span class="cm"> *</span>
<span class="cm"> * The caller needs to hold the pte lock.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">page_add_file_rmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">locked</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">mem_cgroup_begin_update_page_stat</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">locked</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_inc_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">_mapcount</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__inc_zone_page_state</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">NR_FILE_MAPPED</span><span class="p">);</span>
		<span class="n">mem_cgroup_inc_page_stat</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">MEMCG_NR_FILE_MAPPED</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mem_cgroup_end_update_page_stat</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">locked</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * page_remove_rmap - take down pte mapping from a page</span>
<span class="cm"> * @page: page to remove mapping from</span>
<span class="cm"> *</span>
<span class="cm"> * The caller needs to hold the pte lock.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">page_remove_rmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">anon</span> <span class="o">=</span> <span class="n">PageAnon</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">locked</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The anon case has no mem_cgroup page_stat to update; but may</span>
<span class="cm">	 * uncharge_page() below, where the lock ordering can deadlock if</span>
<span class="cm">	 * we hold the lock against page_stat move: so avoid it on anon.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">anon</span><span class="p">)</span>
		<span class="n">mem_cgroup_begin_update_page_stat</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">locked</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* page still mapped by someone else? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_add_negative</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">_mapcount</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now that the last pte has gone, s390 must transfer dirty</span>
<span class="cm">	 * flag from storage key to struct page.  We can usually skip</span>
<span class="cm">	 * this if the page is anon, so about to be freed; but perhaps</span>
<span class="cm">	 * not if it&#39;s in swapcache - there might be another pte slot</span>
<span class="cm">	 * containing the swap entry, but page not yet written to swap.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">anon</span> <span class="o">||</span> <span class="n">PageSwapCache</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="n">page_test_and_clear_dirty</span><span class="p">(</span><span class="n">page_to_pfn</span><span class="p">(</span><span class="n">page</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">set_page_dirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Hugepages are not counted in NR_ANON_PAGES nor NR_FILE_MAPPED</span>
<span class="cm">	 * and not charged by memcg for now.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">PageHuge</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">anon</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mem_cgroup_uncharge_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageTransHuge</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="n">__dec_zone_page_state</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">NR_ANON_PAGES</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">__dec_zone_page_state</span><span class="p">(</span><span class="n">page</span><span class="p">,</span>
					      <span class="n">NR_ANON_TRANSPARENT_HUGEPAGES</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">__dec_zone_page_state</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">NR_FILE_MAPPED</span><span class="p">);</span>
		<span class="n">mem_cgroup_dec_page_stat</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">MEMCG_NR_FILE_MAPPED</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * It would be tidy to reset the PageAnon mapping here,</span>
<span class="cm">	 * but that might overwrite a racing page_add_anon_rmap</span>
<span class="cm">	 * which increments mapcount after us but sets mapping</span>
<span class="cm">	 * before us: so leave the reset to free_hot_cold_page,</span>
<span class="cm">	 * and remember that it&#39;s only reliable while mapped.</span>
<span class="cm">	 * Leaving it set also helps swapoff to reinstate ptes</span>
<span class="cm">	 * faster for those pages still in swapcache.</span>
<span class="cm">	 */</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">anon</span><span class="p">)</span>
		<span class="n">mem_cgroup_end_update_page_stat</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">locked</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Subfunctions of try_to_unmap: try_to_unmap_one called</span>
<span class="cm"> * repeatedly from try_to_unmap_ksm, try_to_unmap_anon or try_to_unmap_file.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">try_to_unmap_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ttu_flags</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="n">pteval</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">ptl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">SWAP_AGAIN</span><span class="p">;</span>

	<span class="n">pte</span> <span class="o">=</span> <span class="n">page_check_address</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptl</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the page is mlock()d, we cannot swap it out.</span>
<span class="cm">	 * If it&#39;s recently referenced (perhaps page_referenced</span>
<span class="cm">	 * skipped over this mm) then we should reactivate it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TTU_IGNORE_MLOCK</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_LOCKED</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_mlock</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">TTU_ACTION</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span> <span class="o">==</span> <span class="n">TTU_MUNLOCK</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unmap</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TTU_IGNORE_ACCESS</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ptep_clear_flush_young_notify</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">SWAP_FAIL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unmap</span><span class="p">;</span>
		<span class="p">}</span>
  	<span class="p">}</span>

	<span class="cm">/* Nuke the page table entry. */</span>
	<span class="n">flush_cache_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">pteval</span> <span class="o">=</span> <span class="n">ptep_clear_flush_notify</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>

	<span class="cm">/* Move the dirty bit to the physical page now the pte is gone. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pte_dirty</span><span class="p">(</span><span class="n">pteval</span><span class="p">))</span>
		<span class="n">set_page_dirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="cm">/* Update high watermark before we lower rss */</span>
	<span class="n">update_hiwater_rss</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PageHWPoison</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TTU_IGNORE_HWPOISON</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageAnon</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="n">dec_mm_counter</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">MM_ANONPAGES</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">dec_mm_counter</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">MM_FILEPAGES</span><span class="p">);</span>
		<span class="n">set_pte_at</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span>
				<span class="n">swp_entry_to_pte</span><span class="p">(</span><span class="n">make_hwpoison_entry</span><span class="p">(</span><span class="n">page</span><span class="p">)));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">PageAnon</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">swp_entry_t</span> <span class="n">entry</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">page_private</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">};</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">PageSwapCache</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Store the swap location in the pte.</span>
<span class="cm">			 * See handle_pte_fault() ...</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">swap_duplicate</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">set_pte_at</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">pteval</span><span class="p">);</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">SWAP_FAIL</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out_unmap</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmlist</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mmlist_lock</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmlist</span><span class="p">))</span>
					<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmlist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">init_mm</span><span class="p">.</span><span class="n">mmlist</span><span class="p">);</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mmlist_lock</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">dec_mm_counter</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">MM_ANONPAGES</span><span class="p">);</span>
			<span class="n">inc_mm_counter</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">MM_SWAPENTS</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_MIGRATION</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Store the pfn of the page in a special migration</span>
<span class="cm">			 * pte. do_swap_page() will wait until the migration</span>
<span class="cm">			 * pte is removed and then restart fault handling.</span>
<span class="cm">			 */</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">TTU_ACTION</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span> <span class="o">!=</span> <span class="n">TTU_MIGRATION</span><span class="p">);</span>
			<span class="n">entry</span> <span class="o">=</span> <span class="n">make_migration_entry</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">pte_write</span><span class="p">(</span><span class="n">pteval</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">set_pte_at</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">swp_entry_to_pte</span><span class="p">(</span><span class="n">entry</span><span class="p">));</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pte_file</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_MIGRATION</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		   <span class="p">(</span><span class="n">TTU_ACTION</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span> <span class="o">==</span> <span class="n">TTU_MIGRATION</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Establish migration entry for a file page */</span>
		<span class="n">swp_entry_t</span> <span class="n">entry</span><span class="p">;</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">make_migration_entry</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">pte_write</span><span class="p">(</span><span class="n">pteval</span><span class="p">));</span>
		<span class="n">set_pte_at</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">swp_entry_to_pte</span><span class="p">(</span><span class="n">entry</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">dec_mm_counter</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">MM_FILEPAGES</span><span class="p">);</span>

	<span class="n">page_remove_rmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

<span class="nl">out_unmap:</span>
	<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">out_mlock:</span>
	<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>


	<span class="cm">/*</span>
<span class="cm">	 * We need mmap_sem locking, Otherwise VM_LOCKED check makes</span>
<span class="cm">	 * unstable result and race. Plus, We can&#39;t wait here because</span>
<span class="cm">	 * we now hold anon_vma-&gt;mutex or mapping-&gt;i_mmap_mutex.</span>
<span class="cm">	 * if trylock failed, the page remain in evictable lru and later</span>
<span class="cm">	 * vmscan could retry to move the page to unevictable lru if the</span>
<span class="cm">	 * page is actually mlocked.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">down_read_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_LOCKED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlock_vma_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">SWAP_MLOCK</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * objrmap doesn&#39;t work for nonlinear VMAs because the assumption that</span>
<span class="cm"> * offset-into-file correlates with offset-into-virtual-addresses does not hold.</span>
<span class="cm"> * Consequently, given a particular page and its -&gt;index, we cannot locate the</span>
<span class="cm"> * ptes which are mapping that page without an exhaustive linear search.</span>
<span class="cm"> *</span>
<span class="cm"> * So what this code does is a mini &quot;virtual scan&quot; of each nonlinear VMA which</span>
<span class="cm"> * maps the file to which the target page belongs.  The -&gt;vm_private_data field</span>
<span class="cm"> * holds the current cursor into that scan.  Successive searches will circulate</span>
<span class="cm"> * around the vma&#39;s virtual address space.</span>
<span class="cm"> *</span>
<span class="cm"> * So as more replacement pressure is applied to the pages in a nonlinear VMA,</span>
<span class="cm"> * more scanning pressure is placed against them as well.   Eventually pages</span>
<span class="cm"> * will become fully unmapped and are eligible for eviction.</span>
<span class="cm"> *</span>
<span class="cm"> * For very sparsely populated VMAs this is a little inefficient - chances are</span>
<span class="cm"> * there there won&#39;t be many ptes located within the scan cluster.  In this case</span>
<span class="cm"> * maybe we could scan further - to the end of the pte page, perhaps.</span>
<span class="cm"> *</span>
<span class="cm"> * Mlocked pages:  check VM_LOCKED under mmap_sem held for read, if we can</span>
<span class="cm"> * acquire it without blocking.  If vma locked, mlock the pages in the cluster,</span>
<span class="cm"> * rather than unmapping them.  If we encounter the &quot;check_page&quot; that vmscan is</span>
<span class="cm"> * trying to unmap, return SWAP_MLOCK, else default SWAP_AGAIN.</span>
<span class="cm"> */</span>
<span class="cp">#define CLUSTER_SIZE	min(32*PAGE_SIZE, PMD_SIZE)</span>
<span class="cp">#define CLUSTER_MASK	(~(CLUSTER_SIZE - 1))</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">try_to_unmap_cluster</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cursor</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">mapcount</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">check_page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">;</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="n">pteval</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">ptl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">SWAP_AGAIN</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">locked_vma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">+</span> <span class="n">cursor</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CLUSTER_MASK</span><span class="p">;</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">address</span> <span class="o">+</span> <span class="n">CLUSTER_SIZE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">&lt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span>
		<span class="n">address</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">)</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">;</span>

	<span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pgd_present</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pud_present</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmd_present</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we can acquire the mmap_sem for read, and vma is VM_LOCKED,</span>
<span class="cm">	 * keep the sem while scanning the cluster for mlocking pages.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">down_read_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">locked_vma</span> <span class="o">=</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_LOCKED</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">locked_vma</span><span class="p">)</span>
			<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span> <span class="cm">/* don&#39;t need it */</span>
	<span class="p">}</span>

	<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_offset_map_lock</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptl</span><span class="p">);</span>

	<span class="cm">/* Update high watermark before we lower rss */</span>
	<span class="n">update_hiwater_rss</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">address</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">pte</span><span class="o">++</span><span class="p">,</span> <span class="n">address</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_present</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">vm_normal_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="o">*</span><span class="n">pte</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">page</span> <span class="o">||</span> <span class="n">PageAnon</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">locked_vma</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlock_vma_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>   <span class="cm">/* no-op if already mlocked */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="n">check_page</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">SWAP_MLOCK</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>	<span class="cm">/* don&#39;t unmap */</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ptep_clear_flush_young_notify</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Nuke the page table entry. */</span>
		<span class="n">flush_cache_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte_pfn</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">));</span>
		<span class="n">pteval</span> <span class="o">=</span> <span class="n">ptep_clear_flush_notify</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>

		<span class="cm">/* If nonlinear, store the file page offset in the pte. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">!=</span> <span class="n">linear_page_index</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">))</span>
			<span class="n">set_pte_at</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">pgoff_to_pte</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">));</span>

		<span class="cm">/* Move the dirty bit to the physical page now the pte is gone. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pte_dirty</span><span class="p">(</span><span class="n">pteval</span><span class="p">))</span>
			<span class="n">set_page_dirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="n">page_remove_rmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">dec_mm_counter</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">MM_FILEPAGES</span><span class="p">);</span>
		<span class="p">(</span><span class="o">*</span><span class="n">mapcount</span><span class="p">)</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">pte</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">locked_vma</span><span class="p">)</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">is_vma_temporary_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">maybe_stack</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_GROWSDOWN</span> <span class="o">|</span> <span class="n">VM_GROWSUP</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">maybe_stack</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_STACK_INCOMPLETE_SETUP</span><span class="p">)</span> <span class="o">==</span>
						<span class="n">VM_STACK_INCOMPLETE_SETUP</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * try_to_unmap_anon - unmap or unlock anonymous page using the object-based</span>
<span class="cm"> * rmap method</span>
<span class="cm"> * @page: the page to unmap/unlock</span>
<span class="cm"> * @flags: action and flags</span>
<span class="cm"> *</span>
<span class="cm"> * Find all the mappings of a page using the mapping pointer and the vma chains</span>
<span class="cm"> * contained in the anon_vma struct it points to.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is only called from try_to_unmap/try_to_munlock for</span>
<span class="cm"> * anonymous pages.</span>
<span class="cm"> * When called from try_to_munlock(), the mmap_sem of the mm containing the vma</span>
<span class="cm"> * where the page was found will be held for write.  So, we won&#39;t recheck</span>
<span class="cm"> * vm_flags for that VMA.  That should be OK, because that vma shouldn&#39;t be</span>
<span class="cm"> * &#39;LOCKED.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">try_to_unmap_anon</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ttu_flags</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">anon_vma_chain</span> <span class="o">*</span><span class="n">avc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">SWAP_AGAIN</span><span class="p">;</span>

	<span class="n">anon_vma</span> <span class="o">=</span> <span class="n">page_lock_anon_vma</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">anon_vma</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">avc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">same_anon_vma</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span> <span class="o">=</span> <span class="n">avc</span><span class="o">-&gt;</span><span class="n">vma</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * During exec, a temporary VMA is setup and later moved.</span>
<span class="cm">		 * The VMA is moved under the anon_vma lock but not the</span>
<span class="cm">		 * page tables leading to a race where migration cannot</span>
<span class="cm">		 * find the migration ptes. Rather than increasing the</span>
<span class="cm">		 * locking requirements of exec(), migration skips</span>
<span class="cm">		 * temporary VMAs until after exec() completes.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_MIGRATION</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TTU_MIGRATION</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="n">is_vma_temporary_stack</span><span class="p">(</span><span class="n">vma</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">address</span> <span class="o">=</span> <span class="n">vma_address</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">==</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">try_to_unmap_one</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">SWAP_AGAIN</span> <span class="o">||</span> <span class="o">!</span><span class="n">page_mapped</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">page_unlock_anon_vma</span><span class="p">(</span><span class="n">anon_vma</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * try_to_unmap_file - unmap/unlock file page using the object-based rmap method</span>
<span class="cm"> * @page: the page to unmap/unlock</span>
<span class="cm"> * @flags: action and flags</span>
<span class="cm"> *</span>
<span class="cm"> * Find all the mappings of a page using the mapping pointer and the vma chains</span>
<span class="cm"> * contained in the address_space struct it points to.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is only called from try_to_unmap/try_to_munlock for</span>
<span class="cm"> * object-based pages.</span>
<span class="cm"> * When called from try_to_munlock(), the mmap_sem of the mm containing the vma</span>
<span class="cm"> * where the page was found will be held for write.  So, we won&#39;t recheck</span>
<span class="cm"> * vm_flags for that VMA.  That should be OK, because that vma shouldn&#39;t be</span>
<span class="cm"> * &#39;LOCKED.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">try_to_unmap_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ttu_flags</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">pgoff</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SHIFT</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">prio_tree_iter</span> <span class="n">iter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">SWAP_AGAIN</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cursor</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_nl_cursor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_nl_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mapcount</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_mutex</span><span class="p">);</span>
	<span class="n">vma_prio_tree_foreach</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap</span><span class="p">,</span> <span class="n">pgoff</span><span class="p">,</span> <span class="n">pgoff</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span> <span class="o">=</span> <span class="n">vma_address</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">==</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">try_to_unmap_one</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">SWAP_AGAIN</span> <span class="o">||</span> <span class="o">!</span><span class="n">page_mapped</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_nonlinear</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We don&#39;t bother to try to find the munlocked page in nonlinears.</span>
<span class="cm">	 * It&#39;s costly. Instead, later, page reclaim logic may call</span>
<span class="cm">	 * try_to_unmap(TTU_MUNLOCK) and recover PG_mlocked lazily.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TTU_ACTION</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span> <span class="o">==</span> <span class="n">TTU_MUNLOCK</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_nonlinear</span><span class="p">,</span>
						<span class="n">shared</span><span class="p">.</span><span class="n">vm_set</span><span class="p">.</span><span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cursor</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_private_data</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cursor</span> <span class="o">&gt;</span> <span class="n">max_nl_cursor</span><span class="p">)</span>
			<span class="n">max_nl_cursor</span> <span class="o">=</span> <span class="n">cursor</span><span class="p">;</span>
		<span class="n">cursor</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cursor</span> <span class="o">&gt;</span> <span class="n">max_nl_size</span><span class="p">)</span>
			<span class="n">max_nl_size</span> <span class="o">=</span> <span class="n">cursor</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">max_nl_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* all nonlinears locked or reserved ? */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">SWAP_FAIL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We don&#39;t try to search for this page in the nonlinear vmas,</span>
<span class="cm">	 * and page_referenced wouldn&#39;t have found it anyway.  Instead</span>
<span class="cm">	 * just walk the nonlinear vmas trying to age and unmap some.</span>
<span class="cm">	 * The mapcount of the page we came in with is irrelevant,</span>
<span class="cm">	 * but even so use it as a guide to how hard we should try?</span>
<span class="cm">	 */</span>
	<span class="n">mapcount</span> <span class="o">=</span> <span class="n">page_mapcount</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapcount</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">cond_resched</span><span class="p">();</span>

	<span class="n">max_nl_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_nl_size</span> <span class="o">+</span> <span class="n">CLUSTER_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CLUSTER_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_nl_cursor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">max_nl_cursor</span> <span class="o">=</span> <span class="n">CLUSTER_SIZE</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_nonlinear</span><span class="p">,</span>
						<span class="n">shared</span><span class="p">.</span><span class="n">vm_set</span><span class="p">.</span><span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cursor</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_private_data</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span> <span class="n">cursor</span> <span class="o">&lt;</span> <span class="n">max_nl_cursor</span> <span class="o">&amp;&amp;</span>
				<span class="n">cursor</span> <span class="o">&lt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">try_to_unmap_cluster</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mapcount</span><span class="p">,</span>
						<span class="n">vma</span><span class="p">,</span> <span class="n">page</span><span class="p">)</span> <span class="o">==</span> <span class="n">SWAP_MLOCK</span><span class="p">)</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="n">SWAP_MLOCK</span><span class="p">;</span>
				<span class="n">cursor</span> <span class="o">+=</span> <span class="n">CLUSTER_SIZE</span><span class="p">;</span>
				<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_private_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">cursor</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">mapcount</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_private_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">max_nl_cursor</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="n">max_nl_cursor</span> <span class="o">+=</span> <span class="n">CLUSTER_SIZE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">max_nl_cursor</span> <span class="o">&lt;=</span> <span class="n">max_nl_size</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t loop forever (perhaps all the remaining pages are</span>
<span class="cm">	 * in locked vmas).  Reset cursor on all unreserved nonlinear</span>
<span class="cm">	 * vmas, now forgetting on which ones it had fallen behind.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_nonlinear</span><span class="p">,</span> <span class="n">shared</span><span class="p">.</span><span class="n">vm_set</span><span class="p">.</span><span class="n">list</span><span class="p">)</span>
		<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_private_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * try_to_unmap - try to remove all page table mappings to a page</span>
<span class="cm"> * @page: the page to get unmapped</span>
<span class="cm"> * @flags: action and flags</span>
<span class="cm"> *</span>
<span class="cm"> * Tries to remove all the page table entries which are mapping this</span>
<span class="cm"> * page, used in the pageout path.  Caller must hold the page lock.</span>
<span class="cm"> * Return values are:</span>
<span class="cm"> *</span>
<span class="cm"> * SWAP_SUCCESS	- we succeeded in removing all mappings</span>
<span class="cm"> * SWAP_AGAIN	- we missed a mapping, try again later</span>
<span class="cm"> * SWAP_FAIL	- the page is unswappable</span>
<span class="cm"> * SWAP_MLOCK	- page is mlocked.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">try_to_unmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ttu_flags</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageHuge</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">PageTransHuge</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">PageKsm</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">try_to_unmap_ksm</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">PageAnon</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">try_to_unmap_anon</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">try_to_unmap_file</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">SWAP_MLOCK</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">page_mapped</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">SWAP_SUCCESS</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * try_to_munlock - try to munlock a page</span>
<span class="cm"> * @page: the page to be munlocked</span>
<span class="cm"> *</span>
<span class="cm"> * Called from munlock code.  Checks all of the VMAs mapping the page</span>
<span class="cm"> * to make sure nobody else has this page mlocked. The page will be</span>
<span class="cm"> * returned with PG_mlocked cleared if no other vmas have it mlocked.</span>
<span class="cm"> *</span>
<span class="cm"> * Return values are:</span>
<span class="cm"> *</span>
<span class="cm"> * SWAP_AGAIN	- no vma is holding page mlocked, or,</span>
<span class="cm"> * SWAP_AGAIN	- page mapped in mlocked vma -- couldn&#39;t acquire mmap sem</span>
<span class="cm"> * SWAP_FAIL	- page cannot be located at present</span>
<span class="cm"> * SWAP_MLOCK	- page is now mlocked.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">try_to_munlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">||</span> <span class="n">PageLRU</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">PageKsm</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">try_to_unmap_ksm</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">TTU_MUNLOCK</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">PageAnon</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">try_to_unmap_anon</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">TTU_MUNLOCK</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">try_to_unmap_file</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">TTU_MUNLOCK</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__put_anon_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">!=</span> <span class="n">anon_vma</span> <span class="o">&amp;&amp;</span> <span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">))</span>
		<span class="n">anon_vma_free</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

	<span class="n">anon_vma_free</span><span class="p">(</span><span class="n">anon_vma</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_MIGRATION</span>
<span class="cm">/*</span>
<span class="cm"> * rmap_walk() and its helpers rmap_walk_anon() and rmap_walk_file():</span>
<span class="cm"> * Called by migrate.c to remove migration ptes, but might be used more later.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rmap_walk_anon</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">rmap_one</span><span class="p">)(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">anon_vma_chain</span> <span class="o">*</span><span class="n">avc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">SWAP_AGAIN</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note: remove_migration_ptes() cannot use page_lock_anon_vma()</span>
<span class="cm">	 * because that depends on page_mapped(); but not all its usages</span>
<span class="cm">	 * are holding mmap_sem. Users without mmap_sem are required to</span>
<span class="cm">	 * take a reference count to prevent the anon_vma disappearing</span>
<span class="cm">	 */</span>
	<span class="n">anon_vma</span> <span class="o">=</span> <span class="n">page_anon_vma</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">anon_vma</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">anon_vma_lock</span><span class="p">(</span><span class="n">anon_vma</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">avc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">same_anon_vma</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span> <span class="o">=</span> <span class="n">avc</span><span class="o">-&gt;</span><span class="n">vma</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span> <span class="o">=</span> <span class="n">vma_address</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">==</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">rmap_one</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">SWAP_AGAIN</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">anon_vma_unlock</span><span class="p">(</span><span class="n">anon_vma</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rmap_walk_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">rmap_one</span><span class="p">)(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">pgoff</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SHIFT</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">prio_tree_iter</span> <span class="n">iter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">SWAP_AGAIN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapping</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_mutex</span><span class="p">);</span>
	<span class="n">vma_prio_tree_foreach</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap</span><span class="p">,</span> <span class="n">pgoff</span><span class="p">,</span> <span class="n">pgoff</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span> <span class="o">=</span> <span class="n">vma_address</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">==</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">rmap_one</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">SWAP_AGAIN</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * No nonlinear handling: being always shared, nonlinear vmas</span>
<span class="cm">	 * never contain migration ptes.  Decide what to do about this</span>
<span class="cm">	 * limitation to linear when we need rmap_walk() on nonlinear.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">rmap_walk</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">rmap_one</span><span class="p">)(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">PageKsm</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">rmap_walk_ksm</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">rmap_one</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">PageAnon</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">rmap_walk_anon</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">rmap_one</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">rmap_walk_file</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">rmap_one</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MIGRATION */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_HUGETLB_PAGE</span>
<span class="cm">/*</span>
<span class="cm"> * The following three functions are for anonymous (private mapped) hugepages.</span>
<span class="cm"> * Unlike common anonymous pages, anonymous hugepages have no accounting code</span>
<span class="cm"> * and no lru code, because we handle hugepages differently from common pages.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__hugepage_set_anon_rmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="kt">int</span> <span class="n">exclusive</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">anon_vma</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PageAnon</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">exclusive</span><span class="p">)</span>
		<span class="n">anon_vma</span> <span class="o">=</span> <span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>

	<span class="n">anon_vma</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">anon_vma</span> <span class="o">+</span> <span class="n">PAGE_MAPPING_ANON</span><span class="p">;</span>
	<span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="p">)</span> <span class="n">anon_vma</span><span class="p">;</span>
	<span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">linear_page_index</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">hugepage_add_anon_rmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">first</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">anon_vma</span><span class="p">);</span>
	<span class="cm">/* address might be in next vma when migration races vma_adjust */</span>
	<span class="n">first</span> <span class="o">=</span> <span class="n">atomic_inc_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">_mapcount</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span>
		<span class="n">__hugepage_set_anon_rmap</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">hugepage_add_new_anon_rmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">address</span> <span class="o">&lt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">||</span> <span class="n">address</span> <span class="o">&gt;=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">_mapcount</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">__hugepage_set_anon_rmap</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HUGETLB_PAGE */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
