<!DOCTYPE html>
<html><head><title>joekychen/linux » mm › huge_memory.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>huge_memory.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  Copyright (C) 2009  Red Hat, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> *  This work is licensed under the terms of the GNU GPL, version 2. See</span>
<span class="cm"> *  the COPYING file in the top-level directory.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/hugetlb.h&gt;</span>
<span class="cp">#include &lt;linux/mmu_notifier.h&gt;</span>
<span class="cp">#include &lt;linux/rmap.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/mm_inline.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/khugepaged.h&gt;</span>
<span class="cp">#include &lt;linux/freezer.h&gt;</span>
<span class="cp">#include &lt;linux/mman.h&gt;</span>
<span class="cp">#include &lt;asm/tlb.h&gt;</span>
<span class="cp">#include &lt;asm/pgalloc.h&gt;</span>
<span class="cp">#include &quot;internal.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * By default transparent hugepage support is enabled for all mappings</span>
<span class="cm"> * and khugepaged scans all mappings. Defrag is only invoked by</span>
<span class="cm"> * khugepaged hugepage allocations and by page faults inside</span>
<span class="cm"> * MADV_HUGEPAGE regions to avoid the risk of slowing down short lived</span>
<span class="cm"> * allocations.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">transparent_hugepage_flags</span> <span class="n">__read_mostly</span> <span class="o">=</span>
<span class="cp">#ifdef CONFIG_TRANSPARENT_HUGEPAGE_ALWAYS</span>
	<span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">TRANSPARENT_HUGEPAGE_FLAG</span><span class="p">)</span><span class="o">|</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_TRANSPARENT_HUGEPAGE_MADVISE</span>
	<span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG</span><span class="p">)</span><span class="o">|</span>
<span class="cp">#endif</span>
	<span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">TRANSPARENT_HUGEPAGE_DEFRAG_FLAG</span><span class="p">)</span><span class="o">|</span>
	<span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">TRANSPARENT_HUGEPAGE_DEFRAG_KHUGEPAGED_FLAG</span><span class="p">);</span>

<span class="cm">/* default scan 8*512 pte (or vmas) every 30 second */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">khugepaged_pages_to_scan</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="n">HPAGE_PMD_NR</span><span class="o">*</span><span class="mi">8</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">khugepaged_pages_collapsed</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">khugepaged_full_scans</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">khugepaged_scan_sleep_millisecs</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>
<span class="cm">/* during fragmentation poll the hugepage allocator once every minute */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">khugepaged_alloc_sleep_millisecs</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">60000</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">khugepaged_thread</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">khugepaged_mutex</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">khugepaged_mm_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DECLARE_WAIT_QUEUE_HEAD</span><span class="p">(</span><span class="n">khugepaged_wait</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm"> * default collapse hugepages if there is at least one pte mapped like</span>
<span class="cm"> * it would have happened if the vma was large enough during page</span>
<span class="cm"> * fault.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">khugepaged_max_ptes_none</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="n">HPAGE_PMD_NR</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">khugepaged</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">none</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mm_slots_hash_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">khugepaged_slab_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">khugepaged_slab_free</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#define MM_SLOTS_HASH_HEADS 1024</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">mm_slots_hash</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">mm_slot_cache</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct mm_slot - hash lookup from mm to mm_slot</span>
<span class="cm"> * @hash: hash collision list</span>
<span class="cm"> * @mm_node: khugepaged scan list headed in khugepaged_scan.mm_head</span>
<span class="cm"> * @mm: the mm that this information is valid for</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mm_slot</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">hash</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">mm_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct khugepaged_scan - cursor for scanning</span>
<span class="cm"> * @mm_head: the head of the mm list to scan</span>
<span class="cm"> * @mm_slot: the current mm_slot we are scanning</span>
<span class="cm"> * @address: the next address inside that to be scanned</span>
<span class="cm"> *</span>
<span class="cm"> * There is only the one khugepaged_scan instance of this cursor structure.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">khugepaged_scan</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">mm_head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_slot</span> <span class="o">*</span><span class="n">mm_slot</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">khugepaged_scan</span> <span class="n">khugepaged_scan</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">mm_head</span> <span class="o">=</span> <span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">khugepaged_scan</span><span class="p">.</span><span class="n">mm_head</span><span class="p">),</span>
<span class="p">};</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_recommended_min_free_kbytes</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_zones</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">recommended_min</span><span class="p">;</span>
	<span class="k">extern</span> <span class="kt">int</span> <span class="n">min_free_kbytes</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">TRANSPARENT_HUGEPAGE_FLAG</span><span class="p">,</span>
		      <span class="o">&amp;</span><span class="n">transparent_hugepage_flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG</span><span class="p">,</span>
		      <span class="o">&amp;</span><span class="n">transparent_hugepage_flags</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">for_each_populated_zone</span><span class="p">(</span><span class="n">zone</span><span class="p">)</span>
		<span class="n">nr_zones</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Make sure at least 2 hugepages are free for MIGRATE_RESERVE */</span>
	<span class="n">recommended_min</span> <span class="o">=</span> <span class="n">pageblock_nr_pages</span> <span class="o">*</span> <span class="n">nr_zones</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure that on average at least two pageblocks are almost free</span>
<span class="cm">	 * of another type, one for a migratetype to fall back to and a</span>
<span class="cm">	 * second to avoid subsequent fallbacks of other types There are 3</span>
<span class="cm">	 * MIGRATE_TYPES we care about.</span>
<span class="cm">	 */</span>
	<span class="n">recommended_min</span> <span class="o">+=</span> <span class="n">pageblock_nr_pages</span> <span class="o">*</span> <span class="n">nr_zones</span> <span class="o">*</span>
			   <span class="n">MIGRATE_PCPTYPES</span> <span class="o">*</span> <span class="n">MIGRATE_PCPTYPES</span><span class="p">;</span>

	<span class="cm">/* don&#39;t ever allow to reserve more than 5% of the lowmem */</span>
	<span class="n">recommended_min</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">recommended_min</span><span class="p">,</span>
			      <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">nr_free_buffer_pages</span><span class="p">()</span> <span class="o">/</span> <span class="mi">20</span><span class="p">);</span>
	<span class="n">recommended_min</span> <span class="o">&lt;&lt;=</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span><span class="o">-</span><span class="mi">10</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">recommended_min</span> <span class="o">&gt;</span> <span class="n">min_free_kbytes</span><span class="p">)</span>
		<span class="n">min_free_kbytes</span> <span class="o">=</span> <span class="n">recommended_min</span><span class="p">;</span>
	<span class="n">setup_per_zone_wmarks</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">late_initcall</span><span class="p">(</span><span class="n">set_recommended_min_free_kbytes</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">start_khugepaged</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">khugepaged_enabled</span><span class="p">())</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">wakeup</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">mm_slot_cache</span> <span class="o">||</span> <span class="o">!</span><span class="n">mm_slots_hash</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">khugepaged_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">khugepaged_thread</span><span class="p">)</span>
			<span class="n">khugepaged_thread</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">khugepaged</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
							<span class="s">&quot;khugepaged&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">khugepaged_thread</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
			       <span class="s">&quot;khugepaged: kthread_run(khugepaged) failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">khugepaged_thread</span><span class="p">);</span>
			<span class="n">khugepaged_thread</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">wakeup</span> <span class="o">=</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">khugepaged_scan</span><span class="p">.</span><span class="n">mm_head</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">khugepaged_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wakeup</span><span class="p">)</span>
			<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">khugepaged_wait</span><span class="p">);</span>

		<span class="n">set_recommended_min_free_kbytes</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="cm">/* wakeup to exit */</span>
		<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">khugepaged_wait</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SYSFS</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">double_flag_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				<span class="k">enum</span> <span class="n">transparent_hugepage_flag</span> <span class="n">enabled</span><span class="p">,</span>
				<span class="k">enum</span> <span class="n">transparent_hugepage_flag</span> <span class="n">req_madv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">enabled</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transparent_hugepage_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">req_madv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transparent_hugepage_flags</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;[always] madvise never</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">req_madv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transparent_hugepage_flags</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;always [madvise] never</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;always madvise [never]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">double_flag_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span>
				 <span class="k">enum</span> <span class="n">transparent_hugepage_flag</span> <span class="n">enabled</span><span class="p">,</span>
				 <span class="k">enum</span> <span class="n">transparent_hugepage_flag</span> <span class="n">req_madv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="s">&quot;always&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span>
		    <span class="n">min</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;always&quot;</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">count</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">enabled</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transparent_hugepage_flags</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">req_madv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transparent_hugepage_flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="s">&quot;madvise&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span>
			   <span class="n">min</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;madvise&quot;</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">count</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">enabled</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transparent_hugepage_flags</span><span class="p">);</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">req_madv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transparent_hugepage_flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="s">&quot;never&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span>
			   <span class="n">min</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;never&quot;</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">count</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">enabled</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transparent_hugepage_flags</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">req_madv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transparent_hugepage_flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">enabled_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">double_flag_show</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span>
				<span class="n">TRANSPARENT_HUGEPAGE_FLAG</span><span class="p">,</span>
				<span class="n">TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">enabled_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">double_flag_store</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span>
				<span class="n">TRANSPARENT_HUGEPAGE_FLAG</span><span class="p">,</span>
				<span class="n">TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">start_khugepaged</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">TRANSPARENT_HUGEPAGE_FLAG</span><span class="p">,</span>
		      <span class="o">&amp;</span><span class="n">transparent_hugepage_flags</span><span class="p">)</span> <span class="o">||</span>
	     <span class="n">test_bit</span><span class="p">(</span><span class="n">TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG</span><span class="p">,</span>
		      <span class="o">&amp;</span><span class="n">transparent_hugepage_flags</span><span class="p">)))</span>
		<span class="n">set_recommended_min_free_kbytes</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="n">enabled_attr</span> <span class="o">=</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">enabled</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">enabled_show</span><span class="p">,</span> <span class="n">enabled_store</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">single_flag_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				<span class="k">enum</span> <span class="n">transparent_hugepage_flag</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="o">!!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transparent_hugepage_flags</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">single_flag_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span>
				 <span class="k">enum</span> <span class="n">transparent_hugepage_flag</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">kstrtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">value</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transparent_hugepage_flags</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transparent_hugepage_flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Currently defrag only disables __GFP_NOWAIT for allocation. A blind</span>
<span class="cm"> * __GFP_REPEAT is too aggressive, it&#39;s never worth swapping tons of</span>
<span class="cm"> * memory just to allocate one more hugepage.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">defrag_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">double_flag_show</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span>
				<span class="n">TRANSPARENT_HUGEPAGE_DEFRAG_FLAG</span><span class="p">,</span>
				<span class="n">TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">defrag_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">double_flag_store</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span>
				 <span class="n">TRANSPARENT_HUGEPAGE_DEFRAG_FLAG</span><span class="p">,</span>
				 <span class="n">TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="n">defrag_attr</span> <span class="o">=</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">defrag</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">defrag_show</span><span class="p">,</span> <span class="n">defrag_store</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_DEBUG_VM</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">debug_cow_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_flag_show</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span>
				<span class="n">TRANSPARENT_HUGEPAGE_DEBUG_COW_FLAG</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">debug_cow_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_flag_store</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span>
				 <span class="n">TRANSPARENT_HUGEPAGE_DEBUG_COW_FLAG</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="n">debug_cow_attr</span> <span class="o">=</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">debug_cow</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">debug_cow_show</span><span class="p">,</span> <span class="n">debug_cow_store</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_DEBUG_VM */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">hugepage_attr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">enabled_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">defrag_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_DEBUG_VM</span>
	<span class="o">&amp;</span><span class="n">debug_cow_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="n">hugepage_attr_group</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">hugepage_attr</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">scan_sleep_millisecs_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
					 <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">khugepaged_scan_sleep_millisecs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">scan_sleep_millisecs_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
					  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">msecs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">strict_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msecs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">||</span> <span class="n">msecs</span> <span class="o">&gt;</span> <span class="n">UINT_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">khugepaged_scan_sleep_millisecs</span> <span class="o">=</span> <span class="n">msecs</span><span class="p">;</span>
	<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">khugepaged_wait</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="n">scan_sleep_millisecs_attr</span> <span class="o">=</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">scan_sleep_millisecs</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">scan_sleep_millisecs_show</span><span class="p">,</span>
	       <span class="n">scan_sleep_millisecs_store</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">alloc_sleep_millisecs_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
					  <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">khugepaged_alloc_sleep_millisecs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">alloc_sleep_millisecs_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
					   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">msecs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">strict_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msecs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">||</span> <span class="n">msecs</span> <span class="o">&gt;</span> <span class="n">UINT_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">khugepaged_alloc_sleep_millisecs</span> <span class="o">=</span> <span class="n">msecs</span><span class="p">;</span>
	<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">khugepaged_wait</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="n">alloc_sleep_millisecs_attr</span> <span class="o">=</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">alloc_sleep_millisecs</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">alloc_sleep_millisecs_show</span><span class="p">,</span>
	       <span class="n">alloc_sleep_millisecs_store</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">pages_to_scan_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				  <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">khugepaged_pages_to_scan</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">pages_to_scan_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pages</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">strict_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pages</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">||</span> <span class="o">!</span><span class="n">pages</span> <span class="o">||</span> <span class="n">pages</span> <span class="o">&gt;</span> <span class="n">UINT_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">khugepaged_pages_to_scan</span> <span class="o">=</span> <span class="n">pages</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="n">pages_to_scan_attr</span> <span class="o">=</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">pages_to_scan</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">pages_to_scan_show</span><span class="p">,</span>
	       <span class="n">pages_to_scan_store</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">pages_collapsed_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				    <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">khugepaged_pages_collapsed</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="n">pages_collapsed_attr</span> <span class="o">=</span>
	<span class="n">__ATTR_RO</span><span class="p">(</span><span class="n">pages_collapsed</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">full_scans_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			       <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">khugepaged_full_scans</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="n">full_scans_attr</span> <span class="o">=</span>
	<span class="n">__ATTR_RO</span><span class="p">(</span><span class="n">full_scans</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">khugepaged_defrag_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_flag_show</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span>
				<span class="n">TRANSPARENT_HUGEPAGE_DEFRAG_KHUGEPAGED_FLAG</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">khugepaged_defrag_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_flag_store</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span>
				 <span class="n">TRANSPARENT_HUGEPAGE_DEFRAG_KHUGEPAGED_FLAG</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="n">khugepaged_defrag_attr</span> <span class="o">=</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">defrag</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">khugepaged_defrag_show</span><span class="p">,</span>
	       <span class="n">khugepaged_defrag_store</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * max_ptes_none controls if khugepaged should collapse hugepages over</span>
<span class="cm"> * any unmapped ptes in turn potentially increasing the memory</span>
<span class="cm"> * footprint of the vmas. When max_ptes_none is 0 khugepaged will not</span>
<span class="cm"> * reduce the available free memory in the system as it</span>
<span class="cm"> * runs. Increasing max_ptes_none will instead potentially reduce the</span>
<span class="cm"> * free memory in the system during the khugepaged scan.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">khugepaged_max_ptes_none_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
					     <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">khugepaged_max_ptes_none</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">khugepaged_max_ptes_none_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
					      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_ptes_none</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">strict_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">max_ptes_none</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">||</span> <span class="n">max_ptes_none</span> <span class="o">&gt;</span> <span class="n">HPAGE_PMD_NR</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">khugepaged_max_ptes_none</span> <span class="o">=</span> <span class="n">max_ptes_none</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="n">khugepaged_max_ptes_none_attr</span> <span class="o">=</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">max_ptes_none</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">khugepaged_max_ptes_none_show</span><span class="p">,</span>
	       <span class="n">khugepaged_max_ptes_none_store</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">khugepaged_attr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">khugepaged_defrag_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">khugepaged_max_ptes_none_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">pages_to_scan_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">pages_collapsed_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">full_scans_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">scan_sleep_millisecs_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">alloc_sleep_millisecs_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="n">khugepaged_attr_group</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">khugepaged_attr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;khugepaged&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">hugepage_init_sysfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">**</span><span class="n">hugepage_kobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="o">*</span><span class="n">hugepage_kobj</span> <span class="o">=</span> <span class="n">kobject_create_and_add</span><span class="p">(</span><span class="s">&quot;transparent_hugepage&quot;</span><span class="p">,</span> <span class="n">mm_kobj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!*</span><span class="n">hugepage_kobj</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;hugepage: failed kobject create</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sysfs_create_group</span><span class="p">(</span><span class="o">*</span><span class="n">hugepage_kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hugepage_attr_group</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;hugepage: failed register hugeage group</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">delete_obj</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sysfs_create_group</span><span class="p">(</span><span class="o">*</span><span class="n">hugepage_kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">khugepaged_attr_group</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;hugepage: failed register hugeage group</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">remove_hp_group</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">remove_hp_group:</span>
	<span class="n">sysfs_remove_group</span><span class="p">(</span><span class="o">*</span><span class="n">hugepage_kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hugepage_attr_group</span><span class="p">);</span>
<span class="nl">delete_obj:</span>
	<span class="n">kobject_put</span><span class="p">(</span><span class="o">*</span><span class="n">hugepage_kobj</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">hugepage_exit_sysfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">hugepage_kobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sysfs_remove_group</span><span class="p">(</span><span class="n">hugepage_kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">khugepaged_attr_group</span><span class="p">);</span>
	<span class="n">sysfs_remove_group</span><span class="p">(</span><span class="n">hugepage_kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hugepage_attr_group</span><span class="p">);</span>
	<span class="n">kobject_put</span><span class="p">(</span><span class="n">hugepage_kobj</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">hugepage_init_sysfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">**</span><span class="n">hugepage_kobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hugepage_exit_sysfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">hugepage_kobj</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SYSFS */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">hugepage_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">hugepage_kobj</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">has_transparent_hugepage</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">transparent_hugepage_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">hugepage_init_sysfs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hugepage_kobj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">khugepaged_slab_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">mm_slots_hash_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">khugepaged_slab_free</span><span class="p">();</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * By default disable transparent hugepages on smaller systems,</span>
<span class="cm">	 * where the extra memory used could hurt more than TLB overhead</span>
<span class="cm">	 * is likely to save.  The admin can still enable it through /sys.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">totalram_pages</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">512</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">20</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">)))</span>
		<span class="n">transparent_hugepage_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">start_khugepaged</span><span class="p">();</span>

	<span class="n">set_recommended_min_free_kbytes</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">hugepage_exit_sysfs</span><span class="p">(</span><span class="n">hugepage_kobj</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">hugepage_init</span><span class="p">)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">setup_transparent_hugepage</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">str</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;always&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">TRANSPARENT_HUGEPAGE_FLAG</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">transparent_hugepage_flags</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG</span><span class="p">,</span>
			  <span class="o">&amp;</span><span class="n">transparent_hugepage_flags</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;madvise&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">TRANSPARENT_HUGEPAGE_FLAG</span><span class="p">,</span>
			  <span class="o">&amp;</span><span class="n">transparent_hugepage_flags</span><span class="p">);</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">transparent_hugepage_flags</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;never&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">TRANSPARENT_HUGEPAGE_FLAG</span><span class="p">,</span>
			  <span class="o">&amp;</span><span class="n">transparent_hugepage_flags</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG</span><span class="p">,</span>
			  <span class="o">&amp;</span><span class="n">transparent_hugepage_flags</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		       <span class="s">&quot;transparent_hugepage= cannot parse, ignored</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;transparent_hugepage=&quot;</span><span class="p">,</span> <span class="n">setup_transparent_hugepage</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">prepare_pmd_huge_pte</span><span class="p">(</span><span class="n">pgtable_t</span> <span class="n">pgtable</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>

	<span class="cm">/* FIFO */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">pmd_huge_pte</span><span class="p">)</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgtable</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgtable</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">pmd_huge_pte</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">pmd_huge_pte</span> <span class="o">=</span> <span class="n">pgtable</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pmd_t</span> <span class="nf">maybe_pmd_mkwrite</span><span class="p">(</span><span class="n">pmd_t</span> <span class="n">pmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_WRITE</span><span class="p">))</span>
		<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_mkwrite</span><span class="p">(</span><span class="n">pmd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pmd</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__do_huge_pmd_anonymous_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">haddr</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgtable_t</span> <span class="n">pgtable</span><span class="p">;</span>

	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageCompound</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">pgtable</span> <span class="o">=</span> <span class="n">pte_alloc_one</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">haddr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pgtable</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">VM_FAULT_OOM</span><span class="p">;</span>

	<span class="n">clear_huge_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">haddr</span><span class="p">,</span> <span class="n">HPAGE_PMD_NR</span><span class="p">);</span>
	<span class="n">__SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pmd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
		<span class="n">mem_cgroup_uncharge_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">pte_free</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pgtable</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pmd_t</span> <span class="n">entry</span><span class="p">;</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">mk_pmd</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">);</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">maybe_pmd_mkwrite</span><span class="p">(</span><span class="n">pmd_mkdirty</span><span class="p">(</span><span class="n">entry</span><span class="p">),</span> <span class="n">vma</span><span class="p">);</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">pmd_mkhuge</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * The spinlocking to take the lru_lock inside</span>
<span class="cm">		 * page_add_new_anon_rmap() acts as a full memory</span>
<span class="cm">		 * barrier to be sure clear_huge_page writes become</span>
<span class="cm">		 * visible after the set_pmd_at() write.</span>
<span class="cm">		 */</span>
		<span class="n">page_add_new_anon_rmap</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">haddr</span><span class="p">);</span>
		<span class="n">set_pmd_at</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">haddr</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
		<span class="n">prepare_pmd_huge_pte</span><span class="p">(</span><span class="n">pgtable</span><span class="p">,</span> <span class="n">mm</span><span class="p">);</span>
		<span class="n">add_mm_counter</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">MM_ANONPAGES</span><span class="p">,</span> <span class="n">HPAGE_PMD_NR</span><span class="p">);</span>
		<span class="n">mm</span><span class="o">-&gt;</span><span class="n">nr_ptes</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">gfp_t</span> <span class="nf">alloc_hugepage_gfpmask</span><span class="p">(</span><span class="kt">int</span> <span class="n">defrag</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">extra_gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">GFP_TRANSHUGE</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">defrag</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">__GFP_WAIT</span><span class="p">))</span> <span class="o">|</span> <span class="n">extra_gfp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">alloc_hugepage_vma</span><span class="p">(</span><span class="kt">int</span> <span class="n">defrag</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
					      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">haddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nd</span><span class="p">,</span>
					      <span class="n">gfp_t</span> <span class="n">extra_gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">alloc_pages_vma</span><span class="p">(</span><span class="n">alloc_hugepage_gfpmask</span><span class="p">(</span><span class="n">defrag</span><span class="p">,</span> <span class="n">extra_gfp</span><span class="p">),</span>
			       <span class="n">HPAGE_PMD_ORDER</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">haddr</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifndef CONFIG_NUMA</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">alloc_hugepage</span><span class="p">(</span><span class="kt">int</span> <span class="n">defrag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">alloc_pages</span><span class="p">(</span><span class="n">alloc_hugepage_gfpmask</span><span class="p">(</span><span class="n">defrag</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
			   <span class="n">HPAGE_PMD_ORDER</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">int</span> <span class="nf">do_huge_pmd_anonymous_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">haddr</span> <span class="o">=</span> <span class="n">address</span> <span class="o">&amp;</span> <span class="n">HPAGE_PMD_MASK</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">haddr</span> <span class="o">&gt;=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&amp;&amp;</span> <span class="n">haddr</span> <span class="o">+</span> <span class="n">HPAGE_PMD_SIZE</span> <span class="o">&lt;=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">anon_vma_prepare</span><span class="p">(</span><span class="n">vma</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">VM_FAULT_OOM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">khugepaged_enter</span><span class="p">(</span><span class="n">vma</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">VM_FAULT_OOM</span><span class="p">;</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_hugepage_vma</span><span class="p">(</span><span class="n">transparent_hugepage_defrag</span><span class="p">(</span><span class="n">vma</span><span class="p">),</span>
					  <span class="n">vma</span><span class="p">,</span> <span class="n">haddr</span><span class="p">,</span> <span class="n">numa_node_id</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">count_vm_event</span><span class="p">(</span><span class="n">THP_FAULT_FALLBACK</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">count_vm_event</span><span class="p">(</span><span class="n">THP_FAULT_ALLOC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">mem_cgroup_newpage_charge</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">__do_huge_pmd_anonymous_page</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">haddr</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span>
							  <span class="n">page</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">mem_cgroup_uncharge_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="cm">/*</span>
<span class="cm">	 * Use __pte_alloc instead of pte_alloc_map, because we can&#39;t</span>
<span class="cm">	 * run pte_offset_map on the pmd, if an huge pmd could</span>
<span class="cm">	 * materialize from under us from a different thread.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">__pte_alloc</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">address</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">VM_FAULT_OOM</span><span class="p">;</span>
	<span class="cm">/* if an huge pmd materialized from under us just retry later */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pmd_trans_huge</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * A regular pmd is established and it can&#39;t morph into a huge pmd</span>
<span class="cm">	 * from under us anymore at this point because we hold the mmap_sem</span>
<span class="cm">	 * read mode and khugepaged takes it in write mode. So now it&#39;s</span>
<span class="cm">	 * safe to run pte_offset_map().</span>
<span class="cm">	 */</span>
	<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_offset_map</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">handle_pte_fault</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">copy_huge_pmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">dst_mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">src_mm</span><span class="p">,</span>
		  <span class="n">pmd_t</span> <span class="o">*</span><span class="n">dst_pmd</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="n">src_pmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">src_page</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="n">pmd</span><span class="p">;</span>
	<span class="n">pgtable_t</span> <span class="n">pgtable</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">pgtable</span> <span class="o">=</span> <span class="n">pte_alloc_one</span><span class="p">(</span><span class="n">dst_mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pgtable</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dst_mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="n">spin_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">src_mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">,</span> <span class="n">SINGLE_DEPTH_NESTING</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="n">pmd</span> <span class="o">=</span> <span class="o">*</span><span class="n">src_pmd</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pmd_trans_huge</span><span class="p">(</span><span class="n">pmd</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">pte_free</span><span class="p">(</span><span class="n">dst_mm</span><span class="p">,</span> <span class="n">pgtable</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pmd_trans_splitting</span><span class="p">(</span><span class="n">pmd</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* split huge page running from under us */</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">src_mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dst_mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
		<span class="n">pte_free</span><span class="p">(</span><span class="n">dst_mm</span><span class="p">,</span> <span class="n">pgtable</span><span class="p">);</span>

		<span class="n">wait_split_huge_page</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">,</span> <span class="n">src_pmd</span><span class="p">);</span> <span class="cm">/* src_vma */</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">src_page</span> <span class="o">=</span> <span class="n">pmd_page</span><span class="p">(</span><span class="n">pmd</span><span class="p">);</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageHead</span><span class="p">(</span><span class="n">src_page</span><span class="p">));</span>
	<span class="n">get_page</span><span class="p">(</span><span class="n">src_page</span><span class="p">);</span>
	<span class="n">page_dup_rmap</span><span class="p">(</span><span class="n">src_page</span><span class="p">);</span>
	<span class="n">add_mm_counter</span><span class="p">(</span><span class="n">dst_mm</span><span class="p">,</span> <span class="n">MM_ANONPAGES</span><span class="p">,</span> <span class="n">HPAGE_PMD_NR</span><span class="p">);</span>

	<span class="n">pmdp_set_wrprotect</span><span class="p">(</span><span class="n">src_mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">src_pmd</span><span class="p">);</span>
	<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_mkold</span><span class="p">(</span><span class="n">pmd_wrprotect</span><span class="p">(</span><span class="n">pmd</span><span class="p">));</span>
	<span class="n">set_pmd_at</span><span class="p">(</span><span class="n">dst_mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">dst_pmd</span><span class="p">,</span> <span class="n">pmd</span><span class="p">);</span>
	<span class="n">prepare_pmd_huge_pte</span><span class="p">(</span><span class="n">pgtable</span><span class="p">,</span> <span class="n">dst_mm</span><span class="p">);</span>
	<span class="n">dst_mm</span><span class="o">-&gt;</span><span class="n">nr_ptes</span><span class="o">++</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_unlock:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">src_mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dst_mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* no &quot;address&quot; argument so destroys page coloring of some arch */</span>
<span class="n">pgtable_t</span> <span class="nf">get_pmd_huge_pte</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgtable_t</span> <span class="n">pgtable</span><span class="p">;</span>

	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>

	<span class="cm">/* FIFO */</span>
	<span class="n">pgtable</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">pmd_huge_pte</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgtable</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">))</span>
		<span class="n">mm</span><span class="o">-&gt;</span><span class="n">pmd_huge_pte</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">mm</span><span class="o">-&gt;</span><span class="n">pmd_huge_pte</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">pgtable</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">page</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgtable</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">pgtable</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_huge_pmd_wp_page_fallback</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
					<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="n">orig_pmd</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">haddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgtable_t</span> <span class="n">pgtable</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="n">_pmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">;</span>

	<span class="n">pages</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="n">HPAGE_PMD_NR</span><span class="p">,</span>
			<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pages</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">VM_FAULT_OOM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HPAGE_PMD_NR</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">alloc_page_vma_node</span><span class="p">(</span><span class="n">GFP_HIGHUSER_MOVABLE</span> <span class="o">|</span>
					       <span class="n">__GFP_OTHER_NODE</span><span class="p">,</span>
					       <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">page_to_nid</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">||</span>
			     <span class="n">mem_cgroup_newpage_charge</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mm</span><span class="p">,</span>
						       <span class="n">GFP_KERNEL</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
				<span class="n">put_page</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">mem_cgroup_uncharge_start</span><span class="p">();</span>
			<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mem_cgroup_uncharge_page</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
				<span class="n">put_page</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="p">}</span>
			<span class="n">mem_cgroup_uncharge_end</span><span class="p">();</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">|=</span> <span class="n">VM_FAULT_OOM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HPAGE_PMD_NR</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">copy_user_highpage</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">page</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span>
				   <span class="n">haddr</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
		<span class="n">__SetPageUptodate</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pmd_same</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">,</span> <span class="n">orig_pmd</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out_free_pages</span><span class="p">;</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageHead</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="n">pmdp_clear_flush_notify</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">haddr</span><span class="p">,</span> <span class="n">pmd</span><span class="p">);</span>
	<span class="cm">/* leave pmd empty until pte is filled */</span>

	<span class="n">pgtable</span> <span class="o">=</span> <span class="n">get_pmd_huge_pte</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="n">pmd_populate</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">_pmd</span><span class="p">,</span> <span class="n">pgtable</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HPAGE_PMD_NR</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">haddr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">,</span> <span class="n">entry</span><span class="p">;</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">mk_pte</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">);</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">maybe_mkwrite</span><span class="p">(</span><span class="n">pte_mkdirty</span><span class="p">(</span><span class="n">entry</span><span class="p">),</span> <span class="n">vma</span><span class="p">);</span>
		<span class="n">page_add_new_anon_rmap</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">vma</span><span class="p">,</span> <span class="n">haddr</span><span class="p">);</span>
		<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_offset_map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_pmd</span><span class="p">,</span> <span class="n">haddr</span><span class="p">);</span>
		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pte_none</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">));</span>
		<span class="n">set_pte_at</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">haddr</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
		<span class="n">pte_unmap</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>

	<span class="n">smp_wmb</span><span class="p">();</span> <span class="cm">/* make pte visible before pmd */</span>
	<span class="n">pmd_populate</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">pgtable</span><span class="p">);</span>
	<span class="n">page_remove_rmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">|=</span> <span class="n">VM_FAULT_WRITE</span><span class="p">;</span>
	<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">out_free_pages:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="n">mem_cgroup_uncharge_start</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HPAGE_PMD_NR</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mem_cgroup_uncharge_page</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">mem_cgroup_uncharge_end</span><span class="p">();</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">do_huge_pmd_wp_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="n">orig_pmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="o">*</span><span class="n">new_page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">haddr</span><span class="p">;</span>

	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pmd_same</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">,</span> <span class="n">orig_pmd</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">pmd_page</span><span class="p">(</span><span class="n">orig_pmd</span><span class="p">);</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageCompound</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">PageHead</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">haddr</span> <span class="o">=</span> <span class="n">address</span> <span class="o">&amp;</span> <span class="n">HPAGE_PMD_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page_mapcount</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmd_t</span> <span class="n">entry</span><span class="p">;</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">pmd_mkyoung</span><span class="p">(</span><span class="n">orig_pmd</span><span class="p">);</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">maybe_pmd_mkwrite</span><span class="p">(</span><span class="n">pmd_mkdirty</span><span class="p">(</span><span class="n">entry</span><span class="p">),</span> <span class="n">vma</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmdp_set_access_flags</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">haddr</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span>  <span class="mi">1</span><span class="p">))</span>
			<span class="n">update_mmu_cache</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">VM_FAULT_WRITE</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">get_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">transparent_hugepage_enabled</span><span class="p">(</span><span class="n">vma</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">transparent_hugepage_debug_cow</span><span class="p">())</span>
		<span class="n">new_page</span> <span class="o">=</span> <span class="n">alloc_hugepage_vma</span><span class="p">(</span><span class="n">transparent_hugepage_defrag</span><span class="p">(</span><span class="n">vma</span><span class="p">),</span>
					      <span class="n">vma</span><span class="p">,</span> <span class="n">haddr</span><span class="p">,</span> <span class="n">numa_node_id</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">new_page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">new_page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">count_vm_event</span><span class="p">(</span><span class="n">THP_FAULT_FALLBACK</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">do_huge_pmd_wp_page_fallback</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span>
						   <span class="n">pmd</span><span class="p">,</span> <span class="n">orig_pmd</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">haddr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_OOM</span><span class="p">)</span>
			<span class="n">split_huge_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">count_vm_event</span><span class="p">(</span><span class="n">THP_FAULT_ALLOC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">mem_cgroup_newpage_charge</span><span class="p">(</span><span class="n">new_page</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">new_page</span><span class="p">);</span>
		<span class="n">split_huge_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">VM_FAULT_OOM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">copy_user_huge_page</span><span class="p">(</span><span class="n">new_page</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">haddr</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">HPAGE_PMD_NR</span><span class="p">);</span>
	<span class="n">__SetPageUptodate</span><span class="p">(</span><span class="n">new_page</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pmd_same</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">,</span> <span class="n">orig_pmd</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
		<span class="n">mem_cgroup_uncharge_page</span><span class="p">(</span><span class="n">new_page</span><span class="p">);</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">new_page</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pmd_t</span> <span class="n">entry</span><span class="p">;</span>
		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageHead</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">mk_pmd</span><span class="p">(</span><span class="n">new_page</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">);</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">maybe_pmd_mkwrite</span><span class="p">(</span><span class="n">pmd_mkdirty</span><span class="p">(</span><span class="n">entry</span><span class="p">),</span> <span class="n">vma</span><span class="p">);</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">pmd_mkhuge</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
		<span class="n">pmdp_clear_flush_notify</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">haddr</span><span class="p">,</span> <span class="n">pmd</span><span class="p">);</span>
		<span class="n">page_add_new_anon_rmap</span><span class="p">(</span><span class="n">new_page</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">haddr</span><span class="p">);</span>
		<span class="n">set_pmd_at</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">haddr</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
		<span class="n">update_mmu_cache</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
		<span class="n">page_remove_rmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">VM_FAULT_WRITE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out_unlock:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">follow_trans_huge_pmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
				   <span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_WRITE</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pmd_write</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">pmd_page</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">);</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageHead</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_TOUCH</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmd_t</span> <span class="n">_pmd</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * We should set the dirty bit only for FOLL_WRITE but</span>
<span class="cm">		 * for now the dirty bit in the pmd is meaningless.</span>
<span class="cm">		 * And if the dirty bit will become meaningful and</span>
<span class="cm">		 * we&#39;ll only set it with FOLL_WRITE, an atomic</span>
<span class="cm">		 * set_bit will be required on the pmd to set the</span>
<span class="cm">		 * young bit, instead of the current set_pmd_at.</span>
<span class="cm">		 */</span>
		<span class="n">_pmd</span> <span class="o">=</span> <span class="n">pmd_mkyoung</span><span class="p">(</span><span class="n">pmd_mkdirty</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">));</span>
		<span class="n">set_pmd_at</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span> <span class="o">&amp;</span> <span class="n">HPAGE_PMD_MASK</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">_pmd</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">page</span> <span class="o">+=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">HPAGE_PMD_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageCompound</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_GET</span><span class="p">)</span>
		<span class="n">get_page_foll</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">zap_huge_pmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmu_gather</span> <span class="o">*</span><span class="n">tlb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		 <span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__pmd_trans_huge_lock</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">vma</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
		<span class="n">pgtable_t</span> <span class="n">pgtable</span><span class="p">;</span>
		<span class="n">pgtable</span> <span class="o">=</span> <span class="n">get_pmd_huge_pte</span><span class="p">(</span><span class="n">tlb</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">pmd_page</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">);</span>
		<span class="n">pmd_clear</span><span class="p">(</span><span class="n">pmd</span><span class="p">);</span>
		<span class="n">tlb_remove_pmd_tlb_entry</span><span class="p">(</span><span class="n">tlb</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">page_remove_rmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">page_mapcount</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">add_mm_counter</span><span class="p">(</span><span class="n">tlb</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="n">MM_ANONPAGES</span><span class="p">,</span> <span class="o">-</span><span class="n">HPAGE_PMD_NR</span><span class="p">);</span>
		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageHead</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
		<span class="n">tlb</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">nr_ptes</span><span class="o">--</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlb</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
		<span class="n">tlb_remove_page</span><span class="p">(</span><span class="n">tlb</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="n">pte_free</span><span class="p">(</span><span class="n">tlb</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="n">pgtable</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">mincore_huge_pmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">vec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__pmd_trans_huge_lock</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">vma</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * All logical pages in the range are present</span>
<span class="cm">		 * if backed by a huge page.</span>
<span class="cm">		 */</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">addr</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">move_huge_pmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">new_vma</span><span class="p">,</span>
		  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old_addr</span><span class="p">,</span>
		  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old_end</span><span class="p">,</span>
		  <span class="n">pmd_t</span> <span class="o">*</span><span class="n">old_pmd</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="n">new_pmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="n">pmd</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">old_addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">HPAGE_PMD_MASK</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">new_addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">HPAGE_PMD_MASK</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">old_end</span> <span class="o">-</span> <span class="n">old_addr</span> <span class="o">&lt;</span> <span class="n">HPAGE_PMD_SIZE</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">new_vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_NOHUGEPAGE</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The destination pmd shouldn&#39;t be established, free_pgtables()</span>
<span class="cm">	 * should have release it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pmd_none</span><span class="p">(</span><span class="o">*</span><span class="n">new_pmd</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">pmd_trans_huge</span><span class="p">(</span><span class="o">*</span><span class="n">new_pmd</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__pmd_trans_huge_lock</span><span class="p">(</span><span class="n">old_pmd</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmdp_get_and_clear</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">old_addr</span><span class="p">,</span> <span class="n">old_pmd</span><span class="p">);</span>
		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pmd_none</span><span class="p">(</span><span class="o">*</span><span class="n">new_pmd</span><span class="p">));</span>
		<span class="n">set_pmd_at</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">new_addr</span><span class="p">,</span> <span class="n">new_pmd</span><span class="p">,</span> <span class="n">pmd</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">change_huge_pmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">newprot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__pmd_trans_huge_lock</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">vma</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmd_t</span> <span class="n">entry</span><span class="p">;</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">pmdp_get_and_clear</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pmd</span><span class="p">);</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">pmd_modify</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">newprot</span><span class="p">);</span>
		<span class="n">set_pmd_at</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Returns 1 if a given pmd maps a stable (not under splitting) thp.</span>
<span class="cm"> * Returns -1 if it maps a thp under splitting. Returns 0 otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that if it returns 1, this routine returns without unlocking page</span>
<span class="cm"> * table locks. So callers must unlock them.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__pmd_trans_huge_lock</span><span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">pmd_trans_huge</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pmd_trans_splitting</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
			<span class="n">wait_split_huge_page</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">,</span> <span class="n">pmd</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Thp mapped by &#39;pmd&#39; is stable, so we can</span>
<span class="cm">			 * handle it as it is. */</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">pmd_t</span> <span class="o">*</span><span class="nf">page_check_address_pmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
			      <span class="k">enum</span> <span class="n">page_check_address_pmd_flag</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">HPAGE_PMD_MASK</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pgd_present</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pud_present</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmd_page</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">)</span> <span class="o">!=</span> <span class="n">page</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * split_vma() may create temporary aliased mappings. There is</span>
<span class="cm">	 * no risk as long as all huge pmd are found and have their</span>
<span class="cm">	 * splitting bit set before __split_huge_page_refcount</span>
<span class="cm">	 * runs. Finding the same huge pmd more than once during the</span>
<span class="cm">	 * same rmap walk is not a problem.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">==</span> <span class="n">PAGE_CHECK_ADDRESS_PMD_NOTSPLITTING_FLAG</span> <span class="o">&amp;&amp;</span>
	    <span class="n">pmd_trans_splitting</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmd_trans_huge</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">flag</span> <span class="o">==</span> <span class="n">PAGE_CHECK_ADDRESS_PMD_SPLITTING_FLAG</span> <span class="o">&amp;&amp;</span>
			  <span class="o">!</span><span class="n">pmd_trans_splitting</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">));</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">pmd</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__split_huge_page_splitting</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="n">pmd</span> <span class="o">=</span> <span class="n">page_check_address_pmd</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span>
				     <span class="n">PAGE_CHECK_ADDRESS_PMD_NOTSPLITTING_FLAG</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmd</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We can&#39;t temporarily set the pmd to null in order</span>
<span class="cm">		 * to split it, the pmd must remain marked huge at all</span>
<span class="cm">		 * times or the VM won&#39;t take the pmd_trans_huge paths</span>
<span class="cm">		 * and it won&#39;t wait on the anon_vma-&gt;root-&gt;mutex to</span>
<span class="cm">		 * serialize against split_huge_page*.</span>
<span class="cm">		 */</span>
		<span class="n">pmdp_splitting_flush_notify</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pmd</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__split_huge_page_refcount</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span> <span class="o">=</span> <span class="n">page_zone</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lruvec</span> <span class="o">*</span><span class="n">lruvec</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tail_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* prevent PageLRU to go away from under us, and freeze lru stats */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lru_lock</span><span class="p">);</span>
	<span class="n">lruvec</span> <span class="o">=</span> <span class="n">mem_cgroup_page_lruvec</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">zone</span><span class="p">);</span>

	<span class="n">compound_lock</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="cm">/* complete memcg works before add pages to LRU */</span>
	<span class="n">mem_cgroup_split_huge_fixup</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">HPAGE_PMD_NR</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page_tail</span> <span class="o">=</span> <span class="n">page</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>

		<span class="cm">/* tail_page-&gt;_mapcount cannot change */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">page_mapcount</span><span class="p">(</span><span class="n">page_tail</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">tail_count</span> <span class="o">+=</span> <span class="n">page_mapcount</span><span class="p">(</span><span class="n">page_tail</span><span class="p">);</span>
		<span class="cm">/* check for overflow */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">tail_count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page_tail</span><span class="o">-&gt;</span><span class="n">_count</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * tail_page-&gt;_count is zero and not changing from</span>
<span class="cm">		 * under us. But get_page_unless_zero() may be running</span>
<span class="cm">		 * from under us on the tail_page. If we used</span>
<span class="cm">		 * atomic_set() below instead of atomic_add(), we</span>
<span class="cm">		 * would then run atomic_set() concurrently with</span>
<span class="cm">		 * get_page_unless_zero(), and atomic_set() is</span>
<span class="cm">		 * implemented in C not using locked ops. spin_unlock</span>
<span class="cm">		 * on x86 sometime uses locked ops because of PPro</span>
<span class="cm">		 * errata 66, 92, so unless somebody can guarantee</span>
<span class="cm">		 * atomic_set() here would be safe on all archs (and</span>
<span class="cm">		 * not only on x86), it&#39;s safer to use atomic_add().</span>
<span class="cm">		 */</span>
		<span class="n">atomic_add</span><span class="p">(</span><span class="n">page_mapcount</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">page_mapcount</span><span class="p">(</span><span class="n">page_tail</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">page_tail</span><span class="o">-&gt;</span><span class="n">_count</span><span class="p">);</span>

		<span class="cm">/* after clearing PageTail the gup refcount can be released */</span>
		<span class="n">smp_mb</span><span class="p">();</span>

		<span class="cm">/*</span>
<span class="cm">		 * retain hwpoison flag of the poisoned tail page:</span>
<span class="cm">		 *   fix for the unsuitable process killed on Guest Machine(KVM)</span>
<span class="cm">		 *   by the memory-failure.</span>
<span class="cm">		 */</span>
		<span class="n">page_tail</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PAGE_FLAGS_CHECK_AT_PREP</span> <span class="o">|</span> <span class="n">__PG_HWPOISON</span><span class="p">;</span>
		<span class="n">page_tail</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span>
				     <span class="p">((</span><span class="mi">1L</span> <span class="o">&lt;&lt;</span> <span class="n">PG_referenced</span><span class="p">)</span> <span class="o">|</span>
				      <span class="p">(</span><span class="mi">1L</span> <span class="o">&lt;&lt;</span> <span class="n">PG_swapbacked</span><span class="p">)</span> <span class="o">|</span>
				      <span class="p">(</span><span class="mi">1L</span> <span class="o">&lt;&lt;</span> <span class="n">PG_mlocked</span><span class="p">)</span> <span class="o">|</span>
				      <span class="p">(</span><span class="mi">1L</span> <span class="o">&lt;&lt;</span> <span class="n">PG_uptodate</span><span class="p">)));</span>
		<span class="n">page_tail</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1L</span> <span class="o">&lt;&lt;</span> <span class="n">PG_dirty</span><span class="p">);</span>

		<span class="cm">/* clear PageTail before overwriting first_page */</span>
		<span class="n">smp_wmb</span><span class="p">();</span>

		<span class="cm">/*</span>
<span class="cm">		 * __split_huge_page_splitting() already set the</span>
<span class="cm">		 * splitting bit in all pmd that could map this</span>
<span class="cm">		 * hugepage, that will ensure no CPU can alter the</span>
<span class="cm">		 * mapcount on the head page. The mapcount is only</span>
<span class="cm">		 * accounted in the head page and it has to be</span>
<span class="cm">		 * transferred to all tail pages in the below code. So</span>
<span class="cm">		 * for this code to be safe, the split the mapcount</span>
<span class="cm">		 * can&#39;t change. But that doesn&#39;t mean userland can&#39;t</span>
<span class="cm">		 * keep changing and reading the page contents while</span>
<span class="cm">		 * we transfer the mapcount, so the pmd splitting</span>
<span class="cm">		 * status is achieved setting a reserved bit in the</span>
<span class="cm">		 * pmd, not by clearing the present bit.</span>
<span class="cm">		*/</span>
		<span class="n">page_tail</span><span class="o">-&gt;</span><span class="n">_mapcount</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">_mapcount</span><span class="p">;</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">page_tail</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">);</span>
		<span class="n">page_tail</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">;</span>

		<span class="n">page_tail</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageAnon</span><span class="p">(</span><span class="n">page_tail</span><span class="p">));</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page_tail</span><span class="p">));</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageDirty</span><span class="p">(</span><span class="n">page_tail</span><span class="p">));</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageSwapBacked</span><span class="p">(</span><span class="n">page_tail</span><span class="p">));</span>

		<span class="n">lru_add_page_tail</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">page_tail</span><span class="p">,</span> <span class="n">lruvec</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">atomic_sub</span><span class="p">(</span><span class="n">tail_count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">_count</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">_count</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">__mod_zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_ANON_TRANSPARENT_HUGEPAGES</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">__mod_zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_ANON_PAGES</span><span class="p">,</span> <span class="n">HPAGE_PMD_NR</span><span class="p">);</span>

	<span class="n">ClearPageCompound</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">compound_unlock</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lru_lock</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HPAGE_PMD_NR</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page_tail</span> <span class="o">=</span> <span class="n">page</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">page_count</span><span class="p">(</span><span class="n">page_tail</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Tail pages may be freed if there wasn&#39;t any mapping</span>
<span class="cm">		 * like if add_to_swap() is running on a lru page that</span>
<span class="cm">		 * had its mapping zapped. And freeing these pages</span>
<span class="cm">		 * requires taking the lru_lock so we do the put_page</span>
<span class="cm">		 * of the tail pages after the split is complete.</span>
<span class="cm">		 */</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">page_tail</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Only the head page (now become a regular page) is required</span>
<span class="cm">	 * to be pinned by the caller.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">page_count</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__split_huge_page_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span> <span class="n">_pmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">pgtable_t</span> <span class="n">pgtable</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">haddr</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="n">pmd</span> <span class="o">=</span> <span class="n">page_check_address_pmd</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span>
				     <span class="n">PAGE_CHECK_ADDRESS_PMD_SPLITTING_FLAG</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pgtable</span> <span class="o">=</span> <span class="n">get_pmd_huge_pte</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
		<span class="n">pmd_populate</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">_pmd</span><span class="p">,</span> <span class="n">pgtable</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">haddr</span> <span class="o">=</span> <span class="n">address</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HPAGE_PMD_NR</span><span class="p">;</span>
		     <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">haddr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">,</span> <span class="n">entry</span><span class="p">;</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">PageCompound</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">i</span><span class="p">));</span>
			<span class="n">entry</span> <span class="o">=</span> <span class="n">mk_pte</span><span class="p">(</span><span class="n">page</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">);</span>
			<span class="n">entry</span> <span class="o">=</span> <span class="n">maybe_mkwrite</span><span class="p">(</span><span class="n">pte_mkdirty</span><span class="p">(</span><span class="n">entry</span><span class="p">),</span> <span class="n">vma</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmd_write</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span>
				<span class="n">entry</span> <span class="o">=</span> <span class="n">pte_wrprotect</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="n">page_mapcount</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmd_young</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span>
				<span class="n">entry</span> <span class="o">=</span> <span class="n">pte_mkold</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
			<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_offset_map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_pmd</span><span class="p">,</span> <span class="n">haddr</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pte_none</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">));</span>
			<span class="n">set_pte_at</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">haddr</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
			<span class="n">pte_unmap</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">smp_wmb</span><span class="p">();</span> <span class="cm">/* make pte visible before pmd */</span>
		<span class="cm">/*</span>
<span class="cm">		 * Up to this point the pmd is present and huge and</span>
<span class="cm">		 * userland has the whole access to the hugepage</span>
<span class="cm">		 * during the split (which happens in place). If we</span>
<span class="cm">		 * overwrite the pmd with the not-huge version</span>
<span class="cm">		 * pointing to the pte here (which of course we could</span>
<span class="cm">		 * if all CPUs were bug free), userland could trigger</span>
<span class="cm">		 * a small page size TLB miss on the small sized TLB</span>
<span class="cm">		 * while the hugepage TLB entry is still established</span>
<span class="cm">		 * in the huge TLB. Some CPU doesn&#39;t like that. See</span>
<span class="cm">		 * http://support.amd.com/us/Processor_TechDocs/41322.pdf,</span>
<span class="cm">		 * Erratum 383 on page 93. Intel should be safe but is</span>
<span class="cm">		 * also warns that it&#39;s only safe if the permission</span>
<span class="cm">		 * and cache attributes of the two entries loaded in</span>
<span class="cm">		 * the two TLB is identical (which should be the case</span>
<span class="cm">		 * here). But it is generally safer to never allow</span>
<span class="cm">		 * small and huge TLB entries for the same virtual</span>
<span class="cm">		 * address to be loaded simultaneously. So instead of</span>
<span class="cm">		 * doing &quot;pmd_populate(); flush_tlb_range();&quot; we first</span>
<span class="cm">		 * mark the current pmd notpresent (atomically because</span>
<span class="cm">		 * here the pmd_trans_huge and pmd_trans_splitting</span>
<span class="cm">		 * must remain set at all times on the pmd until the</span>
<span class="cm">		 * split is complete for this pmd), then we flush the</span>
<span class="cm">		 * SMP TLB and finally we write the non-huge version</span>
<span class="cm">		 * of the pmd entry with pmd_populate.</span>
<span class="cm">		 */</span>
		<span class="n">set_pmd_at</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">pmd_mknotpresent</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">));</span>
		<span class="n">flush_tlb_range</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">address</span> <span class="o">+</span> <span class="n">HPAGE_PMD_SIZE</span><span class="p">);</span>
		<span class="n">pmd_populate</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">pgtable</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* must be called with anon_vma-&gt;root-&gt;mutex hold */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__split_huge_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">mapcount</span><span class="p">,</span> <span class="n">mapcount2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">anon_vma_chain</span> <span class="o">*</span><span class="n">avc</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageHead</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">PageTail</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="n">mapcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">avc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">same_anon_vma</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span> <span class="o">=</span> <span class="n">avc</span><span class="o">-&gt;</span><span class="n">vma</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">vma_address</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">is_vma_temporary_stack</span><span class="p">(</span><span class="n">vma</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">==</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">mapcount</span> <span class="o">+=</span> <span class="n">__split_huge_page_splitting</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * It is critical that new vmas are added to the tail of the</span>
<span class="cm">	 * anon_vma list. This guarantes that if copy_huge_pmd() runs</span>
<span class="cm">	 * and establishes a child pmd before</span>
<span class="cm">	 * __split_huge_page_splitting() freezes the parent pmd (so if</span>
<span class="cm">	 * we fail to prevent copy_huge_pmd() from running until the</span>
<span class="cm">	 * whole __split_huge_page() is complete), we will still see</span>
<span class="cm">	 * the newly established pmd of the child later during the</span>
<span class="cm">	 * walk, to be able to set it as pmd_trans_splitting too.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mapcount</span> <span class="o">!=</span> <span class="n">page_mapcount</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;mapcount %d page_mapcount %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">mapcount</span><span class="p">,</span> <span class="n">page_mapcount</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">mapcount</span> <span class="o">!=</span> <span class="n">page_mapcount</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="n">__split_huge_page_refcount</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">mapcount2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">avc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">same_anon_vma</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span> <span class="o">=</span> <span class="n">avc</span><span class="o">-&gt;</span><span class="n">vma</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">vma_address</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">is_vma_temporary_stack</span><span class="p">(</span><span class="n">vma</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">==</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">mapcount2</span> <span class="o">+=</span> <span class="n">__split_huge_page_map</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mapcount</span> <span class="o">!=</span> <span class="n">mapcount2</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;mapcount %d mapcount2 %d page_mapcount %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">mapcount</span><span class="p">,</span> <span class="n">mapcount2</span><span class="p">,</span> <span class="n">page_mapcount</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">mapcount</span> <span class="o">!=</span> <span class="n">mapcount2</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">split_huge_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageAnon</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">anon_vma</span> <span class="o">=</span> <span class="n">page_lock_anon_vma</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">anon_vma</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageCompound</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageSwapBacked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">__split_huge_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">anon_vma</span><span class="p">);</span>
	<span class="n">count_vm_event</span><span class="p">(</span><span class="n">THP_SPLIT</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">PageCompound</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
<span class="nl">out_unlock:</span>
	<span class="n">page_unlock_anon_vma</span><span class="p">(</span><span class="n">anon_vma</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define VM_NO_THP (VM_SPECIAL|VM_INSERTPAGE|VM_MIXEDMAP|VM_SAO| \</span>
<span class="cp">		   VM_HUGETLB|VM_SHARED|VM_MAYSHARE)</span>

<span class="kt">int</span> <span class="nf">hugepage_madvise</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">vm_flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">advice</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">advice</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MADV_HUGEPAGE</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Be somewhat over-protective like KSM for now!</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_HUGEPAGE</span> <span class="o">|</span> <span class="n">VM_NO_THP</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="o">*</span><span class="n">vm_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">VM_NOHUGEPAGE</span><span class="p">;</span>
		<span class="o">*</span><span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_HUGEPAGE</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the vma become good for khugepaged to scan,</span>
<span class="cm">		 * register it here without waiting a page fault that</span>
<span class="cm">		 * may not happen any time soon.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">khugepaged_enter_vma_merge</span><span class="p">(</span><span class="n">vma</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MADV_NOHUGEPAGE</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Be somewhat over-protective like KSM for now!</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_NOHUGEPAGE</span> <span class="o">|</span> <span class="n">VM_NO_THP</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="o">*</span><span class="n">vm_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">VM_HUGEPAGE</span><span class="p">;</span>
		<span class="o">*</span><span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_NOHUGEPAGE</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Setting VM_NOHUGEPAGE will prevent khugepaged from scanning</span>
<span class="cm">		 * this vma even if we leave the mm registered in khugepaged if</span>
<span class="cm">		 * it got registered before VM_NOHUGEPAGE was set.</span>
<span class="cm">		 */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">khugepaged_slab_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mm_slot_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;khugepaged_mm_slot&quot;</span><span class="p">,</span>
					  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_slot</span><span class="p">),</span>
					  <span class="n">__alignof__</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_slot</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm_slot_cache</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">khugepaged_slab_free</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">mm_slot_cache</span><span class="p">);</span>
	<span class="n">mm_slot_cache</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">mm_slot</span> <span class="o">*</span><span class="nf">alloc_mm_slot</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm_slot_cache</span><span class="p">)</span>	<span class="cm">/* initialization failed */</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">mm_slot_cache</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">free_mm_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_slot</span> <span class="o">*</span><span class="n">mm_slot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">mm_slot_cache</span><span class="p">,</span> <span class="n">mm_slot</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">mm_slots_hash_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mm_slots_hash</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">MM_SLOTS_HASH_HEADS</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_head</span><span class="p">),</span>
				<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm_slots_hash</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">static void __init mm_slots_hash_free(void)</span>
<span class="c">{</span>
<span class="c">	kfree(mm_slots_hash);</span>
<span class="c">	mm_slots_hash = NULL;</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">mm_slot</span> <span class="o">*</span><span class="nf">get_mm_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_slot</span> <span class="o">*</span><span class="n">mm_slot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">bucket</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

	<span class="n">bucket</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mm_slots_hash</span><span class="p">[((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">mm</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span><span class="p">))</span>
				<span class="o">%</span> <span class="n">MM_SLOTS_HASH_HEADS</span><span class="p">];</span>
	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">mm_slot</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">bucket</span><span class="p">,</span> <span class="n">hash</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mm</span> <span class="o">==</span> <span class="n">mm_slot</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">mm_slot</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">insert_to_mm_slots_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">mm_slot</span> <span class="o">*</span><span class="n">mm_slot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">bucket</span><span class="p">;</span>

	<span class="n">bucket</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mm_slots_hash</span><span class="p">[((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">mm</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span><span class="p">))</span>
				<span class="o">%</span> <span class="n">MM_SLOTS_HASH_HEADS</span><span class="p">];</span>
	<span class="n">mm_slot</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">=</span> <span class="n">mm</span><span class="p">;</span>
	<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm_slot</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">,</span> <span class="n">bucket</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">khugepaged_test_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_users</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">__khugepaged_enter</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_slot</span> <span class="o">*</span><span class="n">mm_slot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wakeup</span><span class="p">;</span>

	<span class="n">mm_slot</span> <span class="o">=</span> <span class="n">alloc_mm_slot</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm_slot</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* __khugepaged_exit() must not run from under us */</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">khugepaged_test_exit</span><span class="p">(</span><span class="n">mm</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">MMF_VM_HUGEPAGE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">free_mm_slot</span><span class="p">(</span><span class="n">mm_slot</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">khugepaged_mm_lock</span><span class="p">);</span>
	<span class="n">insert_to_mm_slots_hash</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">mm_slot</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Insert just behind the scanning cursor, to let the area settle</span>
<span class="cm">	 * down a little.</span>
<span class="cm">	 */</span>
	<span class="n">wakeup</span> <span class="o">=</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">khugepaged_scan</span><span class="p">.</span><span class="n">mm_head</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm_slot</span><span class="o">-&gt;</span><span class="n">mm_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">khugepaged_scan</span><span class="p">.</span><span class="n">mm_head</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">khugepaged_mm_lock</span><span class="p">);</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wakeup</span><span class="p">)</span>
		<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">khugepaged_wait</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">khugepaged_enter_vma_merge</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hstart</span><span class="p">,</span> <span class="n">hend</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * Not yet faulted in so we will register later in the</span>
<span class="cm">		 * page fault if needed.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="p">)</span>
		<span class="cm">/* khugepaged not yet working on file or special mappings */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If is_pfn_mapping() is true is_learn_pfn_mapping() must be</span>
<span class="cm">	 * true too, verify it here.</span>
<span class="cm">	 */</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">is_linear_pfn_mapping</span><span class="p">(</span><span class="n">vma</span><span class="p">)</span> <span class="o">||</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_NO_THP</span><span class="p">);</span>
	<span class="n">hstart</span> <span class="o">=</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">+</span> <span class="o">~</span><span class="n">HPAGE_PMD_MASK</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">HPAGE_PMD_MASK</span><span class="p">;</span>
	<span class="n">hend</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">&amp;</span> <span class="n">HPAGE_PMD_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hstart</span> <span class="o">&lt;</span> <span class="n">hend</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">khugepaged_enter</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__khugepaged_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_slot</span> <span class="o">*</span><span class="n">mm_slot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">khugepaged_mm_lock</span><span class="p">);</span>
	<span class="n">mm_slot</span> <span class="o">=</span> <span class="n">get_mm_slot</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm_slot</span> <span class="o">&amp;&amp;</span> <span class="n">khugepaged_scan</span><span class="p">.</span><span class="n">mm_slot</span> <span class="o">!=</span> <span class="n">mm_slot</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm_slot</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm_slot</span><span class="o">-&gt;</span><span class="n">mm_node</span><span class="p">);</span>
		<span class="n">free</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">khugepaged_mm_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">free</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">MMF_VM_HUGEPAGE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">free_mm_slot</span><span class="p">(</span><span class="n">mm_slot</span><span class="p">);</span>
		<span class="n">mmdrop</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mm_slot</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This is required to serialize against</span>
<span class="cm">		 * khugepaged_test_exit() (which is guaranteed to run</span>
<span class="cm">		 * under mmap sem read mode). Stop here (after we</span>
<span class="cm">		 * return all pagetables will be destroyed) until</span>
<span class="cm">		 * khugepaged has finished working on the pagetables</span>
<span class="cm">		 * under the mmap_sem.</span>
<span class="cm">		 */</span>
		<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">release_pte_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* 0 stands for page_is_file_cache(page) == false */</span>
	<span class="n">dec_zone_page_state</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">NR_ISOLATED_ANON</span> <span class="o">+</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">putback_lru_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">release_pte_pages</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">_pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">_pte</span> <span class="o">&gt;=</span> <span class="n">pte</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pte_t</span> <span class="n">pteval</span> <span class="o">=</span> <span class="o">*</span><span class="n">_pte</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_none</span><span class="p">(</span><span class="n">pteval</span><span class="p">))</span>
			<span class="n">release_pte_page</span><span class="p">(</span><span class="n">pte_page</span><span class="p">(</span><span class="n">pteval</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">release_all_pte_pages</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">release_pte_pages</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">pte</span> <span class="o">+</span> <span class="n">HPAGE_PMD_NR</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__collapse_huge_page_isolate</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
					<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">_pte</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">referenced</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">isolated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">none</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">_pte</span> <span class="o">=</span> <span class="n">pte</span><span class="p">;</span> <span class="n">_pte</span> <span class="o">&lt;</span> <span class="n">pte</span><span class="o">+</span><span class="n">HPAGE_PMD_NR</span><span class="p">;</span>
	     <span class="n">_pte</span><span class="o">++</span><span class="p">,</span> <span class="n">address</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pte_t</span> <span class="n">pteval</span> <span class="o">=</span> <span class="o">*</span><span class="n">_pte</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pte_none</span><span class="p">(</span><span class="n">pteval</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">none</span> <span class="o">&lt;=</span> <span class="n">khugepaged_max_ptes_none</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">release_pte_pages</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">_pte</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_present</span><span class="p">(</span><span class="n">pteval</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">pte_write</span><span class="p">(</span><span class="n">pteval</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">release_pte_pages</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">_pte</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">vm_normal_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pteval</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">release_pte_pages</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">_pte</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">PageCompound</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageAnon</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageSwapBacked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

		<span class="cm">/* cannot use mapcount: can&#39;t collapse if there&#39;s a gup pin */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_count</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">release_pte_pages</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">_pte</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * We can do it before isolate_lru_page because the</span>
<span class="cm">		 * page can&#39;t be freed from under us. NOTE: PG_lock</span>
<span class="cm">		 * is needed to serialize against split_huge_page</span>
<span class="cm">		 * when invoked from the VM.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trylock_page</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">release_pte_pages</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">_pte</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Isolate the page to avoid collapsing an hugepage</span>
<span class="cm">		 * currently in use by the VM.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">isolate_lru_page</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">release_pte_pages</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">_pte</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* 0 stands for page_is_file_cache(page) == false */</span>
		<span class="n">inc_zone_page_state</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">NR_ISOLATED_ANON</span> <span class="o">+</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">PageLRU</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

		<span class="cm">/* If there is no mapped pte young don&#39;t collapse the page */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pte_young</span><span class="p">(</span><span class="n">pteval</span><span class="p">)</span> <span class="o">||</span> <span class="n">PageReferenced</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">mmu_notifier_test_young</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">address</span><span class="p">))</span>
			<span class="n">referenced</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">referenced</span><span class="p">))</span>
		<span class="n">release_all_pte_pages</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">isolated</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">isolated</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__collapse_huge_page_copy</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
				      <span class="n">spinlock_t</span> <span class="o">*</span><span class="n">ptl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">_pte</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">_pte</span> <span class="o">=</span> <span class="n">pte</span><span class="p">;</span> <span class="n">_pte</span> <span class="o">&lt;</span> <span class="n">pte</span><span class="o">+</span><span class="n">HPAGE_PMD_NR</span><span class="p">;</span> <span class="n">_pte</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pte_t</span> <span class="n">pteval</span> <span class="o">=</span> <span class="o">*</span><span class="n">_pte</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">src_page</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pte_none</span><span class="p">(</span><span class="n">pteval</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">clear_user_highpage</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
			<span class="n">add_mm_counter</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">MM_ANONPAGES</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">src_page</span> <span class="o">=</span> <span class="n">pte_page</span><span class="p">(</span><span class="n">pteval</span><span class="p">);</span>
			<span class="n">copy_user_highpage</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">src_page</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
			<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">page_mapcount</span><span class="p">(</span><span class="n">src_page</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">page_count</span><span class="p">(</span><span class="n">src_page</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">);</span>
			<span class="n">release_pte_page</span><span class="p">(</span><span class="n">src_page</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * ptl mostly unnecessary, but preempt has to</span>
<span class="cm">			 * be disabled to update the per-cpu stats</span>
<span class="cm">			 * inside page_remove_rmap().</span>
<span class="cm">			 */</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="n">ptl</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * paravirt calls inside pte_clear here are</span>
<span class="cm">			 * superfluous.</span>
<span class="cm">			 */</span>
			<span class="n">pte_clear</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">_pte</span><span class="p">);</span>
			<span class="n">page_remove_rmap</span><span class="p">(</span><span class="n">src_page</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="n">ptl</span><span class="p">);</span>
			<span class="n">free_page_and_swap_cache</span><span class="p">(</span><span class="n">src_page</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">address</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="n">page</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">collapse_huge_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">hpage</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span> <span class="n">_pmd</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
	<span class="n">pgtable_t</span> <span class="n">pgtable</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">new_page</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">ptl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">isolated</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hstart</span><span class="p">,</span> <span class="n">hend</span><span class="p">;</span>

	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">address</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">HPAGE_PMD_MASK</span><span class="p">);</span>
<span class="cp">#ifndef CONFIG_NUMA</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!*</span><span class="n">hpage</span><span class="p">);</span>
	<span class="n">new_page</span> <span class="o">=</span> <span class="o">*</span><span class="n">hpage</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">*</span><span class="n">hpage</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Allocate the page while the vma is still valid and under</span>
<span class="cm">	 * the mmap_sem read mode so there is no memory allocation</span>
<span class="cm">	 * later when we take the mmap_sem in write mode. This is more</span>
<span class="cm">	 * friendly behavior (OTOH it may actually hide bugs) to</span>
<span class="cm">	 * filesystems in userland with daemons allocating memory in</span>
<span class="cm">	 * the userland I/O paths.  Allocating memory with the</span>
<span class="cm">	 * mmap_sem in read mode is good idea also to allow greater</span>
<span class="cm">	 * scalability.</span>
<span class="cm">	 */</span>
	<span class="n">new_page</span> <span class="o">=</span> <span class="n">alloc_hugepage_vma</span><span class="p">(</span><span class="n">khugepaged_defrag</span><span class="p">(),</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span>
				      <span class="n">node</span><span class="p">,</span> <span class="n">__GFP_OTHER_NODE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * After allocating the hugepage, release the mmap_sem read lock in</span>
<span class="cm">	 * preparation for taking it in write mode.</span>
<span class="cm">	 */</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">new_page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">count_vm_event</span><span class="p">(</span><span class="n">THP_COLLAPSE_ALLOC_FAILED</span><span class="p">);</span>
		<span class="o">*</span><span class="n">hpage</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">count_vm_event</span><span class="p">(</span><span class="n">THP_COLLAPSE_ALLOC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">mem_cgroup_newpage_charge</span><span class="p">(</span><span class="n">new_page</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">)))</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_NUMA</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">new_page</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Prevent all access to pagetables with the exception of</span>
<span class="cm">	 * gup_fast later hanlded by the ptep_clear_flush and the VM</span>
<span class="cm">	 * handled by the anon_vma lock + PG_lock.</span>
<span class="cm">	 */</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">khugepaged_test_exit</span><span class="p">(</span><span class="n">mm</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">vma</span> <span class="o">=</span> <span class="n">find_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="n">hstart</span> <span class="o">=</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">+</span> <span class="o">~</span><span class="n">HPAGE_PMD_MASK</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">HPAGE_PMD_MASK</span><span class="p">;</span>
	<span class="n">hend</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">&amp;</span> <span class="n">HPAGE_PMD_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">&lt;</span> <span class="n">hstart</span> <span class="o">||</span> <span class="n">address</span> <span class="o">+</span> <span class="n">HPAGE_PMD_SIZE</span> <span class="o">&gt;</span> <span class="n">hend</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_HUGEPAGE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">khugepaged_always</span><span class="p">())</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_NOHUGEPAGE</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span> <span class="o">||</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_vma_temporary_stack</span><span class="p">(</span><span class="n">vma</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If is_pfn_mapping() is true is_learn_pfn_mapping() must be</span>
<span class="cm">	 * true too, verify it here.</span>
<span class="cm">	 */</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">is_linear_pfn_mapping</span><span class="p">(</span><span class="n">vma</span><span class="p">)</span> <span class="o">||</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_NO_THP</span><span class="p">);</span>

	<span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pgd_present</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pud_present</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="cm">/* pmd can&#39;t go away or become huge under us */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmd_present</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">)</span> <span class="o">||</span> <span class="n">pmd_trans_huge</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">anon_vma_lock</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">);</span>

	<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_offset_map</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="n">ptl</span> <span class="o">=</span> <span class="n">pte_lockptr</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span> <span class="cm">/* probably unnecessary */</span>
	<span class="cm">/*</span>
<span class="cm">	 * After this gup_fast can&#39;t run anymore. This also removes</span>
<span class="cm">	 * any huge TLB entry from the CPU so we won&#39;t allow</span>
<span class="cm">	 * huge and small TLB entries for the same virtual address</span>
<span class="cm">	 * to avoid the risk of CPU bugs in that area.</span>
<span class="cm">	 */</span>
	<span class="n">_pmd</span> <span class="o">=</span> <span class="n">pmdp_clear_flush_notify</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pmd</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="n">ptl</span><span class="p">);</span>
	<span class="n">isolated</span> <span class="o">=</span> <span class="n">__collapse_huge_page_isolate</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="n">ptl</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">isolated</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pte_unmap</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pmd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">));</span>
		<span class="n">set_pmd_at</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">_pmd</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
		<span class="n">anon_vma_unlock</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * All pages are isolated and locked so anon_vma rmap</span>
<span class="cm">	 * can&#39;t run anymore.</span>
<span class="cm">	 */</span>
	<span class="n">anon_vma_unlock</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">);</span>

	<span class="n">__collapse_huge_page_copy</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">new_page</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
	<span class="n">pte_unmap</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
	<span class="n">__SetPageUptodate</span><span class="p">(</span><span class="n">new_page</span><span class="p">);</span>
	<span class="n">pgtable</span> <span class="o">=</span> <span class="n">pmd_pgtable</span><span class="p">(</span><span class="n">_pmd</span><span class="p">);</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">page_count</span><span class="p">(</span><span class="n">pgtable</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">page_mapcount</span><span class="p">(</span><span class="n">pgtable</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">_pmd</span> <span class="o">=</span> <span class="n">mk_pmd</span><span class="p">(</span><span class="n">new_page</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">);</span>
	<span class="n">_pmd</span> <span class="o">=</span> <span class="n">maybe_pmd_mkwrite</span><span class="p">(</span><span class="n">pmd_mkdirty</span><span class="p">(</span><span class="n">_pmd</span><span class="p">),</span> <span class="n">vma</span><span class="p">);</span>
	<span class="n">_pmd</span> <span class="o">=</span> <span class="n">pmd_mkhuge</span><span class="p">(</span><span class="n">_pmd</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * spin_lock() below is not the equivalent of smp_wmb(), so</span>
<span class="cm">	 * this is needed to avoid the copy_huge_page writes to become</span>
<span class="cm">	 * visible after the set_pmd_at() write.</span>
<span class="cm">	 */</span>
	<span class="n">smp_wmb</span><span class="p">();</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pmd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">));</span>
	<span class="n">page_add_new_anon_rmap</span><span class="p">(</span><span class="n">new_page</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="n">set_pmd_at</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">_pmd</span><span class="p">);</span>
	<span class="n">update_mmu_cache</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">_pmd</span><span class="p">);</span>
	<span class="n">prepare_pmd_huge_pte</span><span class="p">(</span><span class="n">pgtable</span><span class="p">,</span> <span class="n">mm</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>

<span class="cp">#ifndef CONFIG_NUMA</span>
	<span class="o">*</span><span class="n">hpage</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">khugepaged_pages_collapsed</span><span class="o">++</span><span class="p">;</span>
<span class="nl">out_up_write:</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">mem_cgroup_uncharge_page</span><span class="p">(</span><span class="n">new_page</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_NUMA</span>
	<span class="n">put_page</span><span class="p">(</span><span class="n">new_page</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">goto</span> <span class="n">out_up_write</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">khugepaged_scan_pmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">hpage</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">,</span> <span class="o">*</span><span class="n">_pte</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">referenced</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">none</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_address</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">ptl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">address</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">HPAGE_PMD_MASK</span><span class="p">);</span>

	<span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pgd_present</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pud_present</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmd_present</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">)</span> <span class="o">||</span> <span class="n">pmd_trans_huge</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_offset_map_lock</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptl</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">_address</span> <span class="o">=</span> <span class="n">address</span><span class="p">,</span> <span class="n">_pte</span> <span class="o">=</span> <span class="n">pte</span><span class="p">;</span> <span class="n">_pte</span> <span class="o">&lt;</span> <span class="n">pte</span><span class="o">+</span><span class="n">HPAGE_PMD_NR</span><span class="p">;</span>
	     <span class="n">_pte</span><span class="o">++</span><span class="p">,</span> <span class="n">_address</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pte_t</span> <span class="n">pteval</span> <span class="o">=</span> <span class="o">*</span><span class="n">_pte</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pte_none</span><span class="p">(</span><span class="n">pteval</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">none</span> <span class="o">&lt;=</span> <span class="n">khugepaged_max_ptes_none</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="k">goto</span> <span class="n">out_unmap</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_present</span><span class="p">(</span><span class="n">pteval</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">pte_write</span><span class="p">(</span><span class="n">pteval</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_unmap</span><span class="p">;</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">vm_normal_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">_address</span><span class="p">,</span> <span class="n">pteval</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_unmap</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Chose the node of the first page. This could</span>
<span class="cm">		 * be more sophisticated and look at more pages,</span>
<span class="cm">		 * but isn&#39;t for now.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">node</span> <span class="o">=</span> <span class="n">page_to_nid</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">PageCompound</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageLRU</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">||</span> <span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">PageAnon</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_unmap</span><span class="p">;</span>
		<span class="cm">/* cannot use mapcount: can&#39;t collapse if there&#39;s a gup pin */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_count</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unmap</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pte_young</span><span class="p">(</span><span class="n">pteval</span><span class="p">)</span> <span class="o">||</span> <span class="n">PageReferenced</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">mmu_notifier_test_young</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">address</span><span class="p">))</span>
			<span class="n">referenced</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">referenced</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">out_unmap:</span>
	<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="cm">/* collapse_huge_page will return with the mmap_sem released */</span>
		<span class="n">collapse_huge_page</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">hpage</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">collect_mm_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_slot</span> <span class="o">*</span><span class="n">mm_slot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">mm_slot</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>

	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">NR_CPUS</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">spin_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">khugepaged_mm_lock</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">khugepaged_test_exit</span><span class="p">(</span><span class="n">mm</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* free mm_slot */</span>
		<span class="n">hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm_slot</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm_slot</span><span class="o">-&gt;</span><span class="n">mm_node</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Not strictly needed because the mm exited already.</span>
<span class="cm">		 *</span>
<span class="cm">		 * clear_bit(MMF_VM_HUGEPAGE, &amp;mm-&gt;flags);</span>
<span class="cm">		 */</span>

		<span class="cm">/* khugepaged_mm_lock actually not necessary for the below */</span>
		<span class="n">free_mm_slot</span><span class="p">(</span><span class="n">mm_slot</span><span class="p">);</span>
		<span class="n">mmdrop</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">khugepaged_scan_mm_slot</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pages</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">hpage</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="o">&amp;</span><span class="n">khugepaged_mm_lock</span><span class="p">)</span>
	<span class="n">__acquires</span><span class="p">(</span><span class="o">&amp;</span><span class="n">khugepaged_mm_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_slot</span> <span class="o">*</span><span class="n">mm_slot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">progress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pages</span><span class="p">);</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">NR_CPUS</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">spin_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">khugepaged_mm_lock</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">khugepaged_scan</span><span class="p">.</span><span class="n">mm_slot</span><span class="p">)</span>
		<span class="n">mm_slot</span> <span class="o">=</span> <span class="n">khugepaged_scan</span><span class="p">.</span><span class="n">mm_slot</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">mm_slot</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">khugepaged_scan</span><span class="p">.</span><span class="n">mm_head</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">mm_slot</span><span class="p">,</span> <span class="n">mm_node</span><span class="p">);</span>
		<span class="n">khugepaged_scan</span><span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">khugepaged_scan</span><span class="p">.</span><span class="n">mm_slot</span> <span class="o">=</span> <span class="n">mm_slot</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">khugepaged_mm_lock</span><span class="p">);</span>

	<span class="n">mm</span> <span class="o">=</span> <span class="n">mm_slot</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">khugepaged_test_exit</span><span class="p">(</span><span class="n">mm</span><span class="p">)))</span>
		<span class="n">vma</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">vma</span> <span class="o">=</span> <span class="n">find_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">khugepaged_scan</span><span class="p">.</span><span class="n">address</span><span class="p">);</span>

	<span class="n">progress</span><span class="o">++</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">vma</span><span class="p">;</span> <span class="n">vma</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hstart</span><span class="p">,</span> <span class="n">hend</span><span class="p">;</span>

		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">khugepaged_test_exit</span><span class="p">(</span><span class="n">mm</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">progress</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_HUGEPAGE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="o">!</span><span class="n">khugepaged_always</span><span class="p">())</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_NOHUGEPAGE</span><span class="p">))</span> <span class="p">{</span>
		<span class="nl">skip:</span>
			<span class="n">progress</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span> <span class="o">||</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">skip</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_vma_temporary_stack</span><span class="p">(</span><span class="n">vma</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">skip</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If is_pfn_mapping() is true is_learn_pfn_mapping()</span>
<span class="cm">		 * must be true too, verify it here.</span>
<span class="cm">		 */</span>
		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">is_linear_pfn_mapping</span><span class="p">(</span><span class="n">vma</span><span class="p">)</span> <span class="o">||</span>
			  <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_NO_THP</span><span class="p">);</span>

		<span class="n">hstart</span> <span class="o">=</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">+</span> <span class="o">~</span><span class="n">HPAGE_PMD_MASK</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">HPAGE_PMD_MASK</span><span class="p">;</span>
		<span class="n">hend</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">&amp;</span> <span class="n">HPAGE_PMD_MASK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hstart</span> <span class="o">&gt;=</span> <span class="n">hend</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">skip</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">khugepaged_scan</span><span class="p">.</span><span class="n">address</span> <span class="o">&gt;</span> <span class="n">hend</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">skip</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">khugepaged_scan</span><span class="p">.</span><span class="n">address</span> <span class="o">&lt;</span> <span class="n">hstart</span><span class="p">)</span>
			<span class="n">khugepaged_scan</span><span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">hstart</span><span class="p">;</span>
		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">khugepaged_scan</span><span class="p">.</span><span class="n">address</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">HPAGE_PMD_MASK</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">khugepaged_scan</span><span class="p">.</span><span class="n">address</span> <span class="o">&lt;</span> <span class="n">hend</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
			<span class="n">cond_resched</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">khugepaged_test_exit</span><span class="p">(</span><span class="n">mm</span><span class="p">)))</span>
				<span class="k">goto</span> <span class="n">breakouterloop</span><span class="p">;</span>

			<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">khugepaged_scan</span><span class="p">.</span><span class="n">address</span> <span class="o">&lt;</span> <span class="n">hstart</span> <span class="o">||</span>
				  <span class="n">khugepaged_scan</span><span class="p">.</span><span class="n">address</span> <span class="o">+</span> <span class="n">HPAGE_PMD_SIZE</span> <span class="o">&gt;</span>
				  <span class="n">hend</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">khugepaged_scan_pmd</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span>
						  <span class="n">khugepaged_scan</span><span class="p">.</span><span class="n">address</span><span class="p">,</span>
						  <span class="n">hpage</span><span class="p">);</span>
			<span class="cm">/* move to next address */</span>
			<span class="n">khugepaged_scan</span><span class="p">.</span><span class="n">address</span> <span class="o">+=</span> <span class="n">HPAGE_PMD_SIZE</span><span class="p">;</span>
			<span class="n">progress</span> <span class="o">+=</span> <span class="n">HPAGE_PMD_NR</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="cm">/* we released mmap_sem so break loop */</span>
				<span class="k">goto</span> <span class="n">breakouterloop_mmap_sem</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">progress</span> <span class="o">&gt;=</span> <span class="n">pages</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">breakouterloop</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">breakouterloop:</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span> <span class="cm">/* exit_mmap will destroy ptes after this */</span>
<span class="nl">breakouterloop_mmap_sem:</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">khugepaged_mm_lock</span><span class="p">);</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">khugepaged_scan</span><span class="p">.</span><span class="n">mm_slot</span> <span class="o">!=</span> <span class="n">mm_slot</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Release the current mm_slot if this mm is about to die, or</span>
<span class="cm">	 * if we scanned all vmas of this mm.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">khugepaged_test_exit</span><span class="p">(</span><span class="n">mm</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">vma</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Make sure that if mm_users is reaching zero while</span>
<span class="cm">		 * khugepaged runs here, khugepaged_exit will find</span>
<span class="cm">		 * mm_slot not pointing to the exiting mm.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mm_slot</span><span class="o">-&gt;</span><span class="n">mm_node</span><span class="p">.</span><span class="n">next</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">khugepaged_scan</span><span class="p">.</span><span class="n">mm_head</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">khugepaged_scan</span><span class="p">.</span><span class="n">mm_slot</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span>
				<span class="n">mm_slot</span><span class="o">-&gt;</span><span class="n">mm_node</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">mm_slot</span><span class="p">,</span> <span class="n">mm_node</span><span class="p">);</span>
			<span class="n">khugepaged_scan</span><span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">khugepaged_scan</span><span class="p">.</span><span class="n">mm_slot</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">khugepaged_full_scans</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">collect_mm_slot</span><span class="p">(</span><span class="n">mm_slot</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">progress</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">khugepaged_has_work</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">khugepaged_scan</span><span class="p">.</span><span class="n">mm_head</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">khugepaged_enabled</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">khugepaged_wait_event</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">khugepaged_scan</span><span class="p">.</span><span class="n">mm_head</span><span class="p">)</span> <span class="o">||</span>
		<span class="o">!</span><span class="n">khugepaged_enabled</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">khugepaged_do_scan</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">hpage</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">progress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pass_through_head</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pages</span> <span class="o">=</span> <span class="n">khugepaged_pages_to_scan</span><span class="p">;</span>

	<span class="n">barrier</span><span class="p">();</span> <span class="cm">/* write khugepaged_pages_to_scan to local stack */</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">progress</span> <span class="o">&lt;</span> <span class="n">pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cond_resched</span><span class="p">();</span>

<span class="cp">#ifndef CONFIG_NUMA</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">hpage</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">hpage</span> <span class="o">=</span> <span class="n">alloc_hugepage</span><span class="p">(</span><span class="n">khugepaged_defrag</span><span class="p">());</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!*</span><span class="n">hpage</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">count_vm_event</span><span class="p">(</span><span class="n">THP_COLLAPSE_ALLOC_FAILED</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">count_vm_event</span><span class="p">(</span><span class="n">THP_COLLAPSE_ALLOC</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#else</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="o">*</span><span class="n">hpage</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">kthread_should_stop</span><span class="p">()</span> <span class="o">||</span> <span class="n">freezing</span><span class="p">(</span><span class="n">current</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">khugepaged_mm_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">khugepaged_scan</span><span class="p">.</span><span class="n">mm_slot</span><span class="p">)</span>
			<span class="n">pass_through_head</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">khugepaged_has_work</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
		    <span class="n">pass_through_head</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">progress</span> <span class="o">+=</span> <span class="n">khugepaged_scan_mm_slot</span><span class="p">(</span><span class="n">pages</span> <span class="o">-</span> <span class="n">progress</span><span class="p">,</span>
							    <span class="n">hpage</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">progress</span> <span class="o">=</span> <span class="n">pages</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">khugepaged_mm_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">khugepaged_alloc_sleep</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wait_event_freezable_timeout</span><span class="p">(</span><span class="n">khugepaged_wait</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span>
			<span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">khugepaged_alloc_sleep_millisecs</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#ifndef CONFIG_NUMA</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">khugepaged_alloc_hugepage</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">hpage</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">hpage</span> <span class="o">=</span> <span class="n">alloc_hugepage</span><span class="p">(</span><span class="n">khugepaged_defrag</span><span class="p">());</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hpage</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">count_vm_event</span><span class="p">(</span><span class="n">THP_COLLAPSE_ALLOC_FAILED</span><span class="p">);</span>
			<span class="n">khugepaged_alloc_sleep</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">count_vm_event</span><span class="p">(</span><span class="n">THP_COLLAPSE_ALLOC</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">hpage</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		 <span class="n">likely</span><span class="p">(</span><span class="n">khugepaged_enabled</span><span class="p">()));</span>
	<span class="k">return</span> <span class="n">hpage</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">khugepaged_loop</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">hpage</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_NUMA</span>
	<span class="n">hpage</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">khugepaged_enabled</span><span class="p">()))</span> <span class="p">{</span>
<span class="cp">#ifndef CONFIG_NUMA</span>
		<span class="n">hpage</span> <span class="o">=</span> <span class="n">khugepaged_alloc_hugepage</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">hpage</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
<span class="cp">#else</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">hpage</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">khugepaged_alloc_sleep</span><span class="p">();</span>
			<span class="n">hpage</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#endif</span>

		<span class="n">khugepaged_do_scan</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hpage</span><span class="p">);</span>
<span class="cp">#ifndef CONFIG_NUMA</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hpage</span><span class="p">)</span>
			<span class="n">put_page</span><span class="p">(</span><span class="n">hpage</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">try_to_freeze</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">kthread_should_stop</span><span class="p">()))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">khugepaged_has_work</span><span class="p">())</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">khugepaged_scan_sleep_millisecs</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">wait_event_freezable_timeout</span><span class="p">(</span><span class="n">khugepaged_wait</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span>
			    <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">khugepaged_scan_sleep_millisecs</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">khugepaged_enabled</span><span class="p">())</span>
			<span class="n">wait_event_freezable</span><span class="p">(</span><span class="n">khugepaged_wait</span><span class="p">,</span>
					     <span class="n">khugepaged_wait_event</span><span class="p">());</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">khugepaged</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">none</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_slot</span> <span class="o">*</span><span class="n">mm_slot</span><span class="p">;</span>

	<span class="n">set_freezable</span><span class="p">();</span>
	<span class="n">set_user_nice</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="mi">19</span><span class="p">);</span>

	<span class="cm">/* serialize with start_khugepaged() */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">khugepaged_mutex</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">khugepaged_mutex</span><span class="p">);</span>
		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">khugepaged_thread</span> <span class="o">!=</span> <span class="n">current</span><span class="p">);</span>
		<span class="n">khugepaged_loop</span><span class="p">();</span>
		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">khugepaged_thread</span> <span class="o">!=</span> <span class="n">current</span><span class="p">);</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">khugepaged_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">khugepaged_enabled</span><span class="p">())</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">kthread_should_stop</span><span class="p">()))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">khugepaged_mm_lock</span><span class="p">);</span>
	<span class="n">mm_slot</span> <span class="o">=</span> <span class="n">khugepaged_scan</span><span class="p">.</span><span class="n">mm_slot</span><span class="p">;</span>
	<span class="n">khugepaged_scan</span><span class="p">.</span><span class="n">mm_slot</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm_slot</span><span class="p">)</span>
		<span class="n">collect_mm_slot</span><span class="p">(</span><span class="n">mm_slot</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">khugepaged_mm_lock</span><span class="p">);</span>

	<span class="n">khugepaged_thread</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">khugepaged_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__split_huge_page_pmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pmd_trans_huge</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">pmd_page</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">);</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">page_count</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">get_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>

	<span class="n">split_huge_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pmd_trans_huge</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">split_huge_page_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>

	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">address</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">HPAGE_PMD_MASK</span><span class="p">));</span>

	<span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pgd_present</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pud_present</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmd_present</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Caller holds the mmap_sem write mode, so a huge pmd cannot</span>
<span class="cm">	 * materialize from under us.</span>
<span class="cm">	 */</span>
	<span class="n">split_huge_page_pmd</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__vma_adjust_trans_huge</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
			     <span class="kt">long</span> <span class="n">adjust_next</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the new start address isn&#39;t hpage aligned and it could</span>
<span class="cm">	 * previously contain an hugepage: check if we need to split</span>
<span class="cm">	 * an huge pmd.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">HPAGE_PMD_MASK</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">start</span> <span class="o">&amp;</span> <span class="n">HPAGE_PMD_MASK</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">start</span> <span class="o">&amp;</span> <span class="n">HPAGE_PMD_MASK</span><span class="p">)</span> <span class="o">+</span> <span class="n">HPAGE_PMD_SIZE</span> <span class="o">&lt;=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">)</span>
		<span class="n">split_huge_page_address</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the new end address isn&#39;t hpage aligned and it could</span>
<span class="cm">	 * previously contain an hugepage: check if we need to split</span>
<span class="cm">	 * an huge pmd.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">HPAGE_PMD_MASK</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">end</span> <span class="o">&amp;</span> <span class="n">HPAGE_PMD_MASK</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">end</span> <span class="o">&amp;</span> <span class="n">HPAGE_PMD_MASK</span><span class="p">)</span> <span class="o">+</span> <span class="n">HPAGE_PMD_SIZE</span> <span class="o">&lt;=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">)</span>
		<span class="n">split_huge_page_address</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we&#39;re also updating the vma-&gt;vm_next-&gt;vm_start, if the new</span>
<span class="cm">	 * vm_next-&gt;vm_start isn&#39;t page aligned and it could previously</span>
<span class="cm">	 * contain an hugepage: check if we need to split an huge pmd.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adjust_next</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nstart</span> <span class="o">=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
		<span class="n">nstart</span> <span class="o">+=</span> <span class="n">adjust_next</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nstart</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">HPAGE_PMD_MASK</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">nstart</span> <span class="o">&amp;</span> <span class="n">HPAGE_PMD_MASK</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">nstart</span> <span class="o">&amp;</span> <span class="n">HPAGE_PMD_MASK</span><span class="p">)</span> <span class="o">+</span> <span class="n">HPAGE_PMD_SIZE</span> <span class="o">&lt;=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">)</span>
			<span class="n">split_huge_page_address</span><span class="p">(</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">nstart</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
