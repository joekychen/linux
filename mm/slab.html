<!DOCTYPE html>
<html><head><title>joekychen/linux » mm › slab.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>slab.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * linux/mm/slab.c</span>
<span class="cm"> * Written by Mark Hemment, 1996/97.</span>
<span class="cm"> * (markhe@nextd.demon.co.uk)</span>
<span class="cm"> *</span>
<span class="cm"> * kmem_cache_destroy() + some cleanup - 1999 Andrea Arcangeli</span>
<span class="cm"> *</span>
<span class="cm"> * Major cleanup, different bufctl logic, per-cpu arrays</span>
<span class="cm"> *	(c) 2000 Manfred Spraul</span>
<span class="cm"> *</span>
<span class="cm"> * Cleanup, make the head arrays unconditional, preparation for NUMA</span>
<span class="cm"> * 	(c) 2002 Manfred Spraul</span>
<span class="cm"> *</span>
<span class="cm"> * An implementation of the Slab Allocator as described in outline in;</span>
<span class="cm"> *	UNIX Internals: The New Frontiers by Uresh Vahalia</span>
<span class="cm"> *	Pub: Prentice Hall	ISBN 0-13-101908-2</span>
<span class="cm"> * or with a little more detail in;</span>
<span class="cm"> *	The Slab Allocator: An Object-Caching Kernel Memory Allocator</span>
<span class="cm"> *	Jeff Bonwick (Sun Microsystems).</span>
<span class="cm"> *	Presented at: USENIX Summer 1994 Technical Conference</span>
<span class="cm"> *</span>
<span class="cm"> * The memory is organized in caches, one cache for each object type.</span>
<span class="cm"> * (e.g. inode_cache, dentry_cache, buffer_head, vm_area_struct)</span>
<span class="cm"> * Each cache consists out of many slabs (they are small (usually one</span>
<span class="cm"> * page long) and always contiguous), and each slab contains multiple</span>
<span class="cm"> * initialized objects.</span>
<span class="cm"> *</span>
<span class="cm"> * This means, that your constructor is used only for newly allocated</span>
<span class="cm"> * slabs and you must pass objects with the same initializations to</span>
<span class="cm"> * kmem_cache_free.</span>
<span class="cm"> *</span>
<span class="cm"> * Each cache can only support one memory type (GFP_DMA, GFP_HIGHMEM,</span>
<span class="cm"> * normal). If you need a special memory type, then must create a new</span>
<span class="cm"> * cache for that memory type.</span>
<span class="cm"> *</span>
<span class="cm"> * In order to reduce fragmentation, the slabs are sorted in 3 groups:</span>
<span class="cm"> *   full slabs with 0 free objects</span>
<span class="cm"> *   partial slabs</span>
<span class="cm"> *   empty slabs with no allocated objects</span>
<span class="cm"> *</span>
<span class="cm"> * If partial slabs exist, then new allocations come from these slabs,</span>
<span class="cm"> * otherwise from empty slabs or new slabs are allocated.</span>
<span class="cm"> *</span>
<span class="cm"> * kmem_cache_destroy() CAN CRASH if you try to allocate from the cache</span>
<span class="cm"> * during kmem_cache_destroy(). The caller must prevent concurrent allocs.</span>
<span class="cm"> *</span>
<span class="cm"> * Each cache has a short per-cpu head array, most allocs</span>
<span class="cm"> * and frees go into that array, and if that array overflows, then 1/2</span>
<span class="cm"> * of the entries in the array are given back into the global cache.</span>
<span class="cm"> * The head array is strictly LIFO and should improve the cache hit rates.</span>
<span class="cm"> * On SMP, it additionally reduces the spinlock operations.</span>
<span class="cm"> *</span>
<span class="cm"> * The c_cpuarray may not be read with enabled local interrupts -</span>
<span class="cm"> * it&#39;s changed with a smp_call_function().</span>
<span class="cm"> *</span>
<span class="cm"> * SMP synchronization:</span>
<span class="cm"> *  constructors and destructors are called without any locking.</span>
<span class="cm"> *  Several members in struct kmem_cache and struct slab never change, they</span>
<span class="cm"> *	are accessed without any locking.</span>
<span class="cm"> *  The per-cpu arrays are never accessed from the wrong cpu, no locking,</span>
<span class="cm"> *  	and local interrupts are disabled so slab code is preempt-safe.</span>
<span class="cm"> *  The non-constant members are protected with a per-cache irq spinlock.</span>
<span class="cm"> *</span>
<span class="cm"> * Many thanks to Mark Hemment, who wrote another per-cpu slab patch</span>
<span class="cm"> * in 2000 - many ideas in the current implementation are derived from</span>
<span class="cm"> * his patch.</span>
<span class="cm"> *</span>
<span class="cm"> * Further notes from the original documentation:</span>
<span class="cm"> *</span>
<span class="cm"> * 11 April &#39;97.  Started multi-threading - markhe</span>
<span class="cm"> *	The global cache-chain is protected by the mutex &#39;cache_chain_mutex&#39;.</span>
<span class="cm"> *	The sem is only needed when accessing/extending the cache-chain, which</span>
<span class="cm"> *	can never happen inside an interrupt (kmem_cache_create(),</span>
<span class="cm"> *	kmem_cache_shrink() and kmem_cache_reap()).</span>
<span class="cm"> *</span>
<span class="cm"> *	At present, each engine can be growing a cache.  This should be blocked.</span>
<span class="cm"> *</span>
<span class="cm"> * 15 March 2005. NUMA slab allocator.</span>
<span class="cm"> *	Shai Fultheim &lt;shai@scalex86.org&gt;.</span>
<span class="cm"> *	Shobhit Dayal &lt;shobhit@calsoftinc.com&gt;</span>
<span class="cm"> *	Alok N Kataria &lt;alokk@calsoftinc.com&gt;</span>
<span class="cm"> *	Christoph Lameter &lt;christoph@lameter.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *	Modified the slab allocator to be node aware on NUMA systems.</span>
<span class="cm"> *	Each node has its own list of partial, free and full slabs.</span>
<span class="cm"> *	All object allocations for a node occur from node specific slab lists.</span>
<span class="cm"> */</span>

<span class="cp">#include	&lt;linux/slab.h&gt;</span>
<span class="cp">#include	&lt;linux/mm.h&gt;</span>
<span class="cp">#include	&lt;linux/poison.h&gt;</span>
<span class="cp">#include	&lt;linux/swap.h&gt;</span>
<span class="cp">#include	&lt;linux/cache.h&gt;</span>
<span class="cp">#include	&lt;linux/interrupt.h&gt;</span>
<span class="cp">#include	&lt;linux/init.h&gt;</span>
<span class="cp">#include	&lt;linux/compiler.h&gt;</span>
<span class="cp">#include	&lt;linux/cpuset.h&gt;</span>
<span class="cp">#include	&lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include	&lt;linux/seq_file.h&gt;</span>
<span class="cp">#include	&lt;linux/notifier.h&gt;</span>
<span class="cp">#include	&lt;linux/kallsyms.h&gt;</span>
<span class="cp">#include	&lt;linux/cpu.h&gt;</span>
<span class="cp">#include	&lt;linux/sysctl.h&gt;</span>
<span class="cp">#include	&lt;linux/module.h&gt;</span>
<span class="cp">#include	&lt;linux/rcupdate.h&gt;</span>
<span class="cp">#include	&lt;linux/string.h&gt;</span>
<span class="cp">#include	&lt;linux/uaccess.h&gt;</span>
<span class="cp">#include	&lt;linux/nodemask.h&gt;</span>
<span class="cp">#include	&lt;linux/kmemleak.h&gt;</span>
<span class="cp">#include	&lt;linux/mempolicy.h&gt;</span>
<span class="cp">#include	&lt;linux/mutex.h&gt;</span>
<span class="cp">#include	&lt;linux/fault-inject.h&gt;</span>
<span class="cp">#include	&lt;linux/rtmutex.h&gt;</span>
<span class="cp">#include	&lt;linux/reciprocal_div.h&gt;</span>
<span class="cp">#include	&lt;linux/debugobjects.h&gt;</span>
<span class="cp">#include	&lt;linux/kmemcheck.h&gt;</span>
<span class="cp">#include	&lt;linux/memory.h&gt;</span>
<span class="cp">#include	&lt;linux/prefetch.h&gt;</span>

<span class="cp">#include	&lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include	&lt;asm/tlbflush.h&gt;</span>
<span class="cp">#include	&lt;asm/page.h&gt;</span>

<span class="cp">#include &lt;trace/events/kmem.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * DEBUG	- 1 for kmem_cache_create() to honour; SLAB_RED_ZONE &amp; SLAB_POISON.</span>
<span class="cm"> *		  0 for faster, smaller code (especially in the critical paths).</span>
<span class="cm"> *</span>
<span class="cm"> * STATS	- 1 to collect stats for /proc/slabinfo.</span>
<span class="cm"> *		  0 for faster, smaller code (especially in the critical paths).</span>
<span class="cm"> *</span>
<span class="cm"> * FORCED_DEBUG	- 1 enables SLAB_RED_ZONE and SLAB_POISON (if possible)</span>
<span class="cm"> */</span>

<span class="cp">#ifdef CONFIG_DEBUG_SLAB</span>
<span class="cp">#define	DEBUG		1</span>
<span class="cp">#define	STATS		1</span>
<span class="cp">#define	FORCED_DEBUG	1</span>
<span class="cp">#else</span>
<span class="cp">#define	DEBUG		0</span>
<span class="cp">#define	STATS		0</span>
<span class="cp">#define	FORCED_DEBUG	0</span>
<span class="cp">#endif</span>

<span class="cm">/* Shouldn&#39;t this be in a header file somewhere? */</span>
<span class="cp">#define	BYTES_PER_WORD		sizeof(void *)</span>
<span class="cp">#define	REDZONE_ALIGN		max(BYTES_PER_WORD, __alignof__(unsigned long long))</span>

<span class="cp">#ifndef ARCH_KMALLOC_FLAGS</span>
<span class="cp">#define ARCH_KMALLOC_FLAGS SLAB_HWCACHE_ALIGN</span>
<span class="cp">#endif</span>

<span class="cm">/* Legal flag mask for kmem_cache_create(). */</span>
<span class="cp">#if DEBUG</span>
<span class="cp"># define CREATE_MASK	(SLAB_RED_ZONE | \</span>
<span class="cp">			 SLAB_POISON | SLAB_HWCACHE_ALIGN | \</span>
<span class="cp">			 SLAB_CACHE_DMA | \</span>
<span class="cp">			 SLAB_STORE_USER | \</span>
<span class="cp">			 SLAB_RECLAIM_ACCOUNT | SLAB_PANIC | \</span>
<span class="cp">			 SLAB_DESTROY_BY_RCU | SLAB_MEM_SPREAD | \</span>
<span class="cp">			 SLAB_DEBUG_OBJECTS | SLAB_NOLEAKTRACE | SLAB_NOTRACK)</span>
<span class="cp">#else</span>
<span class="cp"># define CREATE_MASK	(SLAB_HWCACHE_ALIGN | \</span>
<span class="cp">			 SLAB_CACHE_DMA | \</span>
<span class="cp">			 SLAB_RECLAIM_ACCOUNT | SLAB_PANIC | \</span>
<span class="cp">			 SLAB_DESTROY_BY_RCU | SLAB_MEM_SPREAD | \</span>
<span class="cp">			 SLAB_DEBUG_OBJECTS | SLAB_NOLEAKTRACE | SLAB_NOTRACK)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * kmem_bufctl_t:</span>
<span class="cm"> *</span>
<span class="cm"> * Bufctl&#39;s are used for linking objs within a slab</span>
<span class="cm"> * linked offsets.</span>
<span class="cm"> *</span>
<span class="cm"> * This implementation relies on &quot;struct page&quot; for locating the cache &amp;</span>
<span class="cm"> * slab an object belongs to.</span>
<span class="cm"> * This allows the bufctl structure to be small (one int), but limits</span>
<span class="cm"> * the number of objects a slab (not a cache) can contain when off-slab</span>
<span class="cm"> * bufctls are used. The limit is the size of the largest general cache</span>
<span class="cm"> * that does not use off-slab slabs.</span>
<span class="cm"> * For 32bit archs with 4 kB pages, is this 56.</span>
<span class="cm"> * This is not serious, as it is only for large objects, when it is unwise</span>
<span class="cm"> * to have too many per slab.</span>
<span class="cm"> * Note: This limit can be raised by introducing a general cache whose size</span>
<span class="cm"> * is less than 512 (PAGE_SIZE&lt;&lt;3), but greater than 256.</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">kmem_bufctl_t</span><span class="p">;</span>
<span class="cp">#define BUFCTL_END	(((kmem_bufctl_t)(~0U))-0)</span>
<span class="cp">#define BUFCTL_FREE	(((kmem_bufctl_t)(~0U))-1)</span>
<span class="cp">#define	BUFCTL_ACTIVE	(((kmem_bufctl_t)(~0U))-2)</span>
<span class="cp">#define	SLAB_LIMIT	(((kmem_bufctl_t)(~0U))-3)</span>

<span class="cm">/*</span>
<span class="cm"> * struct slab_rcu</span>
<span class="cm"> *</span>
<span class="cm"> * slab_destroy on a SLAB_DESTROY_BY_RCU cache uses this structure to</span>
<span class="cm"> * arrange for kmem_freepages to be called via RCU.  This is useful if</span>
<span class="cm"> * we need to approach a kernel structure obliquely, from its address</span>
<span class="cm"> * obtained without the usual locking.  We can lock the structure to</span>
<span class="cm"> * stabilize it and check it&#39;s still at the given address, only if we</span>
<span class="cm"> * can be sure that the memory has not been meanwhile reused for some</span>
<span class="cm"> * other kind of object (which our subsystem&#39;s lock might corrupt).</span>
<span class="cm"> *</span>
<span class="cm"> * rcu_read_lock before reading the address, then rcu_read_unlock after</span>
<span class="cm"> * taking the spinlock within the structure expected at that address.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">slab_rcu</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * struct slab</span>
<span class="cm"> *</span>
<span class="cm"> * Manages the objs in a slab. Placed either at the beginning of mem allocated</span>
<span class="cm"> * for a slab, or allocated from an general cache.</span>
<span class="cm"> * Slabs are chained into three list: fully used, partial, fully free slabs.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">slab</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">colouroff</span><span class="p">;</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">s_mem</span><span class="p">;</span>		<span class="cm">/* including colour offset */</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">inuse</span><span class="p">;</span>	<span class="cm">/* num of objs active in slab */</span>
			<span class="n">kmem_bufctl_t</span> <span class="n">free</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">nodeid</span><span class="p">;</span>
		<span class="p">};</span>
		<span class="k">struct</span> <span class="n">slab_rcu</span> <span class="n">__slab_cover_slab_rcu</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * struct array_cache</span>
<span class="cm"> *</span>
<span class="cm"> * Purpose:</span>
<span class="cm"> * - LIFO ordering, to hand out cache-warm objects from _alloc</span>
<span class="cm"> * - reduce the number of linked list operations</span>
<span class="cm"> * - reduce spinlock operations</span>
<span class="cm"> *</span>
<span class="cm"> * The limit is stored in the per-cpu structure to reduce the data cache</span>
<span class="cm"> * footprint.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">array_cache</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">avail</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">limit</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">batchcount</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">touched</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">entry</span><span class="p">[];</span>	<span class="cm">/*</span>
<span class="cm">			 * Must have this definition in here for the proper</span>
<span class="cm">			 * alignment of array_cache. Also simplifies accessing</span>
<span class="cm">			 * the entries.</span>
<span class="cm">			 */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * bootstrap: The caches do not work without cpuarrays anymore, but the</span>
<span class="cm"> * cpuarrays are allocated from the generic caches...</span>
<span class="cm"> */</span>
<span class="cp">#define BOOT_CPUCACHE_ENTRIES	1</span>
<span class="k">struct</span> <span class="n">arraycache_init</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">array_cache</span> <span class="n">cache</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">entries</span><span class="p">[</span><span class="n">BOOT_CPUCACHE_ENTRIES</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The slab lists for all objects.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">kmem_list3</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">slabs_partial</span><span class="p">;</span>	<span class="cm">/* partial list first, better asm code */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">slabs_full</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">slabs_free</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">free_objects</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">free_limit</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">colour_next</span><span class="p">;</span>	<span class="cm">/* Per-node cache coloring */</span>
	<span class="n">spinlock_t</span> <span class="n">list_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">array_cache</span> <span class="o">*</span><span class="n">shared</span><span class="p">;</span>	<span class="cm">/* shared per node */</span>
	<span class="k">struct</span> <span class="n">array_cache</span> <span class="o">**</span><span class="n">alien</span><span class="p">;</span>	<span class="cm">/* on other nodes */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next_reap</span><span class="p">;</span>	<span class="cm">/* updated without locking */</span>
	<span class="kt">int</span> <span class="n">free_touched</span><span class="p">;</span>		<span class="cm">/* updated without locking */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Need this for bootstrapping a per node allocator.</span>
<span class="cm"> */</span>
<span class="cp">#define NUM_INIT_LISTS (3 * MAX_NUMNODES)</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_list3</span> <span class="n">__initdata</span> <span class="n">initkmem_list3</span><span class="p">[</span><span class="n">NUM_INIT_LISTS</span><span class="p">];</span>
<span class="cp">#define	CACHE_CACHE 0</span>
<span class="cp">#define	SIZE_AC MAX_NUMNODES</span>
<span class="cp">#define	SIZE_L3 (2 * MAX_NUMNODES)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">drain_freelist</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">kmem_list3</span> <span class="o">*</span><span class="n">l3</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tofree</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">free_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">objpp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">node</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">enable_cpucache</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">cache_reap</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">unused</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * This function must be completely optimized away if a constant is passed to</span>
<span class="cm"> * it.  Mostly the same as what is in linux/slab.h except it returns an index.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">int</span> <span class="nf">index_of</span><span class="p">(</span><span class="k">const</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">extern</span> <span class="kt">void</span> <span class="n">__bad_size</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__builtin_constant_p</span><span class="p">(</span><span class="n">size</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#define CACHE(x) \</span>
<span class="cp">	if (size &lt;=x) \</span>
<span class="cp">		return i; \</span>
<span class="cp">	else \</span>
<span class="cp">		i++;</span>
<span class="cp">#include &lt;linux/kmalloc_sizes.h&gt;</span>
<span class="cp">#undef CACHE</span>
		<span class="n">__bad_size</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">__bad_size</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">slab_early_init</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="cp">#define INDEX_AC index_of(sizeof(struct arraycache_init))</span>
<span class="cp">#define INDEX_L3 index_of(sizeof(struct kmem_list3))</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kmem_list3_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_list3</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">slabs_full</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">slabs_partial</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">slabs_free</span><span class="p">);</span>
	<span class="n">parent</span><span class="o">-&gt;</span><span class="n">shared</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">parent</span><span class="o">-&gt;</span><span class="n">alien</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">parent</span><span class="o">-&gt;</span><span class="n">colour_next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
	<span class="n">parent</span><span class="o">-&gt;</span><span class="n">free_objects</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">parent</span><span class="o">-&gt;</span><span class="n">free_touched</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define MAKE_LIST(cachep, listp, slab, nodeid)				\</span>
<span class="cp">	do {								\</span>
<span class="cp">		INIT_LIST_HEAD(listp);					\</span>
<span class="cp">		list_splice(&amp;(cachep-&gt;nodelists[nodeid]-&gt;slab), listp);	\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define	MAKE_ALL_LISTS(cachep, ptr, nodeid)				\</span>
<span class="cp">	do {								\</span>
<span class="cp">	MAKE_LIST((cachep), (&amp;(ptr)-&gt;slabs_full), slabs_full, nodeid);	\</span>
<span class="cp">	MAKE_LIST((cachep), (&amp;(ptr)-&gt;slabs_partial), slabs_partial, nodeid); \</span>
<span class="cp">	MAKE_LIST((cachep), (&amp;(ptr)-&gt;slabs_free), slabs_free, nodeid);	\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define CFLGS_OFF_SLAB		(0x80000000UL)</span>
<span class="cp">#define	OFF_SLAB(x)	((x)-&gt;flags &amp; CFLGS_OFF_SLAB)</span>

<span class="cp">#define BATCHREFILL_LIMIT	16</span>
<span class="cm">/*</span>
<span class="cm"> * Optimization question: fewer reaps means less probability for unnessary</span>
<span class="cm"> * cpucache drain/refill cycles.</span>
<span class="cm"> *</span>
<span class="cm"> * OTOH the cpuarrays can contain lots of objects,</span>
<span class="cm"> * which could lock up otherwise freeable slabs.</span>
<span class="cm"> */</span>
<span class="cp">#define REAPTIMEOUT_CPUC	(2*HZ)</span>
<span class="cp">#define REAPTIMEOUT_LIST3	(4*HZ)</span>

<span class="cp">#if STATS</span>
<span class="cp">#define	STATS_INC_ACTIVE(x)	((x)-&gt;num_active++)</span>
<span class="cp">#define	STATS_DEC_ACTIVE(x)	((x)-&gt;num_active--)</span>
<span class="cp">#define	STATS_INC_ALLOCED(x)	((x)-&gt;num_allocations++)</span>
<span class="cp">#define	STATS_INC_GROWN(x)	((x)-&gt;grown++)</span>
<span class="cp">#define	STATS_ADD_REAPED(x,y)	((x)-&gt;reaped += (y))</span>
<span class="cp">#define	STATS_SET_HIGH(x)						\</span>
<span class="cp">	do {								\</span>
<span class="cp">		if ((x)-&gt;num_active &gt; (x)-&gt;high_mark)			\</span>
<span class="cp">			(x)-&gt;high_mark = (x)-&gt;num_active;		\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#define	STATS_INC_ERR(x)	((x)-&gt;errors++)</span>
<span class="cp">#define	STATS_INC_NODEALLOCS(x)	((x)-&gt;node_allocs++)</span>
<span class="cp">#define	STATS_INC_NODEFREES(x)	((x)-&gt;node_frees++)</span>
<span class="cp">#define STATS_INC_ACOVERFLOW(x)   ((x)-&gt;node_overflow++)</span>
<span class="cp">#define	STATS_SET_FREEABLE(x, i)					\</span>
<span class="cp">	do {								\</span>
<span class="cp">		if ((x)-&gt;max_freeable &lt; i)				\</span>
<span class="cp">			(x)-&gt;max_freeable = i;				\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#define STATS_INC_ALLOCHIT(x)	atomic_inc(&amp;(x)-&gt;allochit)</span>
<span class="cp">#define STATS_INC_ALLOCMISS(x)	atomic_inc(&amp;(x)-&gt;allocmiss)</span>
<span class="cp">#define STATS_INC_FREEHIT(x)	atomic_inc(&amp;(x)-&gt;freehit)</span>
<span class="cp">#define STATS_INC_FREEMISS(x)	atomic_inc(&amp;(x)-&gt;freemiss)</span>
<span class="cp">#else</span>
<span class="cp">#define	STATS_INC_ACTIVE(x)	do { } while (0)</span>
<span class="cp">#define	STATS_DEC_ACTIVE(x)	do { } while (0)</span>
<span class="cp">#define	STATS_INC_ALLOCED(x)	do { } while (0)</span>
<span class="cp">#define	STATS_INC_GROWN(x)	do { } while (0)</span>
<span class="cp">#define	STATS_ADD_REAPED(x,y)	do { (void)(y); } while (0)</span>
<span class="cp">#define	STATS_SET_HIGH(x)	do { } while (0)</span>
<span class="cp">#define	STATS_INC_ERR(x)	do { } while (0)</span>
<span class="cp">#define	STATS_INC_NODEALLOCS(x)	do { } while (0)</span>
<span class="cp">#define	STATS_INC_NODEFREES(x)	do { } while (0)</span>
<span class="cp">#define STATS_INC_ACOVERFLOW(x)   do { } while (0)</span>
<span class="cp">#define	STATS_SET_FREEABLE(x, i) do { } while (0)</span>
<span class="cp">#define STATS_INC_ALLOCHIT(x)	do { } while (0)</span>
<span class="cp">#define STATS_INC_ALLOCMISS(x)	do { } while (0)</span>
<span class="cp">#define STATS_INC_FREEHIT(x)	do { } while (0)</span>
<span class="cp">#define STATS_INC_FREEMISS(x)	do { } while (0)</span>
<span class="cp">#endif</span>

<span class="cp">#if DEBUG</span>

<span class="cm">/*</span>
<span class="cm"> * memory layout of objects:</span>
<span class="cm"> * 0		: objp</span>
<span class="cm"> * 0 .. cachep-&gt;obj_offset - BYTES_PER_WORD - 1: padding. This ensures that</span>
<span class="cm"> * 		the end of an object is aligned with the end of the real</span>
<span class="cm"> * 		allocation. Catches writes behind the end of the allocation.</span>
<span class="cm"> * cachep-&gt;obj_offset - BYTES_PER_WORD .. cachep-&gt;obj_offset - 1:</span>
<span class="cm"> * 		redzone word.</span>
<span class="cm"> * cachep-&gt;obj_offset: The real object.</span>
<span class="cm"> * cachep-&gt;buffer_size - 2* BYTES_PER_WORD: redzone word [BYTES_PER_WORD long]</span>
<span class="cm"> * cachep-&gt;buffer_size - 1* BYTES_PER_WORD: last caller address</span>
<span class="cm"> *					[BYTES_PER_WORD long]</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">obj_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">obj_offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">obj_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">obj_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="nf">dbg_redzone1</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">objp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_RED_ZONE</span><span class="p">));</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">objp</span> <span class="o">+</span> <span class="n">obj_offset</span><span class="p">(</span><span class="n">cachep</span><span class="p">)</span> <span class="o">-</span>
				      <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="nf">dbg_redzone2</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">objp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_RED_ZONE</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_STORE_USER</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)(</span><span class="n">objp</span> <span class="o">+</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">-</span>
					      <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="o">-</span>
					      <span class="n">REDZONE_ALIGN</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">objp</span> <span class="o">+</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">-</span>
				       <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">**</span><span class="nf">dbg_userword</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">objp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_STORE_USER</span><span class="p">));</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)(</span><span class="n">objp</span> <span class="o">+</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">-</span> <span class="n">BYTES_PER_WORD</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="cp">#define obj_offset(x)			0</span>
<span class="cp">#define obj_size(cachep)		(cachep-&gt;buffer_size)</span>
<span class="cp">#define dbg_redzone1(cachep, objp)	({BUG(); (unsigned long long *)NULL;})</span>
<span class="cp">#define dbg_redzone2(cachep, objp)	({BUG(); (unsigned long long *)NULL;})</span>
<span class="cp">#define dbg_userword(cachep, objp)	({BUG(); (void **)NULL;})</span>

<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_TRACING</span>
<span class="kt">size_t</span> <span class="nf">slab_buffer_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">buffer_size</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">slab_buffer_size</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Do not go above this order unless 0 objects fit into the slab or</span>
<span class="cm"> * overridden on the command line.</span>
<span class="cm"> */</span>
<span class="cp">#define	SLAB_MAX_ORDER_HI	1</span>
<span class="cp">#define	SLAB_MAX_ORDER_LO	0</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">slab_max_order</span> <span class="o">=</span> <span class="n">SLAB_MAX_ORDER_LO</span><span class="p">;</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">slab_max_order_set</span> <span class="n">__initdata</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Functions for storing/retrieving the cachep and or slab from the page</span>
<span class="cm"> * allocator.  These are used to find the slab an obj belongs to.  With kfree(),</span>
<span class="cm"> * these are used to find the cache which an obj belongs to.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">page_set_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="p">)</span><span class="n">cache</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="nf">page_get_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">compound_head</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageSlab</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="p">)</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">page_set_slab</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">slab</span> <span class="o">*</span><span class="n">slab</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="p">)</span><span class="n">slab</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">slab</span> <span class="o">*</span><span class="nf">page_get_slab</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageSlab</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">slab</span> <span class="o">*</span><span class="p">)</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">.</span><span class="n">prev</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="nf">virt_to_cache</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">virt_to_head_page</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">page_get_cache</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">slab</span> <span class="o">*</span><span class="nf">virt_to_slab</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">virt_to_head_page</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">page_get_slab</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">index_to_obj</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">,</span> <span class="k">struct</span> <span class="n">slab</span> <span class="o">*</span><span class="n">slab</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">slab</span><span class="o">-&gt;</span><span class="n">s_mem</span> <span class="o">+</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">*</span> <span class="n">idx</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We want to avoid an expensive divide : (offset / cache-&gt;buffer_size)</span>
<span class="cm"> *   Using the fact that buffer_size is a constant for a particular cache,</span>
<span class="cm"> *   we can replace (offset / cache-&gt;buffer_size) by</span>
<span class="cm"> *   reciprocal_divide(offset, cache-&gt;reciprocal_buffer_size)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">obj_to_index</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">slab</span> <span class="o">*</span><span class="n">slab</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">obj</span> <span class="o">-</span> <span class="n">slab</span><span class="o">-&gt;</span><span class="n">s_mem</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">reciprocal_divide</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">reciprocal_buffer_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * These are the default caches for kmalloc. Custom caches can have other sizes.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cache_sizes</span> <span class="n">malloc_sizes</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="cp">#define CACHE(x) { .cs_size = (x) },</span>
<span class="cp">#include &lt;linux/kmalloc_sizes.h&gt;</span>
	<span class="n">CACHE</span><span class="p">(</span><span class="n">ULONG_MAX</span><span class="p">)</span>
<span class="cp">#undef CACHE</span>
<span class="p">};</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">malloc_sizes</span><span class="p">);</span>

<span class="cm">/* Must match cache_sizes above. Out of line to keep cache footprint low. */</span>
<span class="k">struct</span> <span class="n">cache_names</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name_dma</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cache_names</span> <span class="n">__initdata</span> <span class="n">cache_names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="cp">#define CACHE(x) { .name = &quot;size-&quot; #x, .name_dma = &quot;size-&quot; #x &quot;(DMA)&quot; },</span>
<span class="cp">#include &lt;linux/kmalloc_sizes.h&gt;</span>
	<span class="p">{</span><span class="nb">NULL</span><span class="p">,}</span>
<span class="cp">#undef CACHE</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">arraycache_init</span> <span class="n">initarray_cache</span> <span class="n">__initdata</span> <span class="o">=</span>
    <span class="p">{</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="n">BOOT_CPUCACHE_ENTRIES</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span> <span class="p">};</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">arraycache_init</span> <span class="n">initarray_generic</span> <span class="o">=</span>
    <span class="p">{</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="n">BOOT_CPUCACHE_ENTRIES</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span> <span class="p">};</span>

<span class="cm">/* internal cache of cache description objs */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_list3</span> <span class="o">*</span><span class="n">cache_cache_nodelists</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">];</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="n">cache_cache</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">nodelists</span> <span class="o">=</span> <span class="n">cache_cache_nodelists</span><span class="p">,</span>
	<span class="p">.</span><span class="n">batchcount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">limit</span> <span class="o">=</span> <span class="n">BOOT_CPUCACHE_ENTRIES</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shared</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buffer_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span><span class="p">),</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;kmem_cache&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define BAD_ALIEN_MAGIC 0x01020304ul</span>

<span class="cm">/*</span>
<span class="cm"> * chicken and egg problem: delay the per-cpu array allocation</span>
<span class="cm"> * until the general caches are up.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">NONE</span><span class="p">,</span>
	<span class="n">PARTIAL_AC</span><span class="p">,</span>
	<span class="n">PARTIAL_L3</span><span class="p">,</span>
	<span class="n">EARLY</span><span class="p">,</span>
	<span class="n">LATE</span><span class="p">,</span>
	<span class="n">FULL</span>
<span class="p">}</span> <span class="n">g_cpucache_up</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * used by boot code to determine if it can use slab based allocator</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">slab_is_available</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">g_cpucache_up</span> <span class="o">&gt;=</span> <span class="n">EARLY</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_LOCKDEP</span>

<span class="cm">/*</span>
<span class="cm"> * Slab sometimes uses the kmalloc slabs to store the slab headers</span>
<span class="cm"> * for other slabs &quot;off slab&quot;.</span>
<span class="cm"> * The locking for this is tricky in that it nests within the locks</span>
<span class="cm"> * of all other slabs in a few places; to deal with this special</span>
<span class="cm"> * locking we put on-slab caches into a separate lock-class.</span>
<span class="cm"> *</span>
<span class="cm"> * We set lock class for alien array caches which are up during init.</span>
<span class="cm"> * The lock annotation will be lost if all cpus of a node goes down and</span>
<span class="cm"> * then comes back up during hotplug</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="n">on_slab_l3_key</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="n">on_slab_alc_key</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="n">debugobj_l3_key</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="n">debugobj_alc_key</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">slab_set_lock_classes</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">lock_class_key</span> <span class="o">*</span><span class="n">l3_key</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="o">*</span><span class="n">alc_key</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">array_cache</span> <span class="o">**</span><span class="n">alc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_list3</span> <span class="o">*</span><span class="n">l3</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">l3</span> <span class="o">=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">q</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">l3</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">lockdep_set_class</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span> <span class="n">l3_key</span><span class="p">);</span>
	<span class="n">alc</span> <span class="o">=</span> <span class="n">l3</span><span class="o">-&gt;</span><span class="n">alien</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * FIXME: This check for BAD_ALIEN_MAGIC</span>
<span class="cm">	 * should go away when common slab code is taught to</span>
<span class="cm">	 * work even without alien caches.</span>
<span class="cm">	 * Currently, non NUMA code returns BAD_ALIEN_MAGIC</span>
<span class="cm">	 * for alloc_alien_cache,</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alc</span> <span class="o">||</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">alc</span> <span class="o">==</span> <span class="n">BAD_ALIEN_MAGIC</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">for_each_node</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">alc</span><span class="p">[</span><span class="n">r</span><span class="p">])</span>
			<span class="n">lockdep_set_class</span><span class="p">(</span><span class="o">&amp;</span><span class="n">alc</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">alc_key</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">slab_set_debugobj_lock_classes_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">slab_set_lock_classes</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">debugobj_l3_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">debugobj_alc_key</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">slab_set_debugobj_lock_classes</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>

	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
		<span class="n">slab_set_debugobj_lock_classes_node</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_node_lock_keys</span><span class="p">(</span><span class="kt">int</span> <span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_sizes</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">malloc_sizes</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">g_cpucache_up</span> <span class="o">&lt;</span> <span class="n">LATE</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">s</span> <span class="o">=</span> <span class="n">malloc_sizes</span><span class="p">;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cs_size</span> <span class="o">!=</span> <span class="n">ULONG_MAX</span><span class="p">;</span> <span class="n">s</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kmem_list3</span> <span class="o">*</span><span class="n">l3</span><span class="p">;</span>

		<span class="n">l3</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cs_cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">q</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">l3</span> <span class="o">||</span> <span class="n">OFF_SLAB</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cs_cachep</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">slab_set_lock_classes</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cs_cachep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">on_slab_l3_key</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">on_slab_alc_key</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">init_lock_keys</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>

	<span class="n">for_each_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
		<span class="n">init_node_lock_keys</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_node_lock_keys</span><span class="p">(</span><span class="kt">int</span> <span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">init_lock_keys</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">slab_set_debugobj_lock_classes_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">slab_set_debugobj_lock_classes</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Guard access to the cache-chain.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">cache_chain_mutex</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="n">cache_chain</span><span class="p">;</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">delayed_work</span><span class="p">,</span> <span class="n">slab_reap_work</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">array_cache</span> <span class="o">*</span><span class="nf">cpu_cache_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="n">smp_processor_id</span><span class="p">()];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="nf">__find_general_cachep</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
							<span class="n">gfp_t</span> <span class="n">gfpflags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_sizes</span> <span class="o">*</span><span class="n">csizep</span> <span class="o">=</span> <span class="n">malloc_sizes</span><span class="p">;</span>

<span class="cp">#if DEBUG</span>
	<span class="cm">/* This happens if someone tries to call</span>
<span class="cm">	 * kmem_cache_create(), or __kmalloc(), before</span>
<span class="cm">	 * the generic caches are initialized.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">malloc_sizes</span><span class="p">[</span><span class="n">INDEX_AC</span><span class="p">].</span><span class="n">cs_cachep</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">size</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ZERO_SIZE_PTR</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">csizep</span><span class="o">-&gt;</span><span class="n">cs_size</span><span class="p">)</span>
		<span class="n">csizep</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Really subtle: The last entry with cs-&gt;cs_size==ULONG_MAX</span>
<span class="cm">	 * has cs_{dma,}cachep==NULL. Thus no special case</span>
<span class="cm">	 * for large kmalloc calls required.</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef CONFIG_ZONE_DMA</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">gfpflags</span> <span class="o">&amp;</span> <span class="n">GFP_DMA</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">csizep</span><span class="o">-&gt;</span><span class="n">cs_dmacachep</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">csizep</span><span class="o">-&gt;</span><span class="n">cs_cachep</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="nf">kmem_find_general_cachep</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfpflags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__find_general_cachep</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">gfpflags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">slab_mgmt_size</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">nr_objs</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">align</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">slab</span><span class="p">)</span><span class="o">+</span><span class="n">nr_objs</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">kmem_bufctl_t</span><span class="p">),</span> <span class="n">align</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Calculate the number of objects and left-over bytes for a given buffer size.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cache_estimate</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gfporder</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buffer_size</span><span class="p">,</span>
			   <span class="kt">size_t</span> <span class="n">align</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">left_over</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nr_objs</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">mgmt_size</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">slab_size</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="n">gfporder</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The slab management structure can be either off the slab or</span>
<span class="cm">	 * on it. For the latter case, the memory allocated for a</span>
<span class="cm">	 * slab is used for:</span>
<span class="cm">	 *</span>
<span class="cm">	 * - The struct slab</span>
<span class="cm">	 * - One kmem_bufctl_t for each object</span>
<span class="cm">	 * - Padding to respect alignment of @align</span>
<span class="cm">	 * - @buffer_size bytes for each object</span>
<span class="cm">	 *</span>
<span class="cm">	 * If the slab management structure is off the slab, then the</span>
<span class="cm">	 * alignment will already be calculated into the size. Because</span>
<span class="cm">	 * the slabs are all pages aligned, the objects will be at the</span>
<span class="cm">	 * correct alignment when allocated.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CFLGS_OFF_SLAB</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mgmt_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">nr_objs</span> <span class="o">=</span> <span class="n">slab_size</span> <span class="o">/</span> <span class="n">buffer_size</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nr_objs</span> <span class="o">&gt;</span> <span class="n">SLAB_LIMIT</span><span class="p">)</span>
			<span class="n">nr_objs</span> <span class="o">=</span> <span class="n">SLAB_LIMIT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Ignore padding for the initial guess. The padding</span>
<span class="cm">		 * is at most @align-1 bytes, and @buffer_size is at</span>
<span class="cm">		 * least @align. In the worst case, this result will</span>
<span class="cm">		 * be one greater than the number of objects that fit</span>
<span class="cm">		 * into the memory allocation when taking the padding</span>
<span class="cm">		 * into account.</span>
<span class="cm">		 */</span>
		<span class="n">nr_objs</span> <span class="o">=</span> <span class="p">(</span><span class="n">slab_size</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">slab</span><span class="p">))</span> <span class="o">/</span>
			  <span class="p">(</span><span class="n">buffer_size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">kmem_bufctl_t</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * This calculated number will be either the right</span>
<span class="cm">		 * amount, or one greater than what we want.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slab_mgmt_size</span><span class="p">(</span><span class="n">nr_objs</span><span class="p">,</span> <span class="n">align</span><span class="p">)</span> <span class="o">+</span> <span class="n">nr_objs</span><span class="o">*</span><span class="n">buffer_size</span>
		       <span class="o">&gt;</span> <span class="n">slab_size</span><span class="p">)</span>
			<span class="n">nr_objs</span><span class="o">--</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nr_objs</span> <span class="o">&gt;</span> <span class="n">SLAB_LIMIT</span><span class="p">)</span>
			<span class="n">nr_objs</span> <span class="o">=</span> <span class="n">SLAB_LIMIT</span><span class="p">;</span>

		<span class="n">mgmt_size</span> <span class="o">=</span> <span class="n">slab_mgmt_size</span><span class="p">(</span><span class="n">nr_objs</span><span class="p">,</span> <span class="n">align</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">num</span> <span class="o">=</span> <span class="n">nr_objs</span><span class="p">;</span>
	<span class="o">*</span><span class="n">left_over</span> <span class="o">=</span> <span class="n">slab_size</span> <span class="o">-</span> <span class="n">nr_objs</span><span class="o">*</span><span class="n">buffer_size</span> <span class="o">-</span> <span class="n">mgmt_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define slab_error(cachep, msg) __slab_error(__func__, cachep, msg)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__slab_error</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">function</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;slab error in %s(): cache `%s&#39;: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">function</span><span class="p">,</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
	<span class="n">dump_stack</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * By default on NUMA we use alien caches to stage the freeing of</span>
<span class="cm"> * objects allocated from other nodes. This causes massive memory</span>
<span class="cm"> * inefficiencies when using fake NUMA setup to split memory into a</span>
<span class="cm"> * large number of small nodes, so it can be disabled on the command</span>
<span class="cm"> * line</span>
<span class="cm">  */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">use_alien_caches</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">noaliencache_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">use_alien_caches</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;noaliencache&quot;</span><span class="p">,</span> <span class="n">noaliencache_setup</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">slab_max_order_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">get_option</span><span class="p">(</span><span class="o">&amp;</span><span class="n">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slab_max_order</span><span class="p">);</span>
	<span class="n">slab_max_order</span> <span class="o">=</span> <span class="n">slab_max_order</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span>
				<span class="n">min</span><span class="p">(</span><span class="n">slab_max_order</span><span class="p">,</span> <span class="n">MAX_ORDER</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">slab_max_order_set</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;slab_max_order=&quot;</span><span class="p">,</span> <span class="n">slab_max_order_setup</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_NUMA</span>
<span class="cm">/*</span>
<span class="cm"> * Special reaping functions for NUMA systems called from cache_reap().</span>
<span class="cm"> * These take care of doing round robin flushing of alien caches (containing</span>
<span class="cm"> * objects freed on different nodes from which they were allocated) and the</span>
<span class="cm"> * flushing of remote pcps by calling drain_node_pages.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">slab_reap_node</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_reap_node</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>

	<span class="n">node</span> <span class="o">=</span> <span class="n">next_node</span><span class="p">(</span><span class="n">cpu_to_mem</span><span class="p">(</span><span class="n">cpu</span><span class="p">),</span> <span class="n">node_online_map</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="n">MAX_NUMNODES</span><span class="p">)</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">first_node</span><span class="p">(</span><span class="n">node_online_map</span><span class="p">);</span>

	<span class="n">per_cpu</span><span class="p">(</span><span class="n">slab_reap_node</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">next_reap_node</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">node</span> <span class="o">=</span> <span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">slab_reap_node</span><span class="p">);</span>

	<span class="n">node</span> <span class="o">=</span> <span class="n">next_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">node_online_map</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">node</span> <span class="o">&gt;=</span> <span class="n">MAX_NUMNODES</span><span class="p">))</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">first_node</span><span class="p">(</span><span class="n">node_online_map</span><span class="p">);</span>
	<span class="n">__this_cpu_write</span><span class="p">(</span><span class="n">slab_reap_node</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else</span>
<span class="cp">#define init_reap_node(cpu) do { } while (0)</span>
<span class="cp">#define next_reap_node(void) do { } while (0)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Initiate the reap timer running on the target CPU.  We run at around 1 to 2Hz</span>
<span class="cm"> * via the workqueue/eventd.</span>
<span class="cm"> * Add the CPU number into the expiration time to minimize the possibility of</span>
<span class="cm"> * the CPUs getting into lockstep and contending for the global cache chain</span>
<span class="cm"> * lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">start_cpu_timer</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="n">reap_work</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">slab_reap_work</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * When this gets called from do_initcalls via cpucache_init(),</span>
<span class="cm">	 * init_workqueues() has already run, so keventd will be setup</span>
<span class="cm">	 * at that time.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">keventd_up</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">reap_work</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">.</span><span class="n">func</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">init_reap_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="n">INIT_DELAYED_WORK_DEFERRABLE</span><span class="p">(</span><span class="n">reap_work</span><span class="p">,</span> <span class="n">cache_reap</span><span class="p">);</span>
		<span class="n">schedule_delayed_work_on</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">reap_work</span><span class="p">,</span>
					<span class="n">__round_jiffies_relative</span><span class="p">(</span><span class="n">HZ</span><span class="p">,</span> <span class="n">cpu</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">array_cache</span> <span class="o">*</span><span class="nf">alloc_arraycache</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">entries</span><span class="p">,</span>
					    <span class="kt">int</span> <span class="n">batchcount</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">memsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="n">entries</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">array_cache</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">array_cache</span> <span class="o">*</span><span class="n">nc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">nc</span> <span class="o">=</span> <span class="n">kmalloc_node</span><span class="p">(</span><span class="n">memsize</span><span class="p">,</span> <span class="n">gfp</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * The array_cache structures contain pointers to free object.</span>
<span class="cm">	 * However, when such objects are allocated or transferred to another</span>
<span class="cm">	 * cache the pointers are not cleared and they could be counted as</span>
<span class="cm">	 * valid references during a kmemleak scan. Therefore, kmemleak must</span>
<span class="cm">	 * not scan such objects.</span>
<span class="cm">	 */</span>
	<span class="n">kmemleak_no_scan</span><span class="p">(</span><span class="n">nc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nc</span><span class="o">-&gt;</span><span class="n">avail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">nc</span><span class="o">-&gt;</span><span class="n">limit</span> <span class="o">=</span> <span class="n">entries</span><span class="p">;</span>
		<span class="n">nc</span><span class="o">-&gt;</span><span class="n">batchcount</span> <span class="o">=</span> <span class="n">batchcount</span><span class="p">;</span>
		<span class="n">nc</span><span class="o">-&gt;</span><span class="n">touched</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">nc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Transfer objects in one arraycache to another.</span>
<span class="cm"> * Locking must be handled by the caller.</span>
<span class="cm"> *</span>
<span class="cm"> * Return the number of entries transferred.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">transfer_objects</span><span class="p">(</span><span class="k">struct</span> <span class="n">array_cache</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">array_cache</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Figure out how many entries to transfer */</span>
	<span class="kt">int</span> <span class="n">nr</span> <span class="o">=</span> <span class="n">min3</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">,</span> <span class="n">max</span><span class="p">,</span> <span class="n">to</span><span class="o">-&gt;</span><span class="n">limit</span> <span class="o">-</span> <span class="n">to</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nr</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">entry</span> <span class="o">+</span> <span class="n">to</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">,</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">entry</span> <span class="o">+</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">avail</span> <span class="o">-</span><span class="n">nr</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span><span class="n">nr</span><span class="p">);</span>

	<span class="n">from</span><span class="o">-&gt;</span><span class="n">avail</span> <span class="o">-=</span> <span class="n">nr</span><span class="p">;</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">avail</span> <span class="o">+=</span> <span class="n">nr</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">nr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifndef CONFIG_NUMA</span>

<span class="cp">#define drain_alien_cache(cachep, alien) do { } while (0)</span>
<span class="cp">#define reap_alien(cachep, l3) do { } while (0)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">array_cache</span> <span class="o">**</span><span class="nf">alloc_alien_cache</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">limit</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">array_cache</span> <span class="o">**</span><span class="p">)</span><span class="n">BAD_ALIEN_MAGIC</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">free_alien_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">array_cache</span> <span class="o">**</span><span class="n">ac_ptr</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cache_free_alien</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">objp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">alternate_node_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span>
		<span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">____cache_alloc_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span>
		 <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nodeid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else	</span><span class="cm">/* CONFIG_NUMA */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="n">____cache_alloc_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="p">,</span> <span class="n">gfp_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="n">alternate_node_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="p">,</span> <span class="n">gfp_t</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">array_cache</span> <span class="o">**</span><span class="nf">alloc_alien_cache</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">limit</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">array_cache</span> <span class="o">**</span><span class="n">ac_ptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">memsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="n">nr_node_ids</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">limit</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">limit</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
	<span class="n">ac_ptr</span> <span class="o">=</span> <span class="n">kzalloc_node</span><span class="p">(</span><span class="n">memsize</span><span class="p">,</span> <span class="n">gfp</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ac_ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">for_each_node</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">node</span> <span class="o">||</span> <span class="o">!</span><span class="n">node_online</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">ac_ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">alloc_arraycache</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="mh">0xbaadf00d</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ac_ptr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
					<span class="n">kfree</span><span class="p">(</span><span class="n">ac_ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">ac_ptr</span><span class="p">);</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ac_ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_alien_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">array_cache</span> <span class="o">**</span><span class="n">ac_ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ac_ptr</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">for_each_node</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
	    <span class="n">kfree</span><span class="p">(</span><span class="n">ac_ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ac_ptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__drain_alien_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">array_cache</span> <span class="o">*</span><span class="n">ac</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_list3</span> <span class="o">*</span><span class="n">rl3</span> <span class="o">=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rl3</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Stuff objects into the remote nodes shared array first.</span>
<span class="cm">		 * That way we could avoid the overhead of putting the objects</span>
<span class="cm">		 * into the free lists and getting them back later.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rl3</span><span class="o">-&gt;</span><span class="n">shared</span><span class="p">)</span>
			<span class="n">transfer_objects</span><span class="p">(</span><span class="n">rl3</span><span class="o">-&gt;</span><span class="n">shared</span><span class="p">,</span> <span class="n">ac</span><span class="p">,</span> <span class="n">ac</span><span class="o">-&gt;</span><span class="n">limit</span><span class="p">);</span>

		<span class="n">free_block</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">ac</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rl3</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called from cache_reap() to regularly drain alien caches round robin.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">reap_alien</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kmem_list3</span> <span class="o">*</span><span class="n">l3</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">node</span> <span class="o">=</span> <span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">slab_reap_node</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">alien</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">array_cache</span> <span class="o">*</span><span class="n">ac</span> <span class="o">=</span> <span class="n">l3</span><span class="o">-&gt;</span><span class="n">alien</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ac</span> <span class="o">&amp;&amp;</span> <span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span> <span class="o">&amp;&amp;</span> <span class="n">spin_trylock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">__drain_alien_cache</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">ac</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">drain_alien_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">array_cache</span> <span class="o">**</span><span class="n">alien</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">array_cache</span> <span class="o">*</span><span class="n">ac</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ac</span> <span class="o">=</span> <span class="n">alien</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ac</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">__drain_alien_cache</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">ac</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cache_free_alien</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">objp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">slab</span> <span class="o">*</span><span class="n">slabp</span> <span class="o">=</span> <span class="n">virt_to_slab</span><span class="p">(</span><span class="n">objp</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">nodeid</span> <span class="o">=</span> <span class="n">slabp</span><span class="o">-&gt;</span><span class="n">nodeid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_list3</span> <span class="o">*</span><span class="n">l3</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">array_cache</span> <span class="o">*</span><span class="n">alien</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>

	<span class="n">node</span> <span class="o">=</span> <span class="n">numa_mem_id</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure we are not freeing a object from another node to the array</span>
<span class="cm">	 * cache on this cpu.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">slabp</span><span class="o">-&gt;</span><span class="n">nodeid</span> <span class="o">==</span> <span class="n">node</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">l3</span> <span class="o">=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>
	<span class="n">STATS_INC_NODEFREES</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">alien</span> <span class="o">&amp;&amp;</span> <span class="n">l3</span><span class="o">-&gt;</span><span class="n">alien</span><span class="p">[</span><span class="n">nodeid</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">alien</span> <span class="o">=</span> <span class="n">l3</span><span class="o">-&gt;</span><span class="n">alien</span><span class="p">[</span><span class="n">nodeid</span><span class="p">];</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">alien</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">alien</span><span class="o">-&gt;</span><span class="n">avail</span> <span class="o">==</span> <span class="n">alien</span><span class="o">-&gt;</span><span class="n">limit</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">STATS_INC_ACOVERFLOW</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
			<span class="n">__drain_alien_cache</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">alien</span><span class="p">,</span> <span class="n">nodeid</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">alien</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">[</span><span class="n">alien</span><span class="o">-&gt;</span><span class="n">avail</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">objp</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">alien</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">nodeid</span><span class="p">])</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
		<span class="n">free_block</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">objp</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nodeid</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">nodeid</span><span class="p">])</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Allocates and initializes nodelists for a node on each slab cache, used for</span>
<span class="cm"> * either memory or cpu hotplug.  If memory is being hot-added, the kmem_list3</span>
<span class="cm"> * will be allocated off-node since memory is not yet online for the new node.</span>
<span class="cm"> * When hotplugging memory or a cpu, existing nodelists are not replaced if</span>
<span class="cm"> * already in use.</span>
<span class="cm"> *</span>
<span class="cm"> * Must hold cache_chain_mutex.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_cache_nodelists_node</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_list3</span> <span class="o">*</span><span class="n">l3</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">memsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_list3</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cache_chain</span><span class="p">,</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set up the size64 kmemlist for cpu before we can</span>
<span class="cm">		 * begin anything. Make sure some other cpu on this</span>
<span class="cm">		 * node has not already allocated this</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">l3</span> <span class="o">=</span> <span class="n">kmalloc_node</span><span class="p">(</span><span class="n">memsize</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">l3</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="n">kmem_list3_init</span><span class="p">(</span><span class="n">l3</span><span class="p">);</span>
			<span class="n">l3</span><span class="o">-&gt;</span><span class="n">next_reap</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">REAPTIMEOUT_LIST3</span> <span class="o">+</span>
			    <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cachep</span><span class="p">)</span> <span class="o">%</span> <span class="n">REAPTIMEOUT_LIST3</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * The l3s don&#39;t come and go as CPUs come and</span>
<span class="cm">			 * go.  cache_chain_mutex is sufficient</span>
<span class="cm">			 * protection here.</span>
<span class="cm">			 */</span>
			<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">l3</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
		<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">free_limit</span> <span class="o">=</span>
			<span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">nr_cpus_node</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="o">*</span>
			<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">batchcount</span> <span class="o">+</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">cpuup_canceled</span><span class="p">(</span><span class="kt">long</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_list3</span> <span class="o">*</span><span class="n">l3</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span> <span class="o">=</span> <span class="n">cpu_to_mem</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span> <span class="o">=</span> <span class="n">cpumask_of_node</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cache_chain</span><span class="p">,</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">array_cache</span> <span class="o">*</span><span class="n">nc</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">array_cache</span> <span class="o">*</span><span class="n">shared</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">array_cache</span> <span class="o">**</span><span class="n">alien</span><span class="p">;</span>

		<span class="cm">/* cpu is dead; no one can alloc from it. */</span>
		<span class="n">nc</span> <span class="o">=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
		<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">l3</span> <span class="o">=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">l3</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">free_array_cache</span><span class="p">;</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>

		<span class="cm">/* Free limit for this kmem_list3 */</span>
		<span class="n">l3</span><span class="o">-&gt;</span><span class="n">free_limit</span> <span class="o">-=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">batchcount</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nc</span><span class="p">)</span>
			<span class="n">free_block</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">nc</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="n">nc</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">free_array_cache</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">shared</span> <span class="o">=</span> <span class="n">l3</span><span class="o">-&gt;</span><span class="n">shared</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">shared</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">free_block</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">shared</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span>
				   <span class="n">shared</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
			<span class="n">l3</span><span class="o">-&gt;</span><span class="n">shared</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">alien</span> <span class="o">=</span> <span class="n">l3</span><span class="o">-&gt;</span><span class="n">alien</span><span class="p">;</span>
		<span class="n">l3</span><span class="o">-&gt;</span><span class="n">alien</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>

		<span class="n">kfree</span><span class="p">(</span><span class="n">shared</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">alien</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">drain_alien_cache</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">alien</span><span class="p">);</span>
			<span class="n">free_alien_cache</span><span class="p">(</span><span class="n">alien</span><span class="p">);</span>
		<span class="p">}</span>
<span class="nl">free_array_cache:</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">nc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * In the previous loop, all the objects were freed to</span>
<span class="cm">	 * the respective cache&#39;s slabs,  now we can go ahead and</span>
<span class="cm">	 * shrink each nodelist to its limit.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cache_chain</span><span class="p">,</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">l3</span> <span class="o">=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">l3</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">drain_freelist</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">l3</span><span class="p">,</span> <span class="n">l3</span><span class="o">-&gt;</span><span class="n">free_objects</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">cpuup_prepare</span><span class="p">(</span><span class="kt">long</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_list3</span> <span class="o">*</span><span class="n">l3</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span> <span class="o">=</span> <span class="n">cpu_to_mem</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to do this right in the beginning since</span>
<span class="cm">	 * alloc_arraycache&#39;s are going to use this list.</span>
<span class="cm">	 * kmalloc_node allows us to add the slab to the right</span>
<span class="cm">	 * kmem_list3 and not this cpu&#39;s kmem_list3</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">init_cache_nodelists_node</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now we can go ahead with allocating the shared arrays and</span>
<span class="cm">	 * array caches</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cache_chain</span><span class="p">,</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">array_cache</span> <span class="o">*</span><span class="n">nc</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">array_cache</span> <span class="o">*</span><span class="n">shared</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">array_cache</span> <span class="o">**</span><span class="n">alien</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">nc</span> <span class="o">=</span> <span class="n">alloc_arraycache</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">limit</span><span class="p">,</span>
					<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">batchcount</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">shared</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">shared</span> <span class="o">=</span> <span class="n">alloc_arraycache</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
				<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">shared</span> <span class="o">*</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">batchcount</span><span class="p">,</span>
				<span class="mh">0xbaadf00d</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shared</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">nc</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">use_alien_caches</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">alien</span> <span class="o">=</span> <span class="n">alloc_alien_cache</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">limit</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alien</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">shared</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">nc</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">nc</span><span class="p">;</span>
		<span class="n">l3</span> <span class="o">=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">l3</span><span class="p">);</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">shared</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We are serialised from CPU_DEAD or</span>
<span class="cm">			 * CPU_UP_CANCELLED by the cpucontrol lock</span>
<span class="cm">			 */</span>
			<span class="n">l3</span><span class="o">-&gt;</span><span class="n">shared</span> <span class="o">=</span> <span class="n">shared</span><span class="p">;</span>
			<span class="n">shared</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#ifdef CONFIG_NUMA</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">alien</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">l3</span><span class="o">-&gt;</span><span class="n">alien</span> <span class="o">=</span> <span class="n">alien</span><span class="p">;</span>
			<span class="n">alien</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">shared</span><span class="p">);</span>
		<span class="n">free_alien_cache</span><span class="p">(</span><span class="n">alien</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_DEBUG_OBJECTS</span><span class="p">)</span>
			<span class="n">slab_set_debugobj_lock_classes_node</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">init_node_lock_keys</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">bad:</span>
	<span class="n">cpuup_canceled</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">cpuup_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nfb</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">cpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">hcpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_UP_PREPARE</span>:
	<span class="k">case</span> <span class="n">CPU_UP_PREPARE_FROZEN</span>:
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_chain_mutex</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">cpuup_prepare</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_chain_mutex</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CPU_ONLINE</span>:
	<span class="k">case</span> <span class="n">CPU_ONLINE_FROZEN</span>:
		<span class="n">start_cpu_timer</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
  	<span class="k">case</span> <span class="n">CPU_DOWN_PREPARE</span>:
  	<span class="k">case</span> <span class="n">CPU_DOWN_PREPARE_FROZEN</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Shutdown cache reaper. Note that the cache_chain_mutex is</span>
<span class="cm">		 * held so that if cache_reap() is invoked it cannot do</span>
<span class="cm">		 * anything expensive but will only modify reap_work</span>
<span class="cm">		 * and reschedule the timer.</span>
<span class="cm">		*/</span>
		<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">slab_reap_work</span><span class="p">,</span> <span class="n">cpu</span><span class="p">));</span>
		<span class="cm">/* Now the cache_reaper is guaranteed to be not running. */</span>
		<span class="n">per_cpu</span><span class="p">(</span><span class="n">slab_reap_work</span><span class="p">,</span> <span class="n">cpu</span><span class="p">).</span><span class="n">work</span><span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  		<span class="k">break</span><span class="p">;</span>
  	<span class="k">case</span> <span class="n">CPU_DOWN_FAILED</span>:
  	<span class="k">case</span> <span class="n">CPU_DOWN_FAILED_FROZEN</span>:
		<span class="n">start_cpu_timer</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
  		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CPU_DEAD</span>:
	<span class="k">case</span> <span class="n">CPU_DEAD_FROZEN</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Even if all the cpus of a node are down, we don&#39;t free the</span>
<span class="cm">		 * kmem_list3 of any cache. This to avoid a race between</span>
<span class="cm">		 * cpu_down, and a kmalloc allocation from another cpu for</span>
<span class="cm">		 * memory from the node of the cpu going down.  The list3</span>
<span class="cm">		 * structure is usually allocated from kmem_cache_create() and</span>
<span class="cm">		 * gets destroyed at kmem_cache_destroy().</span>
<span class="cm">		 */</span>
		<span class="cm">/* fall through */</span>
<span class="cp">#endif</span>
	<span class="k">case</span> <span class="n">CPU_UP_CANCELED</span>:
	<span class="k">case</span> <span class="n">CPU_UP_CANCELED_FROZEN</span>:
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_chain_mutex</span><span class="p">);</span>
		<span class="n">cpuup_canceled</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_chain_mutex</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">notifier_from_errno</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">__cpuinitdata</span> <span class="n">cpucache_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">cpuup_callback</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">};</span>

<span class="cp">#if defined(CONFIG_NUMA) &amp;&amp; defined(CONFIG_MEMORY_HOTPLUG)</span>
<span class="cm">/*</span>
<span class="cm"> * Drains freelist for a node on each slab cache, used for memory hot-remove.</span>
<span class="cm"> * Returns -EBUSY if all objects cannot be drained so that the node is not</span>
<span class="cm"> * removed.</span>
<span class="cm"> *</span>
<span class="cm"> * Must hold cache_chain_mutex.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__meminit</span> <span class="nf">drain_cache_nodelists_node</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cache_chain</span><span class="p">,</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kmem_list3</span> <span class="o">*</span><span class="n">l3</span><span class="p">;</span>

		<span class="n">l3</span> <span class="o">=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">l3</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">drain_freelist</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">l3</span><span class="p">,</span> <span class="n">l3</span><span class="o">-&gt;</span><span class="n">free_objects</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_full</span><span class="p">)</span> <span class="o">||</span>
		    <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_partial</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__meminit</span> <span class="nf">slab_memory_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">memory_notify</span> <span class="o">*</span><span class="n">mnb</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nid</span><span class="p">;</span>

	<span class="n">nid</span> <span class="o">=</span> <span class="n">mnb</span><span class="o">-&gt;</span><span class="n">status_change_nid</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nid</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MEM_GOING_ONLINE</span>:
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_chain_mutex</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">init_cache_nodelists_node</span><span class="p">(</span><span class="n">nid</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_chain_mutex</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MEM_GOING_OFFLINE</span>:
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_chain_mutex</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">drain_cache_nodelists_node</span><span class="p">(</span><span class="n">nid</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_chain_mutex</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MEM_ONLINE</span>:
	<span class="k">case</span> <span class="n">MEM_OFFLINE</span>:
	<span class="k">case</span> <span class="n">MEM_CANCEL_ONLINE</span>:
	<span class="k">case</span> <span class="n">MEM_CANCEL_OFFLINE</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">notifier_from_errno</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_NUMA &amp;&amp; CONFIG_MEMORY_HOTPLUG */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * swap the static kmem_list3 with kmalloced memory</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">init_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kmem_list3</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">nodeid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_list3</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

	<span class="n">ptr</span> <span class="o">=</span> <span class="n">kmalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_list3</span><span class="p">),</span> <span class="n">GFP_NOWAIT</span><span class="p">,</span> <span class="n">nodeid</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">ptr</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">list</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_list3</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * Do not assume that spinlocks can be initialized via memcpy:</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>

	<span class="n">MAKE_ALL_LISTS</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">nodeid</span><span class="p">);</span>
	<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">nodeid</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * For setting up all the kmem_list3s for cache whose buffer_size is same as</span>
<span class="cm"> * size of kmem_list3.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">set_up_list3s</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>

	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">initkmem_list3</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="n">node</span><span class="p">];</span>
		<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next_reap</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span>
		    <span class="n">REAPTIMEOUT_LIST3</span> <span class="o">+</span>
		    <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cachep</span><span class="p">)</span> <span class="o">%</span> <span class="n">REAPTIMEOUT_LIST3</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialisation.  Called after the page allocator have been initialised and</span>
<span class="cm"> * before smp_init().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">kmem_cache_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">left_over</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cache_sizes</span> <span class="o">*</span><span class="n">sizes</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cache_names</span> <span class="o">*</span><span class="n">names</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">order</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num_possible_nodes</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">use_alien_caches</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_INIT_LISTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmem_list3_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">initkmem_list3</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_NUMNODES</span><span class="p">)</span>
			<span class="n">cache_cache</span><span class="p">.</span><span class="n">nodelists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">set_up_list3s</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_cache</span><span class="p">,</span> <span class="n">CACHE_CACHE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fragmentation resistance on low memory - only use bigger</span>
<span class="cm">	 * page orders on machines with more than 32MB of memory if</span>
<span class="cm">	 * not overridden on the command line.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slab_max_order_set</span> <span class="o">&amp;&amp;</span> <span class="n">totalram_pages</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">32</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span>
		<span class="n">slab_max_order</span> <span class="o">=</span> <span class="n">SLAB_MAX_ORDER_HI</span><span class="p">;</span>

	<span class="cm">/* Bootstrap is tricky, because several objects are allocated</span>
<span class="cm">	 * from caches that do not exist yet:</span>
<span class="cm">	 * 1) initialize the cache_cache cache: it contains the struct</span>
<span class="cm">	 *    kmem_cache structures of all caches, except cache_cache itself:</span>
<span class="cm">	 *    cache_cache is statically allocated.</span>
<span class="cm">	 *    Initially an __init data area is used for the head array and the</span>
<span class="cm">	 *    kmem_list3 structures, it&#39;s replaced with a kmalloc allocated</span>
<span class="cm">	 *    array at the end of the bootstrap.</span>
<span class="cm">	 * 2) Create the first kmalloc cache.</span>
<span class="cm">	 *    The struct kmem_cache for the new cache is allocated normally.</span>
<span class="cm">	 *    An __init data area is used for the head array.</span>
<span class="cm">	 * 3) Create the remaining kmalloc caches, with minimally sized</span>
<span class="cm">	 *    head arrays.</span>
<span class="cm">	 * 4) Replace the __init data head arrays for cache_cache and the first</span>
<span class="cm">	 *    kmalloc cache with kmalloc allocated arrays.</span>
<span class="cm">	 * 5) Replace the __init data for kmem_list3 for cache_cache and</span>
<span class="cm">	 *    the other cache&#39;s with kmalloc allocated memory.</span>
<span class="cm">	 * 6) Resize the head arrays of the kmalloc caches to their final sizes.</span>
<span class="cm">	 */</span>

	<span class="n">node</span> <span class="o">=</span> <span class="n">numa_mem_id</span><span class="p">();</span>

	<span class="cm">/* 1) create the cache_cache */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_chain</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_cache</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cache_chain</span><span class="p">);</span>
	<span class="n">cache_cache</span><span class="p">.</span><span class="n">colour_off</span> <span class="o">=</span> <span class="n">cache_line_size</span><span class="p">();</span>
	<span class="n">cache_cache</span><span class="p">.</span><span class="n">array</span><span class="p">[</span><span class="n">smp_processor_id</span><span class="p">()]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">initarray_cache</span><span class="p">.</span><span class="n">cache</span><span class="p">;</span>
	<span class="n">cache_cache</span><span class="p">.</span><span class="n">nodelists</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">initkmem_list3</span><span class="p">[</span><span class="n">CACHE_CACHE</span> <span class="o">+</span> <span class="n">node</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * struct kmem_cache size depends on nr_node_ids &amp; nr_cpu_ids</span>
<span class="cm">	 */</span>
	<span class="n">cache_cache</span><span class="p">.</span><span class="n">buffer_size</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span><span class="p">,</span> <span class="n">array</span><span class="p">[</span><span class="n">nr_cpu_ids</span><span class="p">])</span> <span class="o">+</span>
				  <span class="n">nr_node_ids</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_list3</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#if DEBUG</span>
	<span class="n">cache_cache</span><span class="p">.</span><span class="n">obj_size</span> <span class="o">=</span> <span class="n">cache_cache</span><span class="p">.</span><span class="n">buffer_size</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">cache_cache</span><span class="p">.</span><span class="n">buffer_size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">cache_cache</span><span class="p">.</span><span class="n">buffer_size</span><span class="p">,</span>
					<span class="n">cache_line_size</span><span class="p">());</span>
	<span class="n">cache_cache</span><span class="p">.</span><span class="n">reciprocal_buffer_size</span> <span class="o">=</span>
		<span class="n">reciprocal_value</span><span class="p">(</span><span class="n">cache_cache</span><span class="p">.</span><span class="n">buffer_size</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">order</span> <span class="o">&lt;</span> <span class="n">MAX_ORDER</span><span class="p">;</span> <span class="n">order</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cache_estimate</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">cache_cache</span><span class="p">.</span><span class="n">buffer_size</span><span class="p">,</span>
			<span class="n">cache_line_size</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">left_over</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cache_cache</span><span class="p">.</span><span class="n">num</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cache_cache</span><span class="p">.</span><span class="n">num</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cache_cache</span><span class="p">.</span><span class="n">num</span><span class="p">);</span>
	<span class="n">cache_cache</span><span class="p">.</span><span class="n">gfporder</span> <span class="o">=</span> <span class="n">order</span><span class="p">;</span>
	<span class="n">cache_cache</span><span class="p">.</span><span class="n">colour</span> <span class="o">=</span> <span class="n">left_over</span> <span class="o">/</span> <span class="n">cache_cache</span><span class="p">.</span><span class="n">colour_off</span><span class="p">;</span>
	<span class="n">cache_cache</span><span class="p">.</span><span class="n">slab_size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">cache_cache</span><span class="p">.</span><span class="n">num</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">kmem_bufctl_t</span><span class="p">)</span> <span class="o">+</span>
				      <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">slab</span><span class="p">),</span> <span class="n">cache_line_size</span><span class="p">());</span>

	<span class="cm">/* 2+3) create the kmalloc caches */</span>
	<span class="n">sizes</span> <span class="o">=</span> <span class="n">malloc_sizes</span><span class="p">;</span>
	<span class="n">names</span> <span class="o">=</span> <span class="n">cache_names</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize the caches that provide memory for the array cache and the</span>
<span class="cm">	 * kmem_list3 structures first.  Without this, further allocations will</span>
<span class="cm">	 * bug.</span>
<span class="cm">	 */</span>

	<span class="n">sizes</span><span class="p">[</span><span class="n">INDEX_AC</span><span class="p">].</span><span class="n">cs_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">INDEX_AC</span><span class="p">].</span><span class="n">name</span><span class="p">,</span>
					<span class="n">sizes</span><span class="p">[</span><span class="n">INDEX_AC</span><span class="p">].</span><span class="n">cs_size</span><span class="p">,</span>
					<span class="n">ARCH_KMALLOC_MINALIGN</span><span class="p">,</span>
					<span class="n">ARCH_KMALLOC_FLAGS</span><span class="o">|</span><span class="n">SLAB_PANIC</span><span class="p">,</span>
					<span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">INDEX_AC</span> <span class="o">!=</span> <span class="n">INDEX_L3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sizes</span><span class="p">[</span><span class="n">INDEX_L3</span><span class="p">].</span><span class="n">cs_cachep</span> <span class="o">=</span>
			<span class="n">kmem_cache_create</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">INDEX_L3</span><span class="p">].</span><span class="n">name</span><span class="p">,</span>
				<span class="n">sizes</span><span class="p">[</span><span class="n">INDEX_L3</span><span class="p">].</span><span class="n">cs_size</span><span class="p">,</span>
				<span class="n">ARCH_KMALLOC_MINALIGN</span><span class="p">,</span>
				<span class="n">ARCH_KMALLOC_FLAGS</span><span class="o">|</span><span class="n">SLAB_PANIC</span><span class="p">,</span>
				<span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">slab_early_init</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">sizes</span><span class="o">-&gt;</span><span class="n">cs_size</span> <span class="o">!=</span> <span class="n">ULONG_MAX</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * For performance, all the general caches are L1 aligned.</span>
<span class="cm">		 * This should be particularly beneficial on SMP boxes, as it</span>
<span class="cm">		 * eliminates &quot;false sharing&quot;.</span>
<span class="cm">		 * Note for systems short on memory removing the alignment will</span>
<span class="cm">		 * allow tighter packing of the smaller caches.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sizes</span><span class="o">-&gt;</span><span class="n">cs_cachep</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sizes</span><span class="o">-&gt;</span><span class="n">cs_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="n">names</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
					<span class="n">sizes</span><span class="o">-&gt;</span><span class="n">cs_size</span><span class="p">,</span>
					<span class="n">ARCH_KMALLOC_MINALIGN</span><span class="p">,</span>
					<span class="n">ARCH_KMALLOC_FLAGS</span><span class="o">|</span><span class="n">SLAB_PANIC</span><span class="p">,</span>
					<span class="nb">NULL</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#ifdef CONFIG_ZONE_DMA</span>
		<span class="n">sizes</span><span class="o">-&gt;</span><span class="n">cs_dmacachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span>
					<span class="n">names</span><span class="o">-&gt;</span><span class="n">name_dma</span><span class="p">,</span>
					<span class="n">sizes</span><span class="o">-&gt;</span><span class="n">cs_size</span><span class="p">,</span>
					<span class="n">ARCH_KMALLOC_MINALIGN</span><span class="p">,</span>
					<span class="n">ARCH_KMALLOC_FLAGS</span><span class="o">|</span><span class="n">SLAB_CACHE_DMA</span><span class="o">|</span>
						<span class="n">SLAB_PANIC</span><span class="p">,</span>
					<span class="nb">NULL</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">sizes</span><span class="o">++</span><span class="p">;</span>
		<span class="n">names</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* 4) Replace the bootstrap head arrays */</span>
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">array_cache</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

		<span class="n">ptr</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">arraycache_init</span><span class="p">),</span> <span class="n">GFP_NOWAIT</span><span class="p">);</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cpu_cache_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_cache</span><span class="p">)</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">initarray_cache</span><span class="p">.</span><span class="n">cache</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">cpu_cache_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_cache</span><span class="p">),</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">arraycache_init</span><span class="p">));</span>
		<span class="cm">/*</span>
<span class="cm">		 * Do not assume that spinlocks can be initialized via memcpy:</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">cache_cache</span><span class="p">.</span><span class="n">array</span><span class="p">[</span><span class="n">smp_processor_id</span><span class="p">()]</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>

		<span class="n">ptr</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">arraycache_init</span><span class="p">),</span> <span class="n">GFP_NOWAIT</span><span class="p">);</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cpu_cache_get</span><span class="p">(</span><span class="n">malloc_sizes</span><span class="p">[</span><span class="n">INDEX_AC</span><span class="p">].</span><span class="n">cs_cachep</span><span class="p">)</span>
		       <span class="o">!=</span> <span class="o">&amp;</span><span class="n">initarray_generic</span><span class="p">.</span><span class="n">cache</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">cpu_cache_get</span><span class="p">(</span><span class="n">malloc_sizes</span><span class="p">[</span><span class="n">INDEX_AC</span><span class="p">].</span><span class="n">cs_cachep</span><span class="p">),</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">arraycache_init</span><span class="p">));</span>
		<span class="cm">/*</span>
<span class="cm">		 * Do not assume that spinlocks can be initialized via memcpy:</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">malloc_sizes</span><span class="p">[</span><span class="n">INDEX_AC</span><span class="p">].</span><span class="n">cs_cachep</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="n">smp_processor_id</span><span class="p">()]</span> <span class="o">=</span>
		    <span class="n">ptr</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* 5) Replace the bootstrap kmem_list3&#39;s */</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">nid</span><span class="p">;</span>

		<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">init_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_cache</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">initkmem_list3</span><span class="p">[</span><span class="n">CACHE_CACHE</span> <span class="o">+</span> <span class="n">nid</span><span class="p">],</span> <span class="n">nid</span><span class="p">);</span>

			<span class="n">init_list</span><span class="p">(</span><span class="n">malloc_sizes</span><span class="p">[</span><span class="n">INDEX_AC</span><span class="p">].</span><span class="n">cs_cachep</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">initkmem_list3</span><span class="p">[</span><span class="n">SIZE_AC</span> <span class="o">+</span> <span class="n">nid</span><span class="p">],</span> <span class="n">nid</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">INDEX_AC</span> <span class="o">!=</span> <span class="n">INDEX_L3</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">init_list</span><span class="p">(</span><span class="n">malloc_sizes</span><span class="p">[</span><span class="n">INDEX_L3</span><span class="p">].</span><span class="n">cs_cachep</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">initkmem_list3</span><span class="p">[</span><span class="n">SIZE_L3</span> <span class="o">+</span> <span class="n">nid</span><span class="p">],</span> <span class="n">nid</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">g_cpucache_up</span> <span class="o">=</span> <span class="n">EARLY</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">kmem_cache_init_late</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">;</span>

	<span class="n">g_cpucache_up</span> <span class="o">=</span> <span class="n">LATE</span><span class="p">;</span>

	<span class="cm">/* Annotate slab for lockdep -- annotate the malloc caches */</span>
	<span class="n">init_lock_keys</span><span class="p">();</span>

	<span class="cm">/* 6) resize the head arrays to their final sizes */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_chain_mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cache_chain</span><span class="p">,</span> <span class="n">next</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">enable_cpucache</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">GFP_NOWAIT</span><span class="p">))</span>
			<span class="n">BUG</span><span class="p">();</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_chain_mutex</span><span class="p">);</span>

	<span class="cm">/* Done! */</span>
	<span class="n">g_cpucache_up</span> <span class="o">=</span> <span class="n">FULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Register a cpu startup notifier callback that initializes</span>
<span class="cm">	 * cpu_cache_get for all new cpus</span>
<span class="cm">	 */</span>
	<span class="n">register_cpu_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpucache_notifier</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_NUMA</span>
	<span class="cm">/*</span>
<span class="cm">	 * Register a memory hotplug callback that initializes and frees</span>
<span class="cm">	 * nodelists.</span>
<span class="cm">	 */</span>
	<span class="n">hotplug_memory_notifier</span><span class="p">(</span><span class="n">slab_memory_callback</span><span class="p">,</span> <span class="n">SLAB_CALLBACK_PRI</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * The reap timers are started later, with a module init call: That part</span>
<span class="cm">	 * of the kernel is not yet operational.</span>
<span class="cm">	 */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">cpucache_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Register the timers that return unneeded pages to the page allocator</span>
<span class="cm">	 */</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">start_cpu_timer</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__initcall</span><span class="p">(</span><span class="n">cpucache_init</span><span class="p">);</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">void</span>
<span class="nf">slab_out_of_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfpflags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nodeid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_list3</span> <span class="o">*</span><span class="n">l3</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">slab</span> <span class="o">*</span><span class="n">slabp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		<span class="s">&quot;SLAB: Unable to allocate memory on node %d (gfp=0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">nodeid</span><span class="p">,</span> <span class="n">gfpflags</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;  cache: %s, object size: %d, order: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">buffer_size</span><span class="p">,</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">gfporder</span><span class="p">);</span>

	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">active_objs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">num_objs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">free_objects</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">active_slabs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">num_slabs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">l3</span> <span class="o">=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">l3</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">slabp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_full</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">active_objs</span> <span class="o">+=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">;</span>
			<span class="n">active_slabs</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">slabp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_partial</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">active_objs</span> <span class="o">+=</span> <span class="n">slabp</span><span class="o">-&gt;</span><span class="n">inuse</span><span class="p">;</span>
			<span class="n">active_slabs</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">slabp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_free</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
			<span class="n">num_slabs</span><span class="o">++</span><span class="p">;</span>

		<span class="n">free_objects</span> <span class="o">+=</span> <span class="n">l3</span><span class="o">-&gt;</span><span class="n">free_objects</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">num_slabs</span> <span class="o">+=</span> <span class="n">active_slabs</span><span class="p">;</span>
		<span class="n">num_objs</span> <span class="o">=</span> <span class="n">num_slabs</span> <span class="o">*</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;  node %d: slabs: %ld/%ld, objs: %ld/%ld, free: %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">node</span><span class="p">,</span> <span class="n">active_slabs</span><span class="p">,</span> <span class="n">num_slabs</span><span class="p">,</span> <span class="n">active_objs</span><span class="p">,</span> <span class="n">num_objs</span><span class="p">,</span>
			<span class="n">free_objects</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Interface to system&#39;s page allocator. No need to hold the cache-lock.</span>
<span class="cm"> *</span>
<span class="cm"> * If we requested dmaable memory, we will get it. Even if we</span>
<span class="cm"> * did not request dmaable memory, we might get it, but that</span>
<span class="cm"> * would be relatively rare and ignorable.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">kmem_getpages</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nodeid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_pages</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

<span class="cp">#ifndef CONFIG_MMU</span>
	<span class="cm">/*</span>
<span class="cm">	 * Nommu uses slab&#39;s for process anonymous memory allocations, and thus</span>
<span class="cm">	 * requires __GFP_COMP to properly refcount higher order allocations</span>
<span class="cm">	 */</span>
	<span class="n">flags</span> <span class="o">|=</span> <span class="n">__GFP_COMP</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">flags</span> <span class="o">|=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">gfpflags</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_RECLAIM_ACCOUNT</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">__GFP_RECLAIMABLE</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_pages_exact_node</span><span class="p">(</span><span class="n">nodeid</span><span class="p">,</span> <span class="n">flags</span> <span class="o">|</span> <span class="n">__GFP_NOTRACK</span><span class="p">,</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">gfporder</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">__GFP_NOWARN</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">printk_ratelimit</span><span class="p">())</span>
			<span class="n">slab_out_of_memory</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">nodeid</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nr_pages</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">gfporder</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_RECLAIM_ACCOUNT</span><span class="p">)</span>
		<span class="n">add_zone_page_state</span><span class="p">(</span><span class="n">page_zone</span><span class="p">(</span><span class="n">page</span><span class="p">),</span>
			<span class="n">NR_SLAB_RECLAIMABLE</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">add_zone_page_state</span><span class="p">(</span><span class="n">page_zone</span><span class="p">(</span><span class="n">page</span><span class="p">),</span>
			<span class="n">NR_SLAB_UNRECLAIMABLE</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">__SetPageSlab</span><span class="p">(</span><span class="n">page</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kmemcheck_enabled</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_NOTRACK</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kmemcheck_alloc_shadow</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">gfporder</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">nodeid</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">ctor</span><span class="p">)</span>
			<span class="n">kmemcheck_mark_uninitialized_pages</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">kmemcheck_mark_unallocated_pages</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Interface to system&#39;s page release.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">kmem_freepages</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">gfporder</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_freed</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">kmemcheck_free_shadow</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">gfporder</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_RECLAIM_ACCOUNT</span><span class="p">)</span>
		<span class="n">sub_zone_page_state</span><span class="p">(</span><span class="n">page_zone</span><span class="p">(</span><span class="n">page</span><span class="p">),</span>
				<span class="n">NR_SLAB_RECLAIMABLE</span><span class="p">,</span> <span class="n">nr_freed</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">sub_zone_page_state</span><span class="p">(</span><span class="n">page_zone</span><span class="p">(</span><span class="n">page</span><span class="p">),</span>
				<span class="n">NR_SLAB_UNRECLAIMABLE</span><span class="p">,</span> <span class="n">nr_freed</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageSlab</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
		<span class="n">__ClearPageSlab</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">reclaim_state</span><span class="p">)</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">reclaim_state</span><span class="o">-&gt;</span><span class="n">reclaimed_slab</span> <span class="o">+=</span> <span class="n">nr_freed</span><span class="p">;</span>
	<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">addr</span><span class="p">,</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">gfporder</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kmem_rcu_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">slab_rcu</span> <span class="o">*</span><span class="n">slab_rcu</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">slab_rcu</span> <span class="o">*</span><span class="p">)</span><span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span> <span class="o">=</span> <span class="n">slab_rcu</span><span class="o">-&gt;</span><span class="n">cachep</span><span class="p">;</span>

	<span class="n">kmem_freepages</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">slab_rcu</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">OFF_SLAB</span><span class="p">(</span><span class="n">cachep</span><span class="p">))</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">slabp_cache</span><span class="p">,</span> <span class="n">slab_rcu</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if DEBUG</span>

<span class="cp">#ifdef CONFIG_DEBUG_PAGEALLOC</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">store_stackinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">caller</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">obj_size</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">)[</span><span class="n">obj_offset</span><span class="p">(</span><span class="n">cachep</span><span class="p">)];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="o">*</span><span class="n">addr</span><span class="o">++</span> <span class="o">=</span> <span class="mh">0x12345678</span><span class="p">;</span>
	<span class="o">*</span><span class="n">addr</span><span class="o">++</span> <span class="o">=</span> <span class="n">caller</span><span class="p">;</span>
	<span class="o">*</span><span class="n">addr</span><span class="o">++</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="n">size</span> <span class="o">-=</span> <span class="mi">3</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">sptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">caller</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">svalue</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kstack_end</span><span class="p">(</span><span class="n">sptr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">svalue</span> <span class="o">=</span> <span class="o">*</span><span class="n">sptr</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">kernel_text_address</span><span class="p">(</span><span class="n">svalue</span><span class="p">))</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">addr</span><span class="o">++</span> <span class="o">=</span> <span class="n">svalue</span><span class="p">;</span>
				<span class="n">size</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">))</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

	<span class="p">}</span>
	<span class="o">*</span><span class="n">addr</span><span class="o">++</span> <span class="o">=</span> <span class="mh">0x87654321</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">poison_obj</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">obj_size</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">)[</span><span class="n">obj_offset</span><span class="p">(</span><span class="n">cachep</span><span class="p">)];</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">POISON_END</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dump_line</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bad_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%03x: &quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">POISON_FREE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="n">i</span><span class="p">];</span>
			<span class="n">bad_count</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">print_hex_dump</span><span class="p">(</span><span class="n">KERN_CONT</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span><span class="p">],</span> <span class="n">limit</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bad_count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">^=</span> <span class="n">POISON_FREE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">error</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">error</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Single bit error detected. Probably &quot;</span>
					<span class="s">&quot;bad RAM.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_X86</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Run memtest86+ or a similar memory &quot;</span>
					<span class="s">&quot;test tool.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#else</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Run a memory test tool.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#if DEBUG</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_objinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">objp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lines</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">realobj</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_RED_ZONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Redzone: 0x%llx/0x%llx.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="o">*</span><span class="n">dbg_redzone1</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">),</span>
			<span class="o">*</span><span class="n">dbg_redzone2</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_STORE_USER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Last user: [&lt;%p&gt;]&quot;</span><span class="p">,</span>
			<span class="o">*</span><span class="n">dbg_userword</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">));</span>
		<span class="n">print_symbol</span><span class="p">(</span><span class="s">&quot;(%s)&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">*</span><span class="n">dbg_userword</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">realobj</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">objp</span> <span class="o">+</span> <span class="n">obj_offset</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">obj_size</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="o">&amp;&amp;</span> <span class="n">lines</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">,</span> <span class="n">lines</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">limit</span><span class="p">;</span>
		<span class="n">limit</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">limit</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">)</span>
			<span class="n">limit</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">dump_line</span><span class="p">(</span><span class="n">realobj</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_poison_obj</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">objp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">realobj</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lines</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">realobj</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">objp</span> <span class="o">+</span> <span class="n">obj_offset</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">obj_size</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">POISON_FREE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">exp</span> <span class="o">=</span> <span class="n">POISON_END</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">realobj</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">exp</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">limit</span><span class="p">;</span>
			<span class="cm">/* Mismatch ! */</span>
			<span class="cm">/* Print header */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lines</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
					<span class="s">&quot;Slab corruption (%s): %s start=%p, len=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">print_tainted</span><span class="p">(),</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">realobj</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
				<span class="n">print_objinfo</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/* Hexdump the affected line */</span>
			<span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="mi">16</span><span class="p">)</span> <span class="o">*</span> <span class="mi">16</span><span class="p">;</span>
			<span class="n">limit</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">limit</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">)</span>
				<span class="n">limit</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">dump_line</span><span class="p">(</span><span class="n">realobj</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>
			<span class="n">i</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">;</span>
			<span class="n">lines</span><span class="o">++</span><span class="p">;</span>
			<span class="cm">/* Limit to 5 lines */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lines</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lines</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Print some data about the neighboring objects, if they</span>
<span class="cm">		 * exist:</span>
<span class="cm">		 */</span>
		<span class="k">struct</span> <span class="n">slab</span> <span class="o">*</span><span class="n">slabp</span> <span class="o">=</span> <span class="n">virt_to_slab</span><span class="p">(</span><span class="n">objp</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">objnr</span><span class="p">;</span>

		<span class="n">objnr</span> <span class="o">=</span> <span class="n">obj_to_index</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">slabp</span><span class="p">,</span> <span class="n">objp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">objnr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">objp</span> <span class="o">=</span> <span class="n">index_to_obj</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">slabp</span><span class="p">,</span> <span class="n">objnr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">realobj</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">objp</span> <span class="o">+</span> <span class="n">obj_offset</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Prev obj: start=%p, len=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">realobj</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
			<span class="n">print_objinfo</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">objnr</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">objp</span> <span class="o">=</span> <span class="n">index_to_obj</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">slabp</span><span class="p">,</span> <span class="n">objnr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">realobj</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">objp</span> <span class="o">+</span> <span class="n">obj_offset</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Next obj: start=%p, len=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">realobj</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
			<span class="n">print_objinfo</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#if DEBUG</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">slab_destroy_debugcheck</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">slab</span> <span class="o">*</span><span class="n">slabp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">objp</span> <span class="o">=</span> <span class="n">index_to_obj</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">slabp</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_POISON</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_DEBUG_PAGEALLOC</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">%</span> <span class="n">PAGE_SIZE</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
					<span class="n">OFF_SLAB</span><span class="p">(</span><span class="n">cachep</span><span class="p">))</span>
				<span class="n">kernel_map_pages</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">(</span><span class="n">objp</span><span class="p">),</span>
					<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">check_poison_obj</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">);</span>
<span class="cp">#else</span>
			<span class="n">check_poison_obj</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_RED_ZONE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">dbg_redzone1</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">)</span> <span class="o">!=</span> <span class="n">RED_INACTIVE</span><span class="p">)</span>
				<span class="n">slab_error</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="s">&quot;start of a freed object &quot;</span>
					   <span class="s">&quot;was overwritten&quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">dbg_redzone2</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">)</span> <span class="o">!=</span> <span class="n">RED_INACTIVE</span><span class="p">)</span>
				<span class="n">slab_error</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="s">&quot;end of a freed object &quot;</span>
					   <span class="s">&quot;was overwritten&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">slab_destroy_debugcheck</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">slab</span> <span class="o">*</span><span class="n">slabp</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * slab_destroy - destroy and release all objects in a slab</span>
<span class="cm"> * @cachep: cache pointer being destroyed</span>
<span class="cm"> * @slabp: slab pointer being destroyed</span>
<span class="cm"> *</span>
<span class="cm"> * Destroy all the objs in a slab, and release the mem back to the system.</span>
<span class="cm"> * Before calling the slab must have been unlinked from the cache.  The</span>
<span class="cm"> * cache-lock is not held/needed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">slab_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">slab</span> <span class="o">*</span><span class="n">slabp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">slabp</span><span class="o">-&gt;</span><span class="n">s_mem</span> <span class="o">-</span> <span class="n">slabp</span><span class="o">-&gt;</span><span class="n">colouroff</span><span class="p">;</span>

	<span class="n">slab_destroy_debugcheck</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">slabp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_DESTROY_BY_RCU</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">slab_rcu</span> <span class="o">*</span><span class="n">slab_rcu</span><span class="p">;</span>

		<span class="n">slab_rcu</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">slab_rcu</span> <span class="o">*</span><span class="p">)</span><span class="n">slabp</span><span class="p">;</span>
		<span class="n">slab_rcu</span><span class="o">-&gt;</span><span class="n">cachep</span> <span class="o">=</span> <span class="n">cachep</span><span class="p">;</span>
		<span class="n">slab_rcu</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
		<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slab_rcu</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">kmem_rcu_free</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">kmem_freepages</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">OFF_SLAB</span><span class="p">(</span><span class="n">cachep</span><span class="p">))</span>
			<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">slabp_cache</span><span class="p">,</span> <span class="n">slabp</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__kmem_cache_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_list3</span> <span class="o">*</span><span class="n">l3</span><span class="p">;</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
	    <span class="n">kfree</span><span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="cm">/* NUMA: free the list3 structures */</span>
	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">l3</span> <span class="o">=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">l3</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">shared</span><span class="p">);</span>
			<span class="n">free_alien_cache</span><span class="p">(</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">alien</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">l3</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_cache</span><span class="p">,</span> <span class="n">cachep</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * calculate_slab_order - calculate size (page order) of slabs</span>
<span class="cm"> * @cachep: pointer to the cache that is being created</span>
<span class="cm"> * @size: size of objects to be created in this cache.</span>
<span class="cm"> * @align: required alignment for the objects.</span>
<span class="cm"> * @flags: slab allocation flags</span>
<span class="cm"> *</span>
<span class="cm"> * Also calculates the number of objects per slab.</span>
<span class="cm"> *</span>
<span class="cm"> * This could be made much more intelligent.  For now, try to avoid using</span>
<span class="cm"> * high order pages for slabs.  When the gfp() functions are more friendly</span>
<span class="cm"> * towards high-order requests, this should be changed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">calculate_slab_order</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">align</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offslab_limit</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">left_over</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">gfporder</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">gfporder</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">gfporder</span> <span class="o">&lt;=</span> <span class="n">KMALLOC_MAX_ORDER</span><span class="p">;</span> <span class="n">gfporder</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
		<span class="kt">size_t</span> <span class="n">remainder</span><span class="p">;</span>

		<span class="n">cache_estimate</span><span class="p">(</span><span class="n">gfporder</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">remainder</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">num</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CFLGS_OFF_SLAB</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Max number of objs-per-slab for caches which</span>
<span class="cm">			 * use off-slab slabs. Needed to avoid a possible</span>
<span class="cm">			 * looping condition in cache_grow().</span>
<span class="cm">			 */</span>
			<span class="n">offslab_limit</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">slab</span><span class="p">);</span>
			<span class="n">offslab_limit</span> <span class="o">/=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">kmem_bufctl_t</span><span class="p">);</span>

 			<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="n">offslab_limit</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Found something acceptable - save it away */</span>
		<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
		<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">gfporder</span> <span class="o">=</span> <span class="n">gfporder</span><span class="p">;</span>
		<span class="n">left_over</span> <span class="o">=</span> <span class="n">remainder</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * A VFS-reclaimable slab tends to have most allocations</span>
<span class="cm">		 * as GFP_NOFS and we really don&#39;t want to have to be allocating</span>
<span class="cm">		 * higher-order pages when we are unable to shrink dcache.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_RECLAIM_ACCOUNT</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Large number of objects is good, but very large slabs are</span>
<span class="cm">		 * currently bad for the gfp()s.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gfporder</span> <span class="o">&gt;=</span> <span class="n">slab_max_order</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Acceptable internal fragmentation?</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">left_over</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="n">gfporder</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">left_over</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init_refok</span> <span class="nf">setup_cpu_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">g_cpucache_up</span> <span class="o">==</span> <span class="n">FULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">enable_cpucache</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">g_cpucache_up</span> <span class="o">==</span> <span class="n">NONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Note: the first kmem_cache_create must create the cache</span>
<span class="cm">		 * that&#39;s used by kmalloc(24), otherwise the creation of</span>
<span class="cm">		 * further caches will BUG().</span>
<span class="cm">		 */</span>
		<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="n">smp_processor_id</span><span class="p">()]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">initarray_generic</span><span class="p">.</span><span class="n">cache</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If the cache that&#39;s used by kmalloc(sizeof(kmem_list3)) is</span>
<span class="cm">		 * the first cache, then we need to set up all its list3s,</span>
<span class="cm">		 * otherwise the creation of further caches will BUG().</span>
<span class="cm">		 */</span>
		<span class="n">set_up_list3s</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">SIZE_AC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">INDEX_AC</span> <span class="o">==</span> <span class="n">INDEX_L3</span><span class="p">)</span>
			<span class="n">g_cpucache_up</span> <span class="o">=</span> <span class="n">PARTIAL_L3</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">g_cpucache_up</span> <span class="o">=</span> <span class="n">PARTIAL_AC</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="n">smp_processor_id</span><span class="p">()]</span> <span class="o">=</span>
			<span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">arraycache_init</span><span class="p">),</span> <span class="n">gfp</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">g_cpucache_up</span> <span class="o">==</span> <span class="n">PARTIAL_AC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">set_up_list3s</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">SIZE_L3</span><span class="p">);</span>
			<span class="n">g_cpucache_up</span> <span class="o">=</span> <span class="n">PARTIAL_L3</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>
			<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span>
				    <span class="n">kmalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_list3</span><span class="p">),</span>
						<span class="n">gfp</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">node</span><span class="p">]);</span>
				<span class="n">kmem_list3_init</span><span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">node</span><span class="p">]);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">numa_mem_id</span><span class="p">()]</span><span class="o">-&gt;</span><span class="n">next_reap</span> <span class="o">=</span>
			<span class="n">jiffies</span> <span class="o">+</span> <span class="n">REAPTIMEOUT_LIST3</span> <span class="o">+</span>
			<span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cachep</span><span class="p">)</span> <span class="o">%</span> <span class="n">REAPTIMEOUT_LIST3</span><span class="p">;</span>

	<span class="n">cpu_cache_get</span><span class="p">(</span><span class="n">cachep</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">avail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cpu_cache_get</span><span class="p">(</span><span class="n">cachep</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">limit</span> <span class="o">=</span> <span class="n">BOOT_CPUCACHE_ENTRIES</span><span class="p">;</span>
	<span class="n">cpu_cache_get</span><span class="p">(</span><span class="n">cachep</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">batchcount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">cpu_cache_get</span><span class="p">(</span><span class="n">cachep</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">touched</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">batchcount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">limit</span> <span class="o">=</span> <span class="n">BOOT_CPUCACHE_ENTRIES</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * kmem_cache_create - Create a cache.</span>
<span class="cm"> * @name: A string which is used in /proc/slabinfo to identify this cache.</span>
<span class="cm"> * @size: The size of objects to be created in this cache.</span>
<span class="cm"> * @align: The required alignment for the objects.</span>
<span class="cm"> * @flags: SLAB flags</span>
<span class="cm"> * @ctor: A constructor for the objects.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a ptr to the cache on success, NULL on failure.</span>
<span class="cm"> * Cannot be called within a int, but can be interrupted.</span>
<span class="cm"> * The @ctor is run when new pages are allocated by the cache.</span>
<span class="cm"> *</span>
<span class="cm"> * @name must be valid until the cache is destroyed. This implies that</span>
<span class="cm"> * the module calling this has to destroy the cache before getting unloaded.</span>
<span class="cm"> *</span>
<span class="cm"> * The flags are</span>
<span class="cm"> *</span>
<span class="cm"> * %SLAB_POISON - Poison the slab with a known test pattern (a5a5a5a5)</span>
<span class="cm"> * to catch references to uninitialised memory.</span>
<span class="cm"> *</span>
<span class="cm"> * %SLAB_RED_ZONE - Insert `Red&#39; zones around the allocated memory to check</span>
<span class="cm"> * for buffer overruns.</span>
<span class="cm"> *</span>
<span class="cm"> * %SLAB_HWCACHE_ALIGN - Align the objects in this cache to a hardware</span>
<span class="cm"> * cacheline.  This can be beneficial if you&#39;re counting cycles as closely</span>
<span class="cm"> * as davem.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span>
<span class="nf">kmem_cache_create</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">align</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ctor</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">left_over</span><span class="p">,</span> <span class="n">slab_size</span><span class="p">,</span> <span class="n">ralign</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">pc</span><span class="p">;</span>
	<span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Sanity checks... these are all serious usage bugs.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">name</span> <span class="o">||</span> <span class="n">in_interrupt</span><span class="p">()</span> <span class="o">||</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">BYTES_PER_WORD</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">size</span> <span class="o">&gt;</span> <span class="n">KMALLOC_MAX_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Early error in slab %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				<span class="n">name</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We use cache_chain_mutex to ensure a consistent view of</span>
<span class="cm">	 * cpu_online_mask as well.  Please see cpuup_callback</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slab_is_available</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">get_online_cpus</span><span class="p">();</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_chain_mutex</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">pc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cache_chain</span><span class="p">,</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * This happens when the module gets unloaded and doesn&#39;t</span>
<span class="cm">		 * destroy its slab cache and no-one else reuses the vmalloc</span>
<span class="cm">		 * area of the module.  Print a warning.</span>
<span class="cm">		 */</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">probe_kernel_address</span><span class="p">(</span><span class="n">pc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
			       <span class="s">&quot;SLAB: cache with size %d has lost its name</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">pc</span><span class="o">-&gt;</span><span class="n">buffer_size</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">pc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
			       <span class="s">&quot;kmem_cache_create: duplicate cache %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
			<span class="n">dump_stack</span><span class="p">();</span>
			<span class="k">goto</span> <span class="n">oops</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="cp">#if DEBUG</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">strchr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">));</span>	<span class="cm">/* It confuses parsers */</span>
<span class="cp">#if FORCED_DEBUG</span>
	<span class="cm">/*</span>
<span class="cm">	 * Enable redzoning and last user accounting, except for caches with</span>
<span class="cm">	 * large objects, if the increased size would increase the object size</span>
<span class="cm">	 * above the next power of two: caches with object sizes just above a</span>
<span class="cm">	 * power of two have a significant amount of internal fragmentation.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">4096</span> <span class="o">||</span> <span class="n">fls</span><span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">fls</span><span class="p">(</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="n">REDZONE_ALIGN</span> <span class="o">+</span>
						<span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)))</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">SLAB_RED_ZONE</span> <span class="o">|</span> <span class="n">SLAB_STORE_USER</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_DESTROY_BY_RCU</span><span class="p">))</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">SLAB_POISON</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_DESTROY_BY_RCU</span><span class="p">)</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_POISON</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 * Always checks flags, a caller might be expecting debug support which</span>
<span class="cm">	 * isn&#39;t available.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CREATE_MASK</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check that size is in terms of words.  This is needed to avoid</span>
<span class="cm">	 * unaligned accesses for some archs when redzoning is used, and makes</span>
<span class="cm">	 * sure any on-slab bufctl&#39;s are also correctly aligned.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BYTES_PER_WORD</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="p">(</span><span class="n">BYTES_PER_WORD</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">size</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">BYTES_PER_WORD</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* calculate the final buffer alignment: */</span>

	<span class="cm">/* 1) arch recommendation: can be overridden for debug */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_HWCACHE_ALIGN</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Default alignment: as specified by the arch code.  Except if</span>
<span class="cm">		 * an object is really small, then squeeze multiple objects into</span>
<span class="cm">		 * one cacheline.</span>
<span class="cm">		 */</span>
		<span class="n">ralign</span> <span class="o">=</span> <span class="n">cache_line_size</span><span class="p">();</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">ralign</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">ralign</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ralign</span> <span class="o">=</span> <span class="n">BYTES_PER_WORD</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Redzoning and user store require word alignment or possibly larger.</span>
<span class="cm">	 * Note this will be overridden by architecture or caller mandated</span>
<span class="cm">	 * alignment if either is greater than BYTES_PER_WORD.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_STORE_USER</span><span class="p">)</span>
		<span class="n">ralign</span> <span class="o">=</span> <span class="n">BYTES_PER_WORD</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_RED_ZONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ralign</span> <span class="o">=</span> <span class="n">REDZONE_ALIGN</span><span class="p">;</span>
		<span class="cm">/* If redzoning, ensure that the second redzone is suitably</span>
<span class="cm">		 * aligned, by adjusting the object size accordingly. */</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="n">REDZONE_ALIGN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">REDZONE_ALIGN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* 2) arch mandated alignment */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ralign</span> <span class="o">&lt;</span> <span class="n">ARCH_SLAB_MINALIGN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ralign</span> <span class="o">=</span> <span class="n">ARCH_SLAB_MINALIGN</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* 3) caller mandated alignment */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ralign</span> <span class="o">&lt;</span> <span class="n">align</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ralign</span> <span class="o">=</span> <span class="n">align</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* disable debug if necessary */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ralign</span> <span class="o">&gt;</span> <span class="n">__alignof__</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">))</span>
		<span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">SLAB_RED_ZONE</span> <span class="o">|</span> <span class="n">SLAB_STORE_USER</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * 4) Store it.</span>
<span class="cm">	 */</span>
	<span class="n">align</span> <span class="o">=</span> <span class="n">ralign</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">slab_is_available</span><span class="p">())</span>
		<span class="n">gfp</span> <span class="o">=</span> <span class="n">GFP_KERNEL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">gfp</span> <span class="o">=</span> <span class="n">GFP_NOWAIT</span><span class="p">;</span>

	<span class="cm">/* Get cache&#39;s description obj. */</span>
	<span class="n">cachep</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_cache</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cachep</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">oops</span><span class="p">;</span>

	<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">kmem_list3</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="n">nr_cpu_ids</span><span class="p">];</span>
<span class="cp">#if DEBUG</span>
	<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">obj_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Both debugging options require word-alignment which is calculated</span>
<span class="cm">	 * into align above.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_RED_ZONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* add space for red zone words */</span>
		<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">obj_offset</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">);</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_STORE_USER</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* user store requires one word storage behind the end of</span>
<span class="cm">		 * the real object. But if the second red zone needs to be</span>
<span class="cm">		 * aligned to 64 bits, we must allow that much space.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_RED_ZONE</span><span class="p">)</span>
			<span class="n">size</span> <span class="o">+=</span> <span class="n">REDZONE_ALIGN</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">size</span> <span class="o">+=</span> <span class="n">BYTES_PER_WORD</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#if FORCED_DEBUG &amp;&amp; defined(CONFIG_DEBUG_PAGEALLOC)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">malloc_sizes</span><span class="p">[</span><span class="n">INDEX_L3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">cs_size</span>
	    <span class="o">&amp;&amp;</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">obj_size</span> <span class="o">&gt;</span> <span class="n">cache_line_size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">obj_offset</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">);</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Determine if the slab management is &#39;on&#39; or &#39;off&#39; slab.</span>
<span class="cm">	 * (bootstrapping cannot cope with offslab caches so don&#39;t do</span>
<span class="cm">	 * it too early on. Always use on-slab management when</span>
<span class="cm">	 * SLAB_NOLEAKTRACE to avoid recursive calls into kmemleak)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">slab_early_init</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_NOLEAKTRACE</span><span class="p">))</span>
		<span class="cm">/*</span>
<span class="cm">		 * Size is large, assume best to place the slab management obj</span>
<span class="cm">		 * off-slab (should allow better packing of objs).</span>
<span class="cm">		 */</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">CFLGS_OFF_SLAB</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">);</span>

	<span class="n">left_over</span> <span class="o">=</span> <span class="n">calculate_slab_order</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
		       <span class="s">&quot;kmem_cache_create: couldn&#39;t create cache %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_cache</span><span class="p">,</span> <span class="n">cachep</span><span class="p">);</span>
		<span class="n">cachep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">oops</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">slab_size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">kmem_bufctl_t</span><span class="p">)</span>
			  <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">slab</span><span class="p">),</span> <span class="n">align</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the slab has been placed off-slab, and we have enough space then</span>
<span class="cm">	 * move it on-slab. This is at the expense of any extra colouring.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CFLGS_OFF_SLAB</span> <span class="o">&amp;&amp;</span> <span class="n">left_over</span> <span class="o">&gt;=</span> <span class="n">slab_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CFLGS_OFF_SLAB</span><span class="p">;</span>
		<span class="n">left_over</span> <span class="o">-=</span> <span class="n">slab_size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CFLGS_OFF_SLAB</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* really off slab. No need for manual alignment */</span>
		<span class="n">slab_size</span> <span class="o">=</span>
		    <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">kmem_bufctl_t</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">slab</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PAGE_POISONING</span>
		<span class="cm">/* If we&#39;re going to use the generic kernel_map_pages()</span>
<span class="cm">		 * poisoning, then it&#39;s going to smash the contents of</span>
<span class="cm">		 * the redzone and userword anyhow, so switch them off.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">%</span> <span class="n">PAGE_SIZE</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_POISON</span><span class="p">)</span>
			<span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">SLAB_RED_ZONE</span> <span class="o">|</span> <span class="n">SLAB_STORE_USER</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">colour_off</span> <span class="o">=</span> <span class="n">cache_line_size</span><span class="p">();</span>
	<span class="cm">/* Offset must be a multiple of the alignment. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">colour_off</span> <span class="o">&lt;</span> <span class="n">align</span><span class="p">)</span>
		<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">colour_off</span> <span class="o">=</span> <span class="n">align</span><span class="p">;</span>
	<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">colour</span> <span class="o">=</span> <span class="n">left_over</span> <span class="o">/</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">colour_off</span><span class="p">;</span>
	<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">slab_size</span> <span class="o">=</span> <span class="n">slab_size</span><span class="p">;</span>
	<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">gfpflags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CONFIG_ZONE_DMA_FLAG</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_CACHE_DMA</span><span class="p">))</span>
		<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">gfpflags</span> <span class="o">|=</span> <span class="n">GFP_DMA</span><span class="p">;</span>
	<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">reciprocal_buffer_size</span> <span class="o">=</span> <span class="n">reciprocal_value</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CFLGS_OFF_SLAB</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">slabp_cache</span> <span class="o">=</span> <span class="n">kmem_find_general_cachep</span><span class="p">(</span><span class="n">slab_size</span><span class="p">,</span> <span class="mi">0u</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * This is a possibility for one of the malloc_sizes caches.</span>
<span class="cm">		 * But since we go off slab only for object size greater than</span>
<span class="cm">		 * PAGE_SIZE/8, and malloc_sizes gets created in ascending order,</span>
<span class="cm">		 * this should not happen at all.</span>
<span class="cm">		 * But leave a BUG_ON for some lucky dude.</span>
<span class="cm">		 */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ZERO_OR_NULL_PTR</span><span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">slabp_cache</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">ctor</span> <span class="o">=</span> <span class="n">ctor</span><span class="p">;</span>
	<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">setup_cpu_cache</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">gfp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__kmem_cache_destroy</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
		<span class="n">cachep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">oops</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_DEBUG_OBJECTS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Would deadlock through slab_destroy()-&gt;call_rcu()-&gt;</span>
<span class="cm">		 * debug_object_activate()-&gt;kmem_cache_alloc().</span>
<span class="cm">		 */</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_DESTROY_BY_RCU</span><span class="p">);</span>

		<span class="n">slab_set_debugobj_lock_classes</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* cache setup completed, link it into the list */</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cache_chain</span><span class="p">);</span>
<span class="nl">oops:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cachep</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_PANIC</span><span class="p">))</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;kmem_cache_create(): failed to create slab `%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slab_is_available</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_chain_mutex</span><span class="p">);</span>
		<span class="n">put_online_cpus</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">cachep</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kmem_cache_create</span><span class="p">);</span>

<span class="cp">#if DEBUG</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_irq_off</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">());</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_irq_on</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">irqs_disabled</span><span class="p">());</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_spinlock_acquired</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">check_irq_off</span><span class="p">();</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">numa_mem_id</span><span class="p">()]</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_spinlock_acquired_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">check_irq_off</span><span class="p">();</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cp">#else</span>
<span class="cp">#define check_irq_off()	do { } while(0)</span>
<span class="cp">#define check_irq_on()	do { } while(0)</span>
<span class="cp">#define check_spinlock_acquired(x) do { } while(0)</span>
<span class="cp">#define check_spinlock_acquired_node(x, y) do { } while(0)</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">drain_array</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kmem_list3</span> <span class="o">*</span><span class="n">l3</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">array_cache</span> <span class="o">*</span><span class="n">ac</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">force</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_drain</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">array_cache</span> <span class="o">*</span><span class="n">ac</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span> <span class="o">=</span> <span class="n">numa_mem_id</span><span class="p">();</span>

	<span class="n">check_irq_off</span><span class="p">();</span>
	<span class="n">ac</span> <span class="o">=</span> <span class="n">cpu_cache_get</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
	<span class="n">free_block</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">ac</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
	<span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">drain_cpu_caches</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_list3</span> <span class="o">*</span><span class="n">l3</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>

	<span class="n">on_each_cpu</span><span class="p">(</span><span class="n">do_drain</span><span class="p">,</span> <span class="n">cachep</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">check_irq_on</span><span class="p">();</span>
	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">l3</span> <span class="o">=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">l3</span> <span class="o">&amp;&amp;</span> <span class="n">l3</span><span class="o">-&gt;</span><span class="n">alien</span><span class="p">)</span>
			<span class="n">drain_alien_cache</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">l3</span><span class="o">-&gt;</span><span class="n">alien</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">l3</span> <span class="o">=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">l3</span><span class="p">)</span>
			<span class="n">drain_array</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">l3</span><span class="p">,</span> <span class="n">l3</span><span class="o">-&gt;</span><span class="n">shared</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove slabs from the list of free slabs.</span>
<span class="cm"> * Specify the number of slabs to drain in tofree.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the actual number of slabs released.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">drain_freelist</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">kmem_list3</span> <span class="o">*</span><span class="n">l3</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tofree</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_freed</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">slab</span> <span class="o">*</span><span class="n">slabp</span><span class="p">;</span>

	<span class="n">nr_freed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">nr_freed</span> <span class="o">&lt;</span> <span class="n">tofree</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_free</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_free</span><span class="p">.</span><span class="n">prev</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_free</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">slabp</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">slab</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
<span class="cp">#if DEBUG</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">slabp</span><span class="o">-&gt;</span><span class="n">inuse</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slabp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Safe to drop the lock. The slab is no longer linked</span>
<span class="cm">		 * to the cache.</span>
<span class="cm">		 */</span>
		<span class="n">l3</span><span class="o">-&gt;</span><span class="n">free_objects</span> <span class="o">-=</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
		<span class="n">slab_destroy</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">slabp</span><span class="p">);</span>
		<span class="n">nr_freed</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">nr_freed</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Called with cache_chain_mutex held to protect against cpu hotplug */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__cache_shrink</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_list3</span> <span class="o">*</span><span class="n">l3</span><span class="p">;</span>

	<span class="n">drain_cpu_caches</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>

	<span class="n">check_irq_on</span><span class="p">();</span>
	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">l3</span> <span class="o">=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">l3</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">drain_freelist</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">l3</span><span class="p">,</span> <span class="n">l3</span><span class="o">-&gt;</span><span class="n">free_objects</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">+=</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_full</span><span class="p">)</span> <span class="o">||</span>
			<span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_partial</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ret</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * kmem_cache_shrink - Shrink a cache.</span>
<span class="cm"> * @cachep: The cache to shrink.</span>
<span class="cm"> *</span>
<span class="cm"> * Releases as many slabs as possible for a cache.</span>
<span class="cm"> * To help debugging, a zero exit status indicates all slabs were released.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">kmem_cache_shrink</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cachep</span> <span class="o">||</span> <span class="n">in_interrupt</span><span class="p">());</span>

	<span class="n">get_online_cpus</span><span class="p">();</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_chain_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__cache_shrink</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_chain_mutex</span><span class="p">);</span>
	<span class="n">put_online_cpus</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kmem_cache_shrink</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * kmem_cache_destroy - delete a cache</span>
<span class="cm"> * @cachep: the cache to destroy</span>
<span class="cm"> *</span>
<span class="cm"> * Remove a &amp;struct kmem_cache object from the slab cache.</span>
<span class="cm"> *</span>
<span class="cm"> * It is expected this function will be called by a module when it is</span>
<span class="cm"> * unloaded.  This will remove the cache completely, and avoid a duplicate</span>
<span class="cm"> * cache being allocated each time a module is loaded and unloaded, if the</span>
<span class="cm"> * module doesn&#39;t have persistent in-kernel storage across loads and unloads.</span>
<span class="cm"> *</span>
<span class="cm"> * The cache must be empty before calling this function.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must guarantee that no one will allocate memory from the cache</span>
<span class="cm"> * during the kmem_cache_destroy().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">kmem_cache_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cachep</span> <span class="o">||</span> <span class="n">in_interrupt</span><span class="p">());</span>

	<span class="cm">/* Find the cache in the chain of caches. */</span>
	<span class="n">get_online_cpus</span><span class="p">();</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_chain_mutex</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * the chain is never empty, cache_cache is never destroyed</span>
<span class="cm">	 */</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__cache_shrink</span><span class="p">(</span><span class="n">cachep</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">slab_error</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="s">&quot;Can&#39;t free all objects&quot;</span><span class="p">);</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cache_chain</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_chain_mutex</span><span class="p">);</span>
		<span class="n">put_online_cpus</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_DESTROY_BY_RCU</span><span class="p">))</span>
		<span class="n">rcu_barrier</span><span class="p">();</span>

	<span class="n">__kmem_cache_destroy</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_chain_mutex</span><span class="p">);</span>
	<span class="n">put_online_cpus</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kmem_cache_destroy</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Get the memory for a slab management obj.</span>
<span class="cm"> * For a slab cache when the slab descriptor is off-slab, slab descriptors</span>
<span class="cm"> * always come from malloc_sizes caches.  The slab descriptor cannot</span>
<span class="cm"> * come from the same cache which is getting created because,</span>
<span class="cm"> * when we are searching for an appropriate cache for these</span>
<span class="cm"> * descriptors in kmem_cache_create, we search through the malloc_sizes array.</span>
<span class="cm"> * If we are creating a malloc_sizes cache here it would not be visible to</span>
<span class="cm"> * kmem_find_general_cachep till the initialization is complete.</span>
<span class="cm"> * Hence we cannot have slabp_cache same as the original cache.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">slab</span> <span class="o">*</span><span class="nf">alloc_slabmgmt</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">objp</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">colour_off</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">local_flags</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">nodeid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">slab</span> <span class="o">*</span><span class="n">slabp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">OFF_SLAB</span><span class="p">(</span><span class="n">cachep</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Slab management obj is off-slab. */</span>
		<span class="n">slabp</span> <span class="o">=</span> <span class="n">kmem_cache_alloc_node</span><span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">slabp_cache</span><span class="p">,</span>
					      <span class="n">local_flags</span><span class="p">,</span> <span class="n">nodeid</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the first object in the slab is leaked (it&#39;s allocated</span>
<span class="cm">		 * but no one has a reference to it), we want to make sure</span>
<span class="cm">		 * kmemleak does not treat the -&gt;s_mem pointer as a reference</span>
<span class="cm">		 * to the object. Otherwise we will not report the leak.</span>
<span class="cm">		 */</span>
		<span class="n">kmemleak_scan_area</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slabp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span><span class="p">),</span>
				   <span class="n">local_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slabp</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">slabp</span> <span class="o">=</span> <span class="n">objp</span> <span class="o">+</span> <span class="n">colour_off</span><span class="p">;</span>
		<span class="n">colour_off</span> <span class="o">+=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">slab_size</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">slabp</span><span class="o">-&gt;</span><span class="n">inuse</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">slabp</span><span class="o">-&gt;</span><span class="n">colouroff</span> <span class="o">=</span> <span class="n">colour_off</span><span class="p">;</span>
	<span class="n">slabp</span><span class="o">-&gt;</span><span class="n">s_mem</span> <span class="o">=</span> <span class="n">objp</span> <span class="o">+</span> <span class="n">colour_off</span><span class="p">;</span>
	<span class="n">slabp</span><span class="o">-&gt;</span><span class="n">nodeid</span> <span class="o">=</span> <span class="n">nodeid</span><span class="p">;</span>
	<span class="n">slabp</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">slabp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">kmem_bufctl_t</span> <span class="o">*</span><span class="nf">slab_bufctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">slab</span> <span class="o">*</span><span class="n">slabp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">kmem_bufctl_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">slabp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cache_init_objs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">slab</span> <span class="o">*</span><span class="n">slabp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">objp</span> <span class="o">=</span> <span class="n">index_to_obj</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">slabp</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="cp">#if DEBUG</span>
		<span class="cm">/* need to poison the objs? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_POISON</span><span class="p">)</span>
			<span class="n">poison_obj</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">,</span> <span class="n">POISON_FREE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_STORE_USER</span><span class="p">)</span>
			<span class="o">*</span><span class="n">dbg_userword</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_RED_ZONE</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">dbg_redzone1</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">)</span> <span class="o">=</span> <span class="n">RED_INACTIVE</span><span class="p">;</span>
			<span class="o">*</span><span class="n">dbg_redzone2</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">)</span> <span class="o">=</span> <span class="n">RED_INACTIVE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Constructors are not allowed to allocate memory from the same</span>
<span class="cm">		 * cache which they are a constructor for.  Otherwise, deadlock.</span>
<span class="cm">		 * They must also be threaded.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">ctor</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_POISON</span><span class="p">))</span>
			<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">ctor</span><span class="p">(</span><span class="n">objp</span> <span class="o">+</span> <span class="n">obj_offset</span><span class="p">(</span><span class="n">cachep</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_RED_ZONE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">dbg_redzone2</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">)</span> <span class="o">!=</span> <span class="n">RED_INACTIVE</span><span class="p">)</span>
				<span class="n">slab_error</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="s">&quot;constructor overwrote the&quot;</span>
					   <span class="s">&quot; end of an object&quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">dbg_redzone1</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">)</span> <span class="o">!=</span> <span class="n">RED_INACTIVE</span><span class="p">)</span>
				<span class="n">slab_error</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="s">&quot;constructor overwrote the&quot;</span>
					   <span class="s">&quot; start of an object&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">%</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			    <span class="n">OFF_SLAB</span><span class="p">(</span><span class="n">cachep</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_POISON</span><span class="p">)</span>
			<span class="n">kernel_map_pages</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">(</span><span class="n">objp</span><span class="p">),</span>
					 <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#else</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">ctor</span><span class="p">)</span>
			<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">ctor</span><span class="p">(</span><span class="n">objp</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">slab_bufctl</span><span class="p">(</span><span class="n">slabp</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">slab_bufctl</span><span class="p">(</span><span class="n">slabp</span><span class="p">)[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">BUFCTL_END</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kmem_flagcheck</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CONFIG_ZONE_DMA_FLAG</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">GFP_DMA</span><span class="p">)</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">gfpflags</span> <span class="o">&amp;</span> <span class="n">GFP_DMA</span><span class="p">));</span>
		<span class="k">else</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">gfpflags</span> <span class="o">&amp;</span> <span class="n">GFP_DMA</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">slab_get_obj</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">slab</span> <span class="o">*</span><span class="n">slabp</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">nodeid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">objp</span> <span class="o">=</span> <span class="n">index_to_obj</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">slabp</span><span class="p">,</span> <span class="n">slabp</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">);</span>
	<span class="n">kmem_bufctl_t</span> <span class="n">next</span><span class="p">;</span>

	<span class="n">slabp</span><span class="o">-&gt;</span><span class="n">inuse</span><span class="o">++</span><span class="p">;</span>
	<span class="n">next</span> <span class="o">=</span> <span class="n">slab_bufctl</span><span class="p">(</span><span class="n">slabp</span><span class="p">)[</span><span class="n">slabp</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">];</span>
<span class="cp">#if DEBUG</span>
	<span class="n">slab_bufctl</span><span class="p">(</span><span class="n">slabp</span><span class="p">)[</span><span class="n">slabp</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">]</span> <span class="o">=</span> <span class="n">BUFCTL_FREE</span><span class="p">;</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">slabp</span><span class="o">-&gt;</span><span class="n">nodeid</span> <span class="o">!=</span> <span class="n">nodeid</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">slabp</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">objp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">slab_put_obj</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">slab</span> <span class="o">*</span><span class="n">slabp</span><span class="p">,</span>
				<span class="kt">void</span> <span class="o">*</span><span class="n">objp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nodeid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">objnr</span> <span class="o">=</span> <span class="n">obj_to_index</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">slabp</span><span class="p">,</span> <span class="n">objp</span><span class="p">);</span>

<span class="cp">#if DEBUG</span>
	<span class="cm">/* Verify that the slab belongs to the intended node */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">slabp</span><span class="o">-&gt;</span><span class="n">nodeid</span> <span class="o">!=</span> <span class="n">nodeid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">slab_bufctl</span><span class="p">(</span><span class="n">slabp</span><span class="p">)[</span><span class="n">objnr</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">SLAB_LIMIT</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;slab: double free detected in cache &quot;</span>
				<span class="s">&quot;&#39;%s&#39;, objp %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">objp</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">slab_bufctl</span><span class="p">(</span><span class="n">slabp</span><span class="p">)[</span><span class="n">objnr</span><span class="p">]</span> <span class="o">=</span> <span class="n">slabp</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">;</span>
	<span class="n">slabp</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">=</span> <span class="n">objnr</span><span class="p">;</span>
	<span class="n">slabp</span><span class="o">-&gt;</span><span class="n">inuse</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Map pages beginning at addr to the given cache and slab. This is required</span>
<span class="cm"> * for the slab allocator to be able to lookup the cache and slab of a</span>
<span class="cm"> * virtual address for kfree, ksize, and slab debugging.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">slab_map_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">,</span> <span class="k">struct</span> <span class="n">slab</span> <span class="o">*</span><span class="n">slab</span><span class="p">,</span>
			   <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nr_pages</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>

	<span class="n">nr_pages</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">PageCompound</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span>
		<span class="n">nr_pages</span> <span class="o">&lt;&lt;=</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">gfporder</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">page_set_cache</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">cache</span><span class="p">);</span>
		<span class="n">page_set_slab</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">slab</span><span class="p">);</span>
		<span class="n">page</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">nr_pages</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Grow (by 1) the number of slabs within a cache.  This is called by</span>
<span class="cm"> * kmem_cache_alloc() when there are no active objs left in a cache.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cache_grow</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span>
		<span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nodeid</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">objp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">slab</span> <span class="o">*</span><span class="n">slabp</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">gfp_t</span> <span class="n">local_flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_list3</span> <span class="o">*</span><span class="n">l3</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Be lazy and only check for valid flags here,  keeping it out of the</span>
<span class="cm">	 * critical path in kmem_cache_alloc().</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">GFP_SLAB_BUG_MASK</span><span class="p">);</span>
	<span class="n">local_flags</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">GFP_CONSTRAINT_MASK</span><span class="o">|</span><span class="n">GFP_RECLAIM_MASK</span><span class="p">);</span>

	<span class="cm">/* Take the l3 list lock to change the colour_next on this node */</span>
	<span class="n">check_irq_off</span><span class="p">();</span>
	<span class="n">l3</span> <span class="o">=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">nodeid</span><span class="p">];</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>

	<span class="cm">/* Get colour for the slab, and cal the next value. */</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">l3</span><span class="o">-&gt;</span><span class="n">colour_next</span><span class="p">;</span>
	<span class="n">l3</span><span class="o">-&gt;</span><span class="n">colour_next</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">colour_next</span> <span class="o">&gt;=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">colour</span><span class="p">)</span>
		<span class="n">l3</span><span class="o">-&gt;</span><span class="n">colour_next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>

	<span class="n">offset</span> <span class="o">*=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">colour_off</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">local_flags</span> <span class="o">&amp;</span> <span class="n">__GFP_WAIT</span><span class="p">)</span>
		<span class="n">local_irq_enable</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * The test for missing atomic flag is performed here, rather than</span>
<span class="cm">	 * the more obvious place, simply to reduce the critical path length</span>
<span class="cm">	 * in kmem_cache_alloc(). If a caller is seriously mis-behaving they</span>
<span class="cm">	 * will eventually be caught here (where it matters).</span>
<span class="cm">	 */</span>
	<span class="n">kmem_flagcheck</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get mem for the objs.  Attempt to allocate a physical page from</span>
<span class="cm">	 * &#39;nodeid&#39;.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">objp</span><span class="p">)</span>
		<span class="n">objp</span> <span class="o">=</span> <span class="n">kmem_getpages</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">local_flags</span><span class="p">,</span> <span class="n">nodeid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">objp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>

	<span class="cm">/* Get slab management. */</span>
	<span class="n">slabp</span> <span class="o">=</span> <span class="n">alloc_slabmgmt</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
			<span class="n">local_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">GFP_CONSTRAINT_MASK</span><span class="p">,</span> <span class="n">nodeid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slabp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">opps1</span><span class="p">;</span>

	<span class="n">slab_map_pages</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">slabp</span><span class="p">,</span> <span class="n">objp</span><span class="p">);</span>

	<span class="n">cache_init_objs</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">slabp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">local_flags</span> <span class="o">&amp;</span> <span class="n">__GFP_WAIT</span><span class="p">)</span>
		<span class="n">local_irq_disable</span><span class="p">();</span>
	<span class="n">check_irq_off</span><span class="p">();</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>

	<span class="cm">/* Make slab active. */</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slabp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_free</span><span class="p">));</span>
	<span class="n">STATS_INC_GROWN</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
	<span class="n">l3</span><span class="o">-&gt;</span><span class="n">free_objects</span> <span class="o">+=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">opps1:</span>
	<span class="n">kmem_freepages</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">);</span>
<span class="nl">failed:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">local_flags</span> <span class="o">&amp;</span> <span class="n">__GFP_WAIT</span><span class="p">)</span>
		<span class="n">local_irq_disable</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if DEBUG</span>

<span class="cm">/*</span>
<span class="cm"> * Perform extra freeing checks:</span>
<span class="cm"> * - detect bad pointers.</span>
<span class="cm"> * - POISON/RED_ZONE checking</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">kfree_debugcheck</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">objp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">virt_addr_valid</span><span class="p">(</span><span class="n">objp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;kfree_debugcheck: out of range ptr %lxh.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">objp</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">verify_redzone_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">redzone1</span><span class="p">,</span> <span class="n">redzone2</span><span class="p">;</span>

	<span class="n">redzone1</span> <span class="o">=</span> <span class="o">*</span><span class="n">dbg_redzone1</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">obj</span><span class="p">);</span>
	<span class="n">redzone2</span> <span class="o">=</span> <span class="o">*</span><span class="n">dbg_redzone2</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">obj</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Redzone is ok.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">redzone1</span> <span class="o">==</span> <span class="n">RED_ACTIVE</span> <span class="o">&amp;&amp;</span> <span class="n">redzone2</span> <span class="o">==</span> <span class="n">RED_ACTIVE</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">redzone1</span> <span class="o">==</span> <span class="n">RED_INACTIVE</span> <span class="o">&amp;&amp;</span> <span class="n">redzone2</span> <span class="o">==</span> <span class="n">RED_INACTIVE</span><span class="p">)</span>
		<span class="n">slab_error</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="s">&quot;double free detected&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">slab_error</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="s">&quot;memory outside object was overwritten&quot;</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%p: redzone 1:0x%llx, redzone 2:0x%llx.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">obj</span><span class="p">,</span> <span class="n">redzone1</span><span class="p">,</span> <span class="n">redzone2</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">cache_free_debugcheck</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">objp</span><span class="p">,</span>
				   <span class="kt">void</span> <span class="o">*</span><span class="n">caller</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">objnr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">slab</span> <span class="o">*</span><span class="n">slabp</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">virt_to_cache</span><span class="p">(</span><span class="n">objp</span><span class="p">)</span> <span class="o">!=</span> <span class="n">cachep</span><span class="p">);</span>

	<span class="n">objp</span> <span class="o">-=</span> <span class="n">obj_offset</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
	<span class="n">kfree_debugcheck</span><span class="p">(</span><span class="n">objp</span><span class="p">);</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">virt_to_head_page</span><span class="p">(</span><span class="n">objp</span><span class="p">);</span>

	<span class="n">slabp</span> <span class="o">=</span> <span class="n">page_get_slab</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_RED_ZONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">verify_redzone_free</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">);</span>
		<span class="o">*</span><span class="n">dbg_redzone1</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">)</span> <span class="o">=</span> <span class="n">RED_INACTIVE</span><span class="p">;</span>
		<span class="o">*</span><span class="n">dbg_redzone2</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">)</span> <span class="o">=</span> <span class="n">RED_INACTIVE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_STORE_USER</span><span class="p">)</span>
		<span class="o">*</span><span class="n">dbg_userword</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">)</span> <span class="o">=</span> <span class="n">caller</span><span class="p">;</span>

	<span class="n">objnr</span> <span class="o">=</span> <span class="n">obj_to_index</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">slabp</span><span class="p">,</span> <span class="n">objp</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">objnr</span> <span class="o">&gt;=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">objp</span> <span class="o">!=</span> <span class="n">index_to_obj</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">slabp</span><span class="p">,</span> <span class="n">objnr</span><span class="p">));</span>

<span class="cp">#ifdef CONFIG_DEBUG_SLAB_LEAK</span>
	<span class="n">slab_bufctl</span><span class="p">(</span><span class="n">slabp</span><span class="p">)[</span><span class="n">objnr</span><span class="p">]</span> <span class="o">=</span> <span class="n">BUFCTL_FREE</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_POISON</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_DEBUG_PAGEALLOC</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">%</span> <span class="n">PAGE_SIZE</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">OFF_SLAB</span><span class="p">(</span><span class="n">cachep</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">store_stackinfo</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">caller</span><span class="p">);</span>
			<span class="n">kernel_map_pages</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">(</span><span class="n">objp</span><span class="p">),</span>
					 <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">poison_obj</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">,</span> <span class="n">POISON_FREE</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#else</span>
		<span class="n">poison_obj</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">,</span> <span class="n">POISON_FREE</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">objp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_slabp</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">slab</span> <span class="o">*</span><span class="n">slabp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kmem_bufctl_t</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">entries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Check slab&#39;s freelist to see if this obj is there. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">slabp</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">BUFCTL_END</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">slab_bufctl</span><span class="p">(</span><span class="n">slabp</span><span class="p">)[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">entries</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entries</span> <span class="o">&gt;</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">||</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entries</span> <span class="o">!=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">-</span> <span class="n">slabp</span><span class="o">-&gt;</span><span class="n">inuse</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">bad:</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;slab: Internal list corruption detected in &quot;</span>
			<span class="s">&quot;cache &#39;%s&#39;(%d), slabp %p(%d). Tainted(%s). Hexdump:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">,</span> <span class="n">slabp</span><span class="p">,</span> <span class="n">slabp</span><span class="o">-&gt;</span><span class="n">inuse</span><span class="p">,</span>
			<span class="n">print_tainted</span><span class="p">());</span>
		<span class="n">print_hex_dump</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">DUMP_PREFIX_OFFSET</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">slabp</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">slabp</span><span class="p">)</span> <span class="o">+</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">kmem_bufctl_t</span><span class="p">),</span>
			<span class="mi">1</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define kfree_debugcheck(x) do { } while(0)</span>
<span class="cp">#define cache_free_debugcheck(x,objp,z) (objp)</span>
<span class="cp">#define check_slabp(x,y) do { } while(0)</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">cache_alloc_refill</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">batchcount</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_list3</span> <span class="o">*</span><span class="n">l3</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">array_cache</span> <span class="o">*</span><span class="n">ac</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>

<span class="nl">retry:</span>
	<span class="n">check_irq_off</span><span class="p">();</span>
	<span class="n">node</span> <span class="o">=</span> <span class="n">numa_mem_id</span><span class="p">();</span>
	<span class="n">ac</span> <span class="o">=</span> <span class="n">cpu_cache_get</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
	<span class="n">batchcount</span> <span class="o">=</span> <span class="n">ac</span><span class="o">-&gt;</span><span class="n">batchcount</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">touched</span> <span class="o">&amp;&amp;</span> <span class="n">batchcount</span> <span class="o">&gt;</span> <span class="n">BATCHREFILL_LIMIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If there was little recent activity on this cache, then</span>
<span class="cm">		 * perform only a partial refill.  Otherwise we could generate</span>
<span class="cm">		 * refill bouncing.</span>
<span class="cm">		 */</span>
		<span class="n">batchcount</span> <span class="o">=</span> <span class="n">BATCHREFILL_LIMIT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">l3</span> <span class="o">=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">l3</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>

	<span class="cm">/* See if we can refill from the shared array */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">shared</span> <span class="o">&amp;&amp;</span> <span class="n">transfer_objects</span><span class="p">(</span><span class="n">ac</span><span class="p">,</span> <span class="n">l3</span><span class="o">-&gt;</span><span class="n">shared</span><span class="p">,</span> <span class="n">batchcount</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">l3</span><span class="o">-&gt;</span><span class="n">shared</span><span class="o">-&gt;</span><span class="n">touched</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">alloc_done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">batchcount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">slab</span> <span class="o">*</span><span class="n">slabp</span><span class="p">;</span>
		<span class="cm">/* Get slab alloc is to come from. */</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_partial</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_partial</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">l3</span><span class="o">-&gt;</span><span class="n">free_touched</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">entry</span> <span class="o">=</span> <span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_free</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_free</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">must_grow</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">slabp</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">slab</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">check_slabp</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">slabp</span><span class="p">);</span>
		<span class="n">check_spinlock_acquired</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * The slab was either on partial or free list so</span>
<span class="cm">		 * there must be at least one object available for</span>
<span class="cm">		 * allocation.</span>
<span class="cm">		 */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">slabp</span><span class="o">-&gt;</span><span class="n">inuse</span> <span class="o">&gt;=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">slabp</span><span class="o">-&gt;</span><span class="n">inuse</span> <span class="o">&lt;</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">&amp;&amp;</span> <span class="n">batchcount</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">STATS_INC_ALLOCED</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
			<span class="n">STATS_INC_ACTIVE</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
			<span class="n">STATS_SET_HIGH</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>

			<span class="n">ac</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">[</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">slab_get_obj</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">slabp</span><span class="p">,</span>
							    <span class="n">node</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">check_slabp</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">slabp</span><span class="p">);</span>

		<span class="cm">/* move slabp to correct slabp list: */</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slabp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slabp</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">==</span> <span class="n">BUFCTL_END</span><span class="p">)</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slabp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_full</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slabp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_partial</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">must_grow:</span>
	<span class="n">l3</span><span class="o">-&gt;</span><span class="n">free_objects</span> <span class="o">-=</span> <span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">;</span>
<span class="nl">alloc_done:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
		<span class="n">x</span> <span class="o">=</span> <span class="n">cache_grow</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">flags</span> <span class="o">|</span> <span class="n">GFP_THISNODE</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="cm">/* cache_grow can reenable interrupts, then ac could change. */</span>
		<span class="n">ac</span> <span class="o">=</span> <span class="n">cpu_cache_get</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>	<span class="cm">/* no objects in sight? abort */</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">)</span>		<span class="cm">/* objects refilled by interrupt? */</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ac</span><span class="o">-&gt;</span><span class="n">touched</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ac</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">[</span><span class="o">--</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cache_alloc_debugcheck_before</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span>
						<span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">might_sleep_if</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">__GFP_WAIT</span><span class="p">);</span>
<span class="cp">#if DEBUG</span>
	<span class="n">kmem_flagcheck</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cp">#if DEBUG</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">cache_alloc_debugcheck_after</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span>
				<span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">objp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">caller</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">objp</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">objp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_POISON</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_DEBUG_PAGEALLOC</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">%</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">OFF_SLAB</span><span class="p">(</span><span class="n">cachep</span><span class="p">))</span>
			<span class="n">kernel_map_pages</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">(</span><span class="n">objp</span><span class="p">),</span>
					 <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">check_poison_obj</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">);</span>
<span class="cp">#else</span>
		<span class="n">check_poison_obj</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">poison_obj</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">,</span> <span class="n">POISON_INUSE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_STORE_USER</span><span class="p">)</span>
		<span class="o">*</span><span class="n">dbg_userword</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">)</span> <span class="o">=</span> <span class="n">caller</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_RED_ZONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">dbg_redzone1</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">)</span> <span class="o">!=</span> <span class="n">RED_INACTIVE</span> <span class="o">||</span>
				<span class="o">*</span><span class="n">dbg_redzone2</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">)</span> <span class="o">!=</span> <span class="n">RED_INACTIVE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">slab_error</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="s">&quot;double free, or memory outside&quot;</span>
						<span class="s">&quot; object was overwritten&quot;</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
				<span class="s">&quot;%p: redzone 1:0x%llx, redzone 2:0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">objp</span><span class="p">,</span> <span class="o">*</span><span class="n">dbg_redzone1</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">),</span>
				<span class="o">*</span><span class="n">dbg_redzone2</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">dbg_redzone1</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">)</span> <span class="o">=</span> <span class="n">RED_ACTIVE</span><span class="p">;</span>
		<span class="o">*</span><span class="n">dbg_redzone2</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">)</span> <span class="o">=</span> <span class="n">RED_ACTIVE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef CONFIG_DEBUG_SLAB_LEAK</span>
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">slab</span> <span class="o">*</span><span class="n">slabp</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">objnr</span><span class="p">;</span>

		<span class="n">slabp</span> <span class="o">=</span> <span class="n">page_get_slab</span><span class="p">(</span><span class="n">virt_to_head_page</span><span class="p">(</span><span class="n">objp</span><span class="p">));</span>
		<span class="n">objnr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)(</span><span class="n">objp</span> <span class="o">-</span> <span class="n">slabp</span><span class="o">-&gt;</span><span class="n">s_mem</span><span class="p">)</span> <span class="o">/</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">buffer_size</span><span class="p">;</span>
		<span class="n">slab_bufctl</span><span class="p">(</span><span class="n">slabp</span><span class="p">)[</span><span class="n">objnr</span><span class="p">]</span> <span class="o">=</span> <span class="n">BUFCTL_ACTIVE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">objp</span> <span class="o">+=</span> <span class="n">obj_offset</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">ctor</span> <span class="o">&amp;&amp;</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_POISON</span><span class="p">)</span>
		<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">ctor</span><span class="p">(</span><span class="n">objp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ARCH_SLAB_MINALIGN</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">objp</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ARCH_SLAB_MINALIGN</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;0x%p: not aligned to ARCH_SLAB_MINALIGN=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">objp</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">ARCH_SLAB_MINALIGN</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">objp</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define cache_alloc_debugcheck_after(a,b,objp,d) (objp)</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">slab_should_failslab</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cachep</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">cache_cache</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">should_failslab</span><span class="p">(</span><span class="n">obj_size</span><span class="p">(</span><span class="n">cachep</span><span class="p">),</span> <span class="n">flags</span><span class="p">,</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">____cache_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">objp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">array_cache</span> <span class="o">*</span><span class="n">ac</span><span class="p">;</span>

	<span class="n">check_irq_off</span><span class="p">();</span>

	<span class="n">ac</span> <span class="o">=</span> <span class="n">cpu_cache_get</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">STATS_INC_ALLOCHIT</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
		<span class="n">ac</span><span class="o">-&gt;</span><span class="n">touched</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">objp</span> <span class="o">=</span> <span class="n">ac</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">[</span><span class="o">--</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">STATS_INC_ALLOCMISS</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
		<span class="n">objp</span> <span class="o">=</span> <span class="n">cache_alloc_refill</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * the &#39;ac&#39; may be updated by cache_alloc_refill(),</span>
<span class="cm">		 * and kmemleak_erase() requires its correct value.</span>
<span class="cm">		 */</span>
		<span class="n">ac</span> <span class="o">=</span> <span class="n">cpu_cache_get</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * To avoid a false negative, if an object that is in one of the</span>
<span class="cm">	 * per-CPU caches is leaked, we need to make sure kmemleak doesn&#39;t</span>
<span class="cm">	 * treat the array pointers as a reference to the object.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">objp</span><span class="p">)</span>
		<span class="n">kmemleak_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">[</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">]);</span>
	<span class="k">return</span> <span class="n">objp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NUMA</span>
<span class="cm">/*</span>
<span class="cm"> * Try allocating on another node if PF_SPREAD_SLAB|PF_MEMPOLICY.</span>
<span class="cm"> *</span>
<span class="cm"> * If we are in_interrupt, then process context, including cpusets and</span>
<span class="cm"> * mempolicy, may not apply and should not be used for allocation policy.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">alternate_node_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nid_alloc</span><span class="p">,</span> <span class="n">nid_here</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">in_interrupt</span><span class="p">()</span> <span class="o">||</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">__GFP_THISNODE</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">nid_alloc</span> <span class="o">=</span> <span class="n">nid_here</span> <span class="o">=</span> <span class="n">numa_mem_id</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpuset_do_slab_mem_spread</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_MEM_SPREAD</span><span class="p">))</span>
		<span class="n">nid_alloc</span> <span class="o">=</span> <span class="n">cpuset_slab_spread_node</span><span class="p">();</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mempolicy</span><span class="p">)</span>
		<span class="n">nid_alloc</span> <span class="o">=</span> <span class="n">slab_node</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mempolicy</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nid_alloc</span> <span class="o">!=</span> <span class="n">nid_here</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">____cache_alloc_node</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">nid_alloc</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Fallback function if there was no memory available and no objects on a</span>
<span class="cm"> * certain node and fall back is permitted. First we scan all the</span>
<span class="cm"> * available nodelists for available objects. If that fails then we</span>
<span class="cm"> * perform an allocation without specifying a node. This allows the page</span>
<span class="cm"> * allocator to do its reclaim / fallback magic. We then insert the</span>
<span class="cm"> * slab into the proper nodelist and then allocate from it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">fallback_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">zonelist</span> <span class="o">*</span><span class="n">zonelist</span><span class="p">;</span>
	<span class="n">gfp_t</span> <span class="n">local_flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zoneref</span> <span class="o">*</span><span class="n">z</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">zone_type</span> <span class="n">high_zoneidx</span> <span class="o">=</span> <span class="n">gfp_zone</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nid</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpuset_mems_cookie</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">__GFP_THISNODE</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">local_flags</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">GFP_CONSTRAINT_MASK</span><span class="o">|</span><span class="n">GFP_RECLAIM_MASK</span><span class="p">);</span>

<span class="nl">retry_cpuset:</span>
	<span class="n">cpuset_mems_cookie</span> <span class="o">=</span> <span class="n">get_mems_allowed</span><span class="p">();</span>
	<span class="n">zonelist</span> <span class="o">=</span> <span class="n">node_zonelist</span><span class="p">(</span><span class="n">slab_node</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mempolicy</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>

<span class="nl">retry:</span>
	<span class="cm">/*</span>
<span class="cm">	 * Look through allowed nodes for objects available</span>
<span class="cm">	 * from existing per node queues.</span>
<span class="cm">	 */</span>
	<span class="n">for_each_zone_zonelist</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">zonelist</span><span class="p">,</span> <span class="n">high_zoneidx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nid</span> <span class="o">=</span> <span class="n">zone_to_nid</span><span class="p">(</span><span class="n">zone</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cpuset_zone_allowed_hardwall</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">cache</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
			<span class="n">cache</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">free_objects</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">obj</span> <span class="o">=</span> <span class="n">____cache_alloc_node</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span>
					<span class="n">flags</span> <span class="o">|</span> <span class="n">GFP_THISNODE</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This allocation will be performed within the constraints</span>
<span class="cm">		 * of the current cpuset / memory policy requirements.</span>
<span class="cm">		 * We may trigger various forms of reclaim on the allowed</span>
<span class="cm">		 * set and go into memory reserves if necessary.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">local_flags</span> <span class="o">&amp;</span> <span class="n">__GFP_WAIT</span><span class="p">)</span>
			<span class="n">local_irq_enable</span><span class="p">();</span>
		<span class="n">kmem_flagcheck</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">obj</span> <span class="o">=</span> <span class="n">kmem_getpages</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">local_flags</span><span class="p">,</span> <span class="n">numa_mem_id</span><span class="p">());</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">local_flags</span> <span class="o">&amp;</span> <span class="n">__GFP_WAIT</span><span class="p">)</span>
			<span class="n">local_irq_disable</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Insert into the appropriate per node queues</span>
<span class="cm">			 */</span>
			<span class="n">nid</span> <span class="o">=</span> <span class="n">page_to_nid</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">(</span><span class="n">obj</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cache_grow</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">obj</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">obj</span> <span class="o">=</span> <span class="n">____cache_alloc_node</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span>
					<span class="n">flags</span> <span class="o">|</span> <span class="n">GFP_THISNODE</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">obj</span><span class="p">)</span>
					<span class="cm">/*</span>
<span class="cm">					 * Another processor may allocate the</span>
<span class="cm">					 * objects in the slab since we are</span>
<span class="cm">					 * not holding any locks.</span>
<span class="cm">					 */</span>
					<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* cache_grow already freed obj */</span>
				<span class="n">obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">put_mems_allowed</span><span class="p">(</span><span class="n">cpuset_mems_cookie</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">obj</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">retry_cpuset</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">obj</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * A interface to enable slab creation on nodeid</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">____cache_alloc_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">nodeid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">slab</span> <span class="o">*</span><span class="n">slabp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_list3</span> <span class="o">*</span><span class="n">l3</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">x</span><span class="p">;</span>

	<span class="n">l3</span> <span class="o">=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">nodeid</span><span class="p">];</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">l3</span><span class="p">);</span>

<span class="nl">retry:</span>
	<span class="n">check_irq_off</span><span class="p">();</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_partial</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_partial</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">l3</span><span class="o">-&gt;</span><span class="n">free_touched</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_free</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_free</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">must_grow</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">slabp</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">slab</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="n">check_spinlock_acquired_node</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">nodeid</span><span class="p">);</span>
	<span class="n">check_slabp</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">slabp</span><span class="p">);</span>

	<span class="n">STATS_INC_NODEALLOCS</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
	<span class="n">STATS_INC_ACTIVE</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
	<span class="n">STATS_SET_HIGH</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">slabp</span><span class="o">-&gt;</span><span class="n">inuse</span> <span class="o">==</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">);</span>

	<span class="n">obj</span> <span class="o">=</span> <span class="n">slab_get_obj</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">slabp</span><span class="p">,</span> <span class="n">nodeid</span><span class="p">);</span>
	<span class="n">check_slabp</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">slabp</span><span class="p">);</span>
	<span class="n">l3</span><span class="o">-&gt;</span><span class="n">free_objects</span><span class="o">--</span><span class="p">;</span>
	<span class="cm">/* move slabp to correct slabp list: */</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slabp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">slabp</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">==</span> <span class="n">BUFCTL_END</span><span class="p">)</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slabp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_full</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slabp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_partial</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

<span class="nl">must_grow:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
	<span class="n">x</span> <span class="o">=</span> <span class="n">cache_grow</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">flags</span> <span class="o">|</span> <span class="n">GFP_THISNODE</span><span class="p">,</span> <span class="n">nodeid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">fallback_alloc</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">obj</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * kmem_cache_alloc_node - Allocate an object on the specified node</span>
<span class="cm"> * @cachep: The cache to allocate from.</span>
<span class="cm"> * @flags: See kmalloc().</span>
<span class="cm"> * @nodeid: node number of the target node.</span>
<span class="cm"> * @caller: return address of caller, used for debug information</span>
<span class="cm"> *</span>
<span class="cm"> * Identical to kmem_cache_alloc but it will allocate memory on the given</span>
<span class="cm"> * node, which can improve the performance for cpu bound structures.</span>
<span class="cm"> *</span>
<span class="cm"> * Fallback to other node is possible if __GFP_THISNODE is not set.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">__cache_alloc_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nodeid</span><span class="p">,</span>
		   <span class="kt">void</span> <span class="o">*</span><span class="n">caller</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">save_flags</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slab_node</span> <span class="o">=</span> <span class="n">numa_mem_id</span><span class="p">();</span>

	<span class="n">flags</span> <span class="o">&amp;=</span> <span class="n">gfp_allowed_mask</span><span class="p">;</span>

	<span class="n">lockdep_trace_alloc</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">slab_should_failslab</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">flags</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">cache_alloc_debugcheck_before</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">save_flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nodeid</span> <span class="o">==</span> <span class="n">NUMA_NO_NODE</span><span class="p">)</span>
		<span class="n">nodeid</span> <span class="o">=</span> <span class="n">slab_node</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">nodeid</span><span class="p">]))</span> <span class="p">{</span>
		<span class="cm">/* Node not bootstrapped yet */</span>
		<span class="n">ptr</span> <span class="o">=</span> <span class="n">fallback_alloc</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nodeid</span> <span class="o">==</span> <span class="n">slab_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Use the locally cached objects if possible.</span>
<span class="cm">		 * However ____cache_alloc does not allow fallback</span>
<span class="cm">		 * to other nodes. It may fail while we still have</span>
<span class="cm">		 * objects on other nodes available.</span>
<span class="cm">		 */</span>
		<span class="n">ptr</span> <span class="o">=</span> <span class="n">____cache_alloc</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* ___cache_alloc_node can fall back to other nodes */</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="n">____cache_alloc_node</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">nodeid</span><span class="p">);</span>
  <span class="nl">out:</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">save_flags</span><span class="p">);</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="n">cache_alloc_debugcheck_after</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">caller</span><span class="p">);</span>
	<span class="n">kmemleak_alloc_recursive</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">obj_size</span><span class="p">(</span><span class="n">cachep</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span>
				 <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ptr</span><span class="p">))</span>
		<span class="n">kmemcheck_slab_alloc</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">obj_size</span><span class="p">(</span><span class="n">cachep</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">__GFP_ZERO</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ptr</span><span class="p">))</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">obj_size</span><span class="p">(</span><span class="n">cachep</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">__do_cache_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">objp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PF_SPREAD_SLAB</span> <span class="o">|</span> <span class="n">PF_MEMPOLICY</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">objp</span> <span class="o">=</span> <span class="n">alternate_node_alloc</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">objp</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">objp</span> <span class="o">=</span> <span class="n">____cache_alloc</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We may just have run out of memory on the local node.</span>
<span class="cm">	 * ____cache_alloc_node() knows how to locate memory on other nodes</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">objp</span><span class="p">)</span>
		<span class="n">objp</span> <span class="o">=</span> <span class="n">____cache_alloc_node</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">numa_mem_id</span><span class="p">());</span>

  <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">objp</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>

<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">__do_cache_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">____cache_alloc</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_NUMA */</span><span class="cp"></span>

<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">__cache_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">caller</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">save_flags</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">objp</span><span class="p">;</span>

	<span class="n">flags</span> <span class="o">&amp;=</span> <span class="n">gfp_allowed_mask</span><span class="p">;</span>

	<span class="n">lockdep_trace_alloc</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">slab_should_failslab</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">flags</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">cache_alloc_debugcheck_before</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">save_flags</span><span class="p">);</span>
	<span class="n">objp</span> <span class="o">=</span> <span class="n">__do_cache_alloc</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">save_flags</span><span class="p">);</span>
	<span class="n">objp</span> <span class="o">=</span> <span class="n">cache_alloc_debugcheck_after</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">objp</span><span class="p">,</span> <span class="n">caller</span><span class="p">);</span>
	<span class="n">kmemleak_alloc_recursive</span><span class="p">(</span><span class="n">objp</span><span class="p">,</span> <span class="n">obj_size</span><span class="p">(</span><span class="n">cachep</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span>
				 <span class="n">flags</span><span class="p">);</span>
	<span class="n">prefetchw</span><span class="p">(</span><span class="n">objp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">objp</span><span class="p">))</span>
		<span class="n">kmemcheck_slab_alloc</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">objp</span><span class="p">,</span> <span class="n">obj_size</span><span class="p">(</span><span class="n">cachep</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">__GFP_ZERO</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">objp</span><span class="p">))</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">objp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">obj_size</span><span class="p">(</span><span class="n">cachep</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">objp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Caller needs to acquire correct kmem_list&#39;s list_lock</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">objpp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_objects</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_list3</span> <span class="o">*</span><span class="n">l3</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_objects</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">objp</span> <span class="o">=</span> <span class="n">objpp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">slab</span> <span class="o">*</span><span class="n">slabp</span><span class="p">;</span>

		<span class="n">slabp</span> <span class="o">=</span> <span class="n">virt_to_slab</span><span class="p">(</span><span class="n">objp</span><span class="p">);</span>
		<span class="n">l3</span> <span class="o">=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slabp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">check_spinlock_acquired_node</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="n">check_slabp</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">slabp</span><span class="p">);</span>
		<span class="n">slab_put_obj</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">slabp</span><span class="p">,</span> <span class="n">objp</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="n">STATS_DEC_ACTIVE</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
		<span class="n">l3</span><span class="o">-&gt;</span><span class="n">free_objects</span><span class="o">++</span><span class="p">;</span>
		<span class="n">check_slabp</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">slabp</span><span class="p">);</span>

		<span class="cm">/* fixup slab chains */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slabp</span><span class="o">-&gt;</span><span class="n">inuse</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">free_objects</span> <span class="o">&gt;</span> <span class="n">l3</span><span class="o">-&gt;</span><span class="n">free_limit</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">l3</span><span class="o">-&gt;</span><span class="n">free_objects</span> <span class="o">-=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">;</span>
				<span class="cm">/* No need to drop any previously held</span>
<span class="cm">				 * lock here, even if we have a off-slab slab</span>
<span class="cm">				 * descriptor it is guaranteed to come from</span>
<span class="cm">				 * a different cache, refer to comments before</span>
<span class="cm">				 * alloc_slabmgmt.</span>
<span class="cm">				 */</span>
				<span class="n">slab_destroy</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">slabp</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slabp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_free</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Unconditionally move a slab to the end of the</span>
<span class="cm">			 * partial list on free - maximum time for the</span>
<span class="cm">			 * other objects to be freed, too.</span>
<span class="cm">			 */</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slabp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_partial</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cache_flusharray</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">array_cache</span> <span class="o">*</span><span class="n">ac</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">batchcount</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_list3</span> <span class="o">*</span><span class="n">l3</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span> <span class="o">=</span> <span class="n">numa_mem_id</span><span class="p">();</span>

	<span class="n">batchcount</span> <span class="o">=</span> <span class="n">ac</span><span class="o">-&gt;</span><span class="n">batchcount</span><span class="p">;</span>
<span class="cp">#if DEBUG</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">batchcount</span> <span class="o">||</span> <span class="n">batchcount</span> <span class="o">&gt;</span> <span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">check_irq_off</span><span class="p">();</span>
	<span class="n">l3</span> <span class="o">=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">shared</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">array_cache</span> <span class="o">*</span><span class="n">shared_array</span> <span class="o">=</span> <span class="n">l3</span><span class="o">-&gt;</span><span class="n">shared</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">shared_array</span><span class="o">-&gt;</span><span class="n">limit</span> <span class="o">-</span> <span class="n">shared_array</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">max</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">batchcount</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span>
				<span class="n">batchcount</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">shared_array</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">[</span><span class="n">shared_array</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">]),</span>
			       <span class="n">ac</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="n">batchcount</span><span class="p">);</span>
			<span class="n">shared_array</span><span class="o">-&gt;</span><span class="n">avail</span> <span class="o">+=</span> <span class="n">batchcount</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">free_done</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">free_block</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">ac</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="n">batchcount</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
<span class="nl">free_done:</span>
<span class="cp">#if STATS</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

		<span class="n">p</span> <span class="o">=</span> <span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_free</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_free</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">slab</span> <span class="o">*</span><span class="n">slabp</span><span class="p">;</span>

			<span class="n">slabp</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">slab</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">slabp</span><span class="o">-&gt;</span><span class="n">inuse</span><span class="p">);</span>

			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">STATS_SET_FREEABLE</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
	<span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span> <span class="o">-=</span> <span class="n">batchcount</span><span class="p">;</span>
	<span class="n">memmove</span><span class="p">(</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">[</span><span class="n">batchcount</span><span class="p">]),</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">*</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Release an obj back to its cache. If the obj has a constructed state, it must</span>
<span class="cm"> * be in this state _before_ it is released.  Called with disabled ints.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__cache_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">objp</span><span class="p">,</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">caller</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">array_cache</span> <span class="o">*</span><span class="n">ac</span> <span class="o">=</span> <span class="n">cpu_cache_get</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>

	<span class="n">check_irq_off</span><span class="p">();</span>
	<span class="n">kmemleak_free_recursive</span><span class="p">(</span><span class="n">objp</span><span class="p">,</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">objp</span> <span class="o">=</span> <span class="n">cache_free_debugcheck</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">,</span> <span class="n">caller</span><span class="p">);</span>

	<span class="n">kmemcheck_slab_free</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">,</span> <span class="n">obj_size</span><span class="p">(</span><span class="n">cachep</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Skip calling cache_free_alien() when the platform is not numa.</span>
<span class="cm">	 * This will avoid cache misses that happen while accessing slabp (which</span>
<span class="cm">	 * is per page memory  reference) to get nodeid. Instead use a global</span>
<span class="cm">	 * variable to skip the call, which is mostly likely to be present in</span>
<span class="cm">	 * the cache.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_online_nodes</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">cache_free_alien</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span> <span class="o">&lt;</span> <span class="n">ac</span><span class="o">-&gt;</span><span class="n">limit</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">STATS_INC_FREEHIT</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">STATS_INC_FREEMISS</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
		<span class="n">cache_flusharray</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">ac</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ac</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">[</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">objp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * kmem_cache_alloc - Allocate an object</span>
<span class="cm"> * @cachep: The cache to allocate from.</span>
<span class="cm"> * @flags: See kmalloc().</span>
<span class="cm"> *</span>
<span class="cm"> * Allocate an object from this cache.  The flags are only relevant</span>
<span class="cm"> * if the cache has no available objects.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">kmem_cache_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="n">__cache_alloc</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

	<span class="n">trace_kmem_cache_alloc</span><span class="p">(</span><span class="n">_RET_IP_</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span>
			       <span class="n">obj_size</span><span class="p">(</span><span class="n">cachep</span><span class="p">),</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">buffer_size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kmem_cache_alloc</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_TRACING</span>
<span class="kt">void</span> <span class="o">*</span>
<span class="nf">kmem_cache_alloc_trace</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__cache_alloc</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

	<span class="n">trace_kmalloc</span><span class="p">(</span><span class="n">_RET_IP_</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span>
		      <span class="n">size</span><span class="p">,</span> <span class="n">slab_buffer_size</span><span class="p">(</span><span class="n">cachep</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kmem_cache_alloc_trace</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_NUMA</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">kmem_cache_alloc_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nodeid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="n">__cache_alloc_node</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">nodeid</span><span class="p">,</span>
				       <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

	<span class="n">trace_kmem_cache_alloc_node</span><span class="p">(</span><span class="n">_RET_IP_</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span>
				    <span class="n">obj_size</span><span class="p">(</span><span class="n">cachep</span><span class="p">),</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">buffer_size</span><span class="p">,</span>
				    <span class="n">flags</span><span class="p">,</span> <span class="n">nodeid</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kmem_cache_alloc_node</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_TRACING</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">kmem_cache_alloc_node_trace</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span>
				  <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">nodeid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__cache_alloc_node</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">nodeid</span><span class="p">,</span>
				  <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="n">trace_kmalloc_node</span><span class="p">(</span><span class="n">_RET_IP_</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span>
			   <span class="n">size</span><span class="p">,</span> <span class="n">slab_buffer_size</span><span class="p">(</span><span class="n">cachep</span><span class="p">),</span>
			   <span class="n">flags</span><span class="p">,</span> <span class="n">nodeid</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kmem_cache_alloc_node_trace</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">__do_kmalloc_node</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">caller</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">;</span>

	<span class="n">cachep</span> <span class="o">=</span> <span class="n">kmem_find_general_cachep</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ZERO_OR_NULL_PTR</span><span class="p">(</span><span class="n">cachep</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">cachep</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">kmem_cache_alloc_node_trace</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">cachep</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if defined(CONFIG_DEBUG_SLAB) || defined(CONFIG_TRACING)</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">__kmalloc_node</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__do_kmalloc_node</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span>
			<span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__kmalloc_node</span><span class="p">);</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">__kmalloc_node_track_caller</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">caller</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__do_kmalloc_node</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">caller</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__kmalloc_node_track_caller</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">__kmalloc_node</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__do_kmalloc_node</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__kmalloc_node</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_DEBUG_SLAB || CONFIG_TRACING */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_NUMA */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * __do_kmalloc - allocate memory</span>
<span class="cm"> * @size: how many bytes of memory are required.</span>
<span class="cm"> * @flags: the type of memory to allocate (see kmalloc).</span>
<span class="cm"> * @caller: function caller for debug tracking of the caller</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">__do_kmalloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span>
					  <span class="kt">void</span> <span class="o">*</span><span class="n">caller</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* If you want to save a few bytes .text space: replace</span>
<span class="cm">	 * __ with kmem_.</span>
<span class="cm">	 * Then kmalloc uses the uninlined functions instead of the inline</span>
<span class="cm">	 * functions.</span>
<span class="cm">	 */</span>
	<span class="n">cachep</span> <span class="o">=</span> <span class="n">__find_general_cachep</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ZERO_OR_NULL_PTR</span><span class="p">(</span><span class="n">cachep</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">cachep</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__cache_alloc</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">caller</span><span class="p">);</span>

	<span class="n">trace_kmalloc</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">caller</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span>
		      <span class="n">size</span><span class="p">,</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">buffer_size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cp">#if defined(CONFIG_DEBUG_SLAB) || defined(CONFIG_TRACING)</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">__kmalloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__do_kmalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__kmalloc</span><span class="p">);</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">__kmalloc_track_caller</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">caller</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__do_kmalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">caller</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__kmalloc_track_caller</span><span class="p">);</span>

<span class="cp">#else</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">__kmalloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__do_kmalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__kmalloc</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * kmem_cache_free - Deallocate an object</span>
<span class="cm"> * @cachep: The cache the allocation was from.</span>
<span class="cm"> * @objp: The previously allocated object.</span>
<span class="cm"> *</span>
<span class="cm"> * Free an object which was previously allocated from this</span>
<span class="cm"> * cache.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">kmem_cache_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">objp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">debug_check_no_locks_freed</span><span class="p">(</span><span class="n">objp</span><span class="p">,</span> <span class="n">obj_size</span><span class="p">(</span><span class="n">cachep</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_DEBUG_OBJECTS</span><span class="p">))</span>
		<span class="n">debug_check_no_obj_freed</span><span class="p">(</span><span class="n">objp</span><span class="p">,</span> <span class="n">obj_size</span><span class="p">(</span><span class="n">cachep</span><span class="p">));</span>
	<span class="n">__cache_free</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">,</span> <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">trace_kmem_cache_free</span><span class="p">(</span><span class="n">_RET_IP_</span><span class="p">,</span> <span class="n">objp</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kmem_cache_free</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * kfree - free previously allocated memory</span>
<span class="cm"> * @objp: pointer returned by kmalloc.</span>
<span class="cm"> *</span>
<span class="cm"> * If @objp is NULL, no operation is performed.</span>
<span class="cm"> *</span>
<span class="cm"> * Don&#39;t free memory not originally allocated by kmalloc()</span>
<span class="cm"> * or you will run into trouble.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">kfree</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">objp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">trace_kfree</span><span class="p">(</span><span class="n">_RET_IP_</span><span class="p">,</span> <span class="n">objp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ZERO_OR_NULL_PTR</span><span class="p">(</span><span class="n">objp</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">kfree_debugcheck</span><span class="p">(</span><span class="n">objp</span><span class="p">);</span>
	<span class="n">c</span> <span class="o">=</span> <span class="n">virt_to_cache</span><span class="p">(</span><span class="n">objp</span><span class="p">);</span>
	<span class="n">debug_check_no_locks_freed</span><span class="p">(</span><span class="n">objp</span><span class="p">,</span> <span class="n">obj_size</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
	<span class="n">debug_check_no_obj_freed</span><span class="p">(</span><span class="n">objp</span><span class="p">,</span> <span class="n">obj_size</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
	<span class="n">__cache_free</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">objp</span><span class="p">,</span> <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kfree</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">kmem_cache_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">obj_size</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kmem_cache_size</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * This initializes kmem_list3 or resizes various caches for all nodes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">alloc_kmemlist</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_list3</span> <span class="o">*</span><span class="n">l3</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">array_cache</span> <span class="o">*</span><span class="n">new_shared</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">array_cache</span> <span class="o">**</span><span class="n">new_alien</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">use_alien_caches</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">new_alien</span> <span class="o">=</span> <span class="n">alloc_alien_cache</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">limit</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
                        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_alien</span><span class="p">)</span>
                                <span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
                <span class="p">}</span>

		<span class="n">new_shared</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">shared</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">new_shared</span> <span class="o">=</span> <span class="n">alloc_arraycache</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
				<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">shared</span><span class="o">*</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">batchcount</span><span class="p">,</span>
					<span class="mh">0xbaadf00d</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_shared</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">free_alien_cache</span><span class="p">(</span><span class="n">new_alien</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">l3</span> <span class="o">=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">l3</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">array_cache</span> <span class="o">*</span><span class="n">shared</span> <span class="o">=</span> <span class="n">l3</span><span class="o">-&gt;</span><span class="n">shared</span><span class="p">;</span>

			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">shared</span><span class="p">)</span>
				<span class="n">free_block</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">shared</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span>
						<span class="n">shared</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

			<span class="n">l3</span><span class="o">-&gt;</span><span class="n">shared</span> <span class="o">=</span> <span class="n">new_shared</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">alien</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">l3</span><span class="o">-&gt;</span><span class="n">alien</span> <span class="o">=</span> <span class="n">new_alien</span><span class="p">;</span>
				<span class="n">new_alien</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">l3</span><span class="o">-&gt;</span><span class="n">free_limit</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">nr_cpus_node</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="o">*</span>
					<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">batchcount</span> <span class="o">+</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">shared</span><span class="p">);</span>
			<span class="n">free_alien_cache</span><span class="p">(</span><span class="n">new_alien</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">l3</span> <span class="o">=</span> <span class="n">kmalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_list3</span><span class="p">),</span> <span class="n">gfp</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">l3</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">free_alien_cache</span><span class="p">(</span><span class="n">new_alien</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">new_shared</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">kmem_list3_init</span><span class="p">(</span><span class="n">l3</span><span class="p">);</span>
		<span class="n">l3</span><span class="o">-&gt;</span><span class="n">next_reap</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">REAPTIMEOUT_LIST3</span> <span class="o">+</span>
				<span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cachep</span><span class="p">)</span> <span class="o">%</span> <span class="n">REAPTIMEOUT_LIST3</span><span class="p">;</span>
		<span class="n">l3</span><span class="o">-&gt;</span><span class="n">shared</span> <span class="o">=</span> <span class="n">new_shared</span><span class="p">;</span>
		<span class="n">l3</span><span class="o">-&gt;</span><span class="n">alien</span> <span class="o">=</span> <span class="n">new_alien</span><span class="p">;</span>
		<span class="n">l3</span><span class="o">-&gt;</span><span class="n">free_limit</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">nr_cpus_node</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="o">*</span>
					<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">batchcount</span> <span class="o">+</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">;</span>
		<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">l3</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Cache is not active yet. Roll back what we did */</span>
		<span class="n">node</span><span class="o">--</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">node</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">l3</span> <span class="o">=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>

				<span class="n">kfree</span><span class="p">(</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">shared</span><span class="p">);</span>
				<span class="n">free_alien_cache</span><span class="p">(</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">alien</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">l3</span><span class="p">);</span>
				<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">node</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">ccupdate_struct</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">array_cache</span> <span class="o">*</span><span class="n">new</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_ccupdate_local</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ccupdate_struct</span> <span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">array_cache</span> <span class="o">*</span><span class="n">old</span><span class="p">;</span>

	<span class="n">check_irq_off</span><span class="p">();</span>
	<span class="n">old</span> <span class="o">=</span> <span class="n">cpu_cache_get</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">cachep</span><span class="p">);</span>

	<span class="n">new</span><span class="o">-&gt;</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="n">smp_processor_id</span><span class="p">()]</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">new</span><span class="p">[</span><span class="n">smp_processor_id</span><span class="p">()];</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">new</span><span class="p">[</span><span class="n">smp_processor_id</span><span class="p">()]</span> <span class="o">=</span> <span class="n">old</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Always called with the cache_chain_mutex held */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_tune_cpucache</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">limit</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">batchcount</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shared</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ccupdate_struct</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">new</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">new</span><span class="p">)</span> <span class="o">+</span> <span class="n">nr_cpu_ids</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">array_cache</span> <span class="o">*</span><span class="p">),</span>
		      <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new</span><span class="o">-&gt;</span><span class="n">new</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">alloc_arraycache</span><span class="p">(</span><span class="n">cpu_to_mem</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">limit</span><span class="p">,</span>
						<span class="n">batchcount</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">new</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">new</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">cachep</span> <span class="o">=</span> <span class="n">cachep</span><span class="p">;</span>

	<span class="n">on_each_cpu</span><span class="p">(</span><span class="n">do_ccupdate_local</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">new</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">check_irq_on</span><span class="p">();</span>
	<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">batchcount</span> <span class="o">=</span> <span class="n">batchcount</span><span class="p">;</span>
	<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">limit</span> <span class="o">=</span> <span class="n">limit</span><span class="p">;</span>
	<span class="n">cachep</span><span class="o">-&gt;</span><span class="n">shared</span> <span class="o">=</span> <span class="n">shared</span><span class="p">;</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">array_cache</span> <span class="o">*</span><span class="n">ccold</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">new</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ccold</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">cpu_to_mem</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
		<span class="n">free_block</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">ccold</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="n">ccold</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">,</span> <span class="n">cpu_to_mem</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">cpu_to_mem</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ccold</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">alloc_kmemlist</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Called with cache_chain_mutex held always */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">enable_cpucache</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">limit</span><span class="p">,</span> <span class="n">shared</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The head array serves three purposes:</span>
<span class="cm">	 * - create a LIFO ordering, i.e. return objects that are cache-warm</span>
<span class="cm">	 * - reduce the number of spinlock operations.</span>
<span class="cm">	 * - reduce the number of linked list operations on the slab and</span>
<span class="cm">	 *   bufctl chains: array operations are cheaper.</span>
<span class="cm">	 * The numbers are guessed, we should auto-tune as described by</span>
<span class="cm">	 * Bonwick.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">&gt;</span> <span class="mi">131072</span><span class="p">)</span>
		<span class="n">limit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="n">limit</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">&gt;</span> <span class="mi">1024</span><span class="p">)</span>
		<span class="n">limit</span> <span class="o">=</span> <span class="mi">24</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">&gt;</span> <span class="mi">256</span><span class="p">)</span>
		<span class="n">limit</span> <span class="o">=</span> <span class="mi">54</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">limit</span> <span class="o">=</span> <span class="mi">120</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * CPU bound tasks (e.g. network routing) can exhibit cpu bound</span>
<span class="cm">	 * allocation behaviour: Most allocs on one cpu, most free operations</span>
<span class="cm">	 * on another cpu. For these cases, an efficient object passing between</span>
<span class="cm">	 * cpus is necessary. This is provided by a shared array. The array</span>
<span class="cm">	 * replaces Bonwick&#39;s magazine layer.</span>
<span class="cm">	 * On uniprocessor, it&#39;s functionally equivalent (but less efficient)</span>
<span class="cm">	 * to a larger limit. Thus disabled by default.</span>
<span class="cm">	 */</span>
	<span class="n">shared</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">&lt;=</span> <span class="n">PAGE_SIZE</span> <span class="o">&amp;&amp;</span> <span class="n">num_possible_cpus</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">shared</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

<span class="cp">#if DEBUG</span>
	<span class="cm">/*</span>
<span class="cm">	 * With debugging enabled, large batchcount lead to excessively long</span>
<span class="cm">	 * periods with disabled local interrupts. Limit the batchcount</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">limit</span> <span class="o">&gt;</span> <span class="mi">32</span><span class="p">)</span>
		<span class="n">limit</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">do_tune_cpucache</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="p">(</span><span class="n">limit</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">shared</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;enable_cpucache failed for %s, error %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="o">-</span><span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Drain an array if it contains any elements taking the l3 lock only if</span>
<span class="cm"> * necessary. Note that the l3 listlock also protects the array_cache</span>
<span class="cm"> * if drain_array() is used on the shared array.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">drain_array</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kmem_list3</span> <span class="o">*</span><span class="n">l3</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">array_cache</span> <span class="o">*</span><span class="n">ac</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">tofree</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ac</span> <span class="o">||</span> <span class="o">!</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">touched</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">force</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ac</span><span class="o">-&gt;</span><span class="n">touched</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tofree</span> <span class="o">=</span> <span class="n">force</span> <span class="o">?</span> <span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span> <span class="o">:</span> <span class="p">(</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">limit</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">/</span> <span class="mi">5</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tofree</span> <span class="o">&gt;</span> <span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">)</span>
				<span class="n">tofree</span> <span class="o">=</span> <span class="p">(</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">free_block</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">ac</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="n">tofree</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
			<span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span> <span class="o">-=</span> <span class="n">tofree</span><span class="p">;</span>
			<span class="n">memmove</span><span class="p">(</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">[</span><span class="n">tofree</span><span class="p">]),</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cache_reap - Reclaim memory from caches.</span>
<span class="cm"> * @w: work descriptor</span>
<span class="cm"> *</span>
<span class="cm"> * Called from workqueue/eventd every few seconds.</span>
<span class="cm"> * Purpose:</span>
<span class="cm"> * - clear the per-cpu caches for this CPU.</span>
<span class="cm"> * - return freeable pages to the main free memory pool.</span>
<span class="cm"> *</span>
<span class="cm"> * If we cannot acquire the cache chain mutex then just give up - we&#39;ll try</span>
<span class="cm"> * again on the next iteration.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cache_reap</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">w</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">searchp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_list3</span> <span class="o">*</span><span class="n">l3</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span> <span class="o">=</span> <span class="n">numa_mem_id</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="n">work</span> <span class="o">=</span> <span class="n">to_delayed_work</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_chain_mutex</span><span class="p">))</span>
		<span class="cm">/* Give up. Setup the next iteration. */</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">searchp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cache_chain</span><span class="p">,</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">check_irq_on</span><span class="p">();</span>

		<span class="cm">/*</span>
<span class="cm">		 * We only take the l3 lock if absolutely necessary and we</span>
<span class="cm">		 * have established with reasonable certainty that</span>
<span class="cm">		 * we can do some work if the lock was obtained.</span>
<span class="cm">		 */</span>
		<span class="n">l3</span> <span class="o">=</span> <span class="n">searchp</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>

		<span class="n">reap_alien</span><span class="p">(</span><span class="n">searchp</span><span class="p">,</span> <span class="n">l3</span><span class="p">);</span>

		<span class="n">drain_array</span><span class="p">(</span><span class="n">searchp</span><span class="p">,</span> <span class="n">l3</span><span class="p">,</span> <span class="n">cpu_cache_get</span><span class="p">(</span><span class="n">searchp</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * These are racy checks but it does not matter</span>
<span class="cm">		 * if we skip one check or scan twice.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">next_reap</span><span class="p">,</span> <span class="n">jiffies</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>

		<span class="n">l3</span><span class="o">-&gt;</span><span class="n">next_reap</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">REAPTIMEOUT_LIST3</span><span class="p">;</span>

		<span class="n">drain_array</span><span class="p">(</span><span class="n">searchp</span><span class="p">,</span> <span class="n">l3</span><span class="p">,</span> <span class="n">l3</span><span class="o">-&gt;</span><span class="n">shared</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">free_touched</span><span class="p">)</span>
			<span class="n">l3</span><span class="o">-&gt;</span><span class="n">free_touched</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">freed</span><span class="p">;</span>

			<span class="n">freed</span> <span class="o">=</span> <span class="n">drain_freelist</span><span class="p">(</span><span class="n">searchp</span><span class="p">,</span> <span class="n">l3</span><span class="p">,</span> <span class="p">(</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">free_limit</span> <span class="o">+</span>
				<span class="mi">5</span> <span class="o">*</span> <span class="n">searchp</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="n">searchp</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">));</span>
			<span class="n">STATS_ADD_REAPED</span><span class="p">(</span><span class="n">searchp</span><span class="p">,</span> <span class="n">freed</span><span class="p">);</span>
		<span class="p">}</span>
<span class="nl">next:</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">check_irq_on</span><span class="p">();</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_chain_mutex</span><span class="p">);</span>
	<span class="n">next_reap_node</span><span class="p">();</span>
<span class="nl">out:</span>
	<span class="cm">/* Set up the next iteration */</span>
	<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="n">round_jiffies_relative</span><span class="p">(</span><span class="n">REAPTIMEOUT_CPUC</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SLABINFO</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_slabinfo_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Output format version, so at least we can change it</span>
<span class="cm">	 * without _too_ many complaints.</span>
<span class="cm">	 */</span>
<span class="cp">#if STATS</span>
	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;slabinfo - version: 2.1 (statistics)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;slabinfo - version: 2.1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;# name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &quot;</span>
		 <span class="s">&quot;&lt;objperslab&gt; &lt;pagesperslab&gt;&quot;</span><span class="p">);</span>
	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; : tunables &lt;limit&gt; &lt;batchcount&gt; &lt;sharedfactor&gt;&quot;</span><span class="p">);</span>
	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; : slabdata &lt;active_slabs&gt; &lt;num_slabs&gt; &lt;sharedavail&gt;&quot;</span><span class="p">);</span>
<span class="cp">#if STATS</span>
	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; : globalstat &lt;listallocs&gt; &lt;maxobjs&gt; &lt;grown&gt; &lt;reaped&gt; &quot;</span>
		 <span class="s">&quot;&lt;error&gt; &lt;maxfreeable&gt; &lt;nodeallocs&gt; &lt;remotefrees&gt; &lt;alienoverflow&gt;&quot;</span><span class="p">);</span>
	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; : cpustat &lt;allochit&gt; &lt;allocmiss&gt; &lt;freehit&gt; &lt;freemiss&gt;&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">seq_putc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">s_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">loff_t</span> <span class="n">n</span> <span class="o">=</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_chain_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span>
		<span class="n">print_slabinfo_header</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">seq_list_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_chain</span><span class="p">,</span> <span class="o">*</span><span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">s_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq_list_next</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cache_chain</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">s_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_chain_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">s_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kmem_cache</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">slab</span> <span class="o">*</span><span class="n">slabp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">active_objs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_objs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">active_slabs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_slabs</span><span class="p">,</span> <span class="n">free_objects</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shared_avail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_list3</span> <span class="o">*</span><span class="n">l3</span><span class="p">;</span>

	<span class="n">active_objs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">num_slabs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">l3</span> <span class="o">=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">l3</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">check_irq_on</span><span class="p">();</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>

		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">slabp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_full</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">slabp</span><span class="o">-&gt;</span><span class="n">inuse</span> <span class="o">!=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">error</span><span class="p">)</span>
				<span class="n">error</span> <span class="o">=</span> <span class="s">&quot;slabs_full accounting error&quot;</span><span class="p">;</span>
			<span class="n">active_objs</span> <span class="o">+=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">;</span>
			<span class="n">active_slabs</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">slabp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_partial</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">slabp</span><span class="o">-&gt;</span><span class="n">inuse</span> <span class="o">==</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">error</span><span class="p">)</span>
				<span class="n">error</span> <span class="o">=</span> <span class="s">&quot;slabs_partial inuse accounting error&quot;</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slabp</span><span class="o">-&gt;</span><span class="n">inuse</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">error</span><span class="p">)</span>
				<span class="n">error</span> <span class="o">=</span> <span class="s">&quot;slabs_partial/inuse accounting error&quot;</span><span class="p">;</span>
			<span class="n">active_objs</span> <span class="o">+=</span> <span class="n">slabp</span><span class="o">-&gt;</span><span class="n">inuse</span><span class="p">;</span>
			<span class="n">active_slabs</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">slabp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_free</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">slabp</span><span class="o">-&gt;</span><span class="n">inuse</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">error</span><span class="p">)</span>
				<span class="n">error</span> <span class="o">=</span> <span class="s">&quot;slabs_free/inuse accounting error&quot;</span><span class="p">;</span>
			<span class="n">num_slabs</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">free_objects</span> <span class="o">+=</span> <span class="n">l3</span><span class="o">-&gt;</span><span class="n">free_objects</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">shared</span><span class="p">)</span>
			<span class="n">shared_avail</span> <span class="o">+=</span> <span class="n">l3</span><span class="o">-&gt;</span><span class="n">shared</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">;</span>

		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">num_slabs</span> <span class="o">+=</span> <span class="n">active_slabs</span><span class="p">;</span>
	<span class="n">num_objs</span> <span class="o">=</span> <span class="n">num_slabs</span> <span class="o">*</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_objs</span> <span class="o">-</span> <span class="n">active_objs</span> <span class="o">!=</span> <span class="n">free_objects</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">error</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="s">&quot;free_objects accounting error&quot;</span><span class="p">;</span>

	<span class="n">name</span> <span class="o">=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;slab: cache %s error: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%-17s %6lu %6lu %6u %4u %4d&quot;</span><span class="p">,</span>
		   <span class="n">name</span><span class="p">,</span> <span class="n">active_objs</span><span class="p">,</span> <span class="n">num_objs</span><span class="p">,</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">buffer_size</span><span class="p">,</span>
		   <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">gfporder</span><span class="p">));</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; : tunables %4u %4u %4u&quot;</span><span class="p">,</span>
		   <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">limit</span><span class="p">,</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">batchcount</span><span class="p">,</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">shared</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; : slabdata %6lu %6lu %6lu&quot;</span><span class="p">,</span>
		   <span class="n">active_slabs</span><span class="p">,</span> <span class="n">num_slabs</span><span class="p">,</span> <span class="n">shared_avail</span><span class="p">);</span>
<span class="cp">#if STATS</span>
	<span class="p">{</span>			<span class="cm">/* list3 stats */</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">high</span> <span class="o">=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">high_mark</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">allocs</span> <span class="o">=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">num_allocations</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">grown</span> <span class="o">=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">grown</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reaped</span> <span class="o">=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">reaped</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">errors</span> <span class="o">=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">errors</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_freeable</span> <span class="o">=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">max_freeable</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node_allocs</span> <span class="o">=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">node_allocs</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node_frees</span> <span class="o">=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">node_frees</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">overflows</span> <span class="o">=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">node_overflow</span><span class="p">;</span>

		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; : globalstat %7lu %6lu %5lu %4lu &quot;</span>
			   <span class="s">&quot;%4lu %4lu %4lu %4lu %4lu&quot;</span><span class="p">,</span>
			   <span class="n">allocs</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">grown</span><span class="p">,</span>
			   <span class="n">reaped</span><span class="p">,</span> <span class="n">errors</span><span class="p">,</span> <span class="n">max_freeable</span><span class="p">,</span> <span class="n">node_allocs</span><span class="p">,</span>
			   <span class="n">node_frees</span><span class="p">,</span> <span class="n">overflows</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* cpu stats */</span>
	<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">allochit</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">allochit</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">allocmiss</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">allocmiss</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">freehit</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">freehit</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">freemiss</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">freemiss</span><span class="p">);</span>

		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; : cpustat %6lu %6lu %6lu %6lu&quot;</span><span class="p">,</span>
			   <span class="n">allochit</span><span class="p">,</span> <span class="n">allocmiss</span><span class="p">,</span> <span class="n">freehit</span><span class="p">,</span> <span class="n">freemiss</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">seq_putc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * slabinfo_op - iterator that generates /proc/slabinfo</span>
<span class="cm"> *</span>
<span class="cm"> * Output layout:</span>
<span class="cm"> * cache-name</span>
<span class="cm"> * num-active-objs</span>
<span class="cm"> * total-objs</span>
<span class="cm"> * object size</span>
<span class="cm"> * num-active-slabs</span>
<span class="cm"> * total-slabs</span>
<span class="cm"> * num-pages-per-slab</span>
<span class="cm"> * + further values on SMP and with statistics enabled</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">slabinfo_op</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">s_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">s_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span> <span class="o">=</span> <span class="n">s_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span> <span class="o">=</span> <span class="n">s_show</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define MAX_SLABINFO_WRITE 128</span>
<span class="cm">/**</span>
<span class="cm"> * slabinfo_write - Tuning for the slab allocator</span>
<span class="cm"> * @file: unused</span>
<span class="cm"> * @buffer: user buffer</span>
<span class="cm"> * @count: data length</span>
<span class="cm"> * @ppos: unused</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">slabinfo_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
		       <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">kbuf</span><span class="p">[</span><span class="n">MAX_SLABINFO_WRITE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">limit</span><span class="p">,</span> <span class="n">batchcount</span><span class="p">,</span> <span class="n">shared</span><span class="p">,</span> <span class="n">res</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">MAX_SLABINFO_WRITE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kbuf</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="n">kbuf</span><span class="p">[</span><span class="n">MAX_SLABINFO_WRITE</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">kbuf</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="n">tmp</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s">&quot; %d %d %d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">limit</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">batchcount</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shared</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Find the cache in the chain of caches. */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_chain_mutex</span><span class="p">);</span>
	<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cache_chain</span><span class="p">,</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">kbuf</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">limit</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">batchcount</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span>
					<span class="n">batchcount</span> <span class="o">&gt;</span> <span class="n">limit</span> <span class="o">||</span> <span class="n">shared</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">res</span> <span class="o">=</span> <span class="n">do_tune_cpucache</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span>
						       <span class="n">batchcount</span><span class="p">,</span> <span class="n">shared</span><span class="p">,</span>
						       <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_chain_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">slabinfo_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slabinfo_op</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_slabinfo_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">slabinfo_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">slabinfo_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">seq_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_DEBUG_SLAB_LEAK</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">leaks_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_chain_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">seq_list_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_chain</span><span class="p">,</span> <span class="o">*</span><span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">add_caller</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">l</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">v</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">l</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">q</span> <span class="o">==</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">q</span> <span class="o">&gt;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">l</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">l</span> <span class="o">-=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memmove</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">-</span> <span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span> <span class="o">-</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">n</span><span class="p">));</span>
	<span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
	<span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_slab</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">slab</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">s_mem</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">p</span> <span class="o">+=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">buffer_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slab_bufctl</span><span class="p">(</span><span class="n">s</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">BUFCTL_ACTIVE</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">add_caller</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">*</span><span class="n">dbg_userword</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">p</span><span class="p">)))</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">show_symbol</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_KALLSYMS</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">modname</span><span class="p">[</span><span class="n">MODULE_NAME_LEN</span><span class="p">],</span> <span class="n">name</span><span class="p">[</span><span class="n">KSYM_NAME_LEN</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lookup_symbol_attrs</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span> <span class="n">modname</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%s+%#lx/%#lx&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">modname</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; [%s]&quot;</span><span class="p">,</span> <span class="n">modname</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%p&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">address</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">leaks_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kmem_cache</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">slab</span> <span class="o">*</span><span class="n">slabp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_list3</span> <span class="o">*</span><span class="n">l3</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_STORE_USER</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_RED_ZONE</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* OK, we can do it */</span>

	<span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">l3</span> <span class="o">=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">l3</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">check_irq_on</span><span class="p">();</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>

		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">slabp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_full</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
			<span class="n">handle_slab</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">cachep</span><span class="p">,</span> <span class="n">slabp</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">slabp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_partial</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
			<span class="n">handle_slab</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">cachep</span><span class="p">,</span> <span class="n">slabp</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">name</span> <span class="o">=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
		<span class="cm">/* Increase the buffer size */</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_chain_mutex</span><span class="p">);</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Too bad, we are really out */</span>
			<span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_chain_mutex</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_chain_mutex</span><span class="p">);</span>
		<span class="cm">/* Now make sure this entry will be retried */</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%s: %lu &quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">n</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">]);</span>
		<span class="n">show_symbol</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]);</span>
		<span class="n">seq_putc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">slabstats_op</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">leaks_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">s_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span> <span class="o">=</span> <span class="n">s_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span> <span class="o">=</span> <span class="n">leaks_show</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">slabstats_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slabstats_op</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
			<span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">));</span>
			<span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
			<span class="n">n</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_slabstats_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">slabstats_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">seq_release_private</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">slab_proc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">proc_create</span><span class="p">(</span><span class="s">&quot;slabinfo&quot;</span><span class="p">,</span><span class="n">S_IWUSR</span><span class="o">|</span><span class="n">S_IRUSR</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="o">&amp;</span><span class="n">proc_slabinfo_operations</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_DEBUG_SLAB_LEAK</span>
	<span class="n">proc_create</span><span class="p">(</span><span class="s">&quot;slab_allocators&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proc_slabstats_operations</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">slab_proc_init</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * ksize - get the actual amount of memory allocated for a given object</span>
<span class="cm"> * @objp: Pointer to the object</span>
<span class="cm"> *</span>
<span class="cm"> * kmalloc may internally round up allocations and return more memory</span>
<span class="cm"> * than requested. ksize() can be used to determine the actual amount of</span>
<span class="cm"> * memory allocated. The caller may use this additional memory, even though</span>
<span class="cm"> * a smaller amount of memory was initially specified with the kmalloc call.</span>
<span class="cm"> * The caller must guarantee that objp points to a valid object previously</span>
<span class="cm"> * allocated with either kmalloc() or kmem_cache_alloc(). The object</span>
<span class="cm"> * must not be freed during the duration of the call.</span>
<span class="cm"> */</span>
<span class="kt">size_t</span> <span class="nf">ksize</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">objp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">objp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">objp</span> <span class="o">==</span> <span class="n">ZERO_SIZE_PTR</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">obj_size</span><span class="p">(</span><span class="n">virt_to_cache</span><span class="p">(</span><span class="n">objp</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ksize</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
