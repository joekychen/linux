<!DOCTYPE html>
<html><head><title>joekychen/linux » mm › memory.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>memory.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/mm/memory.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * demand-loading started 01.12.91 - seems it is high on the list of</span>
<span class="cm"> * things wanted, and it should be easy to implement. - Linus</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Ok, demand-loading was easy, shared pages a little bit tricker. Shared</span>
<span class="cm"> * pages started 02.12.91, seems to work. - Linus.</span>
<span class="cm"> *</span>
<span class="cm"> * Tested sharing by executing about 30 /bin/sh: under the old kernel it</span>
<span class="cm"> * would have taken more than the 6M I have free, but it worked well as</span>
<span class="cm"> * far as I could see.</span>
<span class="cm"> *</span>
<span class="cm"> * Also corrected some &quot;invalidate()&quot;s - I wasn&#39;t doing enough of them.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Real VM (paging to/from disk) started 18.12.91. Much more work and</span>
<span class="cm"> * thought has to go into this. Oh, well..</span>
<span class="cm"> * 19.12.91  -  works, somewhat. Sometimes I get faults, don&#39;t know why.</span>
<span class="cm"> *		Found it. Everything seems to work now.</span>
<span class="cm"> * 20.12.91  -  Ok, making the swap-device changeable like the root.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * 05.04.94  -  Multi-page memory management added for v1.1.</span>
<span class="cm"> * 		Idea by Alex Bligh (alex@cconcepts.co.uk)</span>
<span class="cm"> *</span>
<span class="cm"> * 16.07.99  -  Support of BIGMEM added by Gerhard Wichert, Siemens AG</span>
<span class="cm"> *		(Gerhard.Wichert@pdb.siemens.de)</span>
<span class="cm"> *</span>
<span class="cm"> * Aug/Sep 2004 Changed to four level page tables (Andi Kleen)</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel_stat.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/hugetlb.h&gt;</span>
<span class="cp">#include &lt;linux/mman.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/ksm.h&gt;</span>
<span class="cp">#include &lt;linux/rmap.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/delayacct.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>
<span class="cp">#include &lt;linux/memcontrol.h&gt;</span>
<span class="cp">#include &lt;linux/mmu_notifier.h&gt;</span>
<span class="cp">#include &lt;linux/kallsyms.h&gt;</span>
<span class="cp">#include &lt;linux/swapops.h&gt;</span>
<span class="cp">#include &lt;linux/elf.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>

<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/pgalloc.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/tlb.h&gt;</span>
<span class="cp">#include &lt;asm/tlbflush.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>

<span class="cp">#include &quot;internal.h&quot;</span>

<span class="cp">#ifndef CONFIG_NEED_MULTIPLE_NODES</span>
<span class="cm">/* use the per-pgdat data instead for discontigmem - mbligh */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_mapnr</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">mem_map</span><span class="p">;</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">max_mapnr</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">mem_map</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_physpages</span><span class="p">;</span>
<span class="cm">/*</span>
<span class="cm"> * A number of key systems in x86 including ioremap() rely on the assumption</span>
<span class="cm"> * that high_memory defines the upper bound on direct map memory, then end</span>
<span class="cm"> * of ZONE_NORMAL.  Under CONFIG_DISCONTIG this means that max_low_pfn and</span>
<span class="cm"> * highstart_pfn must be the same; there must be no gap between ZONE_NORMAL</span>
<span class="cm"> * and ZONE_HIGHMEM.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span> <span class="n">high_memory</span><span class="p">;</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">num_physpages</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">high_memory</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Randomize the address space (stacks, mmaps, brk, etc.).</span>
<span class="cm"> *</span>
<span class="cm"> * ( When CONFIG_COMPAT_BRK=y we exclude brk from randomization,</span>
<span class="cm"> *   as ancient (libc5 based) binaries can segfault. )</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">randomize_va_space</span> <span class="n">__read_mostly</span> <span class="o">=</span>
<span class="cp">#ifdef CONFIG_COMPAT_BRK</span>
					<span class="mi">1</span><span class="p">;</span>
<span class="cp">#else</span>
					<span class="mi">2</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">disable_randmaps</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">randomize_va_space</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;norandmaps&quot;</span><span class="p">,</span> <span class="n">disable_randmaps</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zero_pfn</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">highest_memmap_pfn</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * CONFIG_MMU architectures set up ZERO_PAGE in their paging_init()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">init_zero_pfn</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">zero_pfn</span> <span class="o">=</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">ZERO_PAGE</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">core_initcall</span><span class="p">(</span><span class="n">init_zero_pfn</span><span class="p">);</span>


<span class="cp">#if defined(SPLIT_RSS_COUNTING)</span>

<span class="kt">void</span> <span class="nf">sync_mm_rss</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_MM_COUNTERS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">rss_stat</span><span class="p">.</span><span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">add_mm_counter</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">rss_stat</span><span class="p">.</span><span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">rss_stat</span><span class="p">.</span><span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">rss_stat</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_mm_counter_fast</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">member</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">==</span> <span class="n">mm</span><span class="p">))</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">rss_stat</span><span class="p">.</span><span class="n">count</span><span class="p">[</span><span class="n">member</span><span class="p">]</span> <span class="o">+=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">add_mm_counter</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">member</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#define inc_mm_counter_fast(mm, member) add_mm_counter_fast(mm, member, 1)</span>
<span class="cp">#define dec_mm_counter_fast(mm, member) add_mm_counter_fast(mm, member, -1)</span>

<span class="cm">/* sync counter once per 64 page faults */</span>
<span class="cp">#define TASK_RSS_EVENTS_THRESH	(64)</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_sync_rss_stat</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">task</span> <span class="o">!=</span> <span class="n">current</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">rss_stat</span><span class="p">.</span><span class="n">events</span><span class="o">++</span> <span class="o">&gt;</span> <span class="n">TASK_RSS_EVENTS_THRESH</span><span class="p">))</span>
		<span class="n">sync_mm_rss</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* SPLIT_RSS_COUNTING */</span><span class="cp"></span>

<span class="cp">#define inc_mm_counter_fast(mm, member) inc_mm_counter(mm, member)</span>
<span class="cp">#define dec_mm_counter_fast(mm, member) dec_mm_counter(mm, member)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_sync_rss_stat</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* SPLIT_RSS_COUNTING */</span><span class="cp"></span>

<span class="cp">#ifdef HAVE_GENERIC_MMU_GATHER</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tlb_next_batch</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmu_gather</span> <span class="o">*</span><span class="n">tlb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mmu_gather_batch</span> <span class="o">*</span><span class="n">batch</span><span class="p">;</span>

	<span class="n">batch</span> <span class="o">=</span> <span class="n">tlb</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">batch</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tlb</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">=</span> <span class="n">batch</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">batch</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_pages</span><span class="p">(</span><span class="n">GFP_NOWAIT</span> <span class="o">|</span> <span class="n">__GFP_NOWARN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">batch</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">batch</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">batch</span><span class="o">-&gt;</span><span class="n">nr</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">batch</span><span class="o">-&gt;</span><span class="n">max</span>  <span class="o">=</span> <span class="n">MAX_GATHER_BATCH</span><span class="p">;</span>

	<span class="n">tlb</span><span class="o">-&gt;</span><span class="n">active</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">batch</span><span class="p">;</span>
	<span class="n">tlb</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">=</span> <span class="n">batch</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* tlb_gather_mmu</span>
<span class="cm"> *	Called to initialize an (on-stack) mmu_gather structure for page-table</span>
<span class="cm"> *	tear-down from @mm. The @fullmm argument is used when @mm is without</span>
<span class="cm"> *	users and we&#39;re going to destroy the full address space (exit/execve).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tlb_gather_mmu</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmu_gather</span> <span class="o">*</span><span class="n">tlb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="n">bool</span> <span class="n">fullmm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tlb</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">=</span> <span class="n">mm</span><span class="p">;</span>

	<span class="n">tlb</span><span class="o">-&gt;</span><span class="n">fullmm</span>     <span class="o">=</span> <span class="n">fullmm</span><span class="p">;</span>
	<span class="n">tlb</span><span class="o">-&gt;</span><span class="n">need_flush</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tlb</span><span class="o">-&gt;</span><span class="n">fast_mode</span>  <span class="o">=</span> <span class="p">(</span><span class="n">num_possible_cpus</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">tlb</span><span class="o">-&gt;</span><span class="n">local</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">tlb</span><span class="o">-&gt;</span><span class="n">local</span><span class="p">.</span><span class="n">nr</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tlb</span><span class="o">-&gt;</span><span class="n">local</span><span class="p">.</span><span class="n">max</span>  <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">tlb</span><span class="o">-&gt;</span><span class="n">__pages</span><span class="p">);</span>
	<span class="n">tlb</span><span class="o">-&gt;</span><span class="n">active</span>     <span class="o">=</span> <span class="o">&amp;</span><span class="n">tlb</span><span class="o">-&gt;</span><span class="n">local</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_HAVE_RCU_TABLE_FREE</span>
	<span class="n">tlb</span><span class="o">-&gt;</span><span class="n">batch</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">tlb_flush_mmu</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmu_gather</span> <span class="o">*</span><span class="n">tlb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mmu_gather_batch</span> <span class="o">*</span><span class="n">batch</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tlb</span><span class="o">-&gt;</span><span class="n">need_flush</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">tlb</span><span class="o">-&gt;</span><span class="n">need_flush</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tlb_flush</span><span class="p">(</span><span class="n">tlb</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_HAVE_RCU_TABLE_FREE</span>
	<span class="n">tlb_table_flush</span><span class="p">(</span><span class="n">tlb</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tlb_fast_mode</span><span class="p">(</span><span class="n">tlb</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">batch</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tlb</span><span class="o">-&gt;</span><span class="n">local</span><span class="p">;</span> <span class="n">batch</span><span class="p">;</span> <span class="n">batch</span> <span class="o">=</span> <span class="n">batch</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_pages_and_swap_cache</span><span class="p">(</span><span class="n">batch</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">,</span> <span class="n">batch</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>
		<span class="n">batch</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tlb</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tlb</span><span class="o">-&gt;</span><span class="n">local</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* tlb_finish_mmu</span>
<span class="cm"> *	Called at the end of the shootdown operation to free up any resources</span>
<span class="cm"> *	that were required.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tlb_finish_mmu</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmu_gather</span> <span class="o">*</span><span class="n">tlb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mmu_gather_batch</span> <span class="o">*</span><span class="n">batch</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="n">tlb_flush_mmu</span><span class="p">(</span><span class="n">tlb</span><span class="p">);</span>

	<span class="cm">/* keep the page table cache within bounds */</span>
	<span class="n">check_pgt_cache</span><span class="p">();</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">batch</span> <span class="o">=</span> <span class="n">tlb</span><span class="o">-&gt;</span><span class="n">local</span><span class="p">.</span><span class="n">next</span><span class="p">;</span> <span class="n">batch</span><span class="p">;</span> <span class="n">batch</span> <span class="o">=</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">batch</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">batch</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">tlb</span><span class="o">-&gt;</span><span class="n">local</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* __tlb_remove_page</span>
<span class="cm"> *	Must perform the equivalent to __free_pte(pte_get_and_clear(ptep)), while</span>
<span class="cm"> *	handling the additional races in SMP caused by other CPUs caching valid</span>
<span class="cm"> *	mappings in their TLBs. Returns the number of free page slots left.</span>
<span class="cm"> *	When out of page slots we must call tlb_flush_mmu().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__tlb_remove_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmu_gather</span> <span class="o">*</span><span class="n">tlb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mmu_gather_batch</span> <span class="o">*</span><span class="n">batch</span><span class="p">;</span>

	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">tlb</span><span class="o">-&gt;</span><span class="n">need_flush</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tlb_fast_mode</span><span class="p">(</span><span class="n">tlb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">free_page_and_swap_cache</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* avoid calling tlb_flush_mmu() */</span>
	<span class="p">}</span>

	<span class="n">batch</span> <span class="o">=</span> <span class="n">tlb</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">;</span>
	<span class="n">batch</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">batch</span><span class="o">-&gt;</span><span class="n">nr</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">batch</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">==</span> <span class="n">batch</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tlb_next_batch</span><span class="p">(</span><span class="n">tlb</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">batch</span> <span class="o">=</span> <span class="n">tlb</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">batch</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">&gt;</span> <span class="n">batch</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">batch</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">-</span> <span class="n">batch</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* HAVE_GENERIC_MMU_GATHER */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_HAVE_RCU_TABLE_FREE</span>

<span class="cm">/*</span>
<span class="cm"> * See the comment near struct mmu_table_batch.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tlb_remove_table_smp_sync</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Simply deliver the interrupt */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tlb_remove_table_one</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">table</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * This isn&#39;t an RCU grace period and hence the page-tables cannot be</span>
<span class="cm">	 * assumed to be actually RCU-freed.</span>
<span class="cm">	 *</span>
<span class="cm">	 * It is however sufficient for software page-table walkers that rely on</span>
<span class="cm">	 * IRQ disabling. See the comment near struct mmu_table_batch.</span>
<span class="cm">	 */</span>
	<span class="n">smp_call_function</span><span class="p">(</span><span class="n">tlb_remove_table_smp_sync</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">__tlb_remove_table</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tlb_remove_table_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mmu_table_batch</span> <span class="o">*</span><span class="n">batch</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">batch</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mmu_table_batch</span><span class="p">,</span> <span class="n">rcu</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">batch</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">__tlb_remove_table</span><span class="p">(</span><span class="n">batch</span><span class="o">-&gt;</span><span class="n">tables</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">batch</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">tlb_table_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmu_gather</span> <span class="o">*</span><span class="n">tlb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mmu_table_batch</span> <span class="o">**</span><span class="n">batch</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tlb</span><span class="o">-&gt;</span><span class="n">batch</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">batch</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">call_rcu_sched</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">batch</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rcu</span><span class="p">,</span> <span class="n">tlb_remove_table_rcu</span><span class="p">);</span>
		<span class="o">*</span><span class="n">batch</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">tlb_remove_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmu_gather</span> <span class="o">*</span><span class="n">tlb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">table</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mmu_table_batch</span> <span class="o">**</span><span class="n">batch</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tlb</span><span class="o">-&gt;</span><span class="n">batch</span><span class="p">;</span>

	<span class="n">tlb</span><span class="o">-&gt;</span><span class="n">need_flush</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * When there&#39;s less then two users of this mm there cannot be a</span>
<span class="cm">	 * concurrent page-table walk.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlb</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_users</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__tlb_remove_table</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">batch</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">batch</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mmu_table_batch</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_NOWAIT</span> <span class="o">|</span> <span class="n">__GFP_NOWARN</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">batch</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tlb_remove_table_one</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="p">(</span><span class="o">*</span><span class="n">batch</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="p">(</span><span class="o">*</span><span class="n">batch</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tables</span><span class="p">[(</span><span class="o">*</span><span class="n">batch</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">table</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">batch</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">==</span> <span class="n">MAX_TABLE_BATCH</span><span class="p">)</span>
		<span class="n">tlb_table_flush</span><span class="p">(</span><span class="n">tlb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_HAVE_RCU_TABLE_FREE */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * If a p?d_bad entry is found while walking page tables, report</span>
<span class="cm"> * the error, before resetting entry to p?d_none.  Usually (but</span>
<span class="cm"> * very seldom) called out from the p?d_none_or_clear_bad macros.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">pgd_clear_bad</span><span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_ERROR</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">);</span>
	<span class="n">pgd_clear</span><span class="p">(</span><span class="n">pgd</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">pud_clear_bad</span><span class="p">(</span><span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pud_ERROR</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">);</span>
	<span class="n">pud_clear</span><span class="p">(</span><span class="n">pud</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">pmd_clear_bad</span><span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pmd_ERROR</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">);</span>
	<span class="n">pmd_clear</span><span class="p">(</span><span class="n">pmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Note: this doesn&#39;t free the actual pages themselves. That</span>
<span class="cm"> * has been handled earlier when unmapping all the memory regions.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_pte_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmu_gather</span> <span class="o">*</span><span class="n">tlb</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgtable_t</span> <span class="n">token</span> <span class="o">=</span> <span class="n">pmd_pgtable</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">);</span>
	<span class="n">pmd_clear</span><span class="p">(</span><span class="n">pmd</span><span class="p">);</span>
	<span class="n">pte_free_tlb</span><span class="p">(</span><span class="n">tlb</span><span class="p">,</span> <span class="n">token</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">tlb</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">nr_ptes</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">free_pmd_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmu_gather</span> <span class="o">*</span><span class="n">tlb</span><span class="p">,</span> <span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">floor</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ceiling</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">;</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">pmd_addr_end</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmd_none_or_clear_bad</span><span class="p">(</span><span class="n">pmd</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">free_pte_range</span><span class="p">(</span><span class="n">tlb</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">pmd</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">next</span><span class="p">,</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span>

	<span class="n">start</span> <span class="o">&amp;=</span> <span class="n">PUD_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">floor</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ceiling</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ceiling</span> <span class="o">&amp;=</span> <span class="n">PUD_MASK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ceiling</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">ceiling</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
	<span class="n">pud_clear</span><span class="p">(</span><span class="n">pud</span><span class="p">);</span>
	<span class="n">pmd_free_tlb</span><span class="p">(</span><span class="n">tlb</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">free_pud_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmu_gather</span> <span class="o">*</span><span class="n">tlb</span><span class="p">,</span> <span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">floor</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ceiling</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">;</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">pud_addr_end</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pud_none_or_clear_bad</span><span class="p">(</span><span class="n">pud</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">free_pmd_range</span><span class="p">(</span><span class="n">tlb</span><span class="p">,</span> <span class="n">pud</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">floor</span><span class="p">,</span> <span class="n">ceiling</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">pud</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">next</span><span class="p">,</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span>

	<span class="n">start</span> <span class="o">&amp;=</span> <span class="n">PGDIR_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">floor</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ceiling</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ceiling</span> <span class="o">&amp;=</span> <span class="n">PGDIR_MASK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ceiling</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">ceiling</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
	<span class="n">pgd_clear</span><span class="p">(</span><span class="n">pgd</span><span class="p">);</span>
	<span class="n">pud_free_tlb</span><span class="p">(</span><span class="n">tlb</span><span class="p">,</span> <span class="n">pud</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function frees user-level page tables of a process.</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called with pagetable lock held.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">free_pgd_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmu_gather</span> <span class="o">*</span><span class="n">tlb</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">floor</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ceiling</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The next few lines have given us lots of grief...</span>
<span class="cm">	 *</span>
<span class="cm">	 * Why are we testing PMD* at this top level?  Because often</span>
<span class="cm">	 * there will be no work to do at all, and we&#39;d prefer not to</span>
<span class="cm">	 * go all the way down to the bottom just to discover that.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Why all these &quot;- 1&quot;s?  Because 0 represents both the bottom</span>
<span class="cm">	 * of the address space and the top of it (using -1 for the</span>
<span class="cm">	 * top wouldn&#39;t help much: the masks would do the wrong thing).</span>
<span class="cm">	 * The rule is that addr 0 and floor 0 refer to the bottom of</span>
<span class="cm">	 * the address space, but end 0 and ceiling 0 refer to the top</span>
<span class="cm">	 * Comparisons need to use &quot;end - 1&quot; and &quot;ceiling - 1&quot; (though</span>
<span class="cm">	 * that end 0 case should be mythical).</span>
<span class="cm">	 *</span>
<span class="cm">	 * Wherever addr is brought up or ceiling brought down, we must</span>
<span class="cm">	 * be careful to reject &quot;the opposite 0&quot; before it confuses the</span>
<span class="cm">	 * subsequent tests.  But what about where end is brought down</span>
<span class="cm">	 * by PMD_SIZE below? no, end can&#39;t go down to 0 there.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Whereas we round start (addr) and ceiling down, by different</span>
<span class="cm">	 * masks at different levels, in order to test whether a table</span>
<span class="cm">	 * now has no other vmas using it, so can be freed, we don&#39;t</span>
<span class="cm">	 * bother to round floor or end up - the tests don&#39;t need that.</span>
<span class="cm">	 */</span>

	<span class="n">addr</span> <span class="o">&amp;=</span> <span class="n">PMD_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="n">floor</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">addr</span> <span class="o">+=</span> <span class="n">PMD_SIZE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addr</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ceiling</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ceiling</span> <span class="o">&amp;=</span> <span class="n">PMD_MASK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ceiling</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">ceiling</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">end</span> <span class="o">-=</span> <span class="n">PMD_SIZE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;</span> <span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset</span><span class="p">(</span><span class="n">tlb</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">pgd_addr_end</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pgd_none_or_clear_bad</span><span class="p">(</span><span class="n">pgd</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">free_pud_range</span><span class="p">(</span><span class="n">tlb</span><span class="p">,</span> <span class="n">pgd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">floor</span><span class="p">,</span> <span class="n">ceiling</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">pgd</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">next</span><span class="p">,</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">free_pgtables</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmu_gather</span> <span class="o">*</span><span class="n">tlb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">floor</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ceiling</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">vma</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Hide vma from rmap and truncate_pagecache before freeing</span>
<span class="cm">		 * pgtables</span>
<span class="cm">		 */</span>
		<span class="n">unlink_anon_vmas</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
		<span class="n">unlink_file_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_vm_hugetlb_page</span><span class="p">(</span><span class="n">vma</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">hugetlb_free_pgd_range</span><span class="p">(</span><span class="n">tlb</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">,</span>
				<span class="n">floor</span><span class="p">,</span> <span class="n">next</span><span class="o">?</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="o">:</span> <span class="n">ceiling</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Optimization: gather nearby vmas into one call down</span>
<span class="cm">			 */</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">next</span> <span class="o">&amp;&amp;</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&lt;=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">+</span> <span class="n">PMD_SIZE</span>
			       <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_vm_hugetlb_page</span><span class="p">(</span><span class="n">next</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">vma</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
				<span class="n">next</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">;</span>
				<span class="n">unlink_anon_vmas</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
				<span class="n">unlink_file_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">free_pgd_range</span><span class="p">(</span><span class="n">tlb</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">,</span>
				<span class="n">floor</span><span class="p">,</span> <span class="n">next</span><span class="o">?</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="o">:</span> <span class="n">ceiling</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">vma</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">__pte_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgtable_t</span> <span class="n">new</span> <span class="o">=</span> <span class="n">pte_alloc_one</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">wait_split_huge_page</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ensure all pte setup (eg. pte page lock and page clearing) are</span>
<span class="cm">	 * visible before the pte is made visible to other CPUs by being</span>
<span class="cm">	 * put into page tables.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The other side of the story is the pointer chasing in the page</span>
<span class="cm">	 * table walking code (when walking the page table without locking;</span>
<span class="cm">	 * ie. most of the time). Fortunately, these data accesses consist</span>
<span class="cm">	 * of a chain of data-dependent loads, meaning most CPUs (alpha</span>
<span class="cm">	 * being the notable exception) will already guarantee loads are</span>
<span class="cm">	 * seen in-order. See the alpha page table accessors for the</span>
<span class="cm">	 * smp_read_barrier_depends() barriers in page table walking code.</span>
<span class="cm">	 */</span>
	<span class="n">smp_wmb</span><span class="p">();</span> <span class="cm">/* Could be smp_wmb__xxx(before|after)_spin_lock */</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="n">wait_split_huge_page</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">pmd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">)))</span> <span class="p">{</span>	<span class="cm">/* Has another populated it ? */</span>
		<span class="n">mm</span><span class="o">-&gt;</span><span class="n">nr_ptes</span><span class="o">++</span><span class="p">;</span>
		<span class="n">pmd_populate</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
		<span class="n">new</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pmd_trans_splitting</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">)))</span>
		<span class="n">wait_split_huge_page</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="p">)</span>
		<span class="n">pte_free</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wait_split_huge_page</span><span class="p">)</span>
		<span class="n">wait_split_huge_page</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">,</span> <span class="n">pmd</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">__pte_alloc_kernel</span><span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="n">pte_alloc_one_kernel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">smp_wmb</span><span class="p">();</span> <span class="cm">/* See comment in __pte_alloc */</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">.</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">pmd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">)))</span> <span class="p">{</span>	<span class="cm">/* Has another populated it ? */</span>
		<span class="n">pmd_populate_kernel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
		<span class="n">new</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">pmd_trans_splitting</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">));</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">.</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="p">)</span>
		<span class="n">pte_free_kernel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">init_rss_vec</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">rss</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">rss</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">NR_MM_COUNTERS</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">add_mm_rss_vec</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">rss</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">==</span> <span class="n">mm</span><span class="p">)</span>
		<span class="n">sync_mm_rss</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_MM_COUNTERS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rss</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">add_mm_counter</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">rss</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function is called to print an error when a bad pte</span>
<span class="cm"> * is found. For example, we might have a PFN-mapped pte in</span>
<span class="cm"> * a region that doesn&#39;t allow it.</span>
<span class="cm"> *</span>
<span class="cm"> * The calling function must still handle the error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_bad_pte</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			  <span class="n">pte_t</span> <span class="n">pte</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">resume</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_shown</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_unshown</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allow a burst of 60 reports, then keep quiet for that minute;</span>
<span class="cm">	 * or allow a steady drip of one report per second.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_shown</span> <span class="o">==</span> <span class="mi">60</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">resume</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">nr_unshown</span><span class="o">++</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr_unshown</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span>
				<span class="s">&quot;BUG: Bad page map: %lu messages suppressed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">nr_unshown</span><span class="p">);</span>
			<span class="n">nr_unshown</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">nr_shown</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_shown</span><span class="o">++</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">resume</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">60</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>

	<span class="n">mapping</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span> <span class="o">?</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_mapping</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">linear_page_index</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span>
		<span class="s">&quot;BUG: Bad page map in process %s  pte:%08llx pmd:%08llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">),</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">pmd_val</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span>
		<span class="n">dump_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span>
		<span class="s">&quot;addr:%p vm_flags:%08lx anon_vma:%p mapping:%p index:%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Choose text because data symbols depend on CONFIG_KALLSYMS_ALL=y</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="p">)</span>
		<span class="n">print_symbol</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;vma-&gt;vm_ops-&gt;fault: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="o">-&gt;</span><span class="n">fault</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span> <span class="o">&amp;&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="p">)</span>
		<span class="n">print_symbol</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;vma-&gt;vm_file-&gt;f_op-&gt;mmap: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">);</span>
	<span class="n">dump_stack</span><span class="p">();</span>
	<span class="n">add_taint</span><span class="p">(</span><span class="n">TAINT_BAD_PAGE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_cow_mapping</span><span class="p">(</span><span class="n">vm_flags_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_SHARED</span> <span class="o">|</span> <span class="n">VM_MAYWRITE</span><span class="p">))</span> <span class="o">==</span> <span class="n">VM_MAYWRITE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifndef is_zero_pfn</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_zero_pfn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pfn</span> <span class="o">==</span> <span class="n">zero_pfn</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef my_zero_pfn</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">my_zero_pfn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">zero_pfn</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * vm_normal_page -- This function gets the &quot;struct page&quot; associated with a pte.</span>
<span class="cm"> *</span>
<span class="cm"> * &quot;Special&quot; mappings do not wish to be associated with a &quot;struct page&quot; (either</span>
<span class="cm"> * it doesn&#39;t exist, or it exists but they don&#39;t want to touch it). In this</span>
<span class="cm"> * case, NULL is returned here. &quot;Normal&quot; mappings do have a struct page.</span>
<span class="cm"> *</span>
<span class="cm"> * There are 2 broad cases. Firstly, an architecture may define a pte_special()</span>
<span class="cm"> * pte bit, in which case this function is trivial. Secondly, an architecture</span>
<span class="cm"> * may not have a spare pte bit, which requires a more complicated scheme,</span>
<span class="cm"> * described below.</span>
<span class="cm"> *</span>
<span class="cm"> * A raw VM_PFNMAP mapping (ie. one that is not COWed) is always considered a</span>
<span class="cm"> * special mapping (even if there are underlying and valid &quot;struct pages&quot;).</span>
<span class="cm"> * COWed pages of a VM_PFNMAP are always normal.</span>
<span class="cm"> *</span>
<span class="cm"> * The way we recognize COWed pages within VM_PFNMAP mappings is through the</span>
<span class="cm"> * rules set up by &quot;remap_pfn_range()&quot;: the vma will have the VM_PFNMAP bit</span>
<span class="cm"> * set, and the vm_pgoff will point to the first PFN mapped: thus every special</span>
<span class="cm"> * mapping will always honor the rule</span>
<span class="cm"> *</span>
<span class="cm"> *	pfn_of_page == vma-&gt;vm_pgoff + ((addr - vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT)</span>
<span class="cm"> *</span>
<span class="cm"> * And for normal mappings this is false.</span>
<span class="cm"> *</span>
<span class="cm"> * This restricts such mappings to be a linear translation from virtual address</span>
<span class="cm"> * to pfn. To get around this restriction, we allow arbitrary mappings so long</span>
<span class="cm"> * as the vma is not a COW mapping; in that case, we know that all ptes are</span>
<span class="cm"> * special (because none can have been COWed).</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * In order to support COW of arbitrary special mappings, we have VM_MIXEDMAP.</span>
<span class="cm"> *</span>
<span class="cm"> * VM_MIXEDMAP mappings can likewise contain memory with or without &quot;struct</span>
<span class="cm"> * page&quot; backing, however the difference is that _all_ pages with a struct</span>
<span class="cm"> * page (that is, those where pfn_valid is true) are refcounted and considered</span>
<span class="cm"> * normal pages by the VM. The disadvantage is that pages are refcounted</span>
<span class="cm"> * (which can be slower and simply not an option for some PFNMAP users). The</span>
<span class="cm"> * advantage is that we don&#39;t have to follow the strict linearity rule of</span>
<span class="cm"> * PFNMAP mappings in order to support COWable mappings.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#ifdef __HAVE_ARCH_PTE_SPECIAL</span>
<span class="cp"># define HAVE_PTE_SPECIAL 1</span>
<span class="cp">#else</span>
<span class="cp"># define HAVE_PTE_SPECIAL 0</span>
<span class="cp">#endif</span>
<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">vm_normal_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
				<span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span> <span class="o">=</span> <span class="n">pte_pfn</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">HAVE_PTE_SPECIAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">pte_special</span><span class="p">(</span><span class="n">pte</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">check_pfn</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_PFNMAP</span> <span class="o">|</span> <span class="n">VM_MIXEDMAP</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_zero_pfn</span><span class="p">(</span><span class="n">pfn</span><span class="p">))</span>
			<span class="n">print_bad_pte</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* !HAVE_PTE_SPECIAL case follows: */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_PFNMAP</span><span class="o">|</span><span class="n">VM_MIXEDMAP</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_MIXEDMAP</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pfn_valid</span><span class="p">(</span><span class="n">pfn</span><span class="p">))</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">off</span><span class="p">;</span>
			<span class="n">off</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">==</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">+</span> <span class="n">off</span><span class="p">)</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_cow_mapping</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span><span class="p">))</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_zero_pfn</span><span class="p">(</span><span class="n">pfn</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">check_pfn:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pfn</span> <span class="o">&gt;</span> <span class="n">highest_memmap_pfn</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">print_bad_pte</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * NOTE! We still have PageReserved() pages in the page tables.</span>
<span class="cm">	 * eg. VDSO mappings can cause them to exist.</span>
<span class="cm">	 */</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * copy one vm_area from one task to the other. Assumes the page tables</span>
<span class="cm"> * already present in the new task to be cleared in the whole range</span>
<span class="cm"> * covered by this vma.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">copy_one_pte</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">dst_mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">src_mm</span><span class="p">,</span>
		<span class="n">pte_t</span> <span class="o">*</span><span class="n">dst_pte</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">src_pte</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">rss</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vm_flags</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="n">pte</span> <span class="o">=</span> <span class="o">*</span><span class="n">src_pte</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="cm">/* pte contains position in swap or file, so copy. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pte_present</span><span class="p">(</span><span class="n">pte</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_file</span><span class="p">(</span><span class="n">pte</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">swp_entry_t</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">pte_to_swp_entry</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">swap_duplicate</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">entry</span><span class="p">.</span><span class="n">val</span><span class="p">;</span>

			<span class="cm">/* make sure dst_mm is on swapoff&#39;s mmlist. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dst_mm</span><span class="o">-&gt;</span><span class="n">mmlist</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mmlist_lock</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dst_mm</span><span class="o">-&gt;</span><span class="n">mmlist</span><span class="p">))</span>
					<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dst_mm</span><span class="o">-&gt;</span><span class="n">mmlist</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">src_mm</span><span class="o">-&gt;</span><span class="n">mmlist</span><span class="p">);</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mmlist_lock</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">non_swap_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">)))</span>
				<span class="n">rss</span><span class="p">[</span><span class="n">MM_SWAPENTS</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_migration_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">page</span> <span class="o">=</span> <span class="n">migration_entry_to_page</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">PageAnon</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
					<span class="n">rss</span><span class="p">[</span><span class="n">MM_ANONPAGES</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">rss</span><span class="p">[</span><span class="n">MM_FILEPAGES</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">is_write_migration_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				    <span class="n">is_cow_mapping</span><span class="p">(</span><span class="n">vm_flags</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/*</span>
<span class="cm">					 * COW mappings require pages in both</span>
<span class="cm">					 * parent and child to be set to read.</span>
<span class="cm">					 */</span>
					<span class="n">make_migration_entry_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="p">);</span>
					<span class="n">pte</span> <span class="o">=</span> <span class="n">swp_entry_to_pte</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
					<span class="n">set_pte_at</span><span class="p">(</span><span class="n">src_mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">src_pte</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">out_set_pte</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If it&#39;s a COW mapping, write protect it both</span>
<span class="cm">	 * in the parent and the child</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_cow_mapping</span><span class="p">(</span><span class="n">vm_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ptep_set_wrprotect</span><span class="p">(</span><span class="n">src_mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">src_pte</span><span class="p">);</span>
		<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_wrprotect</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If it&#39;s a shared mapping, mark it clean in</span>
<span class="cm">	 * the child</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_SHARED</span><span class="p">)</span>
		<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_mkclean</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
	<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_mkold</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">vm_normal_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">get_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page_dup_rmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageAnon</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="n">rss</span><span class="p">[</span><span class="n">MM_ANONPAGES</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">rss</span><span class="p">[</span><span class="n">MM_FILEPAGES</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out_set_pte:</span>
	<span class="n">set_pte_at</span><span class="p">(</span><span class="n">dst_mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">dst_pte</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">copy_pte_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">dst_mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">src_mm</span><span class="p">,</span>
		   <span class="n">pmd_t</span> <span class="o">*</span><span class="n">dst_pmd</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="n">src_pmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">orig_src_pte</span><span class="p">,</span> <span class="o">*</span><span class="n">orig_dst_pte</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">src_pte</span><span class="p">,</span> <span class="o">*</span><span class="n">dst_pte</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">src_ptl</span><span class="p">,</span> <span class="o">*</span><span class="n">dst_ptl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">progress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rss</span><span class="p">[</span><span class="n">NR_MM_COUNTERS</span><span class="p">];</span>
	<span class="n">swp_entry_t</span> <span class="n">entry</span> <span class="o">=</span> <span class="p">(</span><span class="n">swp_entry_t</span><span class="p">){</span><span class="mi">0</span><span class="p">};</span>

<span class="nl">again:</span>
	<span class="n">init_rss_vec</span><span class="p">(</span><span class="n">rss</span><span class="p">);</span>

	<span class="n">dst_pte</span> <span class="o">=</span> <span class="n">pte_alloc_map_lock</span><span class="p">(</span><span class="n">dst_mm</span><span class="p">,</span> <span class="n">dst_pmd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dst_ptl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dst_pte</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">src_pte</span> <span class="o">=</span> <span class="n">pte_offset_map</span><span class="p">(</span><span class="n">src_pmd</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">src_ptl</span> <span class="o">=</span> <span class="n">pte_lockptr</span><span class="p">(</span><span class="n">src_mm</span><span class="p">,</span> <span class="n">src_pmd</span><span class="p">);</span>
	<span class="n">spin_lock_nested</span><span class="p">(</span><span class="n">src_ptl</span><span class="p">,</span> <span class="n">SINGLE_DEPTH_NESTING</span><span class="p">);</span>
	<span class="n">orig_src_pte</span> <span class="o">=</span> <span class="n">src_pte</span><span class="p">;</span>
	<span class="n">orig_dst_pte</span> <span class="o">=</span> <span class="n">dst_pte</span><span class="p">;</span>
	<span class="n">arch_enter_lazy_mmu_mode</span><span class="p">();</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We are holding two locks at this point - either of them</span>
<span class="cm">		 * could generate latencies in another task on another CPU.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">progress</span> <span class="o">&gt;=</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">progress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">need_resched</span><span class="p">()</span> <span class="o">||</span>
			    <span class="n">spin_needbreak</span><span class="p">(</span><span class="n">src_ptl</span><span class="p">)</span> <span class="o">||</span> <span class="n">spin_needbreak</span><span class="p">(</span><span class="n">dst_ptl</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pte_none</span><span class="p">(</span><span class="o">*</span><span class="n">src_pte</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">progress</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">entry</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">copy_one_pte</span><span class="p">(</span><span class="n">dst_mm</span><span class="p">,</span> <span class="n">src_mm</span><span class="p">,</span> <span class="n">dst_pte</span><span class="p">,</span> <span class="n">src_pte</span><span class="p">,</span>
							<span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">rss</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">progress</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">dst_pte</span><span class="o">++</span><span class="p">,</span> <span class="n">src_pte</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span>

	<span class="n">arch_leave_lazy_mmu_mode</span><span class="p">();</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="n">src_ptl</span><span class="p">);</span>
	<span class="n">pte_unmap</span><span class="p">(</span><span class="n">orig_src_pte</span><span class="p">);</span>
	<span class="n">add_mm_rss_vec</span><span class="p">(</span><span class="n">dst_mm</span><span class="p">,</span> <span class="n">rss</span><span class="p">);</span>
	<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">orig_dst_pte</span><span class="p">,</span> <span class="n">dst_ptl</span><span class="p">);</span>
	<span class="n">cond_resched</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">add_swap_count_continuation</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">progress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">copy_pmd_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">dst_mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">src_mm</span><span class="p">,</span>
		<span class="n">pud_t</span> <span class="o">*</span><span class="n">dst_pud</span><span class="p">,</span> <span class="n">pud_t</span> <span class="o">*</span><span class="n">src_pud</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">src_pmd</span><span class="p">,</span> <span class="o">*</span><span class="n">dst_pmd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next</span><span class="p">;</span>

	<span class="n">dst_pmd</span> <span class="o">=</span> <span class="n">pmd_alloc</span><span class="p">(</span><span class="n">dst_mm</span><span class="p">,</span> <span class="n">dst_pud</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dst_pmd</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">src_pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">src_pud</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">pmd_addr_end</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmd_trans_huge</span><span class="p">(</span><span class="o">*</span><span class="n">src_pmd</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
			<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">next</span><span class="o">-</span><span class="n">addr</span> <span class="o">!=</span> <span class="n">HPAGE_PMD_SIZE</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">copy_huge_pmd</span><span class="p">(</span><span class="n">dst_mm</span><span class="p">,</span> <span class="n">src_mm</span><span class="p">,</span>
					    <span class="n">dst_pmd</span><span class="p">,</span> <span class="n">src_pmd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="cm">/* fall through */</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmd_none_or_clear_bad</span><span class="p">(</span><span class="n">src_pmd</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_pte_range</span><span class="p">(</span><span class="n">dst_mm</span><span class="p">,</span> <span class="n">src_mm</span><span class="p">,</span> <span class="n">dst_pmd</span><span class="p">,</span> <span class="n">src_pmd</span><span class="p">,</span>
						<span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">next</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">dst_pmd</span><span class="o">++</span><span class="p">,</span> <span class="n">src_pmd</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">next</span><span class="p">,</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">copy_pud_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">dst_mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">src_mm</span><span class="p">,</span>
		<span class="n">pgd_t</span> <span class="o">*</span><span class="n">dst_pgd</span><span class="p">,</span> <span class="n">pgd_t</span> <span class="o">*</span><span class="n">src_pgd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">src_pud</span><span class="p">,</span> <span class="o">*</span><span class="n">dst_pud</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next</span><span class="p">;</span>

	<span class="n">dst_pud</span> <span class="o">=</span> <span class="n">pud_alloc</span><span class="p">(</span><span class="n">dst_mm</span><span class="p">,</span> <span class="n">dst_pgd</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dst_pud</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">src_pud</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">src_pgd</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">pud_addr_end</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pud_none_or_clear_bad</span><span class="p">(</span><span class="n">src_pud</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_pmd_range</span><span class="p">(</span><span class="n">dst_mm</span><span class="p">,</span> <span class="n">src_mm</span><span class="p">,</span> <span class="n">dst_pud</span><span class="p">,</span> <span class="n">src_pud</span><span class="p">,</span>
						<span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">next</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">dst_pud</span><span class="o">++</span><span class="p">,</span> <span class="n">src_pud</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">next</span><span class="p">,</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">copy_page_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">dst_mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">src_mm</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">src_pgd</span><span class="p">,</span> <span class="o">*</span><span class="n">dst_pgd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t copy ptes where a page fault will fill them correctly.</span>
<span class="cm">	 * Fork becomes much lighter when there are big shared or private</span>
<span class="cm">	 * readonly mappings. The tradeoff is that copy_page_range is more</span>
<span class="cm">	 * efficient than faulting.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_HUGETLB</span><span class="o">|</span><span class="n">VM_NONLINEAR</span><span class="o">|</span><span class="n">VM_PFNMAP</span><span class="o">|</span><span class="n">VM_INSERTPAGE</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_vm_hugetlb_page</span><span class="p">(</span><span class="n">vma</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">copy_hugetlb_page_range</span><span class="p">(</span><span class="n">dst_mm</span><span class="p">,</span> <span class="n">src_mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">is_pfn_mapping</span><span class="p">(</span><span class="n">vma</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We do not free on error cases below as remove_vma</span>
<span class="cm">		 * gets called on error from higher level routine</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">track_pfn_vma_copy</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to invalidate the secondary MMU mappings only when</span>
<span class="cm">	 * there could be a permission downgrade on the ptes of the</span>
<span class="cm">	 * parent mm. And a permission downgrade will only happen if</span>
<span class="cm">	 * is_cow_mapping() returns true.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_cow_mapping</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span><span class="p">))</span>
		<span class="n">mmu_notifier_invalidate_range_start</span><span class="p">(</span><span class="n">src_mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dst_pgd</span> <span class="o">=</span> <span class="n">pgd_offset</span><span class="p">(</span><span class="n">dst_mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">src_pgd</span> <span class="o">=</span> <span class="n">pgd_offset</span><span class="p">(</span><span class="n">src_mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">pgd_addr_end</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pgd_none_or_clear_bad</span><span class="p">(</span><span class="n">src_pgd</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">copy_pud_range</span><span class="p">(</span><span class="n">dst_mm</span><span class="p">,</span> <span class="n">src_mm</span><span class="p">,</span> <span class="n">dst_pgd</span><span class="p">,</span> <span class="n">src_pgd</span><span class="p">,</span>
					    <span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">next</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">dst_pgd</span><span class="o">++</span><span class="p">,</span> <span class="n">src_pgd</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">next</span><span class="p">,</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_cow_mapping</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span><span class="p">))</span>
		<span class="n">mmu_notifier_invalidate_range_end</span><span class="p">(</span><span class="n">src_mm</span><span class="p">,</span>
						  <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">zap_pte_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmu_gather</span> <span class="o">*</span><span class="n">tlb</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">zap_details</span> <span class="o">*</span><span class="n">details</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">tlb</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">force_flush</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rss</span><span class="p">[</span><span class="n">NR_MM_COUNTERS</span><span class="p">];</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">ptl</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">start_pte</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>

<span class="nl">again:</span>
	<span class="n">init_rss_vec</span><span class="p">(</span><span class="n">rss</span><span class="p">);</span>
	<span class="n">start_pte</span> <span class="o">=</span> <span class="n">pte_offset_map_lock</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptl</span><span class="p">);</span>
	<span class="n">pte</span> <span class="o">=</span> <span class="n">start_pte</span><span class="p">;</span>
	<span class="n">arch_enter_lazy_mmu_mode</span><span class="p">();</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">pte_t</span> <span class="n">ptent</span> <span class="o">=</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pte_none</span><span class="p">(</span><span class="n">ptent</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pte_present</span><span class="p">(</span><span class="n">ptent</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

			<span class="n">page</span> <span class="o">=</span> <span class="n">vm_normal_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptent</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">details</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">page</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * unmap_shared_mapping_pages() wants to</span>
<span class="cm">				 * invalidate cache without truncating:</span>
<span class="cm">				 * unmap shared but keep private pages.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">details</span><span class="o">-&gt;</span><span class="n">check_mapping</span> <span class="o">&amp;&amp;</span>
				    <span class="n">details</span><span class="o">-&gt;</span><span class="n">check_mapping</span> <span class="o">!=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="cm">/*</span>
<span class="cm">				 * Each page-&gt;index must be checked when</span>
<span class="cm">				 * invalidating or truncating nonlinear.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">details</span><span class="o">-&gt;</span><span class="n">nonlinear_vma</span> <span class="o">&amp;&amp;</span>
				    <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">details</span><span class="o">-&gt;</span><span class="n">first_index</span> <span class="o">||</span>
				     <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;</span> <span class="n">details</span><span class="o">-&gt;</span><span class="n">last_index</span><span class="p">))</span>
					<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ptent</span> <span class="o">=</span> <span class="n">ptep_get_and_clear_full</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span>
							<span class="n">tlb</span><span class="o">-&gt;</span><span class="n">fullmm</span><span class="p">);</span>
			<span class="n">tlb_remove_tlb_entry</span><span class="p">(</span><span class="n">tlb</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">details</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">details</span><span class="o">-&gt;</span><span class="n">nonlinear_vma</span>
			    <span class="o">&amp;&amp;</span> <span class="n">linear_page_index</span><span class="p">(</span><span class="n">details</span><span class="o">-&gt;</span><span class="n">nonlinear_vma</span><span class="p">,</span>
						<span class="n">addr</span><span class="p">)</span> <span class="o">!=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">)</span>
				<span class="n">set_pte_at</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span>
					   <span class="n">pgoff_to_pte</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">PageAnon</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
				<span class="n">rss</span><span class="p">[</span><span class="n">MM_ANONPAGES</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">pte_dirty</span><span class="p">(</span><span class="n">ptent</span><span class="p">))</span>
					<span class="n">set_page_dirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">pte_young</span><span class="p">(</span><span class="n">ptent</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				    <span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">VM_SequentialReadHint</span><span class="p">(</span><span class="n">vma</span><span class="p">)))</span>
					<span class="n">mark_page_accessed</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="n">rss</span><span class="p">[</span><span class="n">MM_FILEPAGES</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">page_remove_rmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">page_mapcount</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
				<span class="n">print_bad_pte</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptent</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
			<span class="n">force_flush</span> <span class="o">=</span> <span class="o">!</span><span class="n">__tlb_remove_page</span><span class="p">(</span><span class="n">tlb</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">force_flush</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * If details-&gt;check_mapping, we leave swap entries;</span>
<span class="cm">		 * if details-&gt;nonlinear_vma, we leave file entries.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">details</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pte_file</span><span class="p">(</span><span class="n">ptent</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_NONLINEAR</span><span class="p">)))</span>
				<span class="n">print_bad_pte</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptent</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">swp_entry_t</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">pte_to_swp_entry</span><span class="p">(</span><span class="n">ptent</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">non_swap_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span>
				<span class="n">rss</span><span class="p">[</span><span class="n">MM_SWAPENTS</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_migration_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

				<span class="n">page</span> <span class="o">=</span> <span class="n">migration_entry_to_page</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">PageAnon</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
					<span class="n">rss</span><span class="p">[</span><span class="n">MM_ANONPAGES</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">rss</span><span class="p">[</span><span class="n">MM_FILEPAGES</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">free_swap_and_cache</span><span class="p">(</span><span class="n">entry</span><span class="p">)))</span>
				<span class="n">print_bad_pte</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptent</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">pte_clear_not_present_full</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">tlb</span><span class="o">-&gt;</span><span class="n">fullmm</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">pte</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span>

	<span class="n">add_mm_rss_vec</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">rss</span><span class="p">);</span>
	<span class="n">arch_leave_lazy_mmu_mode</span><span class="p">();</span>
	<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">start_pte</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * mmu_gather ran out of room to batch pages, we break out of</span>
<span class="cm">	 * the PTE lock to avoid doing the potential expensive TLB invalidate</span>
<span class="cm">	 * and page-free while holding it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">force_flush</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">force_flush</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tlb_flush_mmu</span><span class="p">(</span><span class="n">tlb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">zap_pmd_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmu_gather</span> <span class="o">*</span><span class="n">tlb</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">zap_details</span> <span class="o">*</span><span class="n">details</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next</span><span class="p">;</span>

	<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">pmd_addr_end</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmd_trans_huge</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">-</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">HPAGE_PMD_SIZE</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_DEBUG_VM</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rwsem_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlb</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: mmap_sem is unlocked! addr=0x%lx end=0x%lx vma-&gt;vm_start=0x%lx vma-&gt;vm_end=0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">__func__</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span>
						<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span>
						<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">);</span>
					<span class="n">BUG</span><span class="p">();</span>
				<span class="p">}</span>
<span class="cp">#endif</span>
				<span class="n">split_huge_page_pmd</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">zap_huge_pmd</span><span class="p">(</span><span class="n">tlb</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">addr</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
			<span class="cm">/* fall through */</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Here there can be other concurrent MADV_DONTNEED or</span>
<span class="cm">		 * trans huge page faults running, and if the pmd is</span>
<span class="cm">		 * none or trans huge it can change under us. This is</span>
<span class="cm">		 * because MADV_DONTNEED holds the mmap_sem in read</span>
<span class="cm">		 * mode.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmd_none_or_trans_huge_or_clear_bad</span><span class="p">(</span><span class="n">pmd</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">zap_pte_range</span><span class="p">(</span><span class="n">tlb</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">details</span><span class="p">);</span>
<span class="nl">next:</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">pmd</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">next</span><span class="p">,</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">zap_pud_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmu_gather</span> <span class="o">*</span><span class="n">tlb</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">zap_details</span> <span class="o">*</span><span class="n">details</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next</span><span class="p">;</span>

	<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">pud_addr_end</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pud_none_or_clear_bad</span><span class="p">(</span><span class="n">pud</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">zap_pmd_range</span><span class="p">(</span><span class="n">tlb</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">pud</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">details</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">pud</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">next</span><span class="p">,</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unmap_page_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmu_gather</span> <span class="o">*</span><span class="n">tlb</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">zap_details</span> <span class="o">*</span><span class="n">details</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">details</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">details</span><span class="o">-&gt;</span><span class="n">check_mapping</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">details</span><span class="o">-&gt;</span><span class="n">nonlinear_vma</span><span class="p">)</span>
		<span class="n">details</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">);</span>
	<span class="n">mem_cgroup_uncharge_start</span><span class="p">();</span>
	<span class="n">tlb_start_vma</span><span class="p">(</span><span class="n">tlb</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
	<span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">pgd_addr_end</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pgd_none_or_clear_bad</span><span class="p">(</span><span class="n">pgd</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">zap_pud_range</span><span class="p">(</span><span class="n">tlb</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">pgd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">details</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">pgd</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">next</span><span class="p">,</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span>
	<span class="n">tlb_end_vma</span><span class="p">(</span><span class="n">tlb</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
	<span class="n">mem_cgroup_uncharge_end</span><span class="p">();</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">unmap_single_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmu_gather</span> <span class="o">*</span><span class="n">tlb</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_addr</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_addr</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">zap_details</span> <span class="o">*</span><span class="n">details</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span> <span class="n">start_addr</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">,</span> <span class="n">end_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&lt;=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">)</span>
		<span class="n">uprobe_munmap</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">is_pfn_mapping</span><span class="p">(</span><span class="n">vma</span><span class="p">)))</span>
		<span class="n">untrack_pfn_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">!=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">is_vm_hugetlb_page</span><span class="p">(</span><span class="n">vma</span><span class="p">)))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * It is undesirable to test vma-&gt;vm_file as it</span>
<span class="cm">			 * should be non-null for valid hugetlb area.</span>
<span class="cm">			 * However, vm_file will be NULL in the error</span>
<span class="cm">			 * cleanup path of do_mmap_pgoff. When</span>
<span class="cm">			 * hugetlbfs -&gt;mmap method fails,</span>
<span class="cm">			 * do_mmap_pgoff() nullifies vma-&gt;vm_file</span>
<span class="cm">			 * before calling this function to clean up.</span>
<span class="cm">			 * Since no pte has actually been setup, it is</span>
<span class="cm">			 * safe to do nothing in this case.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">)</span>
				<span class="n">unmap_hugepage_range</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">unmap_page_range</span><span class="p">(</span><span class="n">tlb</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">details</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * unmap_vmas - unmap a range of memory covered by a list of vma&#39;s</span>
<span class="cm"> * @tlb: address of the caller&#39;s struct mmu_gather</span>
<span class="cm"> * @vma: the starting vma</span>
<span class="cm"> * @start_addr: virtual address at which to start unmapping</span>
<span class="cm"> * @end_addr: virtual address at which to end unmapping</span>
<span class="cm"> *</span>
<span class="cm"> * Unmap all pages in the vma list.</span>
<span class="cm"> *</span>
<span class="cm"> * Only addresses between `start&#39; and `end&#39; will be unmapped.</span>
<span class="cm"> *</span>
<span class="cm"> * The VMA list must be sorted in ascending virtual address order.</span>
<span class="cm"> *</span>
<span class="cm"> * unmap_vmas() assumes that the caller will flush the whole unmapped address</span>
<span class="cm"> * range after unmap_vmas() returns.  So the only responsibility here is to</span>
<span class="cm"> * ensure that any thus-far unmapped pages are flushed before unmap_vmas()</span>
<span class="cm"> * drops the lock and schedules.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">unmap_vmas</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmu_gather</span> <span class="o">*</span><span class="n">tlb</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_addr</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">;</span>

	<span class="n">mmu_notifier_invalidate_range_start</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">start_addr</span><span class="p">,</span> <span class="n">end_addr</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">vma</span> <span class="o">&amp;&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&lt;</span> <span class="n">end_addr</span><span class="p">;</span> <span class="n">vma</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">)</span>
		<span class="n">unmap_single_vma</span><span class="p">(</span><span class="n">tlb</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">start_addr</span><span class="p">,</span> <span class="n">end_addr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">mmu_notifier_invalidate_range_end</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">start_addr</span><span class="p">,</span> <span class="n">end_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * zap_page_range - remove user pages in a given range</span>
<span class="cm"> * @vma: vm_area_struct holding the applicable pages</span>
<span class="cm"> * @start: starting address of pages to zap</span>
<span class="cm"> * @size: number of bytes to zap</span>
<span class="cm"> * @details: details of nonlinear truncation or shared cache invalidation</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must protect the VMA list</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">zap_page_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="k">struct</span> <span class="n">zap_details</span> <span class="o">*</span><span class="n">details</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mmu_gather</span> <span class="n">tlb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">lru_add_drain</span><span class="p">();</span>
	<span class="n">tlb_gather_mmu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlb</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">update_hiwater_rss</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="n">mmu_notifier_invalidate_range_start</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">vma</span> <span class="o">&amp;&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">vma</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">)</span>
		<span class="n">unmap_single_vma</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlb</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">details</span><span class="p">);</span>
	<span class="n">mmu_notifier_invalidate_range_end</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="n">tlb_finish_mmu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlb</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * zap_page_range_single - remove user pages in a given range</span>
<span class="cm"> * @vma: vm_area_struct holding the applicable pages</span>
<span class="cm"> * @address: starting address of pages to zap</span>
<span class="cm"> * @size: number of bytes to zap</span>
<span class="cm"> * @details: details of nonlinear truncation or shared cache invalidation</span>
<span class="cm"> *</span>
<span class="cm"> * The range must fit into one VMA.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">zap_page_range_single</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="k">struct</span> <span class="n">zap_details</span> <span class="o">*</span><span class="n">details</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mmu_gather</span> <span class="n">tlb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">address</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">lru_add_drain</span><span class="p">();</span>
	<span class="n">tlb_gather_mmu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlb</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">update_hiwater_rss</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="n">mmu_notifier_invalidate_range_start</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="n">unmap_single_vma</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlb</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">details</span><span class="p">);</span>
	<span class="n">mmu_notifier_invalidate_range_end</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="n">tlb_finish_mmu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlb</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * zap_vma_ptes - remove ptes mapping the vma</span>
<span class="cm"> * @vma: vm_area_struct holding ptes to be zapped</span>
<span class="cm"> * @address: starting address of pages to zap</span>
<span class="cm"> * @size: number of bytes to zap</span>
<span class="cm"> *</span>
<span class="cm"> * This function only unmaps ptes assigned to VM_PFNMAP vmas.</span>
<span class="cm"> *</span>
<span class="cm"> * The entire address range must be fully contained within the vma.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if successful.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">zap_vma_ptes</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">&lt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">||</span> <span class="n">address</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">||</span>
	    		<span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_PFNMAP</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">zap_page_range_single</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">zap_vma_ptes</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * follow_page - look up a page descriptor from a user-virtual address</span>
<span class="cm"> * @vma: vm_area_struct mapping @address</span>
<span class="cm"> * @address: virtual address to look up</span>
<span class="cm"> * @flags: flags modifying lookup behaviour</span>
<span class="cm"> *</span>
<span class="cm"> * @flags can have FOLL_ flags set, defined in &lt;linux/mm.h&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the mapped (struct page *), %NULL if no mapping exists, or</span>
<span class="cm"> * an error pointer if there is a mapping to something not represented</span>
<span class="cm"> * by a page descriptor (see also vm_normal_page()).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">follow_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">ptl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">follow_huge_addr</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_WRITE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_GET</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pgd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">)</span> <span class="o">||</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">pgd_bad</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">no_page_table</span><span class="p">;</span>

	<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pud_none</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">no_page_table</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pud_huge</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_HUGETLB</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_GET</span><span class="p">);</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">follow_huge_pud</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pud</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_WRITE</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pud_bad</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">no_page_table</span><span class="p">;</span>

	<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">no_page_table</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmd_huge</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_HUGETLB</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_GET</span><span class="p">);</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">follow_huge_pmd</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_WRITE</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmd_trans_huge</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_SPLIT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">split_huge_page_pmd</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">split_fallthrough</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">pmd_trans_huge</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pmd_trans_splitting</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
				<span class="n">wait_split_huge_page</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">,</span> <span class="n">pmd</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">page</span> <span class="o">=</span> <span class="n">follow_trans_huge_pmd</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span>
							     <span class="n">pmd</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
		<span class="cm">/* fall through */</span>
	<span class="p">}</span>
<span class="nl">split_fallthrough:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pmd_bad</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">no_page_table</span><span class="p">;</span>

	<span class="n">ptep</span> <span class="o">=</span> <span class="n">pte_offset_map_lock</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptl</span><span class="p">);</span>

	<span class="n">pte</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_present</span><span class="p">(</span><span class="n">pte</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">no_page</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pte_write</span><span class="p">(</span><span class="n">pte</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">vm_normal_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_DUMP</span><span class="p">)</span> <span class="o">||</span>
		    <span class="o">!</span><span class="n">is_zero_pfn</span><span class="p">(</span><span class="n">pte_pfn</span><span class="p">(</span><span class="n">pte</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">bad_page</span><span class="p">;</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">pte_page</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_GET</span><span class="p">)</span>
		<span class="n">get_page_foll</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_TOUCH</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">pte_dirty</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="n">set_page_dirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * pte_mkyoung() would be more correct here, but atomic care</span>
<span class="cm">		 * is needed to avoid losing the dirty bit: it is easier to use</span>
<span class="cm">		 * mark_page_accessed().</span>
<span class="cm">		 */</span>
		<span class="n">mark_page_accessed</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_MLOCK</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_LOCKED</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The preliminary mapping check is mainly to avoid the</span>
<span class="cm">		 * pointless overhead of lock_page on the ZERO_PAGE</span>
<span class="cm">		 * which might bounce very badly if there is contention.</span>
<span class="cm">		 *</span>
<span class="cm">		 * If the page is already locked, we don&#39;t need to</span>
<span class="cm">		 * handle it now - vmscan will handle it later if and</span>
<span class="cm">		 * when it attempts to reclaim the page.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">&amp;&amp;</span> <span class="n">trylock_page</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">lru_add_drain</span><span class="p">();</span>  <span class="cm">/* push cached pages to LRU */</span>
			<span class="cm">/*</span>
<span class="cm">			 * Because we lock page here and migration is</span>
<span class="cm">			 * blocked by the pte&#39;s page reference, we need</span>
<span class="cm">			 * only check for file-cache page truncation.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">)</span>
				<span class="n">mlock_vma_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">unlock:</span>
	<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>

<span class="nl">bad_page:</span>
	<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EFAULT</span><span class="p">);</span>

<span class="nl">no_page:</span>
	<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_none</span><span class="p">(</span><span class="n">pte</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">page</span><span class="p">;</span>

<span class="nl">no_page_table:</span>
	<span class="cm">/*</span>
<span class="cm">	 * When core dumping an enormous anonymous area that nobody</span>
<span class="cm">	 * has touched so far, we don&#39;t want to allocate unnecessary pages or</span>
<span class="cm">	 * page tables.  Return error instead of NULL to skip handle_mm_fault,</span>
<span class="cm">	 * then get_dump_page() will return NULL to leave a hole in the dump.</span>
<span class="cm">	 * But we can only make this optimization where a hole would surely</span>
<span class="cm">	 * be zero-filled if handle_mm_fault() actually did handle it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_DUMP</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">||</span> <span class="o">!</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="o">-&gt;</span><span class="n">fault</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EFAULT</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">stack_guard_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">stack_guard_page_start</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span> <span class="o">||</span>
	       <span class="n">stack_guard_page_end</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="o">+</span><span class="n">PAGE_SIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __get_user_pages() - pin user pages in memory</span>
<span class="cm"> * @tsk:	task_struct of target task</span>
<span class="cm"> * @mm:		mm_struct of target mm</span>
<span class="cm"> * @start:	starting user address</span>
<span class="cm"> * @nr_pages:	number of pages from start to pin</span>
<span class="cm"> * @gup_flags:	flags modifying pin behaviour</span>
<span class="cm"> * @pages:	array that receives pointers to the pages pinned.</span>
<span class="cm"> *		Should be at least nr_pages long. Or NULL, if caller</span>
<span class="cm"> *		only intends to ensure the pages are faulted in.</span>
<span class="cm"> * @vmas:	array of pointers to vmas corresponding to each page.</span>
<span class="cm"> *		Or NULL if the caller does not require them.</span>
<span class="cm"> * @nonblocking: whether waiting for disk IO or mmap_sem contention</span>
<span class="cm"> *</span>
<span class="cm"> * Returns number of pages pinned. This may be fewer than the number</span>
<span class="cm"> * requested. If nr_pages is 0 or negative, returns 0. If no pages</span>
<span class="cm"> * were pinned, returns -errno. Each page returned must be released</span>
<span class="cm"> * with a put_page() call when it is finished with. vmas will only</span>
<span class="cm"> * remain valid while mmap_sem is held.</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called with mmap_sem held for read or write.</span>
<span class="cm"> *</span>
<span class="cm"> * __get_user_pages walks a process&#39;s page tables and takes a reference to</span>
<span class="cm"> * each struct page that each user address corresponds to at a given</span>
<span class="cm"> * instant. That is, it takes the page that would be accessed if a user</span>
<span class="cm"> * thread accesses the given user virtual address at that instant.</span>
<span class="cm"> *</span>
<span class="cm"> * This does not guarantee that the page exists in the user mappings when</span>
<span class="cm"> * __get_user_pages returns, and there may even be a completely different</span>
<span class="cm"> * page there in some cases (eg. if mmapped pagecache has been invalidated</span>
<span class="cm"> * and subsequently re faulted). However it does guarantee that the page</span>
<span class="cm"> * won&#39;t be freed completely. And mostly callers simply care that the page</span>
<span class="cm"> * contains data that was valid *at some point in time*. Typically, an IO</span>
<span class="cm"> * or similar operation cannot guarantee anything stronger anyway because</span>
<span class="cm"> * locks can&#39;t be held over the syscall boundary.</span>
<span class="cm"> *</span>
<span class="cm"> * If @gup_flags &amp; FOLL_WRITE == 0, the page must not be written to. If</span>
<span class="cm"> * the page is written to, set_page_dirty (or set_page_dirty_lock, as</span>
<span class="cm"> * appropriate) must be called after the page is finished with, and</span>
<span class="cm"> * before put_page is called.</span>
<span class="cm"> *</span>
<span class="cm"> * If @nonblocking != NULL, __get_user_pages will not wait for disk IO</span>
<span class="cm"> * or mmap_sem contention, and if waiting is needed to pin all pages,</span>
<span class="cm"> * *@nonblocking will be set to 0.</span>
<span class="cm"> *</span>
<span class="cm"> * In most cases, get_user_pages or get_user_pages_fast should be used</span>
<span class="cm"> * instead of __get_user_pages. __get_user_pages should be used only if</span>
<span class="cm"> * you need some special @gup_flags.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__get_user_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gup_flags</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">**</span><span class="n">vmas</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="o">*</span><span class="n">nonblocking</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vm_flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr_pages</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!!</span><span class="n">pages</span> <span class="o">!=</span> <span class="o">!!</span><span class="p">(</span><span class="n">gup_flags</span> <span class="o">&amp;</span> <span class="n">FOLL_GET</span><span class="p">));</span>

	<span class="cm">/* </span>
<span class="cm">	 * Require read or write permissions.</span>
<span class="cm">	 * If FOLL_FORCE is set, we only require the &quot;MAY&quot; flags.</span>
<span class="cm">	 */</span>
	<span class="n">vm_flags</span>  <span class="o">=</span> <span class="p">(</span><span class="n">gup_flags</span> <span class="o">&amp;</span> <span class="n">FOLL_WRITE</span><span class="p">)</span> <span class="o">?</span>
			<span class="p">(</span><span class="n">VM_WRITE</span> <span class="o">|</span> <span class="n">VM_MAYWRITE</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">VM_READ</span> <span class="o">|</span> <span class="n">VM_MAYREAD</span><span class="p">);</span>
	<span class="n">vm_flags</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">gup_flags</span> <span class="o">&amp;</span> <span class="n">FOLL_FORCE</span><span class="p">)</span> <span class="o">?</span>
			<span class="p">(</span><span class="n">VM_MAYREAD</span> <span class="o">|</span> <span class="n">VM_MAYWRITE</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">VM_READ</span> <span class="o">|</span> <span class="n">VM_WRITE</span><span class="p">);</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>

		<span class="n">vma</span> <span class="o">=</span> <span class="n">find_extend_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span> <span class="o">&amp;&amp;</span> <span class="n">in_gate_area</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">start</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pg</span> <span class="o">=</span> <span class="n">start</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
			<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
			<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>
			<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>
			<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>

			<span class="cm">/* user gate pages are read-only */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">gup_flags</span> <span class="o">&amp;</span> <span class="n">FOLL_WRITE</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">i</span> <span class="o">?</span> <span class="o">:</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pg</span> <span class="o">&gt;</span> <span class="n">TASK_SIZE</span><span class="p">)</span>
				<span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset_k</span><span class="p">(</span><span class="n">pg</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset_gate</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pg</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pgd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">));</span>
			<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">pg</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pud_none</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">));</span>
			<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">pg</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pmd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">i</span> <span class="o">?</span> <span class="o">:</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">pmd_trans_huge</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">));</span>
			<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_offset_map</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">pg</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pte_none</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pte_unmap</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">i</span> <span class="o">?</span> <span class="o">:</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">vma</span> <span class="o">=</span> <span class="n">get_gate_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pages</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

				<span class="n">page</span> <span class="o">=</span> <span class="n">vm_normal_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="o">*</span><span class="n">pte</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">gup_flags</span> <span class="o">&amp;</span> <span class="n">FOLL_DUMP</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					     <span class="n">is_zero_pfn</span><span class="p">(</span><span class="n">pte_pfn</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">)))</span>
						<span class="n">page</span> <span class="o">=</span> <span class="n">pte_page</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">);</span>
					<span class="k">else</span> <span class="p">{</span>
						<span class="n">pte_unmap</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
						<span class="k">return</span> <span class="n">i</span> <span class="o">?</span> <span class="o">:</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
				<span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
				<span class="n">get_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">pte_unmap</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">next_page</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_IO</span> <span class="o">|</span> <span class="n">VM_PFNMAP</span><span class="p">))</span> <span class="o">||</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">i</span> <span class="o">?</span> <span class="o">:</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_vm_hugetlb_page</span><span class="p">(</span><span class="n">vma</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">follow_hugetlb_page</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">vmas</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr_pages</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">gup_flags</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">foll_flags</span> <span class="o">=</span> <span class="n">gup_flags</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * If we have a pending SIGKILL, don&#39;t keep faulting</span>
<span class="cm">			 * pages and potentially allocating memory.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">fatal_signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">)))</span>
				<span class="k">return</span> <span class="n">i</span> <span class="o">?</span> <span class="n">i</span> <span class="o">:</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>

			<span class="n">cond_resched</span><span class="p">();</span>
			<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">page</span> <span class="o">=</span> <span class="n">follow_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">foll_flags</span><span class="p">)))</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fault_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

				<span class="cm">/* For mlock, just skip the stack guard page. */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">foll_flags</span> <span class="o">&amp;</span> <span class="n">FOLL_MLOCK</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">stack_guard_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">start</span><span class="p">))</span>
						<span class="k">goto</span> <span class="n">next_page</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">foll_flags</span> <span class="o">&amp;</span> <span class="n">FOLL_WRITE</span><span class="p">)</span>
					<span class="n">fault_flags</span> <span class="o">|=</span> <span class="n">FAULT_FLAG_WRITE</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">nonblocking</span><span class="p">)</span>
					<span class="n">fault_flags</span> <span class="o">|=</span> <span class="n">FAULT_FLAG_ALLOW_RETRY</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">foll_flags</span> <span class="o">&amp;</span> <span class="n">FOLL_NOWAIT</span><span class="p">)</span>
					<span class="n">fault_flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">FAULT_FLAG_ALLOW_RETRY</span> <span class="o">|</span> <span class="n">FAULT_FLAG_RETRY_NOWAIT</span><span class="p">);</span>

				<span class="n">ret</span> <span class="o">=</span> <span class="n">handle_mm_fault</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span>
							<span class="n">fault_flags</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_ERROR</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_OOM</span><span class="p">)</span>
						<span class="k">return</span> <span class="n">i</span> <span class="o">?</span> <span class="n">i</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_FAULT_HWPOISON</span> <span class="o">|</span>
						   <span class="n">VM_FAULT_HWPOISON_LARGE</span><span class="p">))</span> <span class="p">{</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span>
							<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
						<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">gup_flags</span> <span class="o">&amp;</span> <span class="n">FOLL_HWPOISON</span><span class="p">)</span>
							<span class="k">return</span> <span class="o">-</span><span class="n">EHWPOISON</span><span class="p">;</span>
						<span class="k">else</span>
							<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_SIGBUS</span><span class="p">)</span>
						<span class="k">return</span> <span class="n">i</span> <span class="o">?</span> <span class="n">i</span> <span class="o">:</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
					<span class="n">BUG</span><span class="p">();</span>
				<span class="p">}</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_MAJOR</span><span class="p">)</span>
						<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">maj_flt</span><span class="o">++</span><span class="p">;</span>
					<span class="k">else</span>
						<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">min_flt</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_RETRY</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">nonblocking</span><span class="p">)</span>
						<span class="o">*</span><span class="n">nonblocking</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="cm">/*</span>
<span class="cm">				 * The VM_FAULT_WRITE bit tells us that</span>
<span class="cm">				 * do_wp_page has broken COW when necessary,</span>
<span class="cm">				 * even if maybe_mkwrite decided not to set</span>
<span class="cm">				 * pte_write. We can thus safely do subsequent</span>
<span class="cm">				 * page lookups as if they were reads. But only</span>
<span class="cm">				 * do so when looping for pte_write is futile:</span>
<span class="cm">				 * in some cases userspace may also be wanting</span>
<span class="cm">				 * to write to the gotten user page, which a</span>
<span class="cm">				 * read fault here might prevent (a readonly</span>
<span class="cm">				 * page might get reCOWed by userspace write).</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				    <span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_WRITE</span><span class="p">))</span>
					<span class="n">foll_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FOLL_WRITE</span><span class="p">;</span>

				<span class="n">cond_resched</span><span class="p">();</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">i</span> <span class="o">?</span> <span class="n">i</span> <span class="o">:</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pages</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>

				<span class="n">flush_anon_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
				<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="p">}</span>
<span class="nl">next_page:</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vmas</span><span class="p">)</span>
				<span class="n">vmas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vma</span><span class="p">;</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="n">start</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
			<span class="n">nr_pages</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">nr_pages</span> <span class="o">&amp;&amp;</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">nr_pages</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__get_user_pages</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * fixup_user_fault() - manually resolve a user page fault</span>
<span class="cm"> * @tsk:	the task_struct to use for page fault accounting, or</span>
<span class="cm"> *		NULL if faults are not to be recorded.</span>
<span class="cm"> * @mm:		mm_struct of target mm</span>
<span class="cm"> * @address:	user address</span>
<span class="cm"> * @fault_flags:flags to pass down to handle_mm_fault()</span>
<span class="cm"> *</span>
<span class="cm"> * This is meant to be called in the specific scenario where for locking reasons</span>
<span class="cm"> * we try to access user memory in atomic context (within a pagefault_disable()</span>
<span class="cm"> * section), this returns -EFAULT, and we want to resolve the user fault before</span>
<span class="cm"> * trying again.</span>
<span class="cm"> *</span>
<span class="cm"> * Typically this is meant to be used by the futex code.</span>
<span class="cm"> *</span>
<span class="cm"> * The main difference with get_user_pages() is that this function will</span>
<span class="cm"> * unconditionally call handle_mm_fault() which will in turn perform all the</span>
<span class="cm"> * necessary SW fixup of the dirty and young bits in the PTE, while</span>
<span class="cm"> * handle_mm_fault() only guarantees to update these in the struct page.</span>
<span class="cm"> *</span>
<span class="cm"> * This is important for some architectures where those bits also gate the</span>
<span class="cm"> * access permission to the page because they are maintained in software.  On</span>
<span class="cm"> * such architectures, gup() will not be enough to make a subsequent access</span>
<span class="cm"> * succeed.</span>
<span class="cm"> *</span>
<span class="cm"> * This should be called with the mm_sem held for read.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">fixup_user_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fault_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">vma</span> <span class="o">=</span> <span class="n">find_extend_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span> <span class="o">||</span> <span class="n">address</span> <span class="o">&lt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">handle_mm_fault</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">fault_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_OOM</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_FAULT_HWPOISON</span> <span class="o">|</span> <span class="n">VM_FAULT_HWPOISON_LARGE</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EHWPOISON</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_SIGBUS</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_MAJOR</span><span class="p">)</span>
			<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">maj_flt</span><span class="o">++</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">min_flt</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * get_user_pages() - pin user pages in memory</span>
<span class="cm"> * @tsk:	the task_struct to use for page fault accounting, or</span>
<span class="cm"> *		NULL if faults are not to be recorded.</span>
<span class="cm"> * @mm:		mm_struct of target mm</span>
<span class="cm"> * @start:	starting user address</span>
<span class="cm"> * @nr_pages:	number of pages from start to pin</span>
<span class="cm"> * @write:	whether pages will be written to by the caller</span>
<span class="cm"> * @force:	whether to force write access even if user mapping is</span>
<span class="cm"> *		readonly. This will result in the page being COWed even</span>
<span class="cm"> *		in MAP_SHARED mappings. You do not want this.</span>
<span class="cm"> * @pages:	array that receives pointers to the pages pinned.</span>
<span class="cm"> *		Should be at least nr_pages long. Or NULL, if caller</span>
<span class="cm"> *		only intends to ensure the pages are faulted in.</span>
<span class="cm"> * @vmas:	array of pointers to vmas corresponding to each page.</span>
<span class="cm"> *		Or NULL if the caller does not require them.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns number of pages pinned. This may be fewer than the number</span>
<span class="cm"> * requested. If nr_pages is 0 or negative, returns 0. If no pages</span>
<span class="cm"> * were pinned, returns -errno. Each page returned must be released</span>
<span class="cm"> * with a put_page() call when it is finished with. vmas will only</span>
<span class="cm"> * remain valid while mmap_sem is held.</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called with mmap_sem held for read or write.</span>
<span class="cm"> *</span>
<span class="cm"> * get_user_pages walks a process&#39;s page tables and takes a reference to</span>
<span class="cm"> * each struct page that each user address corresponds to at a given</span>
<span class="cm"> * instant. That is, it takes the page that would be accessed if a user</span>
<span class="cm"> * thread accesses the given user virtual address at that instant.</span>
<span class="cm"> *</span>
<span class="cm"> * This does not guarantee that the page exists in the user mappings when</span>
<span class="cm"> * get_user_pages returns, and there may even be a completely different</span>
<span class="cm"> * page there in some cases (eg. if mmapped pagecache has been invalidated</span>
<span class="cm"> * and subsequently re faulted). However it does guarantee that the page</span>
<span class="cm"> * won&#39;t be freed completely. And mostly callers simply care that the page</span>
<span class="cm"> * contains data that was valid *at some point in time*. Typically, an IO</span>
<span class="cm"> * or similar operation cannot guarantee anything stronger anyway because</span>
<span class="cm"> * locks can&#39;t be held over the syscall boundary.</span>
<span class="cm"> *</span>
<span class="cm"> * If write=0, the page must not be written to. If the page is written to,</span>
<span class="cm"> * set_page_dirty (or set_page_dirty_lock, as appropriate) must be called</span>
<span class="cm"> * after the page is finished with, and before put_page is called.</span>
<span class="cm"> *</span>
<span class="cm"> * get_user_pages is typically used for fewer-copy IO operations, to get a</span>
<span class="cm"> * handle on the memory by some means other than accesses via the user virtual</span>
<span class="cm"> * addresses. The pages may be submitted for DMA to devices or accessed via</span>
<span class="cm"> * their kernel linear mapping (via the kmap APIs). Care should be taken to</span>
<span class="cm"> * use the correct cache flushing APIs.</span>
<span class="cm"> *</span>
<span class="cm"> * See also get_user_pages_fast, for performance critical applications.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">get_user_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">**</span><span class="n">vmas</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">FOLL_TOUCH</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pages</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">FOLL_GET</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">FOLL_WRITE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">force</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">FOLL_FORCE</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">__get_user_pages</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">vmas</span><span class="p">,</span>
				<span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">get_user_pages</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * get_dump_page() - pin user page in memory while writing it to core dump</span>
<span class="cm"> * @addr: user address</span>
<span class="cm"> *</span>
<span class="cm"> * Returns struct page pointer of user page pinned for dump,</span>
<span class="cm"> * to be freed afterwards by page_cache_release() or put_page().</span>
<span class="cm"> *</span>
<span class="cm"> * Returns NULL on any kind of failure - a hole must then be inserted into</span>
<span class="cm"> * the corefile, to preserve alignment with its headers; and also returns</span>
<span class="cm"> * NULL wherever the ZERO_PAGE, or an anonymous pte_none, has been found -</span>
<span class="cm"> * allowing a hole to be left in the corefile to save diskspace.</span>
<span class="cm"> *</span>
<span class="cm"> * Called without mmap_sem, but after all other threads have been killed.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_ELF_CORE</span>
<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">get_dump_page</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__get_user_pages</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			     <span class="n">FOLL_FORCE</span> <span class="o">|</span> <span class="n">FOLL_DUMP</span> <span class="o">|</span> <span class="n">FOLL_GET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vma</span><span class="p">,</span>
			     <span class="nb">NULL</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">flush_cache_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ELF_CORE */</span><span class="cp"></span>

<span class="n">pte_t</span> <span class="o">*</span><span class="nf">__get_locked_pte</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			<span class="n">spinlock_t</span> <span class="o">**</span><span class="n">ptl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span> <span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">pud_t</span> <span class="o">*</span> <span class="n">pud</span> <span class="o">=</span> <span class="n">pud_alloc</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pgd</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pud</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmd_t</span> <span class="o">*</span> <span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_alloc</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pud</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">pmd_trans_huge</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">));</span>
			<span class="k">return</span> <span class="n">pte_alloc_map_lock</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is the old fallback for page remapping.</span>
<span class="cm"> *</span>
<span class="cm"> * For historical reasons, it only allows reserved pages. Only</span>
<span class="cm"> * old drivers should use this, and they needed to mark their</span>
<span class="cm"> * pages reserved for the old functions anyway.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">insert_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">ptl</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageAnon</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">pte</span> <span class="o">=</span> <span class="n">get_locked_pte</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_none</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="cm">/* Ok, finally just insert the thing.. */</span>
	<span class="n">get_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">inc_mm_counter_fast</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">MM_FILEPAGES</span><span class="p">);</span>
	<span class="n">page_add_file_rmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">set_pte_at</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">mk_pte</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">prot</span><span class="p">));</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="nl">out_unlock:</span>
	<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vm_insert_page - insert single page into user vma</span>
<span class="cm"> * @vma: user vma to map to</span>
<span class="cm"> * @addr: target user address of this page</span>
<span class="cm"> * @page: source kernel page</span>
<span class="cm"> *</span>
<span class="cm"> * This allows drivers to insert individual pages they&#39;ve allocated</span>
<span class="cm"> * into a user vma.</span>
<span class="cm"> *</span>
<span class="cm"> * The page has to be a nice clean _individual_ kernel allocation.</span>
<span class="cm"> * If you allocate a compound page, you need to have marked it as</span>
<span class="cm"> * such (__GFP_COMP), or manually just split the page up yourself</span>
<span class="cm"> * (see split_page()).</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE! Traditionally this was done with &quot;remap_pfn_range()&quot; which</span>
<span class="cm"> * took an arbitrary page protection parameter. This doesn&#39;t allow</span>
<span class="cm"> * that. Your vma protection will have to be set up correctly, which</span>
<span class="cm"> * means that if you want a shared writable mapping, you&#39;d better</span>
<span class="cm"> * ask for a shared writable mapping!</span>
<span class="cm"> *</span>
<span class="cm"> * The page does not need to be reserved.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">vm_insert_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">||</span> <span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_count</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_INSERTPAGE</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">insert_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vm_insert_page</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">insert_pfn</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">,</span> <span class="n">entry</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">ptl</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">pte</span> <span class="o">=</span> <span class="n">get_locked_pte</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_none</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="cm">/* Ok, finally just insert the thing.. */</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">pte_mkspecial</span><span class="p">(</span><span class="n">pfn_pte</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">prot</span><span class="p">));</span>
	<span class="n">set_pte_at</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
	<span class="n">update_mmu_cache</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span> <span class="cm">/* XXX: why not for insert_page? */</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_unlock:</span>
	<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vm_insert_pfn - insert single pfn into user vma</span>
<span class="cm"> * @vma: user vma to map to</span>
<span class="cm"> * @addr: target user address of this page</span>
<span class="cm"> * @pfn: source kernel pfn</span>
<span class="cm"> *</span>
<span class="cm"> * Similar to vm_inert_page, this allows drivers to insert individual pages</span>
<span class="cm"> * they&#39;ve allocated into a user vma. Same comments apply.</span>
<span class="cm"> *</span>
<span class="cm"> * This function should only be called from a vm_ops-&gt;fault handler, and</span>
<span class="cm"> * in that case the handler should return NULL.</span>
<span class="cm"> *</span>
<span class="cm"> * vma cannot be a COW mapping.</span>
<span class="cm"> *</span>
<span class="cm"> * As this is called only for pages that do not currently exist, we</span>
<span class="cm"> * do not need to flush old virtual caches or the TLB.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">vm_insert_pfn</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">pgprot_t</span> <span class="n">pgprot</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Technically, architectures with pte_special can avoid all these</span>
<span class="cm">	 * restrictions (same for remap_pfn_range).  However we would like</span>
<span class="cm">	 * consistency in testing and feature parity among all, so we should</span>
<span class="cm">	 * try to keep these invariants in place for everybody.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_PFNMAP</span><span class="o">|</span><span class="n">VM_MIXEDMAP</span><span class="p">)));</span>
	<span class="n">BUG_ON</span><span class="p">((</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_PFNMAP</span><span class="o">|</span><span class="n">VM_MIXEDMAP</span><span class="p">))</span> <span class="o">==</span>
						<span class="p">(</span><span class="n">VM_PFNMAP</span><span class="o">|</span><span class="n">VM_MIXEDMAP</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">((</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_PFNMAP</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">is_cow_mapping</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">((</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_MIXEDMAP</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">pfn_valid</span><span class="p">(</span><span class="n">pfn</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">||</span> <span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">track_pfn_vma_new</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pgprot</span><span class="p">,</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">insert_pfn</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">pgprot</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">untrack_pfn_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vm_insert_pfn</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">vm_insert_mixed</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_MIXEDMAP</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">||</span> <span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we don&#39;t have pte special, then we have to use the pfn_valid()</span>
<span class="cm">	 * based VM_MIXEDMAP scheme (see vm_normal_page), and thus we *must*</span>
<span class="cm">	 * refcount the page if pfn_valid is true (hence insert_page rather</span>
<span class="cm">	 * than insert_pfn).  If a zero_pfn were inserted into a VM_MIXEDMAP</span>
<span class="cm">	 * without pte special, it would there be refcounted as a normal page.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">HAVE_PTE_SPECIAL</span> <span class="o">&amp;&amp;</span> <span class="n">pfn_valid</span><span class="p">(</span><span class="n">pfn</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

		<span class="n">page</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">insert_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">insert_pfn</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vm_insert_mixed</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * maps a range of physical memory into the requested pages. the old</span>
<span class="cm"> * mappings are removed. any references to nonexistent pages results</span>
<span class="cm"> * in null mappings (currently treated as &quot;copy-on-access&quot;)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">remap_pte_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">ptl</span><span class="p">;</span>

	<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_alloc_map_lock</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">arch_enter_lazy_mmu_mode</span><span class="p">();</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pte_none</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">));</span>
		<span class="n">set_pte_at</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">pte_mkspecial</span><span class="p">(</span><span class="n">pfn_pte</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">prot</span><span class="p">)));</span>
		<span class="n">pfn</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">pte</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span>
	<span class="n">arch_leave_lazy_mmu_mode</span><span class="p">();</span>
	<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">pte</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">remap_pmd_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next</span><span class="p">;</span>

	<span class="n">pfn</span> <span class="o">-=</span> <span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_alloc</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pud</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmd</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">pmd_trans_huge</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">));</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">pmd_addr_end</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">remap_pte_range</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span>
				<span class="n">pfn</span> <span class="o">+</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">),</span> <span class="n">prot</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">pmd</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">next</span><span class="p">,</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">remap_pud_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next</span><span class="p">;</span>

	<span class="n">pfn</span> <span class="o">-=</span> <span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_alloc</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pgd</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pud</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">pud_addr_end</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">remap_pmd_range</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pud</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span>
				<span class="n">pfn</span> <span class="o">+</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">),</span> <span class="n">prot</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">pud</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">next</span><span class="p">,</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * remap_pfn_range - remap kernel memory to userspace</span>
<span class="cm"> * @vma: user vma to map to</span>
<span class="cm"> * @addr: target user address to start at</span>
<span class="cm"> * @pfn: physical address of kernel memory</span>
<span class="cm"> * @size: size of map area</span>
<span class="cm"> * @prot: page protection flags for this mapping</span>
<span class="cm"> *</span>
<span class="cm"> *  Note: this is only safe if the mm semaphore is held when called.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">remap_pfn_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Physically remapped pages are special. Tell the</span>
<span class="cm">	 * rest of the world about it:</span>
<span class="cm">	 *   VM_IO tells people not to look at these pages</span>
<span class="cm">	 *	(accesses can have side effects).</span>
<span class="cm">	 *   VM_RESERVED is specified all over the place, because</span>
<span class="cm">	 *	in 2.4 it kept swapout&#39;s vma scan off this vma; but</span>
<span class="cm">	 *	in 2.6 the LRU scan won&#39;t even find its pages, so this</span>
<span class="cm">	 *	flag means no more than count its pages in reserved_vm,</span>
<span class="cm">	 * 	and omit it from core dump, even when VM_IO turned off.</span>
<span class="cm">	 *   VM_PFNMAP tells the core MM that the base pages are just</span>
<span class="cm">	 *	raw PFN mappings, and do not have a &quot;struct page&quot; associated</span>
<span class="cm">	 *	with them.</span>
<span class="cm">	 *</span>
<span class="cm">	 * There&#39;s a horrible special case to handle copy-on-write</span>
<span class="cm">	 * behaviour that some programs depend on. We mark the &quot;original&quot;</span>
<span class="cm">	 * un-COW&#39;ed pages by matching them up with &quot;vma-&gt;vm_pgoff&quot;.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">==</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&amp;&amp;</span> <span class="n">end</span> <span class="o">==</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">=</span> <span class="n">pfn</span><span class="p">;</span>
		<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_PFN_AT_MMAP</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_cow_mapping</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_IO</span> <span class="o">|</span> <span class="n">VM_RESERVED</span> <span class="o">|</span> <span class="n">VM_PFNMAP</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">track_pfn_vma_new</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prot</span><span class="p">,</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * To indicate that track_pfn related cleanup is not</span>
<span class="cm">		 * needed from higher level routine calling unmap_vmas</span>
<span class="cm">		 */</span>
		<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">VM_IO</span> <span class="o">|</span> <span class="n">VM_RESERVED</span> <span class="o">|</span> <span class="n">VM_PFNMAP</span><span class="p">);</span>
		<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">VM_PFN_AT_MMAP</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">);</span>
	<span class="n">pfn</span> <span class="o">-=</span> <span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">flush_cache_range</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">pgd_addr_end</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">remap_pud_range</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pgd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span>
				<span class="n">pfn</span> <span class="o">+</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">),</span> <span class="n">prot</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">pgd</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">next</span><span class="p">,</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">untrack_pfn_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">remap_pfn_range</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">apply_to_pte_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
				     <span class="n">pte_fn_t</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">pgtable_t</span> <span class="n">token</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">uninitialized_var</span><span class="p">(</span><span class="n">ptl</span><span class="p">);</span>

	<span class="n">pte</span> <span class="o">=</span> <span class="p">(</span><span class="n">mm</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">init_mm</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">pte_alloc_kernel</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">pte_alloc_map_lock</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pmd_huge</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">));</span>

	<span class="n">arch_enter_lazy_mmu_mode</span><span class="p">();</span>

	<span class="n">token</span> <span class="o">=</span> <span class="n">pmd_pgtable</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="n">pte</span><span class="o">++</span><span class="p">,</span> <span class="n">token</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">addr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span>

	<span class="n">arch_leave_lazy_mmu_mode</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">init_mm</span><span class="p">)</span>
		<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">pte</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">apply_to_pmd_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
				     <span class="n">pte_fn_t</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pud_huge</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">));</span>

	<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_alloc</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pud</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmd</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">pmd_addr_end</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">apply_to_pte_range</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">pmd</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">next</span><span class="p">,</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">apply_to_pud_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
				     <span class="n">pte_fn_t</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_alloc</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pgd</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pud</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">pud_addr_end</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">apply_to_pmd_range</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pud</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">pud</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">next</span><span class="p">,</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Scan a region of virtual memory, filling in page tables as necessary</span>
<span class="cm"> * and calling a provided function on each leaf page table.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">apply_to_page_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="n">pte_fn_t</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">);</span>
	<span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">pgd_addr_end</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">apply_to_pud_range</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pgd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">pgd</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">next</span><span class="p">,</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">apply_to_page_range</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * handle_pte_fault chooses page fault handler according to an entry</span>
<span class="cm"> * which was read non-atomically.  Before making any commitment, on</span>
<span class="cm"> * those architectures or configurations (e.g. i386 with PAE) which</span>
<span class="cm"> * might give a mix of unmatched parts, do_swap_page and do_nonlinear_fault</span>
<span class="cm"> * must check under lock before unmapping the pte and proceeding</span>
<span class="cm"> * (but do_wp_page is only called after already making such a check;</span>
<span class="cm"> * and do_anonymous_page can safely check later on).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_unmap_same</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span>
				<span class="n">pte_t</span> <span class="o">*</span><span class="n">page_table</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">orig_pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">same</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#if defined(CONFIG_SMP) || defined(CONFIG_PREEMPT)</span>
	<span class="k">if</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">pte_t</span><span class="p">)</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">ptl</span> <span class="o">=</span> <span class="n">pte_lockptr</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="n">ptl</span><span class="p">);</span>
		<span class="n">same</span> <span class="o">=</span> <span class="n">pte_same</span><span class="p">(</span><span class="o">*</span><span class="n">page_table</span><span class="p">,</span> <span class="n">orig_pte</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="n">ptl</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">pte_unmap</span><span class="p">(</span><span class="n">page_table</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">same</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cow_user_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">va</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the source page was a PFN mapping, we don&#39;t have</span>
<span class="cm">	 * a &quot;struct page&quot; for it. We do a best-effort copy by</span>
<span class="cm">	 * just copying from the original user address. If that</span>
<span class="cm">	 * fails, we just zero-fill it. Live with it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">src</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">kaddr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">dst</span><span class="p">);</span>
		<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)(</span><span class="n">va</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * This really shouldn&#39;t fail, because the page is there</span>
<span class="cm">		 * in the page tables. But it might just be unreadable,</span>
<span class="cm">		 * in which case we just give up and fill the result with</span>
<span class="cm">		 * zeroes.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__copy_from_user_inatomic</span><span class="p">(</span><span class="n">kaddr</span><span class="p">,</span> <span class="n">uaddr</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">))</span>
			<span class="n">clear_page</span><span class="p">(</span><span class="n">kaddr</span><span class="p">);</span>
		<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">kaddr</span><span class="p">);</span>
		<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">dst</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">copy_user_highpage</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This routine handles present pages, when users try to write</span>
<span class="cm"> * to a shared page. It is done by copying the page to a new address</span>
<span class="cm"> * and decrementing the shared-page counter for the old page.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this routine assumes that the protection checks have been</span>
<span class="cm"> * done by the caller (the low-level page fault routine in most cases).</span>
<span class="cm"> * Thus we can safely just mark it writable once we&#39;ve done any necessary</span>
<span class="cm"> * COW.</span>
<span class="cm"> *</span>
<span class="cm"> * We also mark the page dirty at this point even though the page will</span>
<span class="cm"> * change only once the write actually happens. This avoids a few races,</span>
<span class="cm"> * and potentially makes it more efficient.</span>
<span class="cm"> *</span>
<span class="cm"> * We enter with non-exclusive mmap_sem (to exclude vma changes,</span>
<span class="cm"> * but allow concurrent faults), with pte both mapped and locked.</span>
<span class="cm"> * We return with mmap_sem still held, but pte unmapped and unlocked.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_wp_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">page_table</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span>
		<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">ptl</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">orig_pte</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="n">ptl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">old_page</span><span class="p">,</span> <span class="o">*</span><span class="n">new_page</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="n">entry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">page_mkwrite</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">dirty_page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">old_page</span> <span class="o">=</span> <span class="n">vm_normal_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">orig_pte</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">old_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * VM_MIXEDMAP !pfn_valid() case</span>
<span class="cm">		 *</span>
<span class="cm">		 * We should not cow pages in a shared writeable mapping.</span>
<span class="cm">		 * Just mark the pages writable as we can&#39;t do any dirty</span>
<span class="cm">		 * accounting on raw pfn maps.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_WRITE</span><span class="o">|</span><span class="n">VM_SHARED</span><span class="p">))</span> <span class="o">==</span>
				     <span class="p">(</span><span class="n">VM_WRITE</span><span class="o">|</span><span class="n">VM_SHARED</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">reuse</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">gotten</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Take out anonymous pages first, anonymous shared vmas are</span>
<span class="cm">	 * not dirty accountable.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageAnon</span><span class="p">(</span><span class="n">old_page</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PageKsm</span><span class="p">(</span><span class="n">old_page</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trylock_page</span><span class="p">(</span><span class="n">old_page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">page_cache_get</span><span class="p">(</span><span class="n">old_page</span><span class="p">);</span>
			<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">page_table</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
			<span class="n">lock_page</span><span class="p">(</span><span class="n">old_page</span><span class="p">);</span>
			<span class="n">page_table</span> <span class="o">=</span> <span class="n">pte_offset_map_lock</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span>
							 <span class="o">&amp;</span><span class="n">ptl</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_same</span><span class="p">(</span><span class="o">*</span><span class="n">page_table</span><span class="p">,</span> <span class="n">orig_pte</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">unlock_page</span><span class="p">(</span><span class="n">old_page</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">old_page</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reuse_swap_page</span><span class="p">(</span><span class="n">old_page</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The page is all ours.  Move it to our anon_vma so</span>
<span class="cm">			 * the rmap code will not search our parent or siblings.</span>
<span class="cm">			 * Protected against the rmap code by the page lock.</span>
<span class="cm">			 */</span>
			<span class="n">page_move_anon_rmap</span><span class="p">(</span><span class="n">old_page</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">old_page</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">reuse</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">old_page</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_WRITE</span><span class="o">|</span><span class="n">VM_SHARED</span><span class="p">))</span> <span class="o">==</span>
					<span class="p">(</span><span class="n">VM_WRITE</span><span class="o">|</span><span class="n">VM_SHARED</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Only catch write-faults on shared writable pages,</span>
<span class="cm">		 * read-only shared pages can get COWed by</span>
<span class="cm">		 * get_user_pages(.write=1, .force=1).</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">&amp;&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="o">-&gt;</span><span class="n">page_mkwrite</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">vm_fault</span> <span class="n">vmf</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>

			<span class="n">vmf</span><span class="p">.</span><span class="n">virtual_address</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)(</span><span class="n">address</span> <span class="o">&amp;</span>
								<span class="n">PAGE_MASK</span><span class="p">);</span>
			<span class="n">vmf</span><span class="p">.</span><span class="n">pgoff</span> <span class="o">=</span> <span class="n">old_page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
			<span class="n">vmf</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">FAULT_FLAG_WRITE</span><span class="o">|</span><span class="n">FAULT_FLAG_MKWRITE</span><span class="p">;</span>
			<span class="n">vmf</span><span class="p">.</span><span class="n">page</span> <span class="o">=</span> <span class="n">old_page</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Notify the address space that the page is about to</span>
<span class="cm">			 * become writable so that it can prohibit this or wait</span>
<span class="cm">			 * for the page to get into an appropriate state.</span>
<span class="cm">			 *</span>
<span class="cm">			 * We do this without the lock held, so that it can</span>
<span class="cm">			 * sleep if it needs to.</span>
<span class="cm">			 */</span>
			<span class="n">page_cache_get</span><span class="p">(</span><span class="n">old_page</span><span class="p">);</span>
			<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">page_table</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>

			<span class="n">tmp</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="o">-&gt;</span><span class="n">page_mkwrite</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vmf</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span>
					<span class="p">(</span><span class="n">VM_FAULT_ERROR</span> <span class="o">|</span> <span class="n">VM_FAULT_NOPAGE</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">unwritable_page</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_LOCKED</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">lock_page</span><span class="p">(</span><span class="n">old_page</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">old_page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* retry the fault */</span>
					<span class="n">unlock_page</span><span class="p">(</span><span class="n">old_page</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">unwritable_page</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">old_page</span><span class="p">));</span>

			<span class="cm">/*</span>
<span class="cm">			 * Since we dropped the lock we need to revalidate</span>
<span class="cm">			 * the PTE as someone else may have changed it.  If</span>
<span class="cm">			 * they did, we just return, as we can count on the</span>
<span class="cm">			 * MMU to tell us if they didn&#39;t also make it writable.</span>
<span class="cm">			 */</span>
			<span class="n">page_table</span> <span class="o">=</span> <span class="n">pte_offset_map_lock</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span>
							 <span class="o">&amp;</span><span class="n">ptl</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_same</span><span class="p">(</span><span class="o">*</span><span class="n">page_table</span><span class="p">,</span> <span class="n">orig_pte</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">unlock_page</span><span class="p">(</span><span class="n">old_page</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">page_mkwrite</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dirty_page</span> <span class="o">=</span> <span class="n">old_page</span><span class="p">;</span>
		<span class="n">get_page</span><span class="p">(</span><span class="n">dirty_page</span><span class="p">);</span>

<span class="nl">reuse:</span>
		<span class="n">flush_cache_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte_pfn</span><span class="p">(</span><span class="n">orig_pte</span><span class="p">));</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">pte_mkyoung</span><span class="p">(</span><span class="n">orig_pte</span><span class="p">);</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">maybe_mkwrite</span><span class="p">(</span><span class="n">pte_mkdirty</span><span class="p">(</span><span class="n">entry</span><span class="p">),</span> <span class="n">vma</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ptep_set_access_flags</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">page_table</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
			<span class="n">update_mmu_cache</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">page_table</span><span class="p">);</span>
		<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">page_table</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">VM_FAULT_WRITE</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dirty_page</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Yes, Virginia, this is actually required to prevent a race</span>
<span class="cm">		 * with clear_page_dirty_for_io() from clearing the page dirty</span>
<span class="cm">		 * bit after it clear all dirty ptes, but before a racing</span>
<span class="cm">		 * do_wp_page installs a dirty pte.</span>
<span class="cm">		 *</span>
<span class="cm">		 * __do_fault is protected similarly.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_mkwrite</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wait_on_page_locked</span><span class="p">(</span><span class="n">dirty_page</span><span class="p">);</span>
			<span class="n">set_page_dirty_balance</span><span class="p">(</span><span class="n">dirty_page</span><span class="p">,</span> <span class="n">page_mkwrite</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">dirty_page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_mkwrite</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">dirty_page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">;</span>

			<span class="n">set_page_dirty</span><span class="p">(</span><span class="n">dirty_page</span><span class="p">);</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">dirty_page</span><span class="p">);</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">dirty_page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mapping</span><span class="p">)</span>	<span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Some device drivers do not set page.mapping</span>
<span class="cm">				 * but still dirty their pages</span>
<span class="cm">				 */</span>
				<span class="n">balance_dirty_pages_ratelimited</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* file_update_time outside page_lock */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">)</span>
			<span class="n">file_update_time</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ok, we need to copy. Oh, well..</span>
<span class="cm">	 */</span>
	<span class="n">page_cache_get</span><span class="p">(</span><span class="n">old_page</span><span class="p">);</span>
<span class="nl">gotten:</span>
	<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">page_table</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">anon_vma_prepare</span><span class="p">(</span><span class="n">vma</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">oom</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_zero_pfn</span><span class="p">(</span><span class="n">pte_pfn</span><span class="p">(</span><span class="n">orig_pte</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">new_page</span> <span class="o">=</span> <span class="n">alloc_zeroed_user_highpage_movable</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_page</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">oom</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">new_page</span> <span class="o">=</span> <span class="n">alloc_page_vma</span><span class="p">(</span><span class="n">GFP_HIGHUSER_MOVABLE</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_page</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">oom</span><span class="p">;</span>
		<span class="n">cow_user_page</span><span class="p">(</span><span class="n">new_page</span><span class="p">,</span> <span class="n">old_page</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">__SetPageUptodate</span><span class="p">(</span><span class="n">new_page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_newpage_charge</span><span class="p">(</span><span class="n">new_page</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">oom_free_new</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Re-check the pte - we dropped the lock</span>
<span class="cm">	 */</span>
	<span class="n">page_table</span> <span class="o">=</span> <span class="n">pte_offset_map_lock</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">pte_same</span><span class="p">(</span><span class="o">*</span><span class="n">page_table</span><span class="p">,</span> <span class="n">orig_pte</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">old_page</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageAnon</span><span class="p">(</span><span class="n">old_page</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">dec_mm_counter_fast</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">MM_FILEPAGES</span><span class="p">);</span>
				<span class="n">inc_mm_counter_fast</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">MM_ANONPAGES</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">inc_mm_counter_fast</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">MM_ANONPAGES</span><span class="p">);</span>
		<span class="n">flush_cache_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte_pfn</span><span class="p">(</span><span class="n">orig_pte</span><span class="p">));</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">mk_pte</span><span class="p">(</span><span class="n">new_page</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">);</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">maybe_mkwrite</span><span class="p">(</span><span class="n">pte_mkdirty</span><span class="p">(</span><span class="n">entry</span><span class="p">),</span> <span class="n">vma</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Clear the pte entry and flush it first, before updating the</span>
<span class="cm">		 * pte with the new entry. This will avoid a race condition</span>
<span class="cm">		 * seen in the presence of one thread doing SMC and another</span>
<span class="cm">		 * thread doing COW.</span>
<span class="cm">		 */</span>
		<span class="n">ptep_clear_flush</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">page_table</span><span class="p">);</span>
		<span class="n">page_add_new_anon_rmap</span><span class="p">(</span><span class="n">new_page</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * We call the notify macro here because, when using secondary</span>
<span class="cm">		 * mmu page tables (such as kvm shadow page tables), we want the</span>
<span class="cm">		 * new page to be mapped directly into the secondary page table.</span>
<span class="cm">		 */</span>
		<span class="n">set_pte_at_notify</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">page_table</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
		<span class="n">update_mmu_cache</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">page_table</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">old_page</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Only after switching the pte to the new page may</span>
<span class="cm">			 * we remove the mapcount here. Otherwise another</span>
<span class="cm">			 * process may come and find the rmap count decremented</span>
<span class="cm">			 * before the pte is switched to the new page, and</span>
<span class="cm">			 * &quot;reuse&quot; the old page writing into it while our pte</span>
<span class="cm">			 * here still points into it and can be read by other</span>
<span class="cm">			 * threads.</span>
<span class="cm">			 *</span>
<span class="cm">			 * The critical issue is to order this</span>
<span class="cm">			 * page_remove_rmap with the ptp_clear_flush above.</span>
<span class="cm">			 * Those stores are ordered by (if nothing else,)</span>
<span class="cm">			 * the barrier present in the atomic_add_negative</span>
<span class="cm">			 * in page_remove_rmap.</span>
<span class="cm">			 *</span>
<span class="cm">			 * Then the TLB flush in ptep_clear_flush ensures that</span>
<span class="cm">			 * no process can access the old page before the</span>
<span class="cm">			 * decremented mapcount is visible. And the old page</span>
<span class="cm">			 * cannot be reused until after the decremented</span>
<span class="cm">			 * mapcount is visible. So transitively, TLBs to</span>
<span class="cm">			 * old page will be flushed before it can be reused.</span>
<span class="cm">			 */</span>
			<span class="n">page_remove_rmap</span><span class="p">(</span><span class="n">old_page</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Free the old page.. */</span>
		<span class="n">new_page</span> <span class="o">=</span> <span class="n">old_page</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">VM_FAULT_WRITE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">mem_cgroup_uncharge_page</span><span class="p">(</span><span class="n">new_page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_page</span><span class="p">)</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">new_page</span><span class="p">);</span>
<span class="nl">unlock:</span>
	<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">page_table</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Don&#39;t let another task, with possibly unlocked vma,</span>
<span class="cm">		 * keep the mlocked page.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_LOCKED</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">lock_page</span><span class="p">(</span><span class="n">old_page</span><span class="p">);</span>	<span class="cm">/* LRU manipulation */</span>
			<span class="n">munlock_vma_page</span><span class="p">(</span><span class="n">old_page</span><span class="p">);</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">old_page</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">old_page</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="nl">oom_free_new:</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">new_page</span><span class="p">);</span>
<span class="nl">oom:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_mkwrite</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">old_page</span><span class="p">);</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">old_page</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">old_page</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">VM_FAULT_OOM</span><span class="p">;</span>

<span class="nl">unwritable_page:</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">old_page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unmap_mapping_range_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_addr</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">zap_details</span> <span class="o">*</span><span class="n">details</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">zap_page_range_single</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">start_addr</span><span class="p">,</span> <span class="n">end_addr</span> <span class="o">-</span> <span class="n">start_addr</span><span class="p">,</span> <span class="n">details</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">unmap_mapping_range_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">prio_tree_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">zap_details</span> <span class="o">*</span><span class="n">details</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">prio_tree_iter</span> <span class="n">iter</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">vba</span><span class="p">,</span> <span class="n">vea</span><span class="p">,</span> <span class="n">zba</span><span class="p">,</span> <span class="n">zea</span><span class="p">;</span>

	<span class="n">vma_prio_tree_foreach</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span>
			<span class="n">details</span><span class="o">-&gt;</span><span class="n">first_index</span><span class="p">,</span> <span class="n">details</span><span class="o">-&gt;</span><span class="n">last_index</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">vba</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span><span class="p">;</span>
		<span class="n">vea</span> <span class="o">=</span> <span class="n">vba</span> <span class="o">+</span> <span class="p">((</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Assume for now that PAGE_CACHE_SHIFT == PAGE_SHIFT */</span>
		<span class="n">zba</span> <span class="o">=</span> <span class="n">details</span><span class="o">-&gt;</span><span class="n">first_index</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">zba</span> <span class="o">&lt;</span> <span class="n">vba</span><span class="p">)</span>
			<span class="n">zba</span> <span class="o">=</span> <span class="n">vba</span><span class="p">;</span>
		<span class="n">zea</span> <span class="o">=</span> <span class="n">details</span><span class="o">-&gt;</span><span class="n">last_index</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">zea</span> <span class="o">&gt;</span> <span class="n">vea</span><span class="p">)</span>
			<span class="n">zea</span> <span class="o">=</span> <span class="n">vea</span><span class="p">;</span>

		<span class="n">unmap_mapping_range_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span>
			<span class="p">((</span><span class="n">zba</span> <span class="o">-</span> <span class="n">vba</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span>
			<span class="p">((</span><span class="n">zea</span> <span class="o">-</span> <span class="n">vba</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span>
				<span class="n">details</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">unmap_mapping_range_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">zap_details</span> <span class="o">*</span><span class="n">details</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * In nonlinear VMAs there is no correspondence between virtual address</span>
<span class="cm">	 * offset and file offset.  So we must perform an exhaustive search</span>
<span class="cm">	 * across *all* the pages in each nonlinear VMA, not just the pages</span>
<span class="cm">	 * whose virtual address lies outside the file truncation point.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">shared</span><span class="p">.</span><span class="n">vm_set</span><span class="p">.</span><span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">details</span><span class="o">-&gt;</span><span class="n">nonlinear_vma</span> <span class="o">=</span> <span class="n">vma</span><span class="p">;</span>
		<span class="n">unmap_mapping_range_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">,</span> <span class="n">details</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * unmap_mapping_range - unmap the portion of all mmaps in the specified address_space corresponding to the specified page range in the underlying file.</span>
<span class="cm"> * @mapping: the address space containing mmaps to be unmapped.</span>
<span class="cm"> * @holebegin: byte in first page to unmap, relative to the start of</span>
<span class="cm"> * the underlying file.  This will be rounded down to a PAGE_SIZE</span>
<span class="cm"> * boundary.  Note that this is different from truncate_pagecache(), which</span>
<span class="cm"> * must keep the partial page.  In contrast, we must get rid of</span>
<span class="cm"> * partial pages.</span>
<span class="cm"> * @holelen: size of prospective hole in bytes.  This will be rounded</span>
<span class="cm"> * up to a PAGE_SIZE boundary.  A holelen of zero truncates to the</span>
<span class="cm"> * end of the file.</span>
<span class="cm"> * @even_cows: 1 when truncating a file, unmap even private COWed pages;</span>
<span class="cm"> * but 0 when invalidating pagecache, don&#39;t throw away private data.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">unmap_mapping_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
		<span class="n">loff_t</span> <span class="k">const</span> <span class="n">holebegin</span><span class="p">,</span> <span class="n">loff_t</span> <span class="k">const</span> <span class="n">holelen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">even_cows</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">zap_details</span> <span class="n">details</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">hba</span> <span class="o">=</span> <span class="n">holebegin</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">hlen</span> <span class="o">=</span> <span class="p">(</span><span class="n">holelen</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="cm">/* Check for overflow. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">holelen</span><span class="p">)</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hlen</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">long</span> <span class="kt">long</span> <span class="n">holeend</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">holebegin</span> <span class="o">+</span> <span class="n">holelen</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">holeend</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">ULONG_MAX</span><span class="p">)</span>
			<span class="n">hlen</span> <span class="o">=</span> <span class="n">ULONG_MAX</span> <span class="o">-</span> <span class="n">hba</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">details</span><span class="p">.</span><span class="n">check_mapping</span> <span class="o">=</span> <span class="n">even_cows</span><span class="o">?</span> <span class="nb">NULL</span><span class="o">:</span> <span class="n">mapping</span><span class="p">;</span>
	<span class="n">details</span><span class="p">.</span><span class="n">nonlinear_vma</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">details</span><span class="p">.</span><span class="n">first_index</span> <span class="o">=</span> <span class="n">hba</span><span class="p">;</span>
	<span class="n">details</span><span class="p">.</span><span class="n">last_index</span> <span class="o">=</span> <span class="n">hba</span> <span class="o">+</span> <span class="n">hlen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">details</span><span class="p">.</span><span class="n">last_index</span> <span class="o">&lt;</span> <span class="n">details</span><span class="p">.</span><span class="n">first_index</span><span class="p">)</span>
		<span class="n">details</span><span class="p">.</span><span class="n">last_index</span> <span class="o">=</span> <span class="n">ULONG_MAX</span><span class="p">;</span>


	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">prio_tree_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap</span><span class="p">)))</span>
		<span class="n">unmap_mapping_range_tree</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">details</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_nonlinear</span><span class="p">)))</span>
		<span class="n">unmap_mapping_range_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_nonlinear</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">details</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_mutex</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">unmap_mapping_range</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * We enter with non-exclusive mmap_sem (to exclude vma changes,</span>
<span class="cm"> * but allow concurrent faults), and pte mapped but not yet locked.</span>
<span class="cm"> * We return with mmap_sem still held, but pte unmapped and unlocked.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_swap_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">page_table</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">orig_pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">ptl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="o">*</span><span class="n">swapcache</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">swp_entry_t</span> <span class="n">entry</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="n">pte</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">locked</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">exclusive</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_unmap_same</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">page_table</span><span class="p">,</span> <span class="n">orig_pte</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">pte_to_swp_entry</span><span class="p">(</span><span class="n">orig_pte</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">non_swap_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_migration_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">migration_entry_wait</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_hwpoison_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">VM_FAULT_HWPOISON</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">print_bad_pte</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">orig_pte</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">VM_FAULT_SIGBUS</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">delayacct_set_flag</span><span class="p">(</span><span class="n">DELAYACCT_PF_SWAPIN</span><span class="p">);</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">lookup_swap_cache</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">swapin_readahead</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span>
					<span class="n">GFP_HIGHUSER_MOVABLE</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Back out if somebody else faulted in this pte</span>
<span class="cm">			 * while we released the pte lock.</span>
<span class="cm">			 */</span>
			<span class="n">page_table</span> <span class="o">=</span> <span class="n">pte_offset_map_lock</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptl</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">pte_same</span><span class="p">(</span><span class="o">*</span><span class="n">page_table</span><span class="p">,</span> <span class="n">orig_pte</span><span class="p">)))</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">VM_FAULT_OOM</span><span class="p">;</span>
			<span class="n">delayacct_clear_flag</span><span class="p">(</span><span class="n">DELAYACCT_PF_SWAPIN</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Had to read the page from swap area: Major fault */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">VM_FAULT_MAJOR</span><span class="p">;</span>
		<span class="n">count_vm_event</span><span class="p">(</span><span class="n">PGMAJFAULT</span><span class="p">);</span>
		<span class="n">mem_cgroup_count_vm_event</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">PGMAJFAULT</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">PageHWPoison</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * hwpoisoned dirty swapcache pages are kept for killing</span>
<span class="cm">		 * owner processes (which may be unknown at hwpoison time)</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">VM_FAULT_HWPOISON</span><span class="p">;</span>
		<span class="n">delayacct_clear_flag</span><span class="p">(</span><span class="n">DELAYACCT_PF_SWAPIN</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_release</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">locked</span> <span class="o">=</span> <span class="n">lock_page_or_retry</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">delayacct_clear_flag</span><span class="p">(</span><span class="n">DELAYACCT_PF_SWAPIN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">locked</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">VM_FAULT_RETRY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_release</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure try_to_free_swap or reuse_swap_page or swapoff did not</span>
<span class="cm">	 * release the swapcache from under us.  The page pin, and pte_same</span>
<span class="cm">	 * test below, are not enough to exclude that.  Even if it is still</span>
<span class="cm">	 * swapcache, we need to check that the page&#39;s swap has not changed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">PageSwapCache</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">||</span> <span class="n">page_private</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">!=</span> <span class="n">entry</span><span class="p">.</span><span class="n">val</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_page</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ksm_might_need_to_copy</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">swapcache</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">ksm_does_need_to_copy</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">VM_FAULT_OOM</span><span class="p">;</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">swapcache</span><span class="p">;</span>
			<span class="n">swapcache</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_page</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_try_charge_swapin</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">VM_FAULT_OOM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_page</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Back out if somebody else already faulted in this pte.</span>
<span class="cm">	 */</span>
	<span class="n">page_table</span> <span class="o">=</span> <span class="n">pte_offset_map_lock</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pte_same</span><span class="p">(</span><span class="o">*</span><span class="n">page_table</span><span class="p">,</span> <span class="n">orig_pte</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out_nomap</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">VM_FAULT_SIGBUS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_nomap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The page isn&#39;t present yet, go ahead with the fault.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Be careful about the sequence of operations here.</span>
<span class="cm">	 * To get its accounting right, reuse_swap_page() must be called</span>
<span class="cm">	 * while the page is counted on swap but not yet in mapcount i.e.</span>
<span class="cm">	 * before page_add_anon_rmap() and swap_free(); try_to_free_swap()</span>
<span class="cm">	 * must be called after the swap_free(), or it will never succeed.</span>
<span class="cm">	 * Because delete_from_swap_page() may be called by reuse_swap_page(),</span>
<span class="cm">	 * mem_cgroup_commit_charge_swapin() may not be able to find swp_entry</span>
<span class="cm">	 * in page-&gt;private. In this case, a record in swap_cgroup  is silently</span>
<span class="cm">	 * discarded at swap_free().</span>
<span class="cm">	 */</span>

	<span class="n">inc_mm_counter_fast</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">MM_ANONPAGES</span><span class="p">);</span>
	<span class="n">dec_mm_counter_fast</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">MM_SWAPENTS</span><span class="p">);</span>
	<span class="n">pte</span> <span class="o">=</span> <span class="n">mk_pte</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FAULT_FLAG_WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">reuse_swap_page</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pte</span> <span class="o">=</span> <span class="n">maybe_mkwrite</span><span class="p">(</span><span class="n">pte_mkdirty</span><span class="p">(</span><span class="n">pte</span><span class="p">),</span> <span class="n">vma</span><span class="p">);</span>
		<span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FAULT_FLAG_WRITE</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">VM_FAULT_WRITE</span><span class="p">;</span>
		<span class="n">exclusive</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">flush_icache_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
	<span class="n">set_pte_at</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">page_table</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
	<span class="n">do_page_add_anon_rmap</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">exclusive</span><span class="p">);</span>
	<span class="cm">/* It&#39;s better to call commit-charge after rmap is established */</span>
	<span class="n">mem_cgroup_commit_charge_swapin</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>

	<span class="n">swap_free</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vm_swap_full</span><span class="p">()</span> <span class="o">||</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_LOCKED</span><span class="p">)</span> <span class="o">||</span> <span class="n">PageMlocked</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">try_to_free_swap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">swapcache</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Hold the lock to avoid the swap entry to be reused</span>
<span class="cm">		 * until we take the PT lock for the pte_same() check</span>
<span class="cm">		 * (to avoid false positives from pte_same). For</span>
<span class="cm">		 * further safety release the lock after the swap_free</span>
<span class="cm">		 * so that the swap count won&#39;t change under a</span>
<span class="cm">		 * parallel locked swapcache.</span>
<span class="cm">		 */</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">swapcache</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">swapcache</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FAULT_FLAG_WRITE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">do_wp_page</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">page_table</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">ptl</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_ERROR</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">&amp;=</span> <span class="n">VM_FAULT_ERROR</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* No need to invalidate - it was non-present before */</span>
	<span class="n">update_mmu_cache</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">page_table</span><span class="p">);</span>
<span class="nl">unlock:</span>
	<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">page_table</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="nl">out_nomap:</span>
	<span class="n">mem_cgroup_cancel_charge_swapin</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
	<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">page_table</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
<span class="nl">out_page:</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="nl">out_release:</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">swapcache</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">swapcache</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">swapcache</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is like a special single-page &quot;expand_{down|up}wards()&quot;,</span>
<span class="cm"> * except we must first make sure that &#39;address{-|+}PAGE_SIZE&#39;</span>
<span class="cm"> * doesn&#39;t hit another vma.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">check_stack_guard_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">address</span> <span class="o">&amp;=</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_GROWSDOWN</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">address</span> <span class="o">==</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_prev</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Is there a mapping abutting this one below?</span>
<span class="cm">		 *</span>
<span class="cm">		 * That&#39;s only ok if it&#39;s the same stack mapping</span>
<span class="cm">		 * that has gotten split..</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">&amp;&amp;</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">==</span> <span class="n">address</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_GROWSDOWN</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">expand_downwards</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span> <span class="o">-</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_GROWSUP</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">address</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">==</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">;</span>

		<span class="cm">/* As VM_GROWSDOWN but s/below/above/ */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">&amp;&amp;</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">==</span> <span class="n">address</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_GROWSUP</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">expand_upwards</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We enter with non-exclusive mmap_sem (to exclude vma changes,</span>
<span class="cm"> * but allow concurrent faults), and pte mapped but not yet locked.</span>
<span class="cm"> * We return with mmap_sem still held, but pte unmapped and unlocked.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_anonymous_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">page_table</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">ptl</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="n">entry</span><span class="p">;</span>

	<span class="n">pte_unmap</span><span class="p">(</span><span class="n">page_table</span><span class="p">);</span>

	<span class="cm">/* Check if we need to add a guard page to the stack */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_stack_guard_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">VM_FAULT_SIGBUS</span><span class="p">;</span>

	<span class="cm">/* Use the zero-page for reads */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FAULT_FLAG_WRITE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">pte_mkspecial</span><span class="p">(</span><span class="n">pfn_pte</span><span class="p">(</span><span class="n">my_zero_pfn</span><span class="p">(</span><span class="n">address</span><span class="p">),</span>
						<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">));</span>
		<span class="n">page_table</span> <span class="o">=</span> <span class="n">pte_offset_map_lock</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptl</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_none</span><span class="p">(</span><span class="o">*</span><span class="n">page_table</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">setpte</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate our own private page. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">anon_vma_prepare</span><span class="p">(</span><span class="n">vma</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">oom</span><span class="p">;</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_zeroed_user_highpage_movable</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">oom</span><span class="p">;</span>
	<span class="n">__SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_newpage_charge</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">oom_free_page</span><span class="p">;</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">mk_pte</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_WRITE</span><span class="p">)</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">pte_mkwrite</span><span class="p">(</span><span class="n">pte_mkdirty</span><span class="p">(</span><span class="n">entry</span><span class="p">));</span>

	<span class="n">page_table</span> <span class="o">=</span> <span class="n">pte_offset_map_lock</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_none</span><span class="p">(</span><span class="o">*</span><span class="n">page_table</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">release</span><span class="p">;</span>

	<span class="n">inc_mm_counter_fast</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">MM_ANONPAGES</span><span class="p">);</span>
	<span class="n">page_add_new_anon_rmap</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
<span class="nl">setpte:</span>
	<span class="n">set_pte_at</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">page_table</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>

	<span class="cm">/* No need to invalidate - it was non-present before */</span>
	<span class="n">update_mmu_cache</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">page_table</span><span class="p">);</span>
<span class="nl">unlock:</span>
	<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">page_table</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">release:</span>
	<span class="n">mem_cgroup_uncharge_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
<span class="nl">oom_free_page:</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="nl">oom:</span>
	<span class="k">return</span> <span class="n">VM_FAULT_OOM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * __do_fault() tries to create a new page mapping. It aggressively</span>
<span class="cm"> * tries to share with existing pages, but makes a separate copy if</span>
<span class="cm"> * the FAULT_FLAG_WRITE is set in the flags parameter in order to avoid</span>
<span class="cm"> * the next page fault.</span>
<span class="cm"> *</span>
<span class="cm"> * As this is called only for pages that do not currently exist, we</span>
<span class="cm"> * do not need to flush old virtual caches or the TLB.</span>
<span class="cm"> *</span>
<span class="cm"> * We enter with non-exclusive mmap_sem (to exclude vma changes,</span>
<span class="cm"> * but allow concurrent faults), and pte neither mapped nor locked.</span>
<span class="cm"> * We return with mmap_sem still held, but pte unmapped and unlocked.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__do_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span>
		<span class="n">pgoff_t</span> <span class="n">pgoff</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">orig_pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">page_table</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">ptl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">cow_page</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="n">entry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">anon</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">dirty_page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_fault</span> <span class="n">vmf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">page_mkwrite</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we do COW later, allocate page befor taking lock_page()</span>
<span class="cm">	 * on the file cache page. This will reduce lock holding time.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FAULT_FLAG_WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_SHARED</span><span class="p">))</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">anon_vma_prepare</span><span class="p">(</span><span class="n">vma</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">VM_FAULT_OOM</span><span class="p">;</span>

		<span class="n">cow_page</span> <span class="o">=</span> <span class="n">alloc_page_vma</span><span class="p">(</span><span class="n">GFP_HIGHUSER_MOVABLE</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cow_page</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">VM_FAULT_OOM</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_newpage_charge</span><span class="p">(</span><span class="n">cow_page</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">cow_page</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">VM_FAULT_OOM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">cow_page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">vmf</span><span class="p">.</span><span class="n">virtual_address</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)(</span><span class="n">address</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">);</span>
	<span class="n">vmf</span><span class="p">.</span><span class="n">pgoff</span> <span class="o">=</span> <span class="n">pgoff</span><span class="p">;</span>
	<span class="n">vmf</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">vmf</span><span class="p">.</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="o">-&gt;</span><span class="n">fault</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vmf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_FAULT_ERROR</span> <span class="o">|</span> <span class="n">VM_FAULT_NOPAGE</span> <span class="o">|</span>
			    <span class="n">VM_FAULT_RETRY</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">uncharge_out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">PageHWPoison</span><span class="p">(</span><span class="n">vmf</span><span class="p">.</span><span class="n">page</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_LOCKED</span><span class="p">)</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">vmf</span><span class="p">.</span><span class="n">page</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">VM_FAULT_HWPOISON</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">uncharge_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * For consistency in subsequent calls, make the faulted page always</span>
<span class="cm">	 * locked.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_LOCKED</span><span class="p">)))</span>
		<span class="n">lock_page</span><span class="p">(</span><span class="n">vmf</span><span class="p">.</span><span class="n">page</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">vmf</span><span class="p">.</span><span class="n">page</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Should we do an early C-O-W break?</span>
<span class="cm">	 */</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">vmf</span><span class="p">.</span><span class="n">page</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FAULT_FLAG_WRITE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_SHARED</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">cow_page</span><span class="p">;</span>
			<span class="n">anon</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">copy_user_highpage</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vmf</span><span class="p">.</span><span class="n">page</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
			<span class="n">__SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If the page will be shareable, see if the backing</span>
<span class="cm">			 * address space wants to know that the page is about</span>
<span class="cm">			 * to become writable</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="o">-&gt;</span><span class="n">page_mkwrite</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>

				<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="n">vmf</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">FAULT_FLAG_WRITE</span><span class="o">|</span><span class="n">FAULT_FLAG_MKWRITE</span><span class="p">;</span>
				<span class="n">tmp</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="o">-&gt;</span><span class="n">page_mkwrite</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vmf</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span>
					  <span class="p">(</span><span class="n">VM_FAULT_ERROR</span> <span class="o">|</span> <span class="n">VM_FAULT_NOPAGE</span><span class="p">)))</span> <span class="p">{</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">unwritable_page</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_LOCKED</span><span class="p">)))</span> <span class="p">{</span>
					<span class="n">lock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* retry the fault */</span>
						<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
						<span class="k">goto</span> <span class="n">unwritable_page</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span> <span class="k">else</span>
					<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
				<span class="n">page_mkwrite</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

	<span class="p">}</span>

	<span class="n">page_table</span> <span class="o">=</span> <span class="n">pte_offset_map_lock</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptl</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This silly early PAGE_DIRTY setting removes a race</span>
<span class="cm">	 * due to the bad i386 page protection. But it&#39;s valid</span>
<span class="cm">	 * for other architectures too.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note that if FAULT_FLAG_WRITE is set, we either now have</span>
<span class="cm">	 * an exclusive copy of the page, or this is a shared mapping,</span>
<span class="cm">	 * so we can make it writable and dirty to avoid having to</span>
<span class="cm">	 * handle that later.</span>
<span class="cm">	 */</span>
	<span class="cm">/* Only go through if we didn&#39;t race with anybody else... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">pte_same</span><span class="p">(</span><span class="o">*</span><span class="n">page_table</span><span class="p">,</span> <span class="n">orig_pte</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">flush_icache_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">mk_pte</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FAULT_FLAG_WRITE</span><span class="p">)</span>
			<span class="n">entry</span> <span class="o">=</span> <span class="n">maybe_mkwrite</span><span class="p">(</span><span class="n">pte_mkdirty</span><span class="p">(</span><span class="n">entry</span><span class="p">),</span> <span class="n">vma</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">anon</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">inc_mm_counter_fast</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">MM_ANONPAGES</span><span class="p">);</span>
			<span class="n">page_add_new_anon_rmap</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">inc_mm_counter_fast</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">MM_FILEPAGES</span><span class="p">);</span>
			<span class="n">page_add_file_rmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FAULT_FLAG_WRITE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dirty_page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
				<span class="n">get_page</span><span class="p">(</span><span class="n">dirty_page</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">set_pte_at</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">page_table</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>

		<span class="cm">/* no need to invalidate: a not-present page won&#39;t be cached */</span>
		<span class="n">update_mmu_cache</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">page_table</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cow_page</span><span class="p">)</span>
			<span class="n">mem_cgroup_uncharge_page</span><span class="p">(</span><span class="n">cow_page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">anon</span><span class="p">)</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">anon</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* no anon but release faulted_page */</span>
	<span class="p">}</span>

	<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">page_table</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dirty_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">set_page_dirty</span><span class="p">(</span><span class="n">dirty_page</span><span class="p">))</span>
			<span class="n">page_mkwrite</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">dirty_page</span><span class="p">);</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">dirty_page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_mkwrite</span> <span class="o">&amp;&amp;</span> <span class="n">mapping</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Some device drivers do not set page.mapping but still</span>
<span class="cm">			 * dirty their pages</span>
<span class="cm">			 */</span>
			<span class="n">balance_dirty_pages_ratelimited</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* file_update_time outside page_lock */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">)</span>
			<span class="n">file_update_time</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">vmf</span><span class="p">.</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">anon</span><span class="p">)</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">vmf</span><span class="p">.</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">unwritable_page:</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="nl">uncharge_out:</span>
	<span class="cm">/* fs&#39;s fault handler get error */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cow_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mem_cgroup_uncharge_page</span><span class="p">(</span><span class="n">cow_page</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">cow_page</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_linear_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">page_table</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">orig_pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgoff_t</span> <span class="n">pgoff</span> <span class="o">=</span> <span class="p">(((</span><span class="n">address</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">)</span>
			<span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span><span class="p">;</span>

	<span class="n">pte_unmap</span><span class="p">(</span><span class="n">page_table</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">__do_fault</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">pgoff</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">orig_pte</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Fault of a previously existing named mapping. Repopulate the pte</span>
<span class="cm"> * from the encoded file_pte if possible. This enables swappable</span>
<span class="cm"> * nonlinear vmas.</span>
<span class="cm"> *</span>
<span class="cm"> * We enter with non-exclusive mmap_sem (to exclude vma changes,</span>
<span class="cm"> * but allow concurrent faults), and pte mapped but not yet locked.</span>
<span class="cm"> * We return with mmap_sem still held, but pte unmapped and unlocked.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_nonlinear_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">page_table</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">orig_pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgoff_t</span> <span class="n">pgoff</span><span class="p">;</span>

	<span class="n">flags</span> <span class="o">|=</span> <span class="n">FAULT_FLAG_NONLINEAR</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_unmap_same</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">page_table</span><span class="p">,</span> <span class="n">orig_pte</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_NONLINEAR</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Page table corrupted: show pte and kill process.</span>
<span class="cm">		 */</span>
		<span class="n">print_bad_pte</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">orig_pte</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">VM_FAULT_SIGBUS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pgoff</span> <span class="o">=</span> <span class="n">pte_to_pgoff</span><span class="p">(</span><span class="n">orig_pte</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">__do_fault</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">pgoff</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">orig_pte</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * These routines also need to handle stuff like marking pages dirty</span>
<span class="cm"> * and/or accessed for architectures that don&#39;t do it in hardware (most</span>
<span class="cm"> * RISC architectures).  The early dirtying is also good on the i386.</span>
<span class="cm"> *</span>
<span class="cm"> * There is also a hook called &quot;update_mmu_cache()&quot; that architectures</span>
<span class="cm"> * with external mmu caches can use to update those (ie the Sparc or</span>
<span class="cm"> * PowerPC hashed page tables that act as extended TLBs).</span>
<span class="cm"> *</span>
<span class="cm"> * We enter with non-exclusive mmap_sem (to exclude vma changes,</span>
<span class="cm"> * but allow concurrent faults), and pte mapped but not yet locked.</span>
<span class="cm"> * We return with mmap_sem still held, but pte unmapped and unlocked.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">handle_pte_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
		     <span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span> <span class="n">entry</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">ptl</span><span class="p">;</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_present</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pte_none</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="o">-&gt;</span><span class="n">fault</span><span class="p">))</span>
					<span class="k">return</span> <span class="n">do_linear_fault</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span>
						<span class="n">pte</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="n">do_anonymous_page</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span>
						 <span class="n">pte</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pte_file</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">do_nonlinear_fault</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span>
					<span class="n">pte</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">do_swap_page</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span>
					<span class="n">pte</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ptl</span> <span class="o">=</span> <span class="n">pte_lockptr</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="n">ptl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pte_same</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">,</span> <span class="n">entry</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FAULT_FLAG_WRITE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_write</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">do_wp_page</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span>
					<span class="n">pte</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">ptl</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">pte_mkdirty</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">pte_mkyoung</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ptep_set_access_flags</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FAULT_FLAG_WRITE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">update_mmu_cache</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This is needed only for protection faults but the arch code</span>
<span class="cm">		 * is not yet telling us if this is a protection fault or not.</span>
<span class="cm">		 * This still avoids useless tlb flushes for .text page faults</span>
<span class="cm">		 * with threads.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FAULT_FLAG_WRITE</span><span class="p">)</span>
			<span class="n">flush_tlb_fix_spurious_fault</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">unlock:</span>
	<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * By the time we get here, we already hold the mm semaphore</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">handle_mm_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>

	<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>

	<span class="n">count_vm_event</span><span class="p">(</span><span class="n">PGFAULT</span><span class="p">);</span>
	<span class="n">mem_cgroup_count_vm_event</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">PGFAULT</span><span class="p">);</span>

	<span class="cm">/* do counter updates before entering really critical section. */</span>
	<span class="n">check_sync_rss_stat</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">is_vm_hugetlb_page</span><span class="p">(</span><span class="n">vma</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">hugetlb_fault</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

<span class="nl">retry:</span>
	<span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_alloc</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pgd</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pud</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">VM_FAULT_OOM</span><span class="p">;</span>
	<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_alloc</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pud</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmd</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">VM_FAULT_OOM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">transparent_hugepage_enabled</span><span class="p">(</span><span class="n">vma</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">do_huge_pmd_anonymous_page</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span>
							  <span class="n">pmd</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pmd_t</span> <span class="n">orig_pmd</span> <span class="o">=</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">barrier</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmd_trans_huge</span><span class="p">(</span><span class="n">orig_pmd</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FAULT_FLAG_WRITE</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="n">pmd_write</span><span class="p">(</span><span class="n">orig_pmd</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="n">pmd_trans_splitting</span><span class="p">(</span><span class="n">orig_pmd</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">do_huge_pmd_wp_page</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span>
							  <span class="n">orig_pmd</span><span class="p">);</span>
				<span class="cm">/*</span>
<span class="cm">				 * If COW results in an oom, the huge pmd will</span>
<span class="cm">				 * have been split, so retry the fault on the</span>
<span class="cm">				 * pte for a smaller charge.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_OOM</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Use __pte_alloc instead of pte_alloc_map, because we can&#39;t</span>
<span class="cm">	 * run pte_offset_map on the pmd, if an huge pmd could</span>
<span class="cm">	 * materialize from under us from a different thread.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pmd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">__pte_alloc</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">address</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">VM_FAULT_OOM</span><span class="p">;</span>
	<span class="cm">/* if an huge pmd materialized from under us just retry later */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pmd_trans_huge</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * A regular pmd is established and it can&#39;t morph into a huge pmd</span>
<span class="cm">	 * from under us anymore at this point because we hold the mmap_sem</span>
<span class="cm">	 * read mode and khugepaged takes it in write mode. So now it&#39;s</span>
<span class="cm">	 * safe to run pte_offset_map().</span>
<span class="cm">	 */</span>
	<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_offset_map</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">handle_pte_fault</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifndef __PAGETABLE_PUD_FOLDED</span>
<span class="cm">/*</span>
<span class="cm"> * Allocate page upper directory.</span>
<span class="cm"> * We&#39;ve already handled the fast-path in-line.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__pud_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="n">pud_alloc_one</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">smp_wmb</span><span class="p">();</span> <span class="cm">/* See comment in __pte_alloc */</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pgd_present</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">))</span>		<span class="cm">/* Another has populated it */</span>
		<span class="n">pud_free</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">pgd_populate</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pgd</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* __PAGETABLE_PUD_FOLDED */</span><span class="cp"></span>

<span class="cp">#ifndef __PAGETABLE_PMD_FOLDED</span>
<span class="cm">/*</span>
<span class="cm"> * Allocate page middle directory.</span>
<span class="cm"> * We&#39;ve already handled the fast-path in-line.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__pmd_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="n">pmd_alloc_one</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">smp_wmb</span><span class="p">();</span> <span class="cm">/* See comment in __pte_alloc */</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
<span class="cp">#ifndef __ARCH_HAS_4LEVEL_HACK</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pud_present</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">))</span>		<span class="cm">/* Another has populated it */</span>
		<span class="n">pmd_free</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">pud_populate</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pud</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pgd_present</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">))</span>		<span class="cm">/* Another has populated it */</span>
		<span class="n">pmd_free</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">pgd_populate</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pud</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* __ARCH_HAS_4LEVEL_HACK */</span><span class="cp"></span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* __PAGETABLE_PMD_FOLDED */</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">make_pages_present</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">write</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span> <span class="n">vma</span><span class="p">;</span>

	<span class="n">vma</span> <span class="o">=</span> <span class="n">find_vma</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We want to touch writable mappings with a write fault in order</span>
<span class="cm">	 * to break COW, except for shared mappings because these don&#39;t COW</span>
<span class="cm">	 * and we would not want to dirty them for nothing.</span>
<span class="cm">	 */</span>
	<span class="n">write</span> <span class="o">=</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_WRITE</span> <span class="o">|</span> <span class="n">VM_SHARED</span><span class="p">))</span> <span class="o">==</span> <span class="n">VM_WRITE</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="o">-</span> <span class="n">addr</span><span class="o">/</span><span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_user_pages</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span>
			<span class="n">len</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span> <span class="o">==</span> <span class="n">len</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if !defined(__HAVE_ARCH_GATE_AREA)</span>

<span class="cp">#if defined(AT_SYSINFO_EHDR)</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="n">gate_vma</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">gate_vma_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">gate_vma</span><span class="p">.</span><span class="n">vm_mm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">gate_vma</span><span class="p">.</span><span class="n">vm_start</span> <span class="o">=</span> <span class="n">FIXADDR_USER_START</span><span class="p">;</span>
	<span class="n">gate_vma</span><span class="p">.</span><span class="n">vm_end</span> <span class="o">=</span> <span class="n">FIXADDR_USER_END</span><span class="p">;</span>
	<span class="n">gate_vma</span><span class="p">.</span><span class="n">vm_flags</span> <span class="o">=</span> <span class="n">VM_READ</span> <span class="o">|</span> <span class="n">VM_MAYREAD</span> <span class="o">|</span> <span class="n">VM_EXEC</span> <span class="o">|</span> <span class="n">VM_MAYEXEC</span><span class="p">;</span>
	<span class="n">gate_vma</span><span class="p">.</span><span class="n">vm_page_prot</span> <span class="o">=</span> <span class="n">__P101</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__initcall</span><span class="p">(</span><span class="n">gate_vma_init</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="nf">get_gate_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef AT_SYSINFO_EHDR</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">gate_vma</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">in_gate_area_no_mm</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef AT_SYSINFO_EHDR</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">FIXADDR_USER_START</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="n">FIXADDR_USER_END</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif	</span><span class="cm">/* __HAVE_ARCH_GATE_AREA */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__follow_pte</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
		<span class="n">pte_t</span> <span class="o">**</span><span class="n">ptepp</span><span class="p">,</span> <span class="n">spinlock_t</span> <span class="o">**</span><span class="n">ptlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>

	<span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pgd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">)</span> <span class="o">||</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">pgd_bad</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pud_none</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">)</span> <span class="o">||</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">pud_bad</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">pmd_trans_huge</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">)</span> <span class="o">||</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">pmd_bad</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* We cannot handle huge page PFN maps. Luckily they don&#39;t exist. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmd_huge</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ptep</span> <span class="o">=</span> <span class="n">pte_offset_map_lock</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">ptlp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptep</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_present</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="o">*</span><span class="n">ptepp</span> <span class="o">=</span> <span class="n">ptep</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">unlock:</span>
	<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="o">*</span><span class="n">ptlp</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">follow_pte</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
			     <span class="n">pte_t</span> <span class="o">**</span><span class="n">ptepp</span><span class="p">,</span> <span class="n">spinlock_t</span> <span class="o">**</span><span class="n">ptlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="cm">/* (void) is needed to make gcc happy */</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">__cond_lock</span><span class="p">(</span><span class="o">*</span><span class="n">ptlp</span><span class="p">,</span>
			   <span class="o">!</span><span class="p">(</span><span class="n">res</span> <span class="o">=</span> <span class="n">__follow_pte</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">ptepp</span><span class="p">,</span> <span class="n">ptlp</span><span class="p">)));</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * follow_pfn - look up PFN at a user virtual address</span>
<span class="cm"> * @vma: memory mapping</span>
<span class="cm"> * @address: user virtual address</span>
<span class="cm"> * @pfn: location to store found PFN</span>
<span class="cm"> *</span>
<span class="cm"> * Only IO mappings and raw PFN mappings are allowed.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero and the pfn at @pfn on success, -ve otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">follow_pfn</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">ptl</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_IO</span> <span class="o">|</span> <span class="n">VM_PFNMAP</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">follow_pte</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="o">*</span><span class="n">pfn</span> <span class="o">=</span> <span class="n">pte_pfn</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">);</span>
	<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">follow_pfn</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_HAVE_IOREMAP_PROT</span>
<span class="kt">int</span> <span class="nf">follow_phys</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">prot</span><span class="p">,</span> <span class="n">resource_size_t</span> <span class="o">*</span><span class="n">phys</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">ptl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_IO</span> <span class="o">|</span> <span class="n">VM_PFNMAP</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">follow_pte</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptl</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">pte</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pte_write</span><span class="p">(</span><span class="n">pte</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="o">*</span><span class="n">prot</span> <span class="o">=</span> <span class="n">pgprot_val</span><span class="p">(</span><span class="n">pte_pgprot</span><span class="p">(</span><span class="n">pte</span><span class="p">));</span>
	<span class="o">*</span><span class="n">phys</span> <span class="o">=</span> <span class="p">(</span><span class="n">resource_size_t</span><span class="p">)</span><span class="n">pte_pfn</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">unlock:</span>
	<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">generic_access_phys</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">resource_size_t</span> <span class="n">phys_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">maddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">follow_phys</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phys_addr</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">maddr</span> <span class="o">=</span> <span class="n">ioremap_prot</span><span class="p">(</span><span class="n">phys_addr</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">prot</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">)</span>
		<span class="n">memcpy_toio</span><span class="p">(</span><span class="n">maddr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">memcpy_fromio</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">maddr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">maddr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Access another process&#39; address space as given in mm.  If non-NULL, use the</span>
<span class="cm"> * given task for page fault accounting.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__access_remote_vm</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">old_buf</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="cm">/* ignore errors, just check how much was successfully transferred */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">offset</span><span class="p">;</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">maddr</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">get_user_pages</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
				<span class="n">write</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vma</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Check if this is a VM_IO | VM_PFNMAP VMA, which</span>
<span class="cm">			 * we can access using slightly different code.</span>
<span class="cm">			 */</span>
<span class="cp">#ifdef CONFIG_HAVE_IOREMAP_PROT</span>
			<span class="n">vma</span> <span class="o">=</span> <span class="n">find_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span> <span class="o">||</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&gt;</span> <span class="n">addr</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">&amp;&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="o">-&gt;</span><span class="n">access</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="o">-&gt;</span><span class="n">access</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span>
							  <span class="n">len</span><span class="p">,</span> <span class="n">write</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
<span class="cp">#endif</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">bytes</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">bytes</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="o">-</span><span class="n">offset</span><span class="p">)</span>
				<span class="n">bytes</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="o">-</span><span class="n">offset</span><span class="p">;</span>

			<span class="n">maddr</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">copy_to_user_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span>
						  <span class="n">maddr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
				<span class="n">set_page_dirty_lock</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">copy_from_user_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span>
						    <span class="n">buf</span><span class="p">,</span> <span class="n">maddr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">bytes</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">bytes</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">+=</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">buf</span> <span class="o">-</span> <span class="n">old_buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * access_remote_vm - access another process&#39; address space</span>
<span class="cm"> * @mm:		the mm_struct of the target address space</span>
<span class="cm"> * @addr:	start address to access</span>
<span class="cm"> * @buf:	source or destination buffer</span>
<span class="cm"> * @len:	number of bytes to transfer</span>
<span class="cm"> * @write:	whether the access is a write</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must hold a reference on @mm.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">access_remote_vm</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__access_remote_vm</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">write</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Access another process&#39; address space.</span>
<span class="cm"> * Source/target buffer must be kernel space,</span>
<span class="cm"> * Do not walk the page table directly, use get_user_pages</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">access_process_vm</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mm</span> <span class="o">=</span> <span class="n">get_task_mm</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__access_remote_vm</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">write</span><span class="p">);</span>
	<span class="n">mmput</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Print the name of a VMA.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">print_vma_addr</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">prefix</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do not print if we are in atomic</span>
<span class="cm">	 * contexts (in exception stacks, etc.):</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">preempt_count</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="n">vma</span> <span class="o">=</span> <span class="n">find_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span> <span class="o">&amp;&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">;</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>

			<span class="n">p</span> <span class="o">=</span> <span class="n">d_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
				<span class="n">p</span> <span class="o">=</span> <span class="s">&quot;?&quot;</span><span class="p">;</span>
			<span class="n">s</span> <span class="o">=</span> <span class="n">strrchr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="sc">&#39;/&#39;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">)</span>
				<span class="n">p</span> <span class="o">=</span> <span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s%s[%lx+%lx]&quot;</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
					<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span>
					<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">);</span>
			<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">buf</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PROVE_LOCKING</span>
<span class="kt">void</span> <span class="nf">might_fault</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Some code (nfs/sunrpc) uses socket ops on kernel memory while</span>
<span class="cm">	 * holding the mmap_sem, this is safe because kernel memory doesn&#39;t</span>
<span class="cm">	 * get paged out, therefore we&#39;ll never actually fault, and the</span>
<span class="cm">	 * below annotations will generate false positives.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">segment_eq</span><span class="p">(</span><span class="n">get_fs</span><span class="p">(),</span> <span class="n">KERNEL_DS</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">might_sleep</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * it would be nicer only to annotate paths which are not under</span>
<span class="cm">	 * pagefault_disable, however that requires a larger audit and</span>
<span class="cm">	 * providing helpers like get_user_atomic.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_atomic</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span>
		<span class="n">might_lock_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">might_fault</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CONFIG_TRANSPARENT_HUGEPAGE) || defined(CONFIG_HUGETLBFS)</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">clear_gigantic_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pages_per_huge_page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>

	<span class="n">might_sleep</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pages_per_huge_page</span><span class="p">;</span>
	     <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">mem_map_next</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="n">clear_user_highpage</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">clear_huge_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pages_per_huge_page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pages_per_huge_page</span> <span class="o">&gt;</span> <span class="n">MAX_ORDER_NR_PAGES</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">clear_gigantic_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pages_per_huge_page</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">might_sleep</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pages_per_huge_page</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="n">clear_user_highpage</span><span class="p">(</span><span class="n">page</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">copy_user_gigantic_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pages_per_huge_page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">dst_base</span> <span class="o">=</span> <span class="n">dst</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">src_base</span> <span class="o">=</span> <span class="n">src</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pages_per_huge_page</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="n">copy_user_highpage</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>

		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="n">dst</span> <span class="o">=</span> <span class="n">mem_map_next</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">dst_base</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">src</span> <span class="o">=</span> <span class="n">mem_map_next</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">src_base</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">copy_user_huge_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pages_per_huge_page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pages_per_huge_page</span> <span class="o">&gt;</span> <span class="n">MAX_ORDER_NR_PAGES</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">copy_user_gigantic_page</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span>
					<span class="n">pages_per_huge_page</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">might_sleep</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pages_per_huge_page</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="n">copy_user_highpage</span><span class="p">(</span><span class="n">dst</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">src</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_TRANSPARENT_HUGEPAGE || CONFIG_HUGETLBFS */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
