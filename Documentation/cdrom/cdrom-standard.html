<!DOCTYPE html>
<html><head><title>joekychen/linux » Documentation › cdrom › cdrom-standard.tex

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>cdrom-standard.tex</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="k">\documentclass</span><span class="nb">{</span>article<span class="nb">}</span>
<span class="k">\def\version</span><span class="nb">{</span><span class="s">$</span><span class="nb">Id: cdrom</span><span class="o">-</span><span class="nb">standard.tex,v </span><span class="m">1</span><span class="nb">.</span><span class="m">9</span><span class="nb"> </span><span class="m">1997</span><span class="o">/</span><span class="m">12</span><span class="o">/</span><span class="m">28</span><span class="nb"> </span><span class="m">15</span><span class="nb">:</span><span class="m">42</span><span class="nb">:</span><span class="m">49</span><span class="nb"> david Exp </span><span class="s">$</span><span class="nb">}</span>
<span class="k">\newcommand</span><span class="nb">{</span><span class="k">\newsection</span><span class="nb">}</span>[1]<span class="nb">{</span><span class="k">\newpage\section</span><span class="nb">{</span>#1<span class="nb">}}</span>

<span class="k">\evensidemargin</span>=0pt
<span class="k">\oddsidemargin</span>=0pt
<span class="k">\topmargin</span>=-<span class="k">\headheight</span> <span class="k">\advance\topmargin</span> by -<span class="k">\headsep</span>
<span class="k">\textwidth</span>=15.99cm <span class="k">\textheight</span>=24.62cm <span class="c">% normal A4, 1&#39;&#39; margin</span>

<span class="k">\def\linux</span><span class="nb">{{</span><span class="k">\sc</span> Linux<span class="nb">}}</span>
<span class="k">\def\cdrom</span><span class="nb">{{</span><span class="k">\sc</span> cd-rom<span class="nb">}}</span>
<span class="k">\def\UCD</span><span class="nb">{{</span><span class="k">\sc</span> Uniform cd-rom Driver<span class="nb">}}</span>
<span class="k">\def\cdromc</span><span class="nb">{{</span><span class="k">\tt</span> <span class="nb">{</span>cdrom.c<span class="nb">}}}</span>
<span class="k">\def\cdromh</span><span class="nb">{{</span><span class="k">\tt</span> <span class="nb">{</span>cdrom.h<span class="nb">}}}</span>
<span class="k">\def\fo</span><span class="nb">{</span><span class="k">\sl</span><span class="nb">}</span>                    <span class="c">% foreign words</span>
<span class="k">\def\ie</span><span class="nb">{{</span><span class="k">\fo</span> i.e.<span class="nb">}}</span>
<span class="k">\def\eg</span><span class="nb">{{</span><span class="k">\fo</span> e.g.<span class="nb">}}</span>

<span class="k">\everymath</span><span class="nb">{</span><span class="k">\it</span><span class="nb">}</span> <span class="k">\everydisplay</span><span class="nb">{</span><span class="k">\it</span><span class="nb">}</span>
<span class="k">\catcode</span> `<span class="k">\_</span>=<span class="k">\active</span> <span class="k">\def</span><span class="nb">_{</span><span class="k">\_\penalty</span>100 <span class="nb">}</span>
<span class="k">\catcode</span>`<span class="k">\&lt;</span>=<span class="k">\active</span> <span class="k">\def</span>&lt;#1&gt;<span class="nb">{{</span><span class="k">\langle\hbox</span><span class="nb">{</span><span class="k">\rm</span>#1<span class="nb">}</span><span class="k">\rangle</span><span class="nb">}}</span>

<span class="k">\begin</span><span class="nb">{</span>document<span class="nb">}</span>
<span class="k">\title</span><span class="nb">{</span>A <span class="k">\linux\ \cdrom\ </span>standard<span class="nb">}</span>
<span class="k">\author</span><span class="nb">{</span>David van Leeuwen<span class="k">\\</span><span class="nb">{</span><span class="k">\normalsize\tt</span> david@ElseWare.cistron.nl<span class="nb">}</span>
<span class="k">\\</span><span class="nb">{</span><span class="k">\footnotesize</span> updated by Erik Andersen <span class="nb">{</span><span class="k">\tt</span>(andersee@debian.org)<span class="nb">}}</span>
<span class="k">\\</span><span class="nb">{</span><span class="k">\footnotesize</span> updated by Jens Axboe <span class="nb">{</span><span class="k">\tt</span>(axboe@image.dk)<span class="nb">}}}</span>
<span class="k">\date</span><span class="nb">{</span>12 March 1999<span class="nb">}</span>

<span class="k">\maketitle</span>

<span class="k">\newsection</span><span class="nb">{</span>Introduction<span class="nb">}</span>

<span class="k">\linux\ </span>is probably the Unix-like operating system that supports
the widest variety of hardware devices. The reasons for this are
presumably 
<span class="k">\begin</span><span class="nb">{</span>itemize<span class="nb">}</span> 
<span class="k">\item</span> 
  The large list of hardware devices available for the many platforms
  that <span class="k">\linux\ </span>now supports (<span class="k">\ie</span>, i386-PCs, Sparc Suns, etc.)
<span class="k">\item</span> 
  The open design of the operating system, such that anybody can write a
  driver for <span class="k">\linux</span>.
<span class="k">\item</span> 
  There is plenty of source code around as examples of how to write a driver.
<span class="k">\end</span><span class="nb">{</span>itemize<span class="nb">}</span>
The openness of <span class="k">\linux</span>, and the many different types of available
hardware has allowed <span class="k">\linux\ </span>to support many different hardware devices.
Unfortunately, the very openness that has allowed <span class="k">\linux\ </span>to support
all these different devices has also allowed the behavior of each
device driver to differ significantly from one device to another.
This divergence of behavior has been very significant for <span class="k">\cdrom</span><span class="err">\</span>
devices; the way a particular drive reacts to a `standard&#39; <span class="s">$</span><span class="nb">ioctl</span><span class="o">()</span><span class="s">$</span>
call varies greatly from one device driver to another. To avoid making
their drivers totally inconsistent, the writers of <span class="k">\linux\ \cdrom</span><span class="err">\</span>
drivers generally created new device drivers by understanding, copying,
and then changing an existing one. Unfortunately, this practice did not
maintain uniform behavior across all the <span class="k">\linux\ \cdrom\ </span>drivers. 

This document describes an effort to establish Uniform behavior across
all the different <span class="k">\cdrom\ </span>device drivers for <span class="k">\linux</span>. This document also
defines the various <span class="s">$</span><span class="nb">ioctl</span><span class="s">$</span>s, and how the low-level <span class="k">\cdrom\ </span>device
drivers should implement them. Currently (as of the <span class="k">\linux\ </span>2.1.<span class="s">$</span><span class="nb">x</span><span class="s">$</span>
development kernels) several low-level <span class="k">\cdrom\ </span>device drivers, including
both IDE/ATAPI and SCSI, now use this Uniform interface.

When the <span class="k">\cdrom\ </span>was developed, the interface between the <span class="k">\cdrom\ </span>drive
and the computer was not specified in the standards. As a result, many
different <span class="k">\cdrom\ </span>interfaces were developed. Some of them had their
own proprietary design (Sony, Mitsumi, Panasonic, Philips), other
manufacturers adopted an existing electrical interface and changed
the functionality (CreativeLabs/SoundBlaster, Teac, Funai) or simply
adapted their drives to one or more of the already existing electrical
interfaces (Aztech, Sanyo, Funai, Vertos, Longshine, Optics Storage and
most of the `NoName&#39; manufacturers). In cases where a new drive really
brought its own interface or used its own command set and flow control
scheme, either a separate driver had to be written, or an existing
driver had to be enhanced. History has delivered us <span class="k">\cdrom\ </span>support for
many of these different interfaces. Nowadays, almost all new <span class="k">\cdrom</span><span class="err">\</span>
drives are either IDE/ATAPI or SCSI, and it is very unlikely that any
manufacturer will create a new interface. Even finding drives for the
old proprietary interfaces is getting difficult.

When (in the 1.3.70&#39;s) I looked at the existing software interface,
which was expressed through <span class="k">\cdromh</span>, it appeared to be a rather wild
set of commands and data formats.<span class="k">\footnote</span><span class="nb">{</span>I cannot recollect what
kernel version I looked at, then, presumably 1.2.13 and 1.3.34---the
latest kernel that I was indirectly involved in.<span class="nb">}</span> It seemed that many
features of the software interface had been added to accommodate the
capabilities of a particular drive, in an <span class="nb">{</span><span class="k">\fo</span> ad hoc<span class="k">\/</span><span class="nb">}</span> manner. More
importantly, it appeared that the behavior of the `standard&#39; commands
was different for most of the different drivers: <span class="k">\eg</span>, some drivers
close the tray if an <span class="s">$</span><span class="nb">open</span><span class="o">()</span><span class="s">$</span> call occurs when the tray is open, while
others do not. Some drivers lock the door upon opening the device, to
prevent an incoherent file system, but others don&#39;t, to allow software
ejection. Undoubtedly, the capabilities of the different drives vary,
but even when two drives have the same capability their drivers&#39;
behavior was usually different.

I decided to start a discussion on how to make all the <span class="k">\linux\ \cdrom</span><span class="err">\</span>
drivers behave more uniformly. I began by contacting the developers of
the many <span class="k">\cdrom\ </span>drivers found in the <span class="k">\linux\ </span>kernel. Their reactions
encouraged me to write the <span class="k">\UCD\ </span>which this document is intended to
describe. The implementation of the <span class="k">\UCD\ </span>is in the file <span class="k">\cdromc</span>. This
driver is intended to be an additional software layer that sits on top
of the low-level device drivers for each <span class="k">\cdrom\ </span>drive. By adding this
additional layer, it is possible to have all the different <span class="k">\cdrom</span><span class="err">\</span>
devices behave <span class="nb">{</span><span class="k">\em</span> exactly<span class="k">\/</span><span class="nb">}</span> the same (insofar as the underlying
hardware will allow).

The goal of the <span class="k">\UCD\ </span>is <span class="nb">{</span><span class="k">\em</span> not<span class="k">\/</span><span class="nb">}</span> to alienate driver developers who
have not yet taken steps to support this effort. The goal of <span class="k">\UCD\ </span>is
simply to give people writing application programs for <span class="k">\cdrom\ </span>drives
<span class="nb">{</span><span class="k">\em</span> one<span class="k">\/</span><span class="nb">}</span> <span class="k">\linux\ \cdrom\ </span>interface with consistent behavior for all
<span class="k">\cdrom\ </span>devices. In addition, this also provides a consistent interface
between the low-level device driver code and the <span class="k">\linux\ </span>kernel. Care
is taken that 100<span class="k">\,\%</span> compatibility exists with the data structures and
programmer&#39;s interface defined in <span class="k">\cdromh</span>. This guide was written to
help <span class="k">\cdrom\ </span>driver developers adapt their code to use the <span class="k">\UCD\ </span>code
defined in <span class="k">\cdromc</span>.

Personally, I think that the most important hardware interfaces are
the IDE/ATAPI drives and, of course, the SCSI drives, but as prices
of hardware drop continuously, it is also likely that people may have
more than one <span class="k">\cdrom\ </span>drive, possibly of mixed types. It is important
that these drives behave in the same way. In December 1994, one of the
cheapest <span class="k">\cdrom\ </span>drives was a Philips cm206, a double-speed proprietary
drive. In the months that I was busy writing a <span class="k">\linux\ </span>driver for it,
proprietary drives became obsolete and IDE/ATAPI drives became the
standard. At the time of the last update to this document (November
1997) it is becoming difficult to even <span class="nb">{</span><span class="k">\em</span> find<span class="nb">}</span> anything less than a
16 speed <span class="k">\cdrom\ </span>drive, and 24 speed drives are common.

<span class="k">\newsection</span><span class="nb">{</span>Standardizing through another software level<span class="nb">}</span>
<span class="k">\label</span><span class="nb">{</span>cdrom.c<span class="nb">}</span>

At the time this document was conceived, all drivers directly
implemented the <span class="k">\cdrom\ </span><span class="s">$</span><span class="nb">ioctl</span><span class="o">()</span><span class="s">$</span> calls through their own routines. This
led to the danger of different drivers forgetting to do important things
like checking that the user was giving the driver valid data. More
importantly, this led to the divergence of behavior, which has already
been discussed.

For this reason, the <span class="k">\UCD\ </span>was created to enforce consistent <span class="k">\cdrom</span><span class="err">\</span>
drive behavior, and to provide a common set of services to the various
low-level <span class="k">\cdrom\ </span>device drivers. The <span class="k">\UCD\ </span>now provides another
software-level, that separates the <span class="s">$</span><span class="nb">ioctl</span><span class="o">()</span><span class="s">$</span> and <span class="s">$</span><span class="nb">open</span><span class="o">()</span><span class="s">$</span> implementation
from the actual hardware implementation. Note that this effort has
made few changes which will affect a user&#39;s application programs. The
greatest change involved moving the contents of the various low-level
<span class="k">\cdrom\ </span>drivers&#39; header files to the kernel&#39;s cdrom directory. This was
done to help ensure that the user is only presented with only one cdrom
interface, the interface defined in <span class="k">\cdromh</span>.

<span class="k">\cdrom\ </span>drives are specific enough (<span class="k">\ie</span>, different from other
block-devices such as floppy or hard disc drives), to define a set
of common <span class="nb">{</span><span class="k">\em</span> <span class="k">\cdrom\ </span>device operations<span class="nb">}</span>, <span class="s">$</span><span class="nb">&lt;cdrom</span><span class="o">-</span><span class="nb">device&gt;_dops</span><span class="s">$</span>.
These operations are different from the classical block-device file
operations, <span class="s">$</span><span class="nb">&lt;block</span><span class="o">-</span><span class="nb">device&gt;_fops</span><span class="s">$</span>.

The routines for the <span class="k">\UCD\ </span>interface level are implemented in the file
<span class="k">\cdromc</span>. In this file, the <span class="k">\UCD\ </span>interfaces with the kernel as a block
device by registering the following general <span class="s">$</span><span class="nb">struct</span><span class="nv">\ </span><span class="nb">file_operations</span><span class="s">$</span>:
<span class="sb">$$</span><span class="nb"></span>
<span class="nv">\halign</span><span class="nb">{$#$</span><span class="nv">\ \hfil</span><span class="nb">&amp;$#$</span><span class="nv">\ \hfil</span><span class="nb">&amp;$</span><span class="o">/*</span><span class="nb">$ </span><span class="nv">\rm</span><span class="nb"># $</span><span class="o">*/</span><span class="nb">$</span><span class="nv">\hfil\cr</span><span class="nb"></span>
<span class="nb">struct&amp; file_operations</span><span class="nv">\ </span><span class="nb">cdrom_fops </span><span class="o">=</span><span class="nb"> </span><span class="nv">\{\hidewidth\cr</span><span class="nb"></span>
<span class="nb">        &amp;NULL,                  &amp; lseek </span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">        &amp;block_read,            &amp; read</span><span class="o">---</span><span class="nb">general block</span><span class="o">-</span><span class="nb">dev read </span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">        &amp;block_write,           &amp; write</span><span class="o">---</span><span class="nb">general block</span><span class="o">-</span><span class="nb">dev write </span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">        &amp;NULL,                  &amp; readdir </span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">        &amp;NULL,                  &amp; select </span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">        &amp;cdrom_ioctl,           &amp; ioctl </span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">        &amp;NULL,                  &amp; mmap </span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">        &amp;cdrom_open,            &amp; open </span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">        &amp;cdrom_release,         &amp; release </span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">        &amp;NULL,                  &amp; fsync </span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">        &amp;NULL,                  &amp; fasync </span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">        &amp;cdrom_media_changed,   &amp; media change </span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">        &amp;NULL                   &amp; revalidate </span><span class="nv">\cr</span><span class="nb"></span>
<span class="nv">\}</span><span class="nb">;</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">}</span>
<span class="s">$$</span> 

Every active <span class="k">\cdrom\ </span>device shares this <span class="s">$</span><span class="nb">struct</span><span class="s">$</span>. The routines
declared above are all implemented in <span class="k">\cdromc</span>, since this file is the
place where the behavior of all <span class="k">\cdrom</span>-devices is defined and
standardized. The actual interface to the various types of <span class="k">\cdrom\ </span>
hardware is still performed by various low-level <span class="k">\cdrom</span>-device
drivers. These routines simply implement certain <span class="nb">{</span><span class="k">\em</span> capabilities<span class="k">\/</span><span class="nb">}</span>
that are common to all <span class="k">\cdrom\ </span>(and really, all removable-media
devices).

Registration of a low-level <span class="k">\cdrom\ </span>device driver is now done through
the general routines in <span class="k">\cdromc</span>, not through the Virtual File System
(VFS) any more. The interface implemented in <span class="k">\cdromc\ </span>is carried out
through two general structures that contain information about the
capabilities of the driver, and the specific drives on which the
driver operates. The structures are:
<span class="k">\begin</span><span class="nb">{</span>description<span class="nb">}</span>
<span class="k">\item</span><span class="na">[$cdrom_device_ops$]</span> 
  This structure contains information about the low-level driver for a
  <span class="k">\cdrom\ </span>device. This structure is conceptually connected to the major
  number of the device (although some drivers may have different
  major numbers, as is the case for the IDE driver).
<span class="k">\item</span><span class="na">[$cdrom_device_info$]</span> 
  This structure contains information about a particular <span class="k">\cdrom\ </span>drive,
  such as its device name, speed, etc. This structure is conceptually
  connected to the minor number of the device.
<span class="k">\end</span><span class="nb">{</span>description<span class="nb">}</span>

Registering a particular <span class="k">\cdrom\ </span>drive with the <span class="k">\UCD\ </span>is done by the
low-level device driver though a call to:
<span class="sb">$$</span><span class="nb">register_cdrom</span><span class="o">(</span><span class="nb">struct</span><span class="nv">\ </span><span class="nb">cdrom_device_info </span><span class="o">*</span><span class="nb"> &lt;device&gt;_info</span><span class="o">)</span><span class="nb">  </span>
<span class="s">$$</span>
The device information structure, <span class="s">$</span><span class="nb">&lt;device&gt;_info</span><span class="s">$</span>, contains all the
information needed for the kernel to interface with the low-level
<span class="k">\cdrom\ </span>device driver. One of the most important entries in this
structure is a pointer to the <span class="s">$</span><span class="nb">cdrom_device_ops</span><span class="s">$</span> structure of the
low-level driver.

The device operations structure, <span class="s">$</span><span class="nb">cdrom_device_ops</span><span class="s">$</span>, contains a list
of pointers to the functions which are implemented in the low-level
device driver. When <span class="k">\cdromc\ </span>accesses a <span class="k">\cdrom\ </span>device, it does it
through the functions in this structure. It is impossible to know all
the capabilities of future <span class="k">\cdrom\ </span>drives, so it is expected that this
list may need to be expanded from time to time as new technologies are
developed. For example, CD-R and CD-R/W drives are beginning to become
popular, and support will soon need to be added for them. For now, the
current <span class="s">$</span><span class="nb">struct</span><span class="s">$</span> is:
<span class="sb">$$</span><span class="nb"></span>
<span class="nv">\halign</span><span class="nb">{$#$</span><span class="nv">\ \hfil</span><span class="nb">&amp;$#$</span><span class="nv">\ \hfil</span><span class="nb">&amp;</span><span class="nv">\hbox</span><span class="nb"> to </span><span class="m">10</span><span class="nb">em{$#$</span><span class="nv">\hss</span><span class="nb">}&amp;</span>
<span class="nb">  $</span><span class="o">/*</span><span class="nb">$ </span><span class="nv">\rm</span><span class="nb"># $</span><span class="o">*/</span><span class="nb">$</span><span class="nv">\hfil\cr</span><span class="nb"></span>
<span class="nb">struct&amp; cdrom_device_ops</span><span class="nv">\ \{</span><span class="nb"> </span><span class="nv">\hidewidth\cr</span><span class="nb"></span>
<span class="nb">  &amp;int&amp; </span><span class="o">(*</span><span class="nb"> open</span><span class="o">)(</span><span class="nb">struct</span><span class="nv">\ </span><span class="nb">cdrom_device_info </span><span class="o">*</span><span class="nb">, int</span><span class="o">)</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">  &amp;void&amp; </span><span class="o">(*</span><span class="nb"> release</span><span class="o">)(</span><span class="nb">struct</span><span class="nv">\ </span><span class="nb">cdrom_device_info </span><span class="o">*)</span><span class="nb">;</span><span class="nv">\cr</span><span class="nb"> </span>
<span class="nb">  &amp;int&amp; </span><span class="o">(*</span><span class="nb"> drive_status</span><span class="o">)(</span><span class="nb">struct</span><span class="nv">\ </span><span class="nb">cdrom_device_info </span><span class="o">*</span><span class="nb">, int</span><span class="o">)</span><span class="nb">;</span><span class="nv">\cr</span><span class="nb">     </span>
<span class="nb">  &amp;int&amp; </span><span class="o">(*</span><span class="nb"> media_changed</span><span class="o">)(</span><span class="nb">struct</span><span class="nv">\ </span><span class="nb">cdrom_device_info </span><span class="o">*</span><span class="nb">, int</span><span class="o">)</span><span class="nb">;</span><span class="nv">\cr</span><span class="nb"> </span>
<span class="nb">  &amp;int&amp; </span><span class="o">(*</span><span class="nb"> tray_move</span><span class="o">)(</span><span class="nb">struct</span><span class="nv">\ </span><span class="nb">cdrom_device_info </span><span class="o">*</span><span class="nb">, int</span><span class="o">)</span><span class="nb">;</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">  &amp;int&amp; </span><span class="o">(*</span><span class="nb"> lock_door</span><span class="o">)(</span><span class="nb">struct</span><span class="nv">\ </span><span class="nb">cdrom_device_info </span><span class="o">*</span><span class="nb">, int</span><span class="o">)</span><span class="nb">;</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">  &amp;int&amp; </span><span class="o">(*</span><span class="nb"> select_speed</span><span class="o">)(</span><span class="nb">struct</span><span class="nv">\ </span><span class="nb">cdrom_device_info </span><span class="o">*</span><span class="nb">, int</span><span class="o">)</span><span class="nb">;</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">  &amp;int&amp; </span><span class="o">(*</span><span class="nb"> select_disc</span><span class="o">)(</span><span class="nb">struct</span><span class="nv">\ </span><span class="nb">cdrom_device_info </span><span class="o">*</span><span class="nb">, int</span><span class="o">)</span><span class="nb">;</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">  &amp;int&amp; </span><span class="o">(*</span><span class="nb"> get_last_session</span><span class="o">)</span><span class="nb"> </span><span class="o">(</span><span class="nb">struct</span><span class="nv">\ </span><span class="nb">cdrom_device_info </span><span class="o">*</span><span class="nb">, </span>
<span class="nb">        struct</span><span class="nv">\ </span><span class="nb">cdrom_multisession </span><span class="o">*</span><span class="nb">{}</span><span class="o">)</span><span class="nb">;</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">  &amp;int&amp; </span><span class="o">(*</span><span class="nb"> get_mcn</span><span class="o">)(</span><span class="nb">struct</span><span class="nv">\ </span><span class="nb">cdrom_device_info </span><span class="o">*</span><span class="nb">, struct</span><span class="nv">\ </span><span class="nb">cdrom_mcn </span><span class="o">*</span><span class="nb">{}</span><span class="o">)</span><span class="nb">;</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">  &amp;int&amp; </span><span class="o">(*</span><span class="nb"> reset</span><span class="o">)(</span><span class="nb">struct</span><span class="nv">\ </span><span class="nb">cdrom_device_info </span><span class="o">*)</span><span class="nb">;</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">  &amp;int&amp; </span><span class="o">(*</span><span class="nb"> audio_ioctl</span><span class="o">)(</span><span class="nb">struct</span><span class="nv">\ </span><span class="nb">cdrom_device_info </span><span class="o">*</span><span class="nb">, unsigned</span><span class="nv">\ </span><span class="nb">int, </span>
<span class="nb">        void </span><span class="o">*</span><span class="nb">{}</span><span class="o">)</span><span class="nb">;</span><span class="nv">\cr</span><span class="nb"> </span>
<span class="nb">  &amp;int&amp; </span><span class="o">(*</span><span class="nb"> dev_ioctl</span><span class="o">)(</span><span class="nb">struct</span><span class="nv">\ </span><span class="nb">cdrom_device_info </span><span class="o">*</span><span class="nb">, unsigned</span><span class="nv">\ </span><span class="nb">int, </span>
<span class="nb">        unsigned</span><span class="nv">\ </span><span class="nb">long</span><span class="o">)</span><span class="nb">;</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nv">\noalign</span><span class="nb">{</span><span class="nv">\medskip</span><span class="nb">}</span>
<span class="nb">  &amp;const</span><span class="nv">\ </span><span class="nb">int&amp; capability;&amp; capability flags </span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">  &amp;int&amp; n_minors;&amp; number of active minor devices </span><span class="nv">\cr</span><span class="nb"></span>
<span class="nv">\}</span><span class="nb">;</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">}</span>
<span class="s">$$</span>
When a low-level device driver implements one of these capabilities,
it should add a function pointer to this <span class="s">$</span><span class="nb">struct</span><span class="s">$</span>. When a particular
function is not implemented, however, this <span class="s">$</span><span class="nb">struct</span><span class="s">$</span> should contain a
NULL instead. The <span class="s">$</span><span class="nb">capability</span><span class="s">$</span> flags specify the capabilities of the
<span class="k">\cdrom\ </span>hardware and/or low-level <span class="k">\cdrom\ </span>driver when a <span class="k">\cdrom\ </span>drive
is registered with the <span class="k">\UCD</span>. The value <span class="s">$</span><span class="nb">n_minors</span><span class="s">$</span> should be a positive
value indicating the number of minor devices that are supported by
the low-level device driver, normally~1. Although these two variables
are `informative&#39; rather than `operational,&#39; they are included in
<span class="s">$</span><span class="nb">cdrom_device_ops</span><span class="s">$</span> because they describe the capability of the <span class="nb">{</span><span class="k">\em</span>
driver<span class="k">\/</span><span class="nb">}</span> rather than the <span class="nb">{</span><span class="k">\em</span> drive<span class="nb">}</span>. Nomenclature has always been
difficult in computer programming.

Note that most functions have fewer parameters than their
<span class="s">$</span><span class="nb">blkdev_fops</span><span class="s">$</span> counterparts. This is because very little of the
information in the structures <span class="s">$</span><span class="nb">inode</span><span class="s">$</span> and <span class="s">$</span><span class="nb">file</span><span class="s">$</span> is used. For most
drivers, the main parameter is the <span class="s">$</span><span class="nb">struct</span><span class="s">$</span> <span class="s">$</span><span class="nb">cdrom_device_info</span><span class="s">$</span>, from
which the major and minor number can be extracted. (Most low-level
<span class="k">\cdrom\ </span>drivers don&#39;t even look at the major and minor number though,
since many of them only support one device.) This will be available
through <span class="s">$</span><span class="nb">dev</span><span class="s">$</span> in <span class="s">$</span><span class="nb">cdrom_device_info</span><span class="s">$</span> described below.

The drive-specific, minor-like information that is registered with
<span class="k">\cdromc</span>, currently contains the following fields:
<span class="sb">$$</span><span class="nb"></span>
<span class="nv">\halign</span><span class="nb">{$#$</span><span class="nv">\ \hfil</span><span class="nb">&amp;$#$</span><span class="nv">\ \hfil</span><span class="nb">&amp;</span><span class="nv">\hbox</span><span class="nb"> to </span><span class="m">10</span><span class="nb">em{$#$</span><span class="nv">\hss</span><span class="nb">}&amp;</span>
<span class="nb">  $</span><span class="o">/*</span><span class="nb">$ </span><span class="nv">\rm</span><span class="nb"># $</span><span class="o">*/</span><span class="nb">$</span><span class="nv">\hfil\cr</span><span class="nb"></span>
<span class="nb">struct&amp; cdrom_device_info</span><span class="nv">\ \{</span><span class="nb"> </span><span class="nv">\hidewidth\cr</span><span class="nb"></span>
<span class="nb">  &amp; struct</span><span class="nv">\ </span><span class="nb">cdrom_device_ops </span><span class="o">*</span><span class="nb">&amp; ops;&amp; device operations for this major</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">  &amp; struct</span><span class="nv">\ </span><span class="nb">cdrom_device_info </span><span class="o">*</span><span class="nb">&amp; next;&amp; next device_info for this major</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">  &amp; void </span><span class="o">*</span><span class="nb">&amp;  handle;&amp; driver</span><span class="o">-</span><span class="nb">dependent data</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nv">\noalign</span><span class="nb">{</span><span class="nv">\medskip</span><span class="nb">}</span>
<span class="nb">  &amp; kdev_t&amp;  dev;&amp; device number </span><span class="o">(</span><span class="nb">incorporates minor</span><span class="o">)</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">  &amp; int&amp; mask;&amp; mask of capability: disables them </span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">  &amp; int&amp; speed;&amp; maximum speed for reading data </span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">  &amp; int&amp; capacity;&amp; number of discs in a jukebox </span><span class="nv">\cr</span><span class="nb"></span>
<span class="nv">\noalign</span><span class="nb">{</span><span class="nv">\medskip</span><span class="nb">}</span>
<span class="nb">  &amp;int&amp; options : </span><span class="m">30</span><span class="nb">;&amp; options flags </span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">  &amp;unsigned&amp; mc_flags : </span><span class="m">2</span><span class="nb">;&amp; media</span><span class="o">-</span><span class="nb">change buffer flags </span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">  &amp; int&amp; use_count;&amp; number of times device is opened</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">  &amp; char&amp; name</span><span class="o">[</span><span class="m">20</span><span class="o">]</span><span class="nb">;&amp; name of the device type</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nv">\}\cr</span><span class="nb"></span>
<span class="nb">}</span><span class="s">$$</span>
Using this <span class="s">$</span><span class="nb">struct</span><span class="s">$</span>, a linked list of the registered minor devices is
built, using the <span class="s">$</span><span class="nb">next</span><span class="s">$</span> field. The device number, the device operations
struct and specifications of properties of the drive are stored in this
structure.

The <span class="s">$</span><span class="nb">mask</span><span class="s">$</span> flags can be used to mask out some of the capabilities listed
in <span class="s">$</span><span class="nb">ops</span><span class="nv">\to</span><span class="nb"> capability</span><span class="s">$</span>, if a specific drive doesn&#39;t support a feature
of the driver. The value <span class="s">$</span><span class="nb">speed</span><span class="s">$</span> specifies the maximum head-rate of the
drive, measured in units of normal audio speed (176<span class="k">\,</span>kB/sec raw data or
150<span class="k">\,</span>kB/sec file system data). The value <span class="s">$</span><span class="nb">n_discs</span><span class="s">$</span> should reflect the
number of discs the drive can hold simultaneously, if it is designed
as a juke-box, or otherwise~1. The parameters are declared <span class="s">$</span><span class="nb">const</span><span class="s">$</span>
because they describe properties of the drive, which don&#39;t change after
registration.

A few registers contain variables local to the <span class="k">\cdrom\ </span>drive. The
flags <span class="s">$</span><span class="nb">options</span><span class="s">$</span> are used to specify how the general <span class="k">\cdrom\ </span>routines
should behave. These various flags registers should provide enough
flexibility to adapt to the different users&#39; wishes (and <span class="nb">{</span><span class="k">\em</span> not<span class="k">\/</span><span class="nb">}</span> the
`arbitrary&#39; wishes of the author of the low-level device driver, as is
the case in the old scheme). The register <span class="s">$</span><span class="nb">mc_flags</span><span class="s">$</span> is used to buffer
the information from <span class="s">$</span><span class="nb">media_changed</span><span class="o">()</span><span class="s">$</span> to two separate queues. Other
data that is specific to a minor drive, can be accessed through <span class="s">$</span><span class="nb">handle</span><span class="s">$</span>,
which can point to a data structure specific to the low-level driver.
The fields <span class="s">$</span><span class="nb">use_count</span><span class="s">$</span>, <span class="s">$</span><span class="nb">next</span><span class="s">$</span>, <span class="s">$</span><span class="nb">options</span><span class="s">$</span> and <span class="s">$</span><span class="nb">mc_flags</span><span class="s">$</span> need not be
initialized.

The intermediate software layer that <span class="k">\cdromc\ </span>forms will perform some
additional bookkeeping. The use count of the device (the number of
processes that have the device opened) is registered in <span class="s">$</span><span class="nb">use_count</span><span class="s">$</span>. The
function <span class="s">$</span><span class="nb">cdrom_ioctl</span><span class="o">()</span><span class="s">$</span> will verify the appropriate user-memory regions
for read and write, and in case a location on the CD is transferred,
it will `sanitize&#39; the format by making requests to the low-level
drivers in a standard format, and translating all formats between the
user-software and low level drivers. This relieves much of the drivers&#39;
memory checking and format checking and translation. Also, the necessary
structures will be declared on the program stack.

The implementation of the functions should be as defined in the
following sections. Two functions <span class="nb">{</span><span class="k">\em</span> must<span class="k">\/</span><span class="nb">}</span> be implemented, namely
<span class="s">$</span><span class="nb">open</span><span class="o">()</span><span class="s">$</span> and <span class="s">$</span><span class="nb">release</span><span class="o">()</span><span class="s">$</span>. Other functions may be omitted, their
corresponding capability flags will be cleared upon registration.
Generally, a function returns zero on success and negative on error. A
function call should return only after the command has completed, but of
course waiting for the device should not use processor time.

<span class="k">\subsection</span><span class="nb">{</span><span class="s">$</span><span class="nb">Int</span><span class="nv">\ </span><span class="nb">open</span><span class="o">(</span><span class="nb">struct</span><span class="nv">\ </span><span class="nb">cdrom_device_info </span><span class="o">*</span><span class="nb"> cdi, int</span><span class="nv">\ </span><span class="nb">purpose</span><span class="o">)</span><span class="s">$</span><span class="nb">}</span>

<span class="s">$</span><span class="nb">Open</span><span class="o">()</span><span class="s">$</span> should try to open the device for a specific <span class="s">$</span><span class="nb">purpose</span><span class="s">$</span>, which
can be either:
<span class="k">\begin</span><span class="nb">{</span>itemize<span class="nb">}</span>
<span class="k">\item</span><span class="na">[0]</span> Open for reading data, as done by <span class="nb">{</span><span class="k">\tt</span> <span class="nb">{</span>mount()<span class="nb">}}</span> (2), or the
user commands <span class="nb">{</span><span class="k">\tt</span> <span class="nb">{</span>dd<span class="nb">}}</span> or <span class="nb">{</span><span class="k">\tt</span> <span class="nb">{</span>cat<span class="nb">}}</span>.  
<span class="k">\item</span><span class="na">[1]</span> Open for <span class="s">$</span><span class="nb">ioctl</span><span class="s">$</span> commands, as done by audio-CD playing
programs.
<span class="k">\end</span><span class="nb">{</span>itemize<span class="nb">}</span>
Notice that any strategic code (closing tray upon <span class="s">$</span><span class="nb">open</span><span class="o">()</span><span class="s">$</span>, etc.)<span class="k">\ </span>is
done by the calling routine in <span class="k">\cdromc</span>, so the low-level routine
should only be concerned with proper initialization, such as spinning
up the disc, etc. <span class="c">% and device-use count</span>


<span class="k">\subsection</span><span class="nb">{</span><span class="s">$</span><span class="nb">Void</span><span class="nv">\ </span><span class="nb">release</span><span class="o">(</span><span class="nb">struct</span><span class="nv">\ </span><span class="nb">cdrom_device_info </span><span class="o">*</span><span class="nb"> cdi</span><span class="o">)</span><span class="s">$</span><span class="nb">}</span>


Device-specific actions should be taken such as spinning down the device.
However, strategic actions such as ejection of the tray, or unlocking
the door, should be left over to the general routine <span class="s">$</span><span class="nb">cdrom_release</span><span class="o">()</span><span class="s">$</span>.
This is the only function returning type <span class="s">$</span><span class="nb">void</span><span class="s">$</span>.

<span class="k">\subsection</span><span class="nb">{</span><span class="s">$</span><span class="nb">Int</span><span class="nv">\ </span><span class="nb">drive_status</span><span class="o">(</span><span class="nb">struct</span><span class="nv">\ </span><span class="nb">cdrom_device_info </span><span class="o">*</span><span class="nb"> cdi, int</span><span class="nv">\ </span><span class="nb">slot_nr</span><span class="o">)</span><span class="s">$</span><span class="nb">}</span>
<span class="k">\label</span><span class="nb">{</span>drive status<span class="nb">}</span>

The function <span class="s">$</span><span class="nb">drive_status</span><span class="s">$</span>, if implemented, should provide
information on the status of the drive (not the status of the disc,
which may or may not be in the drive). If the drive is not a changer,
<span class="s">$</span><span class="nb">slot_nr</span><span class="s">$</span> should be ignored. In <span class="k">\cdromh\ </span>the possibilities are listed: 
<span class="sb">$$</span><span class="nb"></span>
<span class="nv">\halign</span><span class="nb">{$#$</span><span class="nv">\ \hfil</span><span class="nb">&amp;$</span><span class="o">/*</span><span class="nb">$ </span><span class="nv">\rm</span><span class="nb"># $</span><span class="o">*/</span><span class="nb">$</span><span class="nv">\hfil\cr</span><span class="nb"></span>
<span class="nb">CDS_NO_INFO&amp; no information available</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">CDS_NO_DISC&amp; no disc is inserted, tray is closed</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">CDS_TRAY_OPEN&amp; tray is opened</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">CDS_DRIVE_NOT_READY&amp; something is wrong, tray is moving?</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">CDS_DISC_OK&amp; a disc is loaded and everything is fine</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">}</span>
<span class="s">$$</span>

<span class="k">\subsection</span><span class="nb">{</span><span class="s">$</span><span class="nb">Int</span><span class="nv">\ </span><span class="nb">media_changed</span><span class="o">(</span><span class="nb">struct</span><span class="nv">\ </span><span class="nb">cdrom_device_info </span><span class="o">*</span><span class="nb"> cdi, int</span><span class="nv">\ </span><span class="nb">disc_nr</span><span class="o">)</span><span class="s">$</span><span class="nb">}</span>

This function is very similar to the original function in <span class="s">$</span><span class="nb">struct</span><span class="nv">\ </span><span class="nb"></span>
<span class="nb">file_operations</span><span class="s">$</span>. It returns 1 if the medium of the device <span class="s">$</span><span class="nb">cdi</span><span class="nv">\to</span><span class="nb"></span>
<span class="nb">dev</span><span class="s">$</span> has changed since the last call, and 0 otherwise. The parameter
<span class="s">$</span><span class="nb">disc_nr</span><span class="s">$</span> identifies a specific slot in a juke-box, it should be
ignored for single-disc drives.  Note that by `re-routing&#39; this
function through <span class="s">$</span><span class="nb">cdrom_media_changed</span><span class="o">()</span><span class="s">$</span>, we can implement separate
queues for the VFS and a new <span class="s">$</span><span class="nb">ioctl</span><span class="o">()</span><span class="s">$</span> function that can report device
changes to software (<span class="k">\eg</span>, an auto-mounting daemon).

<span class="k">\subsection</span><span class="nb">{</span><span class="s">$</span><span class="nb">Int</span><span class="nv">\ </span><span class="nb">tray_move</span><span class="o">(</span><span class="nb">struct</span><span class="nv">\ </span><span class="nb">cdrom_device_info </span><span class="o">*</span><span class="nb"> cdi, int</span><span class="nv">\ </span><span class="nb">position</span><span class="o">)</span><span class="s">$</span><span class="nb">}</span>

This function, if implemented, should control the tray movement. (No
other function should control this.) The parameter <span class="s">$</span><span class="nb">position</span><span class="s">$</span> controls
the desired direction of movement:
<span class="k">\begin</span><span class="nb">{</span>itemize<span class="nb">}</span>
<span class="k">\item</span><span class="na">[0]</span> Close tray
<span class="k">\item</span><span class="na">[1]</span> Open tray
<span class="k">\end</span><span class="nb">{</span>itemize<span class="nb">}</span>
This function returns 0 upon success, and a non-zero value upon
error. Note that if the tray is already in the desired position, no
action need be taken, and the return value should be 0. 

<span class="k">\subsection</span><span class="nb">{</span><span class="s">$</span><span class="nb">Int</span><span class="nv">\ </span><span class="nb">lock_door</span><span class="o">(</span><span class="nb">struct</span><span class="nv">\ </span><span class="nb">cdrom_device_info </span><span class="o">*</span><span class="nb"> cdi, int</span><span class="nv">\ </span><span class="nb">lock</span><span class="o">)</span><span class="s">$</span><span class="nb">}</span>

This function (and no other code) controls locking of the door, if the
drive allows this. The value of <span class="s">$</span><span class="nb">lock</span><span class="s">$</span> controls the desired locking
state:
<span class="k">\begin</span><span class="nb">{</span>itemize<span class="nb">}</span>
<span class="k">\item</span><span class="na">[0]</span> Unlock door, manual opening is allowed
<span class="k">\item</span><span class="na">[1]</span> Lock door, tray cannot be ejected manually
<span class="k">\end</span><span class="nb">{</span>itemize<span class="nb">}</span>
This function returns 0 upon success, and a non-zero value upon
error. Note that if the door is already in the requested state, no
action need be taken, and the return value should be 0. 

<span class="k">\subsection</span><span class="nb">{</span><span class="s">$</span><span class="nb">Int</span><span class="nv">\ </span><span class="nb">select_speed</span><span class="o">(</span><span class="nb">struct</span><span class="nv">\ </span><span class="nb">cdrom_device_info </span><span class="o">*</span><span class="nb"> cdi, int</span><span class="nv">\ </span><span class="nb">speed</span><span class="o">)</span><span class="s">$</span><span class="nb">}</span>

Some <span class="k">\cdrom\ </span>drives are capable of changing their head-speed. There
are several reasons for changing the speed of a <span class="k">\cdrom\ </span>drive. Badly
pressed <span class="k">\cdrom</span> s may benefit from less-than-maximum head rate. Modern
<span class="k">\cdrom\ </span>drives can obtain very high head rates (up to <span class="s">$</span><span class="m">24</span><span class="nv">\times</span><span class="s">$</span> is
common).  It has been reported that these drives can make reading
errors at these high speeds, reducing the speed can prevent data loss
in these circumstances.  Finally, some of these drives can
make an annoyingly loud noise, which a lower speed may reduce. <span class="c">%Finally,</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>although the audio-low-pass filters probably aren't designed for it,
more than real-time playback of audio might be used for high-speed
copying of audio tracks.</p></td><td class="code"><div class="highlight"><pre>This function specifies the speed at which data is read or audio is
played back. The value of <span class="s">$</span><span class="nb">speed</span><span class="s">$</span> specifies the head-speed of the
drive, measured in units of standard cdrom speed (176<span class="k">\,</span>kB/sec raw data
or 150<span class="k">\,</span>kB/sec file system data). So to request that a <span class="k">\cdrom\ </span>drive
operate at 300<span class="k">\,</span>kB/sec you would call the CDROM<span class="nb">_</span>SELECT<span class="nb">_</span>SPEED <span class="s">$</span><span class="nb">ioctl</span><span class="s">$</span>
with <span class="s">$</span><span class="nb">speed</span><span class="o">=</span><span class="m">2</span><span class="s">$</span>. The special value `0&#39; means `auto-selection&#39;, <span class="k">\ie</span>,
maximum data-rate or real-time audio rate. If the drive doesn&#39;t have
this `auto-selection&#39; capability, the decision should be made on the
current disc loaded and the return value should be positive. A negative
return value indicates an error.

<span class="k">\subsection</span><span class="nb">{</span><span class="s">$</span><span class="nb">Int</span><span class="nv">\ </span><span class="nb">select_disc</span><span class="o">(</span><span class="nb">struct</span><span class="nv">\ </span><span class="nb">cdrom_device_info </span><span class="o">*</span><span class="nb"> cdi, int</span><span class="nv">\ </span><span class="nb">number</span><span class="o">)</span><span class="s">$</span><span class="nb">}</span>

If the drive can store multiple discs (a juke-box) this function
will perform disc selection. It should return the number of the
selected disc on success, a negative value on error. Currently, only
the ide-cd driver supports this functionality.

<span class="k">\subsection</span><span class="nb">{</span><span class="s">$</span><span class="nb">Int</span><span class="nv">\ </span><span class="nb">get_last_session</span><span class="o">(</span><span class="nb">struct</span><span class="nv">\ </span><span class="nb">cdrom_device_info </span><span class="o">*</span><span class="nb"> cdi, struct</span><span class="err">\</span><span class="nb"></span>
<span class="nb">  cdrom_multisession </span><span class="o">*</span><span class="nb"> ms_info</span><span class="o">)</span><span class="s">$</span><span class="nb">}</span>

This function should implement the old corresponding <span class="s">$</span><span class="nb">ioctl</span><span class="o">()</span><span class="s">$</span>. For
device <span class="s">$</span><span class="nb">cdi</span><span class="nv">\to</span><span class="nb"> dev</span><span class="s">$</span>, the start of the last session of the current disc
should be returned in the pointer argument <span class="s">$</span><span class="nb">ms_info</span><span class="s">$</span>. Note that
routines in <span class="k">\cdromc\ </span>have sanitized this argument: its requested
format will <span class="nb">{</span><span class="k">\em</span> always<span class="k">\/</span><span class="nb">}</span> be of the type <span class="s">$</span><span class="nb">CDROM_LBA</span><span class="s">$</span> (linear block
addressing mode), whatever the calling software requested. But
sanitization goes even further: the low-level implementation may
return the requested information in <span class="s">$</span><span class="nb">CDROM_MSF</span><span class="s">$</span> format if it wishes so
(setting the <span class="s">$</span><span class="nb">ms_info</span><span class="nv">\rightarrow</span><span class="nb"> addr_format</span><span class="s">$</span> field appropriately, of
course) and the routines in <span class="k">\cdromc\ </span>will make the transformation if
necessary. The return value is 0 upon success.

<span class="k">\subsection</span><span class="nb">{</span><span class="s">$</span><span class="nb">Int</span><span class="nv">\ </span><span class="nb">get_mcn</span><span class="o">(</span><span class="nb">struct</span><span class="nv">\ </span><span class="nb">cdrom_device_info </span><span class="o">*</span><span class="nb"> cdi, struct</span><span class="err">\</span><span class="nb"></span>
<span class="nb">  cdrom_mcn </span><span class="o">*</span><span class="nb"> mcn</span><span class="o">)</span><span class="s">$</span><span class="nb">}</span>

Some discs carry a `Media Catalog Number&#39; (MCN), also called
`Universal Product Code&#39; (UPC). This number should reflect the number
that is generally found in the bar-code on the product. Unfortunately,
the few discs that carry such a number on the disc don&#39;t even use the
same format. The return argument to this function is a pointer to a
pre-declared memory region of type <span class="s">$</span><span class="nb">struct</span><span class="nv">\ </span><span class="nb">cdrom_mcn</span><span class="s">$</span>. The MCN is
expected as a 13-character string, terminated by a null-character.

<span class="k">\subsection</span><span class="nb">{</span><span class="s">$</span><span class="nb">Int</span><span class="nv">\ </span><span class="nb">reset</span><span class="o">(</span><span class="nb">struct</span><span class="nv">\ </span><span class="nb">cdrom_device_info </span><span class="o">*</span><span class="nb"> cdi</span><span class="o">)</span><span class="s">$</span><span class="nb">}</span>

This call should perform a hard-reset on the drive (although in
circumstances that a hard-reset is necessary, a drive may very well not
listen to commands anymore). Preferably, control is returned to the
caller only after the drive has finished resetting. If the drive is no
longer listening, it may be wise for the underlying low-level cdrom
driver to time out.

<span class="k">\subsection</span><span class="nb">{</span><span class="s">$</span><span class="nb">Int</span><span class="nv">\ </span><span class="nb">audio_ioctl</span><span class="o">(</span><span class="nb">struct</span><span class="nv">\ </span><span class="nb">cdrom_device_info </span><span class="o">*</span><span class="nb"> cdi, unsigned</span><span class="err">\</span><span class="nb"></span>
<span class="nb">  int</span><span class="nv">\ </span><span class="nb">cmd, void </span><span class="o">*</span><span class="nb"> arg</span><span class="o">)</span><span class="s">$</span><span class="nb">}</span>

Some of the <span class="k">\cdrom</span>-<span class="s">$</span><span class="nb">ioctl</span><span class="s">$</span>s defined in <span class="k">\cdromh\ </span>can be
implemented by the routines described above, and hence the function
<span class="s">$</span><span class="nb">cdrom_ioctl</span><span class="s">$</span> will use those. However, most <span class="s">$</span><span class="nb">ioctl</span><span class="s">$</span>s deal with
audio-control. We have decided to leave these to be accessed through a
single function, repeating the arguments <span class="s">$</span><span class="nb">cmd</span><span class="s">$</span> and <span class="s">$</span><span class="nb">arg</span><span class="s">$</span>. Note that
the latter is of type <span class="s">$</span><span class="nb">void</span><span class="o">*</span><span class="nb">{}</span><span class="s">$</span>, rather than <span class="s">$</span><span class="nb">unsigned</span><span class="nv">\ </span><span class="nb">long</span><span class="err">\</span><span class="nb"></span>
<span class="nb">int</span><span class="s">$</span>. The routine <span class="s">$</span><span class="nb">cdrom_ioctl</span><span class="o">()</span><span class="s">$</span> does do some useful things,
though. It sanitizes the address format type to <span class="s">$</span><span class="nb">CDROM_MSF</span><span class="s">$</span> (Minutes,
Seconds, Frames) for all audio calls. It also verifies the memory
location of <span class="s">$</span><span class="nb">arg</span><span class="s">$</span>, and reserves stack-memory for the argument. This
makes implementation of the <span class="s">$</span><span class="nb">audio_ioctl</span><span class="o">()</span><span class="s">$</span> much simpler than in the
old driver scheme. For example, you may look up the function
<span class="s">$</span><span class="nb">cm</span><span class="m">206</span><span class="nb">_audio_ioctl</span><span class="o">()</span><span class="s">$</span> in <span class="nb">{</span><span class="k">\tt</span> <span class="nb">{</span>cm206.c<span class="nb">}}</span> that should be updated with
this documentation. 

An unimplemented ioctl should return <span class="s">$</span><span class="o">-</span><span class="nb">ENOSYS</span><span class="s">$</span>, but a harmless request
(<span class="k">\eg</span>, <span class="s">$</span><span class="nb">CDROMSTART</span><span class="s">$</span>) may be ignored by returning 0 (success). Other
errors should be according to the standards, whatever they are. When
an error is returned by the low-level driver, the <span class="k">\UCD\ </span>tries whenever
possible to return the error code to the calling program. (We may decide
to sanitize the return value in <span class="s">$</span><span class="nb">cdrom_ioctl</span><span class="o">()</span><span class="s">$</span> though, in order to
guarantee a uniform interface to the audio-player software.)

<span class="k">\subsection</span><span class="nb">{</span><span class="s">$</span><span class="nb">Int</span><span class="nv">\ </span><span class="nb">dev_ioctl</span><span class="o">(</span><span class="nb">struct</span><span class="nv">\ </span><span class="nb">cdrom_device_info </span><span class="o">*</span><span class="nb"> cdi, unsigned</span><span class="nv">\ </span><span class="nb">int</span><span class="err">\</span><span class="nb"></span>
<span class="nb">  cmd, unsigned</span><span class="nv">\ </span><span class="nb">long</span><span class="nv">\ </span><span class="nb">arg</span><span class="o">)</span><span class="s">$</span><span class="nb">}</span>

Some <span class="s">$</span><span class="nb">ioctl</span><span class="s">$</span>s seem to be specific to certain <span class="k">\cdrom\ </span>drives. That is,
they are introduced to service some capabilities of certain drives. In
fact, there are 6 different <span class="s">$</span><span class="nb">ioctl</span><span class="s">$</span>s for reading data, either in some
particular kind of format, or audio data. Not many drives support
reading audio tracks as data, I believe this is because of protection
of copyrights of artists. Moreover, I think that if audio-tracks are
supported, it should be done through the VFS and not via <span class="s">$</span><span class="nb">ioctl</span><span class="s">$</span>s. A
problem here could be the fact that audio-frames are 2352 bytes long,
so either the audio-file-system should ask for 75264 bytes at once
(the least common multiple of 512 and 2352), or the drivers should
bend their backs to cope with this incoherence (to which I would be
opposed).  Furthermore, it is very difficult for the hardware to find
the exact frame boundaries, since there are no synchronization headers
in audio frames.  Once these issues are resolved, this code should be
standardized in <span class="k">\cdromc</span>.

Because there are so many <span class="s">$</span><span class="nb">ioctl</span><span class="s">$</span>s that seem to be introduced to
satisfy certain drivers,<span class="k">\footnote</span><span class="nb">{</span>Is there software around that
  actually uses these? I&#39;d be interested!<span class="nb">}</span> any `non-standard&#39; <span class="s">$</span><span class="nb">ioctl</span><span class="s">$</span>s
are routed through the call <span class="s">$</span><span class="nb">dev_ioctl</span><span class="o">()</span><span class="s">$</span>. In principle, `private&#39;
<span class="s">$</span><span class="nb">ioctl</span><span class="s">$</span>s should be numbered after the device&#39;s major number, and not
the general <span class="k">\cdrom\ </span><span class="s">$</span><span class="nb">ioctl</span><span class="s">$</span> number, <span class="nb">{</span><span class="k">\tt</span> <span class="nb">{</span>0x53<span class="nb">}}</span>. Currently the
non-supported <span class="s">$</span><span class="nb">ioctl</span><span class="s">$</span>s are: <span class="nb">{</span><span class="k">\it</span> CDROMREADMODE1, CDROMREADMODE2,
  CDROMREADAUDIO, CDROMREADRAW, CDROMREADCOOKED, CDROMSEEK,
  CDROMPLAY<span class="k">\-</span>BLK and CDROM<span class="k">\-</span>READALL<span class="nb">}</span>.


<span class="k">\subsection</span><span class="nb">{</span><span class="k">\cdrom\ </span>capabilities<span class="nb">}</span>
<span class="k">\label</span><span class="nb">{</span>capability<span class="nb">}</span>

Instead of just implementing some <span class="s">$</span><span class="nb">ioctl</span><span class="s">$</span> calls, the interface in
<span class="k">\cdromc\ </span>supplies the possibility to indicate the <span class="nb">{</span><span class="k">\em</span> capabilities<span class="k">\/</span><span class="nb">}</span>
of a <span class="k">\cdrom\ </span>drive. This can be done by ORing any number of
capability-constants that are defined in <span class="k">\cdromh\ </span>at the registration
phase. Currently, the capabilities are any of:
<span class="sb">$$</span><span class="nb"></span>
<span class="nv">\halign</span><span class="nb">{$#$</span><span class="nv">\ \hfil</span><span class="nb">&amp;$</span><span class="o">/*</span><span class="nb">$ </span><span class="nv">\rm</span><span class="nb"># $</span><span class="o">*/</span><span class="nb">$</span><span class="nv">\hfil\cr</span><span class="nb"></span>
<span class="nb">CDC_CLOSE_TRAY&amp; can close tray by software control</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">CDC_OPEN_TRAY&amp; can open tray</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">CDC_LOCK&amp; can lock and unlock the door</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">CDC_SELECT_SPEED&amp; can select speed, in units of $</span><span class="nv">\sim</span><span class="nb">$</span><span class="m">150</span><span class="nv">\,</span><span class="nb">kB</span><span class="o">/</span><span class="nb">s</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">CDC_SELECT_DISC&amp; drive is juke</span><span class="o">-</span><span class="nb">box</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">CDC_MULTI_SESSION&amp; can read sessions $&gt;</span><span class="nv">\rm</span><span class="m">1</span><span class="nb">$</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">CDC_MCN&amp; can read Media Catalog Number</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">CDC_MEDIA_CHANGED&amp; can report if disc has changed</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">CDC_PLAY_AUDIO&amp; can perform audio</span><span class="o">-</span><span class="nb">functions </span><span class="o">(</span><span class="nb">play, pause, etc</span><span class="o">)</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">CDC_RESET&amp; hard reset device</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">CDC_IOCTLS&amp; driver has non</span><span class="o">-</span><span class="nb">standard ioctls</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">CDC_DRIVE_STATUS&amp; driver implements drive status</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">}</span>
<span class="s">$$</span>
The capability flag is declared <span class="s">$</span><span class="nb">const</span><span class="s">$</span>, to prevent drivers from
accidentally tampering with the contents. The capability fags actually
inform <span class="k">\cdromc\ </span>of what the driver can do. If the drive found
by the driver does not have the capability, is can be masked out by
the <span class="s">$</span><span class="nb">cdrom_device_info</span><span class="s">$</span> variable <span class="s">$</span><span class="nb">mask</span><span class="s">$</span>. For instance, the SCSI <span class="k">\cdrom</span><span class="err">\</span>
driver has implemented the code for loading and ejecting <span class="k">\cdrom</span>&#39;s, and
hence its corresponding flags in <span class="s">$</span><span class="nb">capability</span><span class="s">$</span> will be set. But a SCSI
<span class="k">\cdrom\ </span>drive might be a caddy system, which can&#39;t load the tray, and
hence for this drive the <span class="s">$</span><span class="nb">cdrom_device_info</span><span class="s">$</span> struct will have set
the <span class="s">$</span><span class="nb">CDC_CLOSE_TRAY</span><span class="s">$</span> bit in <span class="s">$</span><span class="nb">mask</span><span class="s">$</span>.

In the file <span class="k">\cdromc\ </span>you will encounter many constructions of the type
<span class="sb">$$</span><span class="nv">\it</span><span class="nb"></span>
<span class="nb">if</span><span class="nv">\ </span><span class="o">(</span><span class="nb">cdo</span><span class="nv">\rightarrow</span><span class="nb"> capability </span><span class="nv">\mathrel\&amp;</span><span class="nb"> </span><span class="nv">\mathord</span><span class="nb">{</span><span class="nv">\sim</span><span class="nb">} cdi</span><span class="nv">\rightarrow</span><span class="nb"> mask </span>
<span class="nb">   </span><span class="nv">\mathrel</span><span class="nb">{</span><span class="nv">\&amp;</span><span class="nb">} CDC_&lt;capability&gt;</span><span class="o">)</span><span class="nb"> </span><span class="nv">\ldots</span><span class="nb"></span>
<span class="s">$$</span>
There is no <span class="s">$</span><span class="nb">ioctl</span><span class="s">$</span> to set the mask<span class="k">\dots</span> The reason is that
I think it is better to control the <span class="nb">{</span><span class="k">\em</span> behavior<span class="k">\/</span><span class="nb">}</span> rather than the
<span class="nb">{</span><span class="k">\em</span> capabilities<span class="nb">}</span>.

<span class="k">\subsection</span><span class="nb">{</span>Options<span class="nb">}</span>

A final flag register controls the <span class="nb">{</span><span class="k">\em</span> behavior<span class="k">\/</span><span class="nb">}</span> of the <span class="k">\cdrom</span><span class="err">\</span>
drives, in order to satisfy different users&#39; wishes, hopefully
independently of the ideas of the respective author who happened to
have made the drive&#39;s support available to the <span class="k">\linux\ </span>community. The
current behavior options are:
<span class="sb">$$</span><span class="nb"></span>
<span class="nv">\halign</span><span class="nb">{$#$</span><span class="nv">\ \hfil</span><span class="nb">&amp;$</span><span class="o">/*</span><span class="nb">$ </span><span class="nv">\rm</span><span class="nb"># $</span><span class="o">*/</span><span class="nb">$</span><span class="nv">\hfil\cr</span><span class="nb"></span>
<span class="nb">CDO_AUTO_CLOSE&amp; try to close tray upon device $open</span><span class="o">()</span><span class="nb">$</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">CDO_AUTO_EJECT&amp; try to open tray on last device $close</span><span class="o">()</span><span class="nb">$</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">CDO_USE_FFLAGS&amp; use $file_pointer</span><span class="nv">\rightarrow</span><span class="nb"> f_flags$ to indicate</span>
<span class="nb"> purpose for $open</span><span class="o">()</span><span class="nb">$</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">CDO_LOCK&amp; try to lock door if device is opened</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">CDO_CHECK_TYPE&amp; ensure disc type is data if opened for data</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">}</span>
<span class="s">$$</span>

The initial value of this register is <span class="s">$</span><span class="nb">CDO_AUTO_CLOSE </span><span class="nv">\mathrel</span><span class="nb">|</span>
<span class="nb">CDO_USE_FFLAGS </span><span class="nv">\mathrel</span><span class="nb">| CDO_LOCK</span><span class="s">$</span>, reflecting my own view on user
interface and software standards. Before you protest, there are two
new <span class="s">$</span><span class="nb">ioctl</span><span class="s">$</span>s implemented in <span class="k">\cdromc</span>, that allow you to control the
behavior by software. These are:
<span class="sb">$$</span><span class="nb"></span>
<span class="nv">\halign</span><span class="nb">{$#$</span><span class="nv">\ \hfil</span><span class="nb">&amp;$</span><span class="o">/*</span><span class="nb">$ </span><span class="nv">\rm</span><span class="nb"># $</span><span class="o">*/</span><span class="nb">$</span><span class="nv">\hfil\cr</span><span class="nb"></span>
<span class="nb">CDROM_SET_OPTIONS&amp; set options specified in $</span><span class="o">(</span><span class="nb">int</span><span class="o">)</span><span class="nv">\ </span><span class="nb">arg$</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">CDROM_CLEAR_OPTIONS&amp; clear options specified in $</span><span class="o">(</span><span class="nb">int</span><span class="o">)</span><span class="nv">\ </span><span class="nb">arg$</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">}</span>
<span class="s">$$</span>
One option needs some more explanation: <span class="s">$</span><span class="nb">CDO_USE_FFLAGS</span><span class="s">$</span>. In the next
newsection we explain what the need for this option is.

A software package <span class="nb">{</span><span class="k">\tt</span> setcd<span class="nb">}</span>, available from the Debian distribution
and <span class="nb">{</span><span class="k">\tt</span> sunsite.unc.edu<span class="nb">}</span>, allows user level control of these flags. 

<span class="k">\newsection</span><span class="nb">{</span>The need to know the purpose of opening the <span class="k">\cdrom\ </span>device<span class="nb">}</span>

Traditionally, Unix devices can be used in two different `modes&#39;,
either by reading/writing to the device file, or by issuing
controlling commands to the device, by the device&#39;s <span class="s">$</span><span class="nb">ioctl</span><span class="o">()</span><span class="s">$</span>
call. The problem with <span class="k">\cdrom\ </span>drives, is that they can be used for
two entirely different purposes. One is to mount removable
file systems, <span class="k">\cdrom</span> s, the other is to play audio CD&#39;s. Audio commands
are implemented entirely through <span class="s">$</span><span class="nb">ioctl</span><span class="s">$</span>s, presumably because the
first implementation (SUN?) has been such. In principle there is
nothing wrong with this, but a good control of the `CD player&#39; demands
that the device can <span class="nb">{</span><span class="k">\em</span> always<span class="k">\/</span><span class="nb">}</span> be opened in order to give the
<span class="s">$</span><span class="nb">ioctl</span><span class="s">$</span> commands, regardless of the state the drive is in. 

On the other hand, when used as a removable-media disc drive (what the
original purpose of <span class="k">\cdrom</span> s is) we would like to make sure that the
disc drive is ready for operation upon opening the device. In the old
scheme, some <span class="k">\cdrom\ </span>drivers don&#39;t do any integrity checking, resulting
in a number of i/o errors reported by the VFS to the kernel when an
attempt for mounting a <span class="k">\cdrom\ </span>on an empty drive occurs. This is not a
particularly elegant way to find out that there is no <span class="k">\cdrom\ </span>inserted;
it more-or-less looks like the old IBM-PC trying to read an empty floppy
drive for a couple of seconds, after which the system complains it
can&#39;t read from it. Nowadays we can <span class="nb">{</span><span class="k">\em</span> sense<span class="k">\/</span><span class="nb">}</span> the existence of a
removable medium in a drive, and we believe we should exploit that
fact. An integrity check on opening of the device, that verifies the
availability of a <span class="k">\cdrom\ </span>and its correct type (data), would be
desirable.

These two ways of using a <span class="k">\cdrom\ </span>drive, principally for data and
secondarily for playing audio discs, have different demands for the
behavior of the <span class="s">$</span><span class="nb">open</span><span class="o">()</span><span class="s">$</span> call. Audio use simply wants to open the
device in order to get a file handle which is needed for issuing
<span class="s">$</span><span class="nb">ioctl</span><span class="s">$</span> commands, while data use wants to open for correct and
reliable data transfer. The only way user programs can indicate what
their <span class="nb">{</span><span class="k">\em</span> purpose<span class="k">\/</span><span class="nb">}</span> of opening the device is, is through the <span class="s">$</span><span class="nb">flags</span><span class="s">$</span>
parameter (see <span class="nb">{</span><span class="k">\tt</span> <span class="nb">{</span>open(2)<span class="nb">}}</span>). For <span class="k">\cdrom\ </span>devices, these flags aren&#39;t
implemented (some drivers implement checking for write-related flags,
but this is not strictly necessary if the device file has correct
permission flags). Most option flags simply don&#39;t make sense to
<span class="k">\cdrom\ </span>devices: <span class="s">$</span><span class="nb">O_CREAT</span><span class="s">$</span>, <span class="s">$</span><span class="nb">O_NOCTTY</span><span class="s">$</span>, <span class="s">$</span><span class="nb">O_TRUNC</span><span class="s">$</span>, <span class="s">$</span><span class="nb">O_APPEND</span><span class="s">$</span>, and
<span class="s">$</span><span class="nb">O_SYNC</span><span class="s">$</span> have no meaning to a <span class="k">\cdrom</span>. 

We therefore propose to use the flag <span class="s">$</span><span class="nb">O_NONBLOCK</span><span class="s">$</span> to indicate
that the device is opened just for issuing <span class="s">$</span><span class="nb">ioctl</span><span class="s">$</span>
commands. Strictly, the meaning of <span class="s">$</span><span class="nb">O_NONBLOCK</span><span class="s">$</span> is that opening and
subsequent calls to the device don&#39;t cause the calling process to
wait. We could interpret this as ``don&#39;t wait until someone has
inserted some valid data-<span class="k">\cdrom</span>.&#39;&#39; Thus, our proposal of the
implementation for the <span class="s">$</span><span class="nb">open</span><span class="o">()</span><span class="s">$</span> call for <span class="k">\cdrom</span> s is:
<span class="k">\begin</span><span class="nb">{</span>itemize<span class="nb">}</span>
<span class="k">\item</span> If no other flags are set than <span class="s">$</span><span class="nb">O_RDONLY</span><span class="s">$</span>, the device is opened
for data transfer, and the return value will be 0 only upon successful
initialization of the transfer. The call may even induce some actions
on the <span class="k">\cdrom</span>, such as closing the tray.  
<span class="k">\item</span> If the option flag <span class="s">$</span><span class="nb">O_NONBLOCK</span><span class="s">$</span> is set, opening will always be
successful, unless the whole device doesn&#39;t exist. The drive will take
no actions whatsoever. 
<span class="k">\end</span><span class="nb">{</span>itemize<span class="nb">}</span>

<span class="k">\subsection</span><span class="nb">{</span>And what about standards?<span class="nb">}</span>

You might hesitate to accept this proposal as it comes from the
<span class="k">\linux\ </span>community, and not from some standardizing institute. What
about SUN, SGI, HP and all those other Unix and hardware vendors?
Well, these companies are in the lucky position that they generally
control both the hardware and software of their supported products,
and are large enough to set their own standard. They do not have to
deal with a dozen or more different, competing hardware
configurations.<span class="k">\footnote</span><span class="nb">{</span>Incidentally, I think that SUN&#39;s approach to
mounting <span class="k">\cdrom</span> s is very good in origin: under Solaris a
volume-daemon automatically mounts a newly inserted <span class="k">\cdrom\ </span>under <span class="nb">{</span><span class="k">\tt</span>
<span class="nb">{</span>/cdrom/<span class="s">$</span><span class="nb">&lt;volume</span><span class="o">-</span><span class="nb">name&gt;</span><span class="s">$</span>/<span class="nb">}}</span>. In my opinion they should have pushed this
further and have <span class="nb">{</span><span class="k">\em</span> every<span class="k">\/</span><span class="nb">}</span> <span class="k">\cdrom\ </span>on the local area network be
mounted at the similar location, <span class="k">\ie</span>, no matter in which particular
machine you insert a <span class="k">\cdrom</span>, it will always appear at the same
position in the directory tree, on every system. When I wanted to
implement such a user-program for <span class="k">\linux</span>, I came across the
differences in behavior of the various drivers, and the need for an
<span class="s">$</span><span class="nb">ioctl</span><span class="s">$</span> informing about media changes.<span class="nb">}</span>

We believe that using <span class="s">$</span><span class="nb">O_NONBLOCK</span><span class="s">$</span> to indicate that a device is being opened
for <span class="s">$</span><span class="nb">ioctl</span><span class="s">$</span> commands only can be easily introduced in the <span class="k">\linux</span><span class="err">\</span>
community. All the CD-player authors will have to be informed, we can
even send in our own patches to the programs. The use of <span class="s">$</span><span class="nb">O_NONBLOCK</span><span class="s">$</span>
has most likely no influence on the behavior of the CD-players on
other operating systems than <span class="k">\linux</span>. Finally, a user can always revert
to old behavior by a call to <span class="s">$</span><span class="nb">ioctl</span><span class="o">(</span><span class="nb">file_descriptor, CDROM_CLEAR_OPTIONS,</span>
<span class="nb">CDO_USE_FFLAGS</span><span class="o">)</span><span class="s">$</span>. 

<span class="k">\subsection</span><span class="nb">{</span>The preferred strategy of <span class="s">$</span><span class="nb">open</span><span class="o">()</span><span class="s">$</span><span class="nb">}</span>

The routines in <span class="k">\cdromc\ </span>are designed in such a way that run-time
configuration of the behavior of <span class="k">\cdrom\ </span>devices (of <span class="nb">{</span><span class="k">\em</span> any<span class="k">\/</span><span class="nb">}</span> type)
can be carried out, by the <span class="s">$</span><span class="nb">CDROM_SET</span><span class="o">/</span><span class="nb">CLEAR_OPTIONS</span><span class="s">$</span> <span class="s">$</span><span class="nb">ioctls</span><span class="s">$</span>. Thus, various
modes of operation can be set:
<span class="k">\begin</span><span class="nb">{</span>description<span class="nb">}</span>
<span class="k">\item</span><span class="na">[$CDO_AUTO_CLOSE \mathrel| CDO_USE_FFLAGS \mathrel| CDO_LOCK$]</span> This
is the default setting. (With <span class="s">$</span><span class="nb">CDO_CHECK_TYPE</span><span class="s">$</span> it will be better, in the
future.) If the device is not yet opened by any other process, and if
the device is being opened for data (<span class="s">$</span><span class="nb">O_NONBLOCK</span><span class="s">$</span> is not set) and the
tray is found to be open, an attempt to close the tray is made. Then,
it is verified that a disc is in the drive and, if <span class="s">$</span><span class="nb">CDO_CHECK_TYPE</span><span class="s">$</span> is
set, that it contains tracks of type `data mode 1.&#39; Only if all tests
are passed is the return value zero. The door is locked to prevent file
system corruption. If the drive is opened for audio (<span class="s">$</span><span class="nb">O_NONBLOCK</span><span class="s">$</span> is
set), no actions are taken and a value of 0 will be returned. 
<span class="k">\item</span><span class="na">[$CDO_AUTO_CLOSE \mathrel| CDO_AUTO_EJECT \mathrel| CDO_LOCK$]</span> This
mimics the behavior of the current sbpcd-driver. The option flags are
ignored, the tray is closed on the first open, if necessary. Similarly,
the tray is opened on the last release, <span class="k">\ie</span>, if a <span class="k">\cdrom\ </span>is unmounted,
it is automatically ejected, such that the user can replace it.
<span class="k">\end</span><span class="nb">{</span>description<span class="nb">}</span> 
We hope that these option can convince everybody (both driver
maintainers and user program developers) to adopt the new <span class="k">\cdrom</span><span class="err">\</span>
driver scheme and option flag interpretation.

<span class="k">\newsection</span><span class="nb">{</span>Description of routines in <span class="k">\cdromc</span><span class="nb">}</span>

Only a few routines in <span class="k">\cdromc\ </span>are exported to the drivers. In this
new section we will discuss these, as well as the functions that `take
over&#39; the <span class="k">\cdrom\ </span>interface to the kernel. The header file belonging
to <span class="k">\cdromc\ </span>is called <span class="k">\cdromh</span>. Formerly, some of the contents of this
file were placed in the file <span class="nb">{</span><span class="k">\tt</span> <span class="nb">{</span>ucdrom.h<span class="nb">}}</span>, but this file has now been
merged back into <span class="k">\cdromh</span>.

<span class="k">\subsection</span><span class="nb">{</span><span class="s">$</span><span class="nb">Struct</span><span class="nv">\ </span><span class="nb">file_operations</span><span class="nv">\ </span><span class="nb">cdrom_fops</span><span class="s">$</span><span class="nb">}</span>

The contents of this structure were described in section~<span class="k">\ref</span><span class="nb">{</span>cdrom.c<span class="nb">}</span>.
A pointer to this structure is assigned to the <span class="s">$</span><span class="nb">fops</span><span class="s">$</span> field
of the <span class="s">$</span><span class="nb">struct gendisk</span><span class="s">$</span>.

<span class="k">\subsection</span><span class="nb">{</span><span class="s">$</span><span class="nb">Int</span><span class="nv">\ </span><span class="nb">register_cdrom</span><span class="o">(</span><span class="nb"> struct</span><span class="nv">\ </span><span class="nb">cdrom_device_info</span><span class="nv">\ </span><span class="o">*</span><span class="nb"> cdi</span><span class="o">)</span><span class="s">$</span><span class="nb">}</span>

This function is used in about the same way one registers <span class="s">$</span><span class="nb">cdrom_fops</span><span class="s">$</span>
with the kernel, the device operations and information structures,
as described in section~<span class="k">\ref</span><span class="nb">{</span>cdrom.c<span class="nb">}</span>, should be registered with the
<span class="k">\UCD</span>:
<span class="sb">$$</span><span class="nb"></span>
<span class="nb">register_cdrom</span><span class="o">(</span><span class="nv">\&amp;</span><span class="nb">&lt;device&gt;_info</span><span class="o">))</span><span class="nb">;</span>
<span class="s">$$</span>
This function returns zero upon success, and non-zero upon
failure. The structure <span class="s">$</span><span class="nb">&lt;device&gt;_info</span><span class="s">$</span> should have a pointer to the
driver&#39;s <span class="s">$</span><span class="nb">&lt;device&gt;_dops</span><span class="s">$</span>, as in 
<span class="sb">$$</span><span class="nb"></span>
<span class="nv">\vbox</span><span class="nb">{</span><span class="nv">\halign</span><span class="nb">{&amp;$#$</span><span class="nv">\hfil\cr</span><span class="nb"></span>
<span class="nb">struct</span><span class="nv">\ </span><span class="nb">&amp;cdrom_device_info</span><span class="nv">\ </span><span class="nb">&lt;device&gt;_info </span><span class="o">=</span><span class="nb"> </span><span class="nv">\{\cr</span><span class="nb"></span>
<span class="nb">&amp; &lt;device&gt;_dops;</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">&amp;</span><span class="nv">\ldots\cr</span><span class="nb"></span>
<span class="nv">\}\cr</span><span class="nb"></span>
<span class="nb">}}</span><span class="s">$$</span>
Note that a driver must have one static structure, <span class="s">$</span><span class="nb">&lt;device&gt;_dops</span><span class="s">$</span>, while
it may have as many structures <span class="s">$</span><span class="nb">&lt;device&gt;_info</span><span class="s">$</span> as there are minor devices
active. <span class="s">$</span><span class="nb">Register_cdrom</span><span class="o">()</span><span class="s">$</span> builds a linked list from these. 

<span class="k">\subsection</span><span class="nb">{</span><span class="s">$</span><span class="nb">Void</span><span class="nv">\ </span><span class="nb">unregister_cdrom</span><span class="o">(</span><span class="nb">struct</span><span class="nv">\ </span><span class="nb">cdrom_device_info </span><span class="o">*</span><span class="nb"> cdi</span><span class="o">)</span><span class="s">$</span><span class="nb">}</span>

Unregistering device <span class="s">$</span><span class="nb">cdi</span><span class="s">$</span> with minor number <span class="s">$</span><span class="nb">MINOR</span><span class="o">(</span><span class="nb">cdi</span><span class="nv">\to</span><span class="nb"> dev</span><span class="o">)</span><span class="s">$</span> removes
the minor device from the list. If it was the last registered minor for
the low-level driver, this disconnects the registered device-operation
routines from the <span class="k">\cdrom\ </span>interface. This function returns zero upon
success, and non-zero upon failure.

<span class="k">\subsection</span><span class="nb">{</span><span class="s">$</span><span class="nb">Int</span><span class="nv">\ </span><span class="nb">cdrom_open</span><span class="o">(</span><span class="nb">struct</span><span class="nv">\ </span><span class="nb">inode </span><span class="o">*</span><span class="nb"> ip, struct</span><span class="nv">\ </span><span class="nb">file </span><span class="o">*</span><span class="nb"> fp</span><span class="o">)</span><span class="s">$</span><span class="nb">}</span>

This function is not called directly by the low-level drivers, it is
listed in the standard <span class="s">$</span><span class="nb">cdrom_fops</span><span class="s">$</span>. If the VFS opens a file, this
function becomes active. A strategy is implemented in this routine,
taking care of all capabilities and options that are set in the
<span class="s">$</span><span class="nb">cdrom_device_ops</span><span class="s">$</span> connected to the device. Then, the program flow is
transferred to the device<span class="nb">_</span>dependent <span class="s">$</span><span class="nb">open</span><span class="o">()</span><span class="s">$</span> call.

<span class="k">\subsection</span><span class="nb">{</span><span class="s">$</span><span class="nb">Void</span><span class="nv">\ </span><span class="nb">cdrom_release</span><span class="o">(</span><span class="nb">struct</span><span class="nv">\ </span><span class="nb">inode </span><span class="o">*</span><span class="nb">ip, struct</span><span class="nv">\ </span><span class="nb">file</span>
<span class="o">*</span><span class="nb">fp</span><span class="o">)</span><span class="s">$</span><span class="nb">}</span>

This function implements the reverse-logic of <span class="s">$</span><span class="nb">cdrom_open</span><span class="o">()</span><span class="s">$</span>, and then
calls the device-dependent <span class="s">$</span><span class="nb">release</span><span class="o">()</span><span class="s">$</span> routine. When the use-count has
reached 0, the allocated buffers are flushed by calls to <span class="s">$</span><span class="nb">sync_dev</span><span class="o">(</span><span class="nb">dev</span><span class="o">)</span><span class="s">$</span>
and <span class="s">$</span><span class="nb">invalidate_buffers</span><span class="o">(</span><span class="nb">dev</span><span class="o">)</span><span class="s">$</span>.


<span class="k">\subsection</span><span class="nb">{</span><span class="s">$</span><span class="nb">Int</span><span class="nv">\ </span><span class="nb">cdrom_ioctl</span><span class="o">(</span><span class="nb">struct</span><span class="nv">\ </span><span class="nb">inode </span><span class="o">*</span><span class="nb">ip, struct</span><span class="nv">\ </span><span class="nb">file </span><span class="o">*</span><span class="nb">fp,</span>
<span class="nb">unsigned</span><span class="nv">\ </span><span class="nb">int</span><span class="nv">\ </span><span class="nb">cmd, unsigned</span><span class="nv">\ </span><span class="nb">long</span><span class="nv">\ </span><span class="nb">arg</span><span class="o">)</span><span class="s">$</span><span class="nb">}</span>
<span class="k">\label</span><span class="nb">{</span>cdrom-ioctl<span class="nb">}</span>

This function handles all the standard <span class="s">$</span><span class="nb">ioctl</span><span class="s">$</span> requests for <span class="k">\cdrom</span><span class="err">\</span>
devices in a uniform way. The different calls fall into three
categories: <span class="s">$</span><span class="nb">ioctl</span><span class="s">$</span>s that can be directly implemented by device
operations, ones that are routed through the call <span class="s">$</span><span class="nb">audio_ioctl</span><span class="o">()</span><span class="s">$</span>, and
the remaining ones, that are presumable device-dependent. Generally, a
negative return value indicates an error.

<span class="k">\subsubsection</span><span class="nb">{</span>Directly implemented <span class="s">$</span><span class="nb">ioctl</span><span class="s">$</span>s<span class="nb">}</span>
<span class="k">\label</span><span class="nb">{</span>ioctl-direct<span class="nb">}</span>

The following `old&#39; <span class="k">\cdrom</span>-<span class="s">$</span><span class="nb">ioctl</span><span class="s">$</span>s are implemented by directly
calling device-operations in <span class="s">$</span><span class="nb">cdrom_device_ops</span><span class="s">$</span>, if implemented and
not masked:
<span class="k">\begin</span><span class="nb">{</span>description<span class="nb">}</span>
<span class="k">\item</span><span class="na">[CDROMMULTISESSION]</span> Requests the last session on a <span class="k">\cdrom</span>.
<span class="k">\item</span><span class="na">[CDROMEJECT]</span> Open tray. 
<span class="k">\item</span><span class="na">[CDROMCLOSETRAY]</span> Close tray.
<span class="k">\item</span><span class="na">[CDROMEJECT_SW]</span> If <span class="s">$</span><span class="nb">arg</span><span class="nv">\not</span><span class="o">=</span><span class="m">0</span><span class="s">$</span>, set behavior to auto-close (close
tray on first open) and auto-eject (eject on last release), otherwise
set behavior to non-moving on <span class="s">$</span><span class="nb">open</span><span class="o">()</span><span class="s">$</span> and <span class="s">$</span><span class="nb">release</span><span class="o">()</span><span class="s">$</span> calls.
<span class="k">\item</span><span class="na">[CDROM_GET_MCN]</span> Get the Media Catalog Number from a CD.
<span class="k">\end</span><span class="nb">{</span>description<span class="nb">}</span>

<span class="k">\subsubsection</span><span class="nb">{</span><span class="s">$</span><span class="nb">Ioctl</span><span class="s">$</span>s routed through <span class="s">$</span><span class="nb">audio_ioctl</span><span class="o">()</span><span class="s">$</span><span class="nb">}</span>
<span class="k">\label</span><span class="nb">{</span>ioctl-audio<span class="nb">}</span>

The following set of <span class="s">$</span><span class="nb">ioctl</span><span class="s">$</span>s are all implemented through a call to
the <span class="s">$</span><span class="nb">cdrom_fops</span><span class="s">$</span> function <span class="s">$</span><span class="nb">audio_ioctl</span><span class="o">()</span><span class="s">$</span>. Memory checks and
allocation are performed in <span class="s">$</span><span class="nb">cdrom_ioctl</span><span class="o">()</span><span class="s">$</span>, and also sanitization of
address format (<span class="s">$</span><span class="nb">CDROM_LBA</span><span class="s">$</span>/<span class="s">$</span><span class="nb">CDROM_MSF</span><span class="s">$</span>) is done.
<span class="k">\begin</span><span class="nb">{</span>description<span class="nb">}</span>
<span class="k">\item</span><span class="na">[CDROMSUBCHNL]</span> Get sub-channel data in argument <span class="s">$</span><span class="nb">arg</span><span class="s">$</span> of type <span class="s">$</span><span class="nb">struct</span><span class="err">\</span><span class="nb"></span>
<span class="nb">cdrom_subchnl </span><span class="o">*</span><span class="nb">{}</span><span class="s">$</span>.
<span class="k">\item</span><span class="na">[CDROMREADTOCHDR]</span> Read Table of Contents header, in <span class="s">$</span><span class="nb">arg</span><span class="s">$</span> of type
<span class="s">$</span><span class="nb">struct</span><span class="nv">\ </span><span class="nb">cdrom_tochdr </span><span class="o">*</span><span class="nb">{}</span><span class="s">$</span>. 
<span class="k">\item</span><span class="na">[CDROMREADTOCENTRY]</span> Read a Table of Contents entry in <span class="s">$</span><span class="nb">arg</span><span class="s">$</span> and
specified by <span class="s">$</span><span class="nb">arg</span><span class="s">$</span> of type <span class="s">$</span><span class="nb">struct</span><span class="nv">\ </span><span class="nb">cdrom_tocentry </span><span class="o">*</span><span class="nb">{}</span><span class="s">$</span>.
<span class="k">\item</span><span class="na">[CDROMPLAYMSF]</span> Play audio fragment specified in Minute, Second,
Frame format, delimited by <span class="s">$</span><span class="nb">arg</span><span class="s">$</span> of type <span class="s">$</span><span class="nb">struct</span><span class="nv">\ </span><span class="nb">cdrom_msf </span><span class="o">*</span><span class="nb">{}</span><span class="s">$</span>.
<span class="k">\item</span><span class="na">[CDROMPLAYTRKIND]</span> Play audio fragment in track-index format
delimited by <span class="s">$</span><span class="nb">arg</span><span class="s">$</span> of type <span class="s">$</span><span class="nb">struct</span><span class="nv">\ \penalty</span><span class="o">-</span><span class="m">1000</span><span class="nb"> cdrom_ti </span><span class="o">*</span><span class="nb">{}</span><span class="s">$</span>.
<span class="k">\item</span><span class="na">[CDROMVOLCTRL]</span> Set volume specified by <span class="s">$</span><span class="nb">arg</span><span class="s">$</span> of type <span class="s">$</span><span class="nb">struct</span><span class="err">\</span><span class="nb"></span>
<span class="nb">cdrom_volctrl </span><span class="o">*</span><span class="nb">{}</span><span class="s">$</span>.
<span class="k">\item</span><span class="na">[CDROMVOLREAD]</span> Read volume into by <span class="s">$</span><span class="nb">arg</span><span class="s">$</span> of type <span class="s">$</span><span class="nb">struct</span><span class="err">\</span><span class="nb"></span>
<span class="nb">cdrom_volctrl </span><span class="o">*</span><span class="nb">{}</span><span class="s">$</span>.
<span class="k">\item</span><span class="na">[CDROMSTART]</span> Spin up disc.
<span class="k">\item</span><span class="na">[CDROMSTOP]</span> Stop playback of audio fragment.
<span class="k">\item</span><span class="na">[CDROMPAUSE]</span> Pause playback of audio fragment.
<span class="k">\item</span><span class="na">[CDROMRESUME]</span> Resume playing.
<span class="k">\end</span><span class="nb">{</span>description<span class="nb">}</span>

<span class="k">\subsubsection</span><span class="nb">{</span>New <span class="s">$</span><span class="nb">ioctl</span><span class="s">$</span>s in <span class="k">\cdromc</span><span class="nb">}</span>

The following <span class="s">$</span><span class="nb">ioctl</span><span class="s">$</span>s have been introduced to allow user programs to
control the behavior of individual <span class="k">\cdrom\ </span>devices. New <span class="s">$</span><span class="nb">ioctl</span><span class="s">$</span>
commands can be identified by the underscores in their names.
<span class="k">\begin</span><span class="nb">{</span>description<span class="nb">}</span>
<span class="k">\item</span><span class="na">[CDROM_SET_OPTIONS]</span> Set options specified by <span class="s">$</span><span class="nb">arg</span><span class="s">$</span>. Returns the
option flag register after modification. Use  <span class="s">$</span><span class="nb">arg </span><span class="o">=</span><span class="nb"> </span><span class="nv">\rm</span><span class="m">0</span><span class="s">$</span> for reading
the current flags.
<span class="k">\item</span><span class="na">[CDROM_CLEAR_OPTIONS]</span> Clear options specified by <span class="s">$</span><span class="nb">arg</span><span class="s">$</span>. Returns
  the option flag register after modification.
<span class="k">\item</span><span class="na">[CDROM_SELECT_SPEED]</span> Select head-rate speed of disc specified as
  by <span class="s">$</span><span class="nb">arg</span><span class="s">$</span> in units of standard cdrom speed (176<span class="k">\,</span>kB/sec raw data or
  150<span class="k">\,</span>kB/sec file system data). The value 0 means `auto-select&#39;, <span class="k">\ie</span>,
  play audio discs at real time and data discs at maximum speed. The value
  <span class="s">$</span><span class="nb">arg</span><span class="s">$</span> is checked against the maximum head rate of the drive found in the
  <span class="s">$</span><span class="nb">cdrom_dops</span><span class="s">$</span>.
<span class="k">\item</span><span class="na">[CDROM_SELECT_DISC]</span> Select disc numbered <span class="s">$</span><span class="nb">arg</span><span class="s">$</span> from a juke-box.
  First disc is numbered 0. The number <span class="s">$</span><span class="nb">arg</span><span class="s">$</span> is checked against the
  maximum number of discs in the juke-box found in the <span class="s">$</span><span class="nb">cdrom_dops</span><span class="s">$</span>.
<span class="k">\item</span><span class="na">[CDROM_MEDIA_CHANGED]</span> Returns 1 if a disc has been changed since
  the last call. Note that calls to <span class="s">$</span><span class="nb">cdrom_media_changed</span><span class="s">$</span> by the VFS
  are treated by an independent queue, so both mechanisms will detect
  a media change once. For juke-boxes, an extra argument <span class="s">$</span><span class="nb">arg</span><span class="s">$</span>
  specifies the slot for which the information is given. The special
  value <span class="s">$</span><span class="nb">CDSL_CURRENT</span><span class="s">$</span> requests that information about the currently
  selected slot be returned.
<span class="k">\item</span><span class="na">[CDROM_DRIVE_STATUS]</span> Returns the status of the drive by a call to
  <span class="s">$</span><span class="nb">drive_status</span><span class="o">()</span><span class="s">$</span>. Return values are defined in section~<span class="k">\ref</span><span class="nb">{</span>drive
   status<span class="nb">}</span>. Note that this call doesn&#39;t return information on the
  current playing activity of the drive; this can be polled through an
  <span class="s">$</span><span class="nb">ioctl</span><span class="s">$</span> call to <span class="s">$</span><span class="nb">CDROMSUBCHNL</span><span class="s">$</span>. For juke-boxes, an extra argument
  <span class="s">$</span><span class="nb">arg</span><span class="s">$</span> specifies the slot for which (possibly limited) information is
  given. The special value <span class="s">$</span><span class="nb">CDSL_CURRENT</span><span class="s">$</span> requests that information
  about the currently selected slot be returned.
<span class="k">\item</span><span class="na">[CDROM_DISC_STATUS]</span> Returns the type of the disc currently in the
  drive.  It should be viewed as a complement to <span class="s">$</span><span class="nb">CDROM_DRIVE_STATUS</span><span class="s">$</span>.
  This <span class="s">$</span><span class="nb">ioctl</span><span class="s">$</span> can provide <span class="k">\emph</span> <span class="nb">{</span>some<span class="nb">}</span> information about the current
  disc that is inserted in the drive.  This functionality used to be
  implemented in the low level drivers, but is now carried out
  entirely in <span class="k">\UCD</span>.
  
  The history of development of the CD&#39;s use as a carrier medium for
  various digital information has lead to many different disc types.
  This <span class="s">$</span><span class="nb">ioctl</span><span class="s">$</span> is useful only in the case that CDs have <span class="k">\emph</span> <span class="nb">{</span>only
    one<span class="nb">}</span> type of data on them.  While this is often the case, it is
  also very common for CDs to have some tracks with data, and some
  tracks with audio.  Because this is an existing interface, rather
  than fixing this interface by changing the assumptions it was made
  under, thereby breaking all user applications that use this
  function, the <span class="k">\UCD\ </span>implements this <span class="s">$</span><span class="nb">ioctl</span><span class="s">$</span> as follows: If the CD in
  question has audio tracks on it, and it has absolutely no CD-I, XA,
  or data tracks on it, it will be reported as <span class="s">$</span><span class="nb">CDS_AUDIO</span><span class="s">$</span>.  If it has
  both audio and data tracks, it will return <span class="s">$</span><span class="nb">CDS_MIXED</span><span class="s">$</span>.  If there
  are no audio tracks on the disc, and if the CD in question has any
  CD-I tracks on it, it will be reported as <span class="s">$</span><span class="nb">CDS_XA_</span><span class="m">2</span><span class="nb">_</span><span class="m">2</span><span class="s">$</span>.  Failing
  that, if the CD in question has any XA tracks on it, it will be
  reported as <span class="s">$</span><span class="nb">CDS_XA_</span><span class="m">2</span><span class="nb">_</span><span class="m">1</span><span class="s">$</span>.  Finally, if the CD in question has any
  data tracks on it, it will be reported as a data CD (<span class="s">$</span><span class="nb">CDS_DATA_</span><span class="m">1</span><span class="s">$</span>).

  This <span class="s">$</span><span class="nb">ioctl</span><span class="s">$</span> can return:
  <span class="sb">$$</span><span class="nb"></span>
<span class="nb">  </span><span class="nv">\halign</span><span class="nb">{$#$</span><span class="nv">\ \hfil</span><span class="nb">&amp;$</span><span class="o">/*</span><span class="nb">$ </span><span class="nv">\rm</span><span class="nb"># $</span><span class="o">*/</span><span class="nb">$</span><span class="nv">\hfil\cr</span><span class="nb"></span>
<span class="nb">    CDS_NO_INFO&amp; no information available</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">    CDS_NO_DISC&amp; no disc is inserted, or tray is opened</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">    CDS_AUDIO&amp; Audio disc </span><span class="o">(</span><span class="m">2352</span><span class="nb"> audio bytes</span><span class="o">/</span><span class="nb">frame</span><span class="o">)</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">    CDS_DATA_</span><span class="m">1</span><span class="nb">&amp; data disc, mode </span><span class="m">1</span><span class="nb"> </span><span class="o">(</span><span class="m">2048</span><span class="nb"> user bytes</span><span class="o">/</span><span class="nb">frame</span><span class="o">)</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">    CDS_XA_</span><span class="m">2</span><span class="nb">_</span><span class="m">1</span><span class="nb">&amp; mixed data </span><span class="o">(</span><span class="nb">XA</span><span class="o">)</span><span class="nb">, mode </span><span class="m">2</span><span class="nb">, form </span><span class="m">1</span><span class="nb"> </span><span class="o">(</span><span class="m">2048</span><span class="nb"> user bytes</span><span class="o">)</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">    CDS_XA_</span><span class="m">2</span><span class="nb">_</span><span class="m">2</span><span class="nb">&amp; mixed data </span><span class="o">(</span><span class="nb">XA</span><span class="o">)</span><span class="nb">, mode </span><span class="m">2</span><span class="nb">, form </span><span class="m">1</span><span class="nb"> </span><span class="o">(</span><span class="m">2324</span><span class="nb">  user bytes</span><span class="o">)</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">    CDS_MIXED&amp; mixed audio</span><span class="o">/</span><span class="nb">data disc</span><span class="nv">\cr</span><span class="nb"></span>
<span class="nb">    }</span>
<span class="nb">  </span><span class="s">$$</span>
  For some information concerning frame layout of the various disc
  types, see a recent version of <span class="k">\cdromh</span>.

<span class="k">\item</span><span class="na">[CDROM_CHANGER_NSLOTS]</span> Returns the number of slots in a
  juke-box. 
<span class="k">\item</span><span class="na">[CDROMRESET]</span> Reset the drive. 
<span class="k">\item</span><span class="na">[CDROM_GET_CAPABILITY]</span> Returns the <span class="s">$</span><span class="nb">capability</span><span class="s">$</span> flags for the
  drive. Refer to section <span class="k">\ref</span><span class="nb">{</span>capability<span class="nb">}</span> for more information on
  these flags.
<span class="k">\item</span><span class="na">[CDROM_LOCKDOOR]</span> Locks the door of the drive. <span class="s">$</span><span class="nb">arg </span><span class="o">==</span><span class="nb"> </span><span class="nv">\rm</span><span class="m">0</span><span class="s">$</span>
  unlocks the door, any other value locks it.
<span class="k">\item</span><span class="na">[CDROM_DEBUG]</span> Turns on debugging info. Only root is allowed
  to do this. Same semantics as CDROM<span class="nb">_</span>LOCKDOOR.
<span class="k">\end</span><span class="nb">{</span>description<span class="nb">}</span>

<span class="k">\subsubsection</span><span class="nb">{</span>Device dependent <span class="s">$</span><span class="nb">ioctl</span><span class="s">$</span>s<span class="nb">}</span>

Finally, all other <span class="s">$</span><span class="nb">ioctl</span><span class="s">$</span>s are passed to the function <span class="s">$</span><span class="nb">dev_ioctl</span><span class="o">()</span><span class="s">$</span>,
if implemented. No memory allocation or verification is carried out. 

<span class="k">\newsection</span><span class="nb">{</span>How to update your driver<span class="nb">}</span>

<span class="k">\begin</span><span class="nb">{</span>enumerate<span class="nb">}</span>
<span class="k">\item</span> Make a backup of your current driver. 
<span class="k">\item</span> Get hold of the files <span class="k">\cdromc\ </span>and <span class="k">\cdromh</span>, they should be in
  the directory tree that came with this documentation.
<span class="k">\item</span> Make sure you include <span class="k">\cdromh</span>.
<span class="k">\item</span> Change the 3rd argument of <span class="s">$</span><span class="nb">register_blkdev</span><span class="s">$</span> from
<span class="s">$</span><span class="nv">\&amp;</span><span class="nb">&lt;your</span><span class="o">-</span><span class="nb">drive&gt;_fops</span><span class="s">$</span> to <span class="s">$</span><span class="nv">\&amp;</span><span class="nb">cdrom_fops</span><span class="s">$</span>. 
<span class="k">\item</span> Just after that line, add the following to register with the <span class="k">\UCD</span>:
  <span class="sb">$$</span><span class="nb">register_cdrom</span><span class="o">(</span><span class="nv">\&amp;</span><span class="nb">&lt;your</span><span class="o">-</span><span class="nb">drive&gt;_info</span><span class="o">)</span><span class="nb">;</span><span class="s">$$</span>
  Similarly, add a call to <span class="s">$</span><span class="nb">unregister_cdrom</span><span class="o">()</span><span class="s">$</span> at the appropriate place.
<span class="k">\item</span> Copy an example of the device-operations <span class="s">$</span><span class="nb">struct</span><span class="s">$</span> to your
  source, <span class="k">\eg</span>, from <span class="nb">{</span><span class="k">\tt</span> <span class="nb">{</span>cm206.c<span class="nb">}}</span> <span class="s">$</span><span class="nb">cm</span><span class="m">206</span><span class="nb">_dops</span><span class="s">$</span>, and change all
  entries to names corresponding to your driver, or names you just
  happen to like. If your driver doesn&#39;t support a certain function,
  make the entry <span class="s">$</span><span class="nb">NULL</span><span class="s">$</span>. At the entry <span class="s">$</span><span class="nb">capability</span><span class="s">$</span> you should list all
  capabilities your driver currently supports. If your driver
  has a capability that is not listed, please send me a message.
<span class="k">\item</span> Copy the <span class="s">$</span><span class="nb">cdrom_device_info</span><span class="s">$</span> declaration from the same example
  driver, and modify the entries according to your needs. If your
  driver dynamically determines the capabilities of the hardware, this
  structure should also be declared dynamically. 
<span class="k">\item</span> Implement all functions in your <span class="s">$</span><span class="nb">&lt;device&gt;_dops</span><span class="s">$</span> structure,
  according to prototypes listed in <span class="k">\cdromh</span>, and specifications given
  in section~<span class="k">\ref</span><span class="nb">{</span>cdrom.c<span class="nb">}</span>. Most likely you have already implemented
  the code in a large part, and you will almost certainly need to adapt the
  prototype and return values.
<span class="k">\item</span> Rename your <span class="s">$</span><span class="nb">&lt;device&gt;_ioctl</span><span class="o">()</span><span class="s">$</span> function to <span class="s">$</span><span class="nb">audio_ioctl</span><span class="s">$</span> and
  change the prototype a little. Remove entries listed in the first
  part in section~<span class="k">\ref</span><span class="nb">{</span>cdrom-ioctl<span class="nb">}</span>, if your code was OK, these are
  just calls to the routines you adapted in the previous step.
<span class="k">\item</span> You may remove all remaining memory checking code in the
  <span class="s">$</span><span class="nb">audio_ioctl</span><span class="o">()</span><span class="s">$</span> function that deals with audio commands (these are
  listed in the second part of section~<span class="k">\ref</span><span class="nb">{</span>cdrom-ioctl<span class="nb">}</span>). There is no
  need for memory allocation either, so most <span class="s">$</span><span class="nb">case</span><span class="s">$</span>s in the <span class="s">$</span><span class="nb">switch</span><span class="s">$</span>
  statement look similar to:
  <span class="sb">$$</span><span class="nb"></span>
<span class="nb">  case</span><span class="nv">\ </span><span class="nb">CDROMREADTOCENTRY</span><span class="nv">\colon</span><span class="nb"> get_toc_entry</span><span class="nv">\bigl</span><span class="o">((</span><span class="nb">struct</span><span class="nv">\ </span><span class="nb"></span>
<span class="nb">  cdrom_tocentry </span><span class="o">*</span><span class="nb">{}</span><span class="o">)</span><span class="nv">\ </span><span class="nb">arg</span><span class="nv">\bigr</span><span class="o">)</span><span class="nb">;</span>
<span class="nb">  </span><span class="s">$$</span>
<span class="k">\item</span> All remaining <span class="s">$</span><span class="nb">ioctl</span><span class="s">$</span> cases must be moved to a separate
  function, <span class="s">$</span><span class="nb">&lt;device&gt;_ioctl</span><span class="s">$</span>, the device-dependent <span class="s">$</span><span class="nb">ioctl</span><span class="s">$</span>s. Note that
  memory checking and allocation must be kept in this code!
<span class="k">\item</span> Change the prototypes of <span class="s">$</span><span class="nb">&lt;device&gt;_open</span><span class="o">()</span><span class="s">$</span> and
  <span class="s">$</span><span class="nb">&lt;device&gt;_release</span><span class="o">()</span><span class="s">$</span>, and remove any strategic code (<span class="k">\ie</span>, tray
  movement, door locking, etc.).
<span class="k">\item</span> Try to recompile the drivers. We advise you to use modules, both
  for <span class="nb">{</span><span class="k">\tt</span> <span class="nb">{</span>cdrom.o<span class="nb">}}</span> and your driver, as debugging is much easier this
  way.
<span class="k">\end</span><span class="nb">{</span>enumerate<span class="nb">}</span> 

<span class="k">\newsection</span><span class="nb">{</span>Thanks<span class="nb">}</span>

Thanks to all the people involved.  First, Erik Andersen, who has
taken over the torch in maintaining <span class="k">\cdromc\ </span>and integrating much
<span class="k">\cdrom</span>-related code in the 2.1-kernel.  Thanks to Scott Snyder and
Gerd Knorr, who were the first to implement this interface for SCSI
and IDE-CD drivers and added many ideas for extension of the data
structures relative to kernel~2.0.  Further thanks to Heiko Ei<span class="nb">{</span><span class="k">\sz</span><span class="nb">}</span>feldt,
Thomas Quinot, Jon Tombs, Ken Pizzini, Eberhard M<span class="k">\&quot;</span>onkeberg and Andrew
Kroll, the <span class="k">\linux\ \cdrom\ </span>device driver developers who were kind
enough to give suggestions and criticisms during the writing. Finally
of course, I want to thank Linus Torvalds for making this possible in
the first place.

<span class="k">\vfill</span>
<span class="s">$</span><span class="nb"> </span><span class="nv">\version\ </span><span class="s">$</span>
<span class="k">\eject</span>
<span class="k">\end</span><span class="nb">{</span>document<span class="nb">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
