f | netfs-api.txt | g | 28K |  | David Howells | dhowells@redhat.com | 1310070116 |  | FS-Cache: Add a helper to bulk uncache pages on an inode  Add an FS-Cache helper to bulk uncache pages on an inode.  This will only work for the circumstance where the pages in the cache correspond 1:1 with the pages attached to an inode's page cache.  This is required for CIFS and NFS: When disabling inode cookie, we were returning the cookie and setting cifsi->fscache to NULL but failed to invalidate any previously mapped pages.  This resulted in "Bad page state" errors and manifested in other kind of errors when running fsstress.  Fix it by uncaching mapped pages when we disable the inode cookie.  This patch should fix the following oops and "Bad page state" errors seen during fsstress testing.    ------------[ cut here ]------------   kernel BUG at fs/cachefiles/namei.c:201!   invalid opcode: 0000 [#1] SMP   Pid: 5, comm: kworker/u:0 Not tainted 2.6.38.7-30.fc15.x86_64 #1 Bochs Bochs   RIP: 0010: cachefiles_walk_to_object+0x436/0x745 [cachefiles]   RSP: 0018:ffff88002ce6dd00  EFLAGS: 00010282   RAX: ffff88002ef165f0 RBX: ffff88001811f500 RCX: 0000000000000000   RDX: 0000000000000000 RSI: 0000000000000100 RDI: 0000000000000282   RBP: ffff88002ce6dda0 R08: 0000000000000100 R09: ffffffff81b3a300   R10: 0000ffff00066c0a R11: 0000000000000003 R12: ffff88002ae54840   R13: ffff88002ae54840 R14: ffff880029c29c00 R15: ffff88001811f4b0   FS:  00007f394dd32720(0000) GS:ffff88002ef00000(0000) knlGS:0000000000000000   CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b   CR2: 00007fffcb62ddf8 CR3: 000000001825f000 CR4: 00000000000006e0   DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000   DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400   Process kworker/u:0 (pid: 5, threadinfo ffff88002ce6c000, task ffff88002ce55cc0)   Stack:    0000000000000246 ffff88002ce55cc0 ffff88002ce6dd58 ffff88001815dc00    ffff8800185246c0 ffff88001811f618 ffff880029c29d18 ffff88001811f380    ffff88002ce6dd50 ffffffff814757e4 ffff88002ce6dda0 ffffffff8106ac56   Call Trace:    cachefiles_lookup_object+0x78/0xd4 [cachefiles]    fscache_lookup_object+0x131/0x16d [fscache]    fscache_object_work_func+0x1bc/0x669 [fscache]    process_one_work+0x186/0x298    worker_thread+0xda/0x15d    kthread+0x84/0x8c    kernel_thread_helper+0x4/0x10   RIP  cachefiles_walk_to_object+0x436/0x745 [cachefiles]   ---[ end trace 1d481c9af1804caa ]---  I tested the uncaching by the following means:   (1) Create a big file on my NFS server (104857600 bytes).   (2) Read the file into the cache with md5sum on the NFS client.  Look in      /proc/fs/fscache/stats:  	Pages  : mrk=25601 unc=0   (3) Open the file for read/write ("bash 5<>/warthog/bigfile").  Look in proc      again:  	Pages  : mrk=25601 unc=25601  Reported-by: Jeff Layton <jlayton@redhat.com> Signed-off-by: David Howells <dhowells@redhat.com> Reviewed-and-Tested-by: Suresh Jayaraman <sjayaraman@suse.de> cc: stable@kernel.org Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
f | fscache.txt | g | 18K |  | Tejun Heo | tj@kernel.org | 1279832314 |  | fscache: convert object to use workqueue instead of slow-work  Make fscache object state transition callbacks use workqueue instead of slow-work.  New dedicated unbound CPU workqueue fscache_object_wq is created.  get/put callbacks are renamed and modified to take @object and called directly from the enqueue wrapper and the work function.  While at it, make all open coded instances of get/put to use fscache_get/put_object().  * Unbound workqueue is used.  * work_busy() output is printed instead of slow-work flags in object   debugging outputs.  They mean basically the same thing bit-for-bit.  * sysctl fscache.object_max_active added to control concurrency.  The   default value is nr_cpus clamped between 4 and   WQ_UNBOUND_MAX_ACTIVE.  * slow_work_sleep_till_thread_needed() is replaced with fscache   private implementation fscache_object_sleep_till_congested() which   waits on fscache_object_wq congestion.  * debugfs support is dropped for now.  Tracing API based debug   facility is planned to be added.  Signed-off-by: Tejun Heo <tj@kernel.org> Acked-by: David Howells <dhowells@redhat.com>
f | cachefiles.txt | g | 16K |  | Marc Dionne | marc.c.dionne@gmail.com | 1240604910 |  | CacheFiles: Fix the documentation to use the correct credential pointer names  Adjust the CacheFiles documentation to use the correct names of the credential pointers in task_struct.  The documentation was using names from the old versions of the credentials patches.  Signed-off-by: Marc Dionne <marc.c.dionne@gmail.com> Signed-off-by: David Howells <dhowells@redhat.com> Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
f | backend-api.txt | g | 22K |  | David Howells | dhowells@redhat.com | 1238773357 |  | FS-Cache: Add use of /proc and presentation of statistics  Make FS-Cache create its /proc interface and present various statistical information through it.  Also provide the functions for updating this information.  These features are enabled by:  	CONFIG_FSCACHE_PROC 	CONFIG_FSCACHE_STATS 	CONFIG_FSCACHE_HISTOGRAM  The /proc directory for FS-Cache is also exported so that caching modules can add their own statistics there too.  The FS-Cache module is loadable at this point, and the statistics files can be examined by userspace:  	cat /proc/fs/fscache/stats 	cat /proc/fs/fscache/histogram  Signed-off-by: David Howells <dhowells@redhat.com> Acked-by: Steve Dickson <steved@redhat.com> Acked-by: Trond Myklebust <Trond.Myklebust@netapp.com> Acked-by: Al Viro <viro@zeniv.linux.org.uk> Tested-by: Daire Byrne <Daire.Byrne@framestore.com>
f | object.txt | g | 12K |  | Paul Bolle | pebolle@tiscali.nl | 1317139684 |  | doc: fix broken references  There are numerous broken references to Documentation files (in other Documentation files, in comments, etc.). These broken references are caused by typo's in the references, and by renames or removals of the Documentation files. Some broken references are simply odd.  Fix these broken references, sometimes by dropping the irrelevant text they were part of.  Signed-off-by: Paul Bolle <pebolle@tiscali.nl> Signed-off-by: Jiri Kosina <jkosina@suse.cz>
f | operations.txt | g | 7.2K |  | David Howells | dhowells@redhat.com | 1238773359 |  | FS-Cache: Add and document asynchronous operation handling  Add and document asynchronous operation handling for use by FS-Cache's data storage and retrieval routines.  The following documentation is added to:  	Documentation/filesystems/caching/operations.txt  		       ================================ 		       ASYNCHRONOUS OPERATIONS HANDLING 		       ================================  ======== OVERVIEW ========  FS-Cache has an asynchronous operations handling facility that it uses for its data storage and retrieval routines.  Its operations are represented by fscache_operation structs, though these are usually embedded into some other structure.  This facility is available to and expected to be be used by the cache backends, and FS-Cache will create operations and pass them off to the appropriate cache backend for completion.  To make use of this facility, <linux/fscache-cache.h> should be #included.  =============================== OPERATION RECORD INITIALISATION ===============================  An operation is recorded in an fscache_operation struct:  	struct fscache_operation { 		union { 			struct work_struct fast_work; 			struct slow_work slow_work; 		}; 		unsigned long		flags; 		fscache_operation_processor_t processor; 		... 	};  Someone wanting to issue an operation should allocate something with this struct embedded in it.  They should initialise it by calling:  	void fscache_operation_init(struct fscache_operation *op, 				    fscache_operation_release_t release);  with the operation to be initialised and the release function to use.  The op->flags parameter should be set to indicate the CPU time provision and the exclusivity (see the Parameters section).  The op->fast_work, op->slow_work and op->processor flags should be set as appropriate for the CPU time provision (see the Parameters section).  FSCACHE_OP_WAITING may be set in op->flags prior to each submission of the operation and waited for afterwards.  ========== PARAMETERS ==========  There are a number of parameters that can be set in the operation record's flag parameter.  There are three options for the provision of CPU time in these operations:   (1) The operation may be done synchronously (FSCACHE_OP_MYTHREAD).  A thread      may decide it wants to handle an operation itself without deferring it to      another thread.       This is, for example, used in read operations for calling readpages() on      the backing filesystem in CacheFiles.  Although readpages() does an      asynchronous data fetch, the determination of whether pages exist is done      synchronously - and the netfs does not proceed until this has been      determined.       If this option is to be used, FSCACHE_OP_WAITING must be set in op->flags      before submitting the operation, and the operating thread must wait for it      to be cleared before proceeding:  		wait_on_bit(&op->flags, FSCACHE_OP_WAITING, 			    fscache_wait_bit, TASK_UNINTERRUPTIBLE);   (2) The operation may be fast asynchronous (FSCACHE_OP_FAST), in which case it      will be given to keventd to process.  Such an operation is not permitted      to sleep on I/O.       This is, for example, used by CacheFiles to copy data from a backing fs      page to a netfs page after the backing fs has read the page in.       If this option is used, op->fast_work and op->processor must be      initialised before submitting the operation:  		INIT_WORK(&op->fast_work, do_some_work);   (3) The operation may be slow asynchronous (FSCACHE_OP_SLOW), in which case it      will be given to the slow work facility to process.  Such an operation is      permitted to sleep on I/O.       This is, for example, used by FS-Cache to handle background writes of      pages that have just been fetched from a remote server.       If this option is used, op->slow_work and op->processor must be      initialised before submitting the operation:  		fscache_operation_init_slow(op, processor)  Furthermore, operations may be one of two types:   (1) Exclusive (FSCACHE_OP_EXCLUSIVE).  Operations of this type may not run in      conjunction with any other operation on the object being operated upon.       An example of this is the attribute change operation, in which the file      being written to may need truncation.   (2) Shareable.  Operations of this type may be running simultaneously.  It's      up to the operation implementation to prevent interference between other      operations running at the same time.  ========= PROCEDURE =========  Operations are used through the following procedure:   (1) The submitting thread must allocate the operation and initialise it      itself.  Normally this would be part of a more specific structure with the      generic op embedded within.   (2) The submitting thread must then submit the operation for processing using      one of the following two functions:  	int fscache_submit_op(struct fscache_object *object, 			      struct fscache_operation *op);  	int fscache_submit_exclusive_op(struct fscache_object *object, 					struct fscache_operation *op);       The first function should be used to submit non-exclusive ops and the      second to submit exclusive ones.  The caller must still set the      FSCACHE_OP_EXCLUSIVE flag.       If successful, both functions will assign the operation to the specified      object and return 0.  -ENOBUFS will be returned if the object specified is      permanently unavailable.       The operation manager will defer operations on an object that is still      undergoing lookup or creation.  The operation will also be deferred if an      operation of conflicting exclusivity is in progress on the object.       If the operation is asynchronous, the manager will retain a reference to      it, so the caller should put their reference to it by passing it to:  	void fscache_put_operation(struct fscache_operation *op);   (3) If the submitting thread wants to do the work itself, and has marked the      operation with FSCACHE_OP_MYTHREAD, then it should monitor      FSCACHE_OP_WAITING as described above and check the state of the object if      necessary (the object might have died whilst the thread was waiting).       When it has finished doing its processing, it should call      fscache_put_operation() on it.   (4) The operation holds an effective lock upon the object, preventing other      exclusive ops conflicting until it is released.  The operation can be      enqueued for further immediate asynchronous processing by adjusting the      CPU time provisioning option if necessary, eg:  	op->flags &= ~FSCACHE_OP_TYPE; 	op->flags ||= ~FSCACHE_OP_FAST;       and calling:  	void fscache_enqueue_operation(struct fscache_operation *op)       This can be used to allow other things to have use of the worker thread      pools.  ===================== ASYNCHRONOUS CALLBACK =====================  When used in asynchronous mode, the worker thread pool will invoke the processor method with a pointer to the operation.  This should then get at the container struct by using container_of():  	static void fscache_write_op(struct fscache_operation *_op) 	{ 		struct fscache_storage *op = 			container_of(_op, struct fscache_storage, op); 	... 	}  The caller holds a reference on the operation, and will invoke fscache_put_operation() when the processor function returns.  The processor function is at liberty to call fscache_enqueue_operation() or to take extra references.  Signed-off-by: David Howells <dhowells@redhat.com> Acked-by: Steve Dickson <steved@redhat.com> Acked-by: Trond Myklebust <Trond.Myklebust@netapp.com> Acked-by: Al Viro <viro@zeniv.linux.org.uk> Tested-by: Daire Byrne <Daire.Byrne@framestore.com>
