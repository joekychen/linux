f | kvm_main.c | s | 61K | 2407 | Konstantin Weitz | WEITZKON@de.ibm.com | 1335832711 |  | KVM: s390: Implement the directed yield (diag 9c) hypervisor call for KVM  This patch implements the directed yield hypercall found on other System z hypervisors. It delegates execution time to the virtual cpu specified in the instruction's parameter.  Useful to avoid long spinlock waits in the guest.  Christian Borntraeger: moved common code in virt/kvm/  Signed-off-by: Konstantin Weitz <WEITZKON@de.ibm.com> Signed-off-by: Christian Borntraeger <borntraeger@de.ibm.com> Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
f | iommu.c | s | 8.3K | 281 | Alex Williamson | alex.williamson@redhat.com | 1334804658 |  | KVM: lock slots_lock around device assignment  As pointed out by Jason Baron, when assigning a device to a guest we first set the iommu domain pointer, which enables mapping and unmapping of memory slots to the iommu.  This leaves a window where this path is enabled, but we haven't synchronized the iommu mappings to the existing memory slots.  Thus a slot being removed at that point could send us down unexpected code paths removing non-existent pinnings and iommu mappings.  Take the slots_lock around creating the iommu domain and initial mappings as well as around iommu teardown to avoid this race.  Signed-off-by: Alex Williamson <alex.williamson@redhat.com> Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
f | coalesced_mmio.c | s | 4.1K | 147 | Dan Carpenter | dan.carpenter@oracle.com | 1324977427 |  | KVM: make checks stricter in coalesced_mmio_in_range()  My testing version of Smatch complains that addr and len come from the user and they can wrap.  The path is:   -> kvm_vm_ioctl()      -> kvm_vm_ioctl_unregister_coalesced_mmio()         -> coalesced_mmio_in_range()  I don't know what the implications are of wrapping here, but we may as well fix it, if only to silence the warning.  Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com> Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
f | eventfd.c | s | 15K | 536 | Sasha Levin | levinsasha928@gmail.com | 1316967479 |  | KVM: Intelligent device lookup on I/O bus  Currently the method of dealing with an IO operation on a bus (PIO/MMIO) is to call the read or write callback for each device registered on the bus until we find a device which handles it.  Since the number of devices on a bus can be significant due to ioeventfds and coalesced MMIO zones, this leads to a lot of overhead on each IO operation.  Instead of registering devices, we now register ranges which points to a device. Lookup is done using an efficient bsearch instead of a linear search.  Performance test was conducted by comparing exit count per second with 200 ioeventfds created on one byte and the guest is trying to access a different byte continuously (triggering usermode exits). Before the patch the guest has achieved 259k exits per second, after the patch the guest does 274k exits per second.  Cc: Avi Kivity <avi@redhat.com> Cc: Marcelo Tosatti <mtosatti@redhat.com> Signed-off-by: Sasha Levin <levinsasha928@gmail.com> Signed-off-by: Avi Kivity <avi@redhat.com>
f | irq_comm.c | s | 12K | 417 | Avi Kivity | avi@redhat.com | 1338903598 |  | KVM: Fix buffer overflow in kvm_set_irq()  kvm_set_irq() has an internal buffer of three irq routing entries, allowing connecting a GSI to three IRQ chips or on MSI.  However setup_routing_entry() does not properly enforce this, allowing three irqchip routes followed by an MSI route to overflow the buffer.  Fix by ensuring that an MSI entry is added to an empty list.  Signed-off-by: Avi Kivity <avi@redhat.com>
f | ioapic.h | s | 2.3K | 71 | Michael S. Tsirkin | mst@redhat.com | 1334619398 |  | KVM: dont clear TMR on EOI  Intel spec says that TMR needs to be set/cleared when IRR is set, but kvm also clears it on  EOI.  I did some tests on a real (AMD based) system, and I see same TMR values both before and after EOI, so I think it's a minor bug in kvm.  This patch fixes TMR to be set/cleared on IRR set only as per spec.  And now that we don't clear TMR, we can save an atomic read of TMR on EOI that's not propagated to ioapic, by checking whether ioapic needs a specific vector first and calculating the mode afterwards.  Signed-off-by: Michael S. Tsirkin <mst@redhat.com> Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
f | iodev.h | s | 1.9K | 59 | Michael S. Tsirkin | mst@redhat.com | 1252560785 |  | KVM: remove in_range from io devices  This changes bus accesses to use high-level kvm_io_bus_read/kvm_io_bus_write functions. in_range now becomes unused so it is removed from device ops in favor of read/write callbacks performing range checks internally.  This allows aliasing (mostly for in-kernel virtio), as well as better error handling by making it possible to pass errors up to userspace.  Signed-off-by: Michael S. Tsirkin <mst@redhat.com> Signed-off-by: Avi Kivity <avi@redhat.com>
f | async_pf.h | s | 1.1K | 33 | Gleb Natapov | gleb@redhat.com | 1294824099 |  | KVM: Halt vcpu if page it tries to access is swapped out  If a guest accesses swapped out memory do not swap it in from vcpu thread context. Schedule work to do swapping and put vcpu into halted state instead.  Interrupts will still be delivered to the guest and if interrupt will cause reschedule guest will continue to run another task.  [avi: remove call to get_user_pages_noio(), nacked by Linus; this       makes everything synchrnous again]  Acked-by: Rik van Riel <riel@redhat.com> Signed-off-by: Gleb Natapov <gleb@redhat.com> Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
f | assigned-dev.c | s | 24K | 873 | Jan Kiszka | jan.kiszka@siemens.com | 1339813332 |  | KVM: Fix PCI header check on device assignment  The masking was wrong (must have been 0x7f), and there is no need to re-read the value as pci_setup_device already does this for us.  Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=43339 Signed-off-by: Jan Kiszka <jan.kiszka@siemens.com> Acked-by: Alex Williamson <alex.williamson@redhat.com> Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
f | async_pf.c | s | 5.2K | 179 | Xiao Guangrong | xiaoguangrong@cn.fujitsu.com | 1294824543 |  | KVM: fix the race while wakeup all pv guest  In kvm_async_pf_wakeup_all(), we add a dummy apf to vcpu->async_pf.done without holding vcpu->async_pf.lock, it will break if we are handling apfs at this time.  Also use 'list_empty_careful()' instead of 'list_empty()'  Signed-off-by: Xiao Guangrong <xiaoguangrong@cn.fujitsu.com> Acked-by: Gleb Natapov <gleb@redhat.com> Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
f | Kconfig | g | 308B |  | Jan Kiszka | jan.kiszka@siemens.com | 1335272387 |  | KVM: Introduce direct MSI message injection for in-kernel irqchips  Currently, MSI messages can only be injected to in-kernel irqchips by defining a corresponding IRQ route for each message. This is not only unhandy if the MSI messages are generated "on the fly" by user space, IRQ routes are a limited resource that user space has to manage carefully.  By providing a direct injection path, we can both avoid using up limited resources and simplify the necessary steps for user land.  Signed-off-by: Jan Kiszka <jan.kiszka@siemens.com> Signed-off-by: Avi Kivity <avi@redhat.com>
f | coalesced_mmio.h | s | 915B | 29 | Sasha Levin | levinsasha928@gmail.com | 1316967477 |  | KVM: Make coalesced mmio use a device per zone  This patch changes coalesced mmio to create one mmio device per zone instead of handling all zones in one device.  Doing so enables us to take advantage of existing locking and prevents a race condition between coalesced mmio registration/unregistration and lookups.  Suggested-by: Avi Kivity <avi@redhat.com> Signed-off-by: Sasha Levin <levinsasha928@gmail.com> Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
f | ioapic.c | s | 10K | 391 | Michael S. Tsirkin | mst@redhat.com | 1334619398 |  | KVM: dont clear TMR on EOI  Intel spec says that TMR needs to be set/cleared when IRR is set, but kvm also clears it on  EOI.  I did some tests on a real (AMD based) system, and I see same TMR values both before and after EOI, so I think it's a minor bug in kvm.  This patch fixes TMR to be set/cleared on IRR set only as per spec.  And now that we don't clear TMR, we can save an atomic read of TMR on EOI that's not propagated to ioapic, by checking whether ioapic needs a specific vector first and calculating the mode afterwards.  Signed-off-by: Michael S. Tsirkin <mst@redhat.com> Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
