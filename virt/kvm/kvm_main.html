<!DOCTYPE html>
<html><head><title>joekychen/linux » virt › kvm › kvm_main.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>kvm_main.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Kernel-based Virtual Machine driver for Linux</span>
<span class="cm"> *</span>
<span class="cm"> * This module enables machines with Intel VT-x extensions to run virtual</span>
<span class="cm"> * machines without emulation or binary translation.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006 Qumranet, Inc.</span>
<span class="cm"> * Copyright 2010 Red Hat, Inc. and/or its affiliates.</span>
<span class="cm"> *</span>
<span class="cm"> * Authors:</span>
<span class="cm"> *   Avi Kivity   &lt;avi@qumranet.com&gt;</span>
<span class="cm"> *   Yaniv Kamay  &lt;yaniv@qumranet.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This work is licensed under the terms of the GNU GPL, version 2.  See</span>
<span class="cm"> * the COPYING file in the top-level directory.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;iodev.h&quot;</span>

<span class="cp">#include &lt;linux/kvm_host.h&gt;</span>
<span class="cp">#include &lt;linux/kvm.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/miscdevice.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/reboot.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/syscore_ops.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/cpumask.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/anon_inodes.h&gt;</span>
<span class="cp">#include &lt;linux/profile.h&gt;</span>
<span class="cp">#include &lt;linux/kvm_para.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/mman.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/compat.h&gt;</span>
<span class="cp">#include &lt;linux/srcu.h&gt;</span>
<span class="cp">#include &lt;linux/hugetlb.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/sort.h&gt;</span>
<span class="cp">#include &lt;linux/bsearch.h&gt;</span>

<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>

<span class="cp">#include &quot;coalesced_mmio.h&quot;</span>
<span class="cp">#include &quot;async_pf.h&quot;</span>

<span class="cp">#define CREATE_TRACE_POINTS</span>
<span class="cp">#include &lt;trace/events/kvm.h&gt;</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Qumranet&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Ordering of locks:</span>
<span class="cm"> *</span>
<span class="cm"> * 		kvm-&gt;lock --&gt; kvm-&gt;slots_lock --&gt; kvm-&gt;irq_lock</span>
<span class="cm"> */</span>

<span class="n">DEFINE_RAW_SPINLOCK</span><span class="p">(</span><span class="n">kvm_lock</span><span class="p">);</span>
<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">vm_list</span><span class="p">);</span>

<span class="k">static</span> <span class="n">cpumask_var_t</span> <span class="n">cpus_hardware_enabled</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">kvm_usage_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">hardware_enable_failed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">kvm_vcpu_cache</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_vcpu_cache</span><span class="p">);</span>

<span class="k">static</span> <span class="n">__read_mostly</span> <span class="k">struct</span> <span class="n">preempt_ops</span> <span class="n">kvm_preempt_ops</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">kvm_debugfs_dir</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">long</span> <span class="n">kvm_vcpu_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ioctl</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">kvm_vcpu_compat_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ioctl</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">hardware_enable_all</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">hardware_disable_all</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">kvm_io_bus_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_io_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">);</span>

<span class="n">bool</span> <span class="n">kvm_rebooting</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_rebooting</span><span class="p">);</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">largepages_enabled</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">hwpoison_page</span><span class="p">;</span>
<span class="k">static</span> <span class="n">pfn_t</span> <span class="n">hwpoison_pfn</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">fault_page</span><span class="p">;</span>
<span class="n">pfn_t</span> <span class="n">fault_pfn</span><span class="p">;</span>

<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">kvm_is_mmio_pfn</span><span class="p">(</span><span class="n">pfn_t</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pfn_valid</span><span class="p">(</span><span class="n">pfn</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">reserved</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">tail</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">compound_trans_head</span><span class="p">(</span><span class="n">tail</span><span class="p">);</span>
		<span class="n">reserved</span> <span class="o">=</span> <span class="n">PageReserved</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">!=</span> <span class="n">tail</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * &quot;head&quot; is not a dangling pointer</span>
<span class="cm">			 * (compound_trans_head takes care of that)</span>
<span class="cm">			 * but the hugepage may have been splitted</span>
<span class="cm">			 * from under us (and we may not hold a</span>
<span class="cm">			 * reference count on the head page so it can</span>
<span class="cm">			 * be reused before we run PageReferenced), so</span>
<span class="cm">			 * we&#39;ve to check PageTail before returning</span>
<span class="cm">			 * what we just read.</span>
<span class="cm">			 */</span>
			<span class="n">smp_rmb</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">PageTail</span><span class="p">(</span><span class="n">tail</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">reserved</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">PageReserved</span><span class="p">(</span><span class="n">tail</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Switches to specified vcpu, until a matching vcpu_put()</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">vcpu_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">!=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pids</span><span class="p">[</span><span class="n">PIDTYPE_PID</span><span class="p">].</span><span class="n">pid</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* The thread running this VCPU changed. */</span>
		<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">oldpid</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">newpid</span> <span class="o">=</span> <span class="n">get_task_pid</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">PIDTYPE_PID</span><span class="p">);</span>
		<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">newpid</span><span class="p">);</span>
		<span class="n">synchronize_rcu</span><span class="p">();</span>
		<span class="n">put_pid</span><span class="p">(</span><span class="n">oldpid</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">cpu</span> <span class="o">=</span> <span class="n">get_cpu</span><span class="p">();</span>
	<span class="n">preempt_notifier_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">preempt_notifier</span><span class="p">);</span>
	<span class="n">kvm_arch_vcpu_load</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">put_cpu</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">vcpu_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">kvm_arch_vcpu_put</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">preempt_notifier_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">preempt_notifier</span><span class="p">);</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ack_flush</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">_completed</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">make_all_cpus_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">me</span><span class="p">;</span>
	<span class="n">cpumask_var_t</span> <span class="n">cpus</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">called</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">;</span>

	<span class="n">zalloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpus</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="n">me</span> <span class="o">=</span> <span class="n">get_cpu</span><span class="p">();</span>
	<span class="n">kvm_for_each_vcpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">,</span> <span class="n">kvm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>
		<span class="n">cpu</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">;</span>

		<span class="cm">/* Set -&gt;requests bit before we read -&gt;mode */</span>
		<span class="n">smp_mb</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cpus</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">cpu</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">cpu</span> <span class="o">!=</span> <span class="n">me</span> <span class="o">&amp;&amp;</span>
		      <span class="n">kvm_vcpu_exiting_guest_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">!=</span> <span class="n">OUTSIDE_GUEST_MODE</span><span class="p">)</span>
			<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpus</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">cpus</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="n">smp_call_function_many</span><span class="p">(</span><span class="n">cpu_online_mask</span><span class="p">,</span> <span class="n">ack_flush</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="n">cpus</span><span class="p">))</span>
		<span class="n">smp_call_function_many</span><span class="p">(</span><span class="n">cpus</span><span class="p">,</span> <span class="n">ack_flush</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">called</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">put_cpu</span><span class="p">();</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">cpus</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">called</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_flush_remote_tlbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">dirty_count</span> <span class="o">=</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">tlbs_dirty</span><span class="p">;</span>

	<span class="n">smp_mb</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">make_all_cpus_request</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">KVM_REQ_TLB_FLUSH</span><span class="p">))</span>
		<span class="o">++</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">remote_tlb_flush</span><span class="p">;</span>
	<span class="n">cmpxchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">tlbs_dirty</span><span class="p">,</span> <span class="n">dirty_count</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_reload_remote_mmus</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">make_all_cpus_request</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">KVM_REQ_MMU_RELOAD</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_vcpu_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span> <span class="o">=</span> <span class="n">kvm</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">vcpu_id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
	<span class="n">kvm_async_pf_vcpu_init</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_ZERO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_arch_vcpu_init</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_free_run</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail_free_run:</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">);</span>
<span class="nl">fail:</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_vcpu_init</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">kvm_vcpu_uninit</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">put_pid</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
	<span class="n">kvm_arch_vcpu_uninit</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_vcpu_uninit</span><span class="p">);</span>

<span class="cp">#if defined(CONFIG_MMU_NOTIFIER) &amp;&amp; defined(KVM_ARCH_WANT_MMU_NOTIFIER)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="nf">mmu_notifier_to_kvm</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmu_notifier</span> <span class="o">*</span><span class="n">mn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">mn</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm</span><span class="p">,</span> <span class="n">mmu_notifier</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_mmu_notifier_invalidate_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmu_notifier</span> <span class="o">*</span><span class="n">mn</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span> <span class="o">=</span> <span class="n">mmu_notifier_to_kvm</span><span class="p">(</span><span class="n">mn</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">need_tlb_flush</span><span class="p">,</span> <span class="n">idx</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * When -&gt;invalidate_page runs, the linux pte has been zapped</span>
<span class="cm">	 * already but the page is still allocated until</span>
<span class="cm">	 * -&gt;invalidate_page returns. So if we increase the sequence</span>
<span class="cm">	 * here the kvm page fault will notice if the spte can&#39;t be</span>
<span class="cm">	 * established because the page is going to be freed. If</span>
<span class="cm">	 * instead the kvm page fault establishes the spte before</span>
<span class="cm">	 * -&gt;invalidate_page runs, kvm_unmap_hva will release it</span>
<span class="cm">	 * before returning.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The sequence increase only need to be seen at spin_unlock</span>
<span class="cm">	 * time, and not at spin_lock time.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Increasing the sequence after the spin_unlock would be</span>
<span class="cm">	 * unsafe because the kvm page fault could then establish the</span>
<span class="cm">	 * pte after kvm_unmap_hva returned, without noticing the page</span>
<span class="cm">	 * is going to be freed.</span>
<span class="cm">	 */</span>
	<span class="n">idx</span> <span class="o">=</span> <span class="n">srcu_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>

	<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_notifier_seq</span><span class="o">++</span><span class="p">;</span>
	<span class="n">need_tlb_flush</span> <span class="o">=</span> <span class="n">kvm_unmap_hva</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span> <span class="o">|</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">tlbs_dirty</span><span class="p">;</span>
	<span class="cm">/* we&#39;ve to flush the tlb before the pages can be freed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">need_tlb_flush</span><span class="p">)</span>
		<span class="n">kvm_flush_remote_tlbs</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
	<span class="n">srcu_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_mmu_notifier_change_pte</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmu_notifier</span> <span class="o">*</span><span class="n">mn</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
					<span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span> <span class="o">=</span> <span class="n">mmu_notifier_to_kvm</span><span class="p">(</span><span class="n">mn</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>

	<span class="n">idx</span> <span class="o">=</span> <span class="n">srcu_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
	<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_notifier_seq</span><span class="o">++</span><span class="p">;</span>
	<span class="n">kvm_set_spte_hva</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
	<span class="n">srcu_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_mmu_notifier_invalidate_range_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmu_notifier</span> <span class="o">*</span><span class="n">mn</span><span class="p">,</span>
						    <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
						    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
						    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span> <span class="o">=</span> <span class="n">mmu_notifier_to_kvm</span><span class="p">(</span><span class="n">mn</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">need_tlb_flush</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">;</span>

	<span class="n">idx</span> <span class="o">=</span> <span class="n">srcu_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * The count increase must become visible at unlock time as no</span>
<span class="cm">	 * spte can be established without taking the mmu_lock and</span>
<span class="cm">	 * count is also read inside the mmu_lock critical section.</span>
<span class="cm">	 */</span>
	<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_notifier_count</span><span class="o">++</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">start</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="n">need_tlb_flush</span> <span class="o">|=</span> <span class="n">kvm_unmap_hva</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
	<span class="n">need_tlb_flush</span> <span class="o">|=</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">tlbs_dirty</span><span class="p">;</span>
	<span class="cm">/* we&#39;ve to flush the tlb before the pages can be freed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">need_tlb_flush</span><span class="p">)</span>
		<span class="n">kvm_flush_remote_tlbs</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
	<span class="n">srcu_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_mmu_notifier_invalidate_range_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmu_notifier</span> <span class="o">*</span><span class="n">mn</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
						  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
						  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span> <span class="o">=</span> <span class="n">mmu_notifier_to_kvm</span><span class="p">(</span><span class="n">mn</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * This sequence increase will notify the kvm page fault that</span>
<span class="cm">	 * the page that is going to be mapped in the spte could have</span>
<span class="cm">	 * been freed.</span>
<span class="cm">	 */</span>
	<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_notifier_seq</span><span class="o">++</span><span class="p">;</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * The above sequence increase must be visible before the</span>
<span class="cm">	 * below count decrease, which is ensured by the smp_wmb above</span>
<span class="cm">	 * in conjunction with the smp_rmb in mmu_notifier_retry().</span>
<span class="cm">	 */</span>
	<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_notifier_count</span><span class="o">--</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_notifier_count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_mmu_notifier_clear_flush_young</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmu_notifier</span> <span class="o">*</span><span class="n">mn</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
					      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span> <span class="o">=</span> <span class="n">mmu_notifier_to_kvm</span><span class="p">(</span><span class="n">mn</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">young</span><span class="p">,</span> <span class="n">idx</span><span class="p">;</span>

	<span class="n">idx</span> <span class="o">=</span> <span class="n">srcu_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>

	<span class="n">young</span> <span class="o">=</span> <span class="n">kvm_age_hva</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">young</span><span class="p">)</span>
		<span class="n">kvm_flush_remote_tlbs</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
	<span class="n">srcu_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">young</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_mmu_notifier_test_young</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmu_notifier</span> <span class="o">*</span><span class="n">mn</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span> <span class="o">=</span> <span class="n">mmu_notifier_to_kvm</span><span class="p">(</span><span class="n">mn</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">young</span><span class="p">,</span> <span class="n">idx</span><span class="p">;</span>

	<span class="n">idx</span> <span class="o">=</span> <span class="n">srcu_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
	<span class="n">young</span> <span class="o">=</span> <span class="n">kvm_test_age_hva</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
	<span class="n">srcu_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">young</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_mmu_notifier_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmu_notifier</span> <span class="o">*</span><span class="n">mn</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span> <span class="o">=</span> <span class="n">mmu_notifier_to_kvm</span><span class="p">(</span><span class="n">mn</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>

	<span class="n">idx</span> <span class="o">=</span> <span class="n">srcu_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">);</span>
	<span class="n">kvm_arch_flush_shadow</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
	<span class="n">srcu_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">mmu_notifier_ops</span> <span class="n">kvm_mmu_notifier_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">invalidate_page</span>	<span class="o">=</span> <span class="n">kvm_mmu_notifier_invalidate_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">invalidate_range_start</span>	<span class="o">=</span> <span class="n">kvm_mmu_notifier_invalidate_range_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">invalidate_range_end</span>	<span class="o">=</span> <span class="n">kvm_mmu_notifier_invalidate_range_end</span><span class="p">,</span>
	<span class="p">.</span><span class="n">clear_flush_young</span>	<span class="o">=</span> <span class="n">kvm_mmu_notifier_clear_flush_young</span><span class="p">,</span>
	<span class="p">.</span><span class="n">test_young</span>		<span class="o">=</span> <span class="n">kvm_mmu_notifier_test_young</span><span class="p">,</span>
	<span class="p">.</span><span class="n">change_pte</span>		<span class="o">=</span> <span class="n">kvm_mmu_notifier_change_pte</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>		<span class="o">=</span> <span class="n">kvm_mmu_notifier_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_init_mmu_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_notifier</span><span class="p">.</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kvm_mmu_notifier_ops</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">mmu_notifier_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_notifier</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else  </span><span class="cm">/* !(CONFIG_MMU_NOTIFIER &amp;&amp; KVM_ARCH_WANT_MMU_NOTIFIER) */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_init_mmu_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_MMU_NOTIFIER &amp;&amp; KVM_ARCH_WANT_MMU_NOTIFIER */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_init_memslots_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_memslots</span> <span class="o">*</span><span class="n">slots</span> <span class="o">=</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">memslots</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">KVM_MEM_SLOTS_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">slots</span><span class="o">-&gt;</span><span class="n">id_to_index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">slots</span><span class="o">-&gt;</span><span class="n">memslots</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">id</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="nf">kvm_create_vm</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span> <span class="o">=</span> <span class="n">kvm_arch_alloc_vm</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_arch_init_vm</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err_nodisable</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">hardware_enable_all</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err_nodisable</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_HAVE_KVM_IRQCHIP</span>
	<span class="n">INIT_HLIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mask_notifier_list</span><span class="p">);</span>
	<span class="n">INIT_HLIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">irq_ack_notifier_list</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">memslots</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_memslots</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">memslots</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err_nosrcu</span><span class="p">;</span>
	<span class="n">kvm_init_memslots_id</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">init_srcu_struct</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_err_nosrcu</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">KVM_NR_BUSES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">buses</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_io_bus</span><span class="p">),</span>
					<span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">buses</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
	<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_count</span><span class="p">);</span>
	<span class="n">kvm_eventfd_init</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">irq_lock</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">slots_lock</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">users_count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_init_mmu_notifier</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_lock</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">vm_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vm_list</span><span class="p">);</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">kvm</span><span class="p">;</span>

<span class="nl">out_err:</span>
	<span class="n">cleanup_srcu_struct</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">);</span>
<span class="nl">out_err_nosrcu:</span>
	<span class="n">hardware_disable_all</span><span class="p">();</span>
<span class="nl">out_err_nodisable:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">KVM_NR_BUSES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">buses</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">memslots</span><span class="p">);</span>
	<span class="n">kvm_arch_free_vm</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_destroy_dirty_bitmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">memslot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memslot</span><span class="o">-&gt;</span><span class="n">dirty_bitmap</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">kvm_dirty_bitmap_bytes</span><span class="p">(</span><span class="n">memslot</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">memslot</span><span class="o">-&gt;</span><span class="n">dirty_bitmap</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">memslot</span><span class="o">-&gt;</span><span class="n">dirty_bitmap</span><span class="p">);</span>

	<span class="n">memslot</span><span class="o">-&gt;</span><span class="n">dirty_bitmap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free any memory in @free but not in @dont.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_free_physmem_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">free</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">dont</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dont</span> <span class="o">||</span> <span class="n">free</span><span class="o">-&gt;</span><span class="n">rmap</span> <span class="o">!=</span> <span class="n">dont</span><span class="o">-&gt;</span><span class="n">rmap</span><span class="p">)</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">rmap</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dont</span> <span class="o">||</span> <span class="n">free</span><span class="o">-&gt;</span><span class="n">dirty_bitmap</span> <span class="o">!=</span> <span class="n">dont</span><span class="o">-&gt;</span><span class="n">dirty_bitmap</span><span class="p">)</span>
		<span class="n">kvm_destroy_dirty_bitmap</span><span class="p">(</span><span class="n">free</span><span class="p">);</span>

	<span class="n">kvm_arch_free_memslot</span><span class="p">(</span><span class="n">free</span><span class="p">,</span> <span class="n">dont</span><span class="p">);</span>

	<span class="n">free</span><span class="o">-&gt;</span><span class="n">npages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">free</span><span class="o">-&gt;</span><span class="n">rmap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_free_physmem</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_memslots</span> <span class="o">*</span><span class="n">slots</span> <span class="o">=</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">memslots</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">memslot</span><span class="p">;</span>

	<span class="n">kvm_for_each_memslot</span><span class="p">(</span><span class="n">memslot</span><span class="p">,</span> <span class="n">slots</span><span class="p">)</span>
		<span class="n">kvm_free_physmem_slot</span><span class="p">(</span><span class="n">memslot</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">memslots</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_destroy_vm</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>

	<span class="n">kvm_arch_sync_events</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_lock</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">vm_list</span><span class="p">);</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_lock</span><span class="p">);</span>
	<span class="n">kvm_free_irq_routing</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">KVM_NR_BUSES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">kvm_io_bus_destroy</span><span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">buses</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">kvm_coalesced_mmio_free</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
<span class="cp">#if defined(CONFIG_MMU_NOTIFIER) &amp;&amp; defined(KVM_ARCH_WANT_MMU_NOTIFIER)</span>
	<span class="n">mmu_notifier_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_notifier</span><span class="p">,</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">kvm_arch_flush_shadow</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">kvm_arch_destroy_vm</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
	<span class="n">kvm_free_physmem</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
	<span class="n">cleanup_srcu_struct</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">);</span>
	<span class="n">kvm_arch_free_vm</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
	<span class="n">hardware_disable_all</span><span class="p">();</span>
	<span class="n">mmdrop</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_get_kvm</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">users_count</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_get_kvm</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">kvm_put_kvm</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">users_count</span><span class="p">))</span>
		<span class="n">kvm_destroy_vm</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_put_kvm</span><span class="p">);</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_vm_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">kvm_irqfd_release</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>

	<span class="n">kvm_put_kvm</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocation size is twice as large as the actual dirty bitmap size.</span>
<span class="cm"> * See x86&#39;s kvm_vm_ioctl_get_dirty_log() why this is needed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_create_dirty_bitmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">memslot</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifndef CONFIG_S390</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dirty_bytes</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">kvm_dirty_bitmap_bytes</span><span class="p">(</span><span class="n">memslot</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dirty_bytes</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="n">memslot</span><span class="o">-&gt;</span><span class="n">dirty_bitmap</span> <span class="o">=</span> <span class="n">vzalloc</span><span class="p">(</span><span class="n">dirty_bytes</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">memslot</span><span class="o">-&gt;</span><span class="n">dirty_bitmap</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">dirty_bytes</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memslot</span><span class="o">-&gt;</span><span class="n">dirty_bitmap</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

<span class="cp">#endif </span><span class="cm">/* !CONFIG_S390 */</span><span class="cp"></span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cmp_memslot</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">slot1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">slot2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">s1</span><span class="p">,</span> <span class="o">*</span><span class="n">s2</span><span class="p">;</span>

	<span class="n">s1</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="p">)</span><span class="n">slot1</span><span class="p">;</span>
	<span class="n">s2</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="p">)</span><span class="n">slot2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s1</span><span class="o">-&gt;</span><span class="n">npages</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="o">-&gt;</span><span class="n">npages</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s1</span><span class="o">-&gt;</span><span class="n">npages</span> <span class="o">&gt;</span> <span class="n">s2</span><span class="o">-&gt;</span><span class="n">npages</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Sort the memslots base on its size, so the larger slots</span>
<span class="cm"> * will get better fit.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sort_memslots</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_memslots</span> <span class="o">*</span><span class="n">slots</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">sort</span><span class="p">(</span><span class="n">slots</span><span class="o">-&gt;</span><span class="n">memslots</span><span class="p">,</span> <span class="n">KVM_MEM_SLOTS_NUM</span><span class="p">,</span>
	      <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_memory_slot</span><span class="p">),</span> <span class="n">cmp_memslot</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">KVM_MEM_SLOTS_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">slots</span><span class="o">-&gt;</span><span class="n">id_to_index</span><span class="p">[</span><span class="n">slots</span><span class="o">-&gt;</span><span class="n">memslots</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">update_memslots</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_memslots</span> <span class="o">*</span><span class="n">slots</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">old</span> <span class="o">=</span> <span class="n">id_to_memslot</span><span class="p">(</span><span class="n">slots</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">npages</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">npages</span><span class="p">;</span>

		<span class="o">*</span><span class="n">old</span> <span class="o">=</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">npages</span> <span class="o">!=</span> <span class="n">npages</span><span class="p">)</span>
			<span class="n">sort_memslots</span><span class="p">(</span><span class="n">slots</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">slots</span><span class="o">-&gt;</span><span class="n">generation</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate some memory and give it an address in the guest physical address</span>
<span class="cm"> * space.</span>
<span class="cm"> *</span>
<span class="cm"> * Discontiguous memory is allowed, mostly for framebuffers.</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called holding mmap_sem for write.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__kvm_set_memory_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">kvm_userspace_memory_region</span> <span class="o">*</span><span class="n">mem</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">user_alloc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="n">gfn_t</span> <span class="n">base_gfn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">npages</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">memslot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_memslots</span> <span class="o">*</span><span class="n">slots</span><span class="p">,</span> <span class="o">*</span><span class="n">old_memslots</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="cm">/* General sanity checks */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">memory_size</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">guest_phys_addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/* We can read the guest memory with __xxx_user() later on. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">user_alloc</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">userspace_addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">||</span>
	     <span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">userspace_addr</span><span class="p">,</span>
			<span class="n">mem</span><span class="o">-&gt;</span><span class="n">memory_size</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">slot</span> <span class="o">&gt;=</span> <span class="n">KVM_MEM_SLOTS_NUM</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">guest_phys_addr</span> <span class="o">+</span> <span class="n">mem</span><span class="o">-&gt;</span><span class="n">memory_size</span> <span class="o">&lt;</span> <span class="n">mem</span><span class="o">-&gt;</span><span class="n">guest_phys_addr</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">memslot</span> <span class="o">=</span> <span class="n">id_to_memslot</span><span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">memslots</span><span class="p">,</span> <span class="n">mem</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">);</span>
	<span class="n">base_gfn</span> <span class="o">=</span> <span class="n">mem</span><span class="o">-&gt;</span><span class="n">guest_phys_addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">npages</span> <span class="o">=</span> <span class="n">mem</span><span class="o">-&gt;</span><span class="n">memory_size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">npages</span> <span class="o">&gt;</span> <span class="n">KVM_MEM_MAX_NR_PAGES</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">npages</span><span class="p">)</span>
		<span class="n">mem</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">KVM_MEM_LOG_DIRTY_PAGES</span><span class="p">;</span>

	<span class="n">new</span> <span class="o">=</span> <span class="n">old</span> <span class="o">=</span> <span class="o">*</span><span class="n">memslot</span><span class="p">;</span>

	<span class="n">new</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">mem</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">;</span>
	<span class="n">new</span><span class="p">.</span><span class="n">base_gfn</span> <span class="o">=</span> <span class="n">base_gfn</span><span class="p">;</span>
	<span class="n">new</span><span class="p">.</span><span class="n">npages</span> <span class="o">=</span> <span class="n">npages</span><span class="p">;</span>
	<span class="n">new</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">mem</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Disallow changing a memory slot&#39;s size. */</span>
	<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">npages</span> <span class="o">&amp;&amp;</span> <span class="n">old</span><span class="p">.</span><span class="n">npages</span> <span class="o">&amp;&amp;</span> <span class="n">npages</span> <span class="o">!=</span> <span class="n">old</span><span class="p">.</span><span class="n">npages</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="cm">/* Check for overlaps */</span>
	<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">KVM_MEMORY_SLOTS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">memslots</span><span class="o">-&gt;</span><span class="n">memslots</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">memslot</span> <span class="o">||</span> <span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">npages</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">base_gfn</span> <span class="o">+</span> <span class="n">npages</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">base_gfn</span><span class="p">)</span> <span class="o">||</span>
		      <span class="p">(</span><span class="n">base_gfn</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">base_gfn</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">npages</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Free page dirty bitmap if unneeded */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">new</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">KVM_MEM_LOG_DIRTY_PAGES</span><span class="p">))</span>
		<span class="n">new</span><span class="p">.</span><span class="n">dirty_bitmap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Allocate if a slot is being created */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">npages</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">old</span><span class="p">.</span><span class="n">npages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new</span><span class="p">.</span><span class="n">user_alloc</span> <span class="o">=</span> <span class="n">user_alloc</span><span class="p">;</span>
		<span class="n">new</span><span class="p">.</span><span class="n">userspace_addr</span> <span class="o">=</span> <span class="n">mem</span><span class="o">-&gt;</span><span class="n">userspace_addr</span><span class="p">;</span>
<span class="cp">#ifndef CONFIG_S390</span>
		<span class="n">new</span><span class="p">.</span><span class="n">rmap</span> <span class="o">=</span> <span class="n">vzalloc</span><span class="p">(</span><span class="n">npages</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">new</span><span class="p">.</span><span class="n">rmap</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">.</span><span class="n">rmap</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* not defined CONFIG_S390 */</span><span class="cp"></span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_arch_create_memslot</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="p">,</span> <span class="n">npages</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate page dirty bitmap if needed */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">new</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">KVM_MEM_LOG_DIRTY_PAGES</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">new</span><span class="p">.</span><span class="n">dirty_bitmap</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_create_dirty_bitmap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="cm">/* destroy any largepage mappings for dirty tracking */</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">npages</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">slots</span> <span class="o">=</span> <span class="n">kmemdup</span><span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">memslots</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_memslots</span><span class="p">),</span>
				<span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slots</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="n">slot</span> <span class="o">=</span> <span class="n">id_to_memslot</span><span class="p">(</span><span class="n">slots</span><span class="p">,</span> <span class="n">mem</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">);</span>
		<span class="n">slot</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">KVM_MEMSLOT_INVALID</span><span class="p">;</span>

		<span class="n">update_memslots</span><span class="p">(</span><span class="n">slots</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="n">old_memslots</span> <span class="o">=</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">memslots</span><span class="p">;</span>
		<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">memslots</span><span class="p">,</span> <span class="n">slots</span><span class="p">);</span>
		<span class="n">synchronize_srcu_expedited</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">);</span>
		<span class="cm">/* From this point no new shadow pages pointing to a deleted</span>
<span class="cm">		 * memslot will be created.</span>
<span class="cm">		 *</span>
<span class="cm">		 * validation of sp-&gt;gfn happens in:</span>
<span class="cm">		 * 	- gfn_to_hva (kvm_read_guest, gfn_to_pfn)</span>
<span class="cm">		 * 	- kvm_is_visible_gfn (mmu_check_roots)</span>
<span class="cm">		 */</span>
		<span class="n">kvm_arch_flush_shadow</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">old_memslots</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_arch_prepare_memory_region</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">mem</span><span class="p">,</span> <span class="n">user_alloc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="cm">/* map/unmap the pages in iommu page table */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">npages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_iommu_map_pages</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">kvm_iommu_unmap_pages</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">slots</span> <span class="o">=</span> <span class="n">kmemdup</span><span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">memslots</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_memslots</span><span class="p">),</span>
			<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slots</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="cm">/* actual memory is freed via old in kvm_free_physmem_slot below */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">npages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new</span><span class="p">.</span><span class="n">rmap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">new</span><span class="p">.</span><span class="n">dirty_bitmap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="p">.</span><span class="n">arch</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">new</span><span class="p">.</span><span class="n">arch</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">update_memslots</span><span class="p">(</span><span class="n">slots</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new</span><span class="p">);</span>
	<span class="n">old_memslots</span> <span class="o">=</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">memslots</span><span class="p">;</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">memslots</span><span class="p">,</span> <span class="n">slots</span><span class="p">);</span>
	<span class="n">synchronize_srcu_expedited</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">);</span>

	<span class="n">kvm_arch_commit_memory_region</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">mem</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">user_alloc</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the new memory slot is created, we need to clear all</span>
<span class="cm">	 * mmio sptes.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">npages</span> <span class="o">&amp;&amp;</span> <span class="n">old</span><span class="p">.</span><span class="n">base_gfn</span> <span class="o">!=</span> <span class="n">mem</span><span class="o">-&gt;</span><span class="n">guest_phys_addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span>
		<span class="n">kvm_arch_flush_shadow</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>

	<span class="n">kvm_free_physmem_slot</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">old_memslots</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_free:</span>
	<span class="n">kvm_free_physmem_slot</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__kvm_set_memory_region</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">kvm_set_memory_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">kvm_userspace_memory_region</span> <span class="o">*</span><span class="n">mem</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">user_alloc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">slots_lock</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">__kvm_set_memory_region</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">mem</span><span class="p">,</span> <span class="n">user_alloc</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">slots_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_set_memory_region</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">kvm_vm_ioctl_set_memory_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
				   <span class="k">struct</span>
				   <span class="n">kvm_userspace_memory_region</span> <span class="o">*</span><span class="n">mem</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">user_alloc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">slot</span> <span class="o">&gt;=</span> <span class="n">KVM_MEMORY_SLOTS</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">kvm_set_memory_region</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">mem</span><span class="p">,</span> <span class="n">user_alloc</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_get_dirty_log</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">kvm_dirty_log</span> <span class="o">*</span><span class="n">log</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">is_dirty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">memslot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">any</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">slot</span> <span class="o">&gt;=</span> <span class="n">KVM_MEMORY_SLOTS</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">memslot</span> <span class="o">=</span> <span class="n">id_to_memslot</span><span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">memslots</span><span class="p">,</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memslot</span><span class="o">-&gt;</span><span class="n">dirty_bitmap</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">kvm_dirty_bitmap_bytes</span><span class="p">(</span><span class="n">memslot</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">!</span><span class="n">any</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">any</span> <span class="o">=</span> <span class="n">memslot</span><span class="o">-&gt;</span><span class="n">dirty_bitmap</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">dirty_bitmap</span><span class="p">,</span> <span class="n">memslot</span><span class="o">-&gt;</span><span class="n">dirty_bitmap</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">any</span><span class="p">)</span>
		<span class="o">*</span><span class="n">is_dirty</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">kvm_largepages_enabled</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">largepages_enabled</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_disable_largepages</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">largepages_enabled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_disable_largepages</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">is_error_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">page</span> <span class="o">==</span> <span class="n">bad_page</span> <span class="o">||</span> <span class="n">page</span> <span class="o">==</span> <span class="n">hwpoison_page</span> <span class="o">||</span> <span class="n">page</span> <span class="o">==</span> <span class="n">fault_page</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">is_error_page</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">is_error_pfn</span><span class="p">(</span><span class="n">pfn_t</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pfn</span> <span class="o">==</span> <span class="n">bad_pfn</span> <span class="o">||</span> <span class="n">pfn</span> <span class="o">==</span> <span class="n">hwpoison_pfn</span> <span class="o">||</span> <span class="n">pfn</span> <span class="o">==</span> <span class="n">fault_pfn</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">is_error_pfn</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">is_hwpoison_pfn</span><span class="p">(</span><span class="n">pfn_t</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pfn</span> <span class="o">==</span> <span class="n">hwpoison_pfn</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">is_hwpoison_pfn</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">is_fault_pfn</span><span class="p">(</span><span class="n">pfn_t</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pfn</span> <span class="o">==</span> <span class="n">fault_pfn</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">is_fault_pfn</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">is_noslot_pfn</span><span class="p">(</span><span class="n">pfn_t</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pfn</span> <span class="o">==</span> <span class="n">bad_pfn</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">is_noslot_pfn</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">is_invalid_pfn</span><span class="p">(</span><span class="n">pfn_t</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pfn</span> <span class="o">==</span> <span class="n">hwpoison_pfn</span> <span class="o">||</span> <span class="n">pfn</span> <span class="o">==</span> <span class="n">fault_pfn</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">is_invalid_pfn</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">bad_hva</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">PAGE_OFFSET</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_is_error_hva</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">addr</span> <span class="o">==</span> <span class="n">bad_hva</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_is_error_hva</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="nf">gfn_to_memslot</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__gfn_to_memslot</span><span class="p">(</span><span class="n">kvm_memslots</span><span class="p">(</span><span class="n">kvm</span><span class="p">),</span> <span class="n">gfn</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">gfn_to_memslot</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">kvm_is_visible_gfn</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">memslot</span> <span class="o">=</span> <span class="n">gfn_to_memslot</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memslot</span> <span class="o">||</span> <span class="n">memslot</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">KVM_MEMORY_SLOTS</span> <span class="o">||</span>
	      <span class="n">memslot</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">KVM_MEMSLOT_INVALID</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_is_visible_gfn</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">kvm_host_page_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">gfn_to_hva</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_is_error_hva</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="n">vma</span> <span class="o">=</span> <span class="n">find_vma</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">vma_kernel_pagesize</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">gfn_to_hva_many</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span>
				     <span class="n">gfn_t</span> <span class="o">*</span><span class="n">nr_pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slot</span> <span class="o">||</span> <span class="n">slot</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">KVM_MEMSLOT_INVALID</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">bad_hva</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr_pages</span><span class="p">)</span>
		<span class="o">*</span><span class="n">nr_pages</span> <span class="o">=</span> <span class="n">slot</span><span class="o">-&gt;</span><span class="n">npages</span> <span class="o">-</span> <span class="p">(</span><span class="n">gfn</span> <span class="o">-</span> <span class="n">slot</span><span class="o">-&gt;</span><span class="n">base_gfn</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">gfn_to_hva_memslot</span><span class="p">(</span><span class="n">slot</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">gfn_to_hva</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">gfn_to_hva_many</span><span class="p">(</span><span class="n">gfn_to_memslot</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">),</span> <span class="n">gfn</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">gfn_to_hva</span><span class="p">);</span>

<span class="k">static</span> <span class="n">pfn_t</span> <span class="nf">get_fault_pfn</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">get_page</span><span class="p">(</span><span class="n">fault_page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">fault_pfn</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">get_user_page_nowait</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">FOLL_TOUCH</span> <span class="o">|</span> <span class="n">FOLL_NOWAIT</span> <span class="o">|</span> <span class="n">FOLL_HWPOISON</span> <span class="o">|</span> <span class="n">FOLL_GET</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">FOLL_WRITE</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">__get_user_pages</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">check_user_page_hwpoison</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">FOLL_TOUCH</span> <span class="o">|</span> <span class="n">FOLL_HWPOISON</span> <span class="o">|</span> <span class="n">FOLL_WRITE</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">__get_user_pages</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			      <span class="n">flags</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EHWPOISON</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">pfn_t</span> <span class="nf">hva_to_pfn</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">bool</span> <span class="n">atomic</span><span class="p">,</span>
			<span class="n">bool</span> <span class="o">*</span><span class="n">async</span><span class="p">,</span> <span class="n">bool</span> <span class="n">write_fault</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">writable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">npages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pfn_t</span> <span class="n">pfn</span><span class="p">;</span>

	<span class="cm">/* we can do it either atomically or asynchronously, not both */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">atomic</span> <span class="o">&amp;&amp;</span> <span class="n">async</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">write_fault</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">writable</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">writable</span><span class="p">)</span>
		<span class="o">*</span><span class="n">writable</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic</span> <span class="o">||</span> <span class="n">async</span><span class="p">)</span>
		<span class="n">npages</span> <span class="o">=</span> <span class="n">__get_user_pages_fast</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">npages</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">atomic</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">might_sleep</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">writable</span><span class="p">)</span>
			<span class="o">*</span><span class="n">writable</span> <span class="o">=</span> <span class="n">write_fault</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">async</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
			<span class="n">npages</span> <span class="o">=</span> <span class="n">get_user_page_nowait</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span>
						     <span class="n">addr</span><span class="p">,</span> <span class="n">write_fault</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
			<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">npages</span> <span class="o">=</span> <span class="n">get_user_pages_fast</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">write_fault</span><span class="p">,</span>
						     <span class="n">page</span><span class="p">);</span>

		<span class="cm">/* map read fault as writable if possible */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">write_fault</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">npages</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">wpage</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

			<span class="n">npages</span> <span class="o">=</span> <span class="n">__get_user_pages_fast</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">wpage</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">npages</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">writable</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
				<span class="n">page</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">wpage</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="p">}</span>
			<span class="n">npages</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">npages</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">atomic</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">get_fault_pfn</span><span class="p">();</span>

		<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">npages</span> <span class="o">==</span> <span class="o">-</span><span class="n">EHWPOISON</span> <span class="o">||</span>
			<span class="p">(</span><span class="o">!</span><span class="n">async</span> <span class="o">&amp;&amp;</span> <span class="n">check_user_page_hwpoison</span><span class="p">(</span><span class="n">addr</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
			<span class="n">get_page</span><span class="p">(</span><span class="n">hwpoison_page</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">hwpoison_page</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">vma</span> <span class="o">=</span> <span class="n">find_vma_intersection</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">addr</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">pfn</span> <span class="o">=</span> <span class="n">get_fault_pfn</span><span class="p">();</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_PFNMAP</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pfn</span> <span class="o">=</span> <span class="p">((</span><span class="n">addr</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">+</span>
				<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span><span class="p">;</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">kvm_is_mmio_pfn</span><span class="p">(</span><span class="n">pfn</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">async</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_WRITE</span><span class="p">))</span>
				<span class="o">*</span><span class="n">async</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">pfn</span> <span class="o">=</span> <span class="n">get_fault_pfn</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">pfn</span> <span class="o">=</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">page</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="k">return</span> <span class="n">pfn</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">pfn_t</span> <span class="nf">hva_to_pfn_atomic</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hva_to_pfn</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">hva_to_pfn_atomic</span><span class="p">);</span>

<span class="k">static</span> <span class="n">pfn_t</span> <span class="nf">__gfn_to_pfn</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">bool</span> <span class="n">atomic</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">async</span><span class="p">,</span>
			  <span class="n">bool</span> <span class="n">write_fault</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">writable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">async</span><span class="p">)</span>
		<span class="o">*</span><span class="n">async</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">gfn_to_hva</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_is_error_hva</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">get_page</span><span class="p">(</span><span class="n">bad_page</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">bad_page</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">hva_to_pfn</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">atomic</span><span class="p">,</span> <span class="n">async</span><span class="p">,</span> <span class="n">write_fault</span><span class="p">,</span> <span class="n">writable</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">pfn_t</span> <span class="nf">gfn_to_pfn_atomic</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__gfn_to_pfn</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">gfn_to_pfn_atomic</span><span class="p">);</span>

<span class="n">pfn_t</span> <span class="nf">gfn_to_pfn_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">async</span><span class="p">,</span>
		       <span class="n">bool</span> <span class="n">write_fault</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">writable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__gfn_to_pfn</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">async</span><span class="p">,</span> <span class="n">write_fault</span><span class="p">,</span> <span class="n">writable</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">gfn_to_pfn_async</span><span class="p">);</span>

<span class="n">pfn_t</span> <span class="nf">gfn_to_pfn</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__gfn_to_pfn</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">gfn_to_pfn</span><span class="p">);</span>

<span class="n">pfn_t</span> <span class="nf">gfn_to_pfn_prot</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">bool</span> <span class="n">write_fault</span><span class="p">,</span>
		      <span class="n">bool</span> <span class="o">*</span><span class="n">writable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__gfn_to_pfn</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">write_fault</span><span class="p">,</span> <span class="n">writable</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">gfn_to_pfn_prot</span><span class="p">);</span>

<span class="n">pfn_t</span> <span class="nf">gfn_to_pfn_memslot</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">gfn_to_hva_memslot</span><span class="p">(</span><span class="n">slot</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">hva_to_pfn</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">gfn_to_page_many_atomic</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span>
								  <span class="kt">int</span> <span class="n">nr_pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">gfn_t</span> <span class="n">entry</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">gfn_to_hva_many</span><span class="p">(</span><span class="n">gfn_to_memslot</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">),</span> <span class="n">gfn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_is_error_hva</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">&lt;</span> <span class="n">nr_pages</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">__get_user_pages_fast</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pages</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">gfn_to_page_many_atomic</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">gfn_to_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pfn_t</span> <span class="n">pfn</span><span class="p">;</span>

	<span class="n">pfn</span> <span class="o">=</span> <span class="n">gfn_to_pfn</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm_is_mmio_pfn</span><span class="p">(</span><span class="n">pfn</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">kvm_is_mmio_pfn</span><span class="p">(</span><span class="n">pfn</span><span class="p">));</span>

	<span class="n">get_page</span><span class="p">(</span><span class="n">bad_page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">bad_page</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">gfn_to_page</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">kvm_release_page_clean</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_release_pfn_clean</span><span class="p">(</span><span class="n">page_to_pfn</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_release_page_clean</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">kvm_release_pfn_clean</span><span class="p">(</span><span class="n">pfn_t</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm_is_mmio_pfn</span><span class="p">(</span><span class="n">pfn</span><span class="p">))</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_release_pfn_clean</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">kvm_release_page_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_release_pfn_dirty</span><span class="p">(</span><span class="n">page_to_pfn</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_release_page_dirty</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">kvm_release_pfn_dirty</span><span class="p">(</span><span class="n">pfn_t</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_set_pfn_dirty</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
	<span class="n">kvm_release_pfn_clean</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_release_pfn_dirty</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">kvm_set_page_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_set_pfn_dirty</span><span class="p">(</span><span class="n">page_to_pfn</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_set_page_dirty</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">kvm_set_pfn_dirty</span><span class="p">(</span><span class="n">pfn_t</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm_is_mmio_pfn</span><span class="p">(</span><span class="n">pfn</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageReserved</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="n">SetPageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_set_pfn_dirty</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">kvm_set_pfn_accessed</span><span class="p">(</span><span class="n">pfn_t</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm_is_mmio_pfn</span><span class="p">(</span><span class="n">pfn</span><span class="p">))</span>
		<span class="n">mark_page_accessed</span><span class="p">(</span><span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_set_pfn_accessed</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">kvm_get_pfn</span><span class="p">(</span><span class="n">pfn_t</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm_is_mmio_pfn</span><span class="p">(</span><span class="n">pfn</span><span class="p">))</span>
		<span class="n">get_page</span><span class="p">(</span><span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_get_pfn</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">next_segment</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_read_guest_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">gfn_to_hva</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_is_error_hva</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">__copy_from_user</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_read_guest_page</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">kvm_read_guest</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">gfn_t</span> <span class="n">gfn</span> <span class="o">=</span> <span class="n">gpa</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">seg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">offset_in_page</span><span class="p">(</span><span class="n">gpa</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">seg</span> <span class="o">=</span> <span class="n">next_segment</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">offset</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">kvm_read_guest_page</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">seg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">seg</span><span class="p">;</span>
		<span class="n">data</span> <span class="o">+=</span> <span class="n">seg</span><span class="p">;</span>
		<span class="o">++</span><span class="n">gfn</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_read_guest</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">kvm_read_guest_atomic</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">gfn_t</span> <span class="n">gfn</span> <span class="o">=</span> <span class="n">gpa</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">offset_in_page</span><span class="p">(</span><span class="n">gpa</span><span class="p">);</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">gfn_to_hva</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_is_error_hva</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="n">pagefault_disable</span><span class="p">();</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">__copy_from_user_inatomic</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">pagefault_enable</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kvm_read_guest_atomic</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">kvm_write_guest_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">gfn_to_hva</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_is_error_hva</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">__copy_to_user</span><span class="p">((</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="n">mark_page_dirty</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_write_guest_page</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">kvm_write_guest</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">gfn_t</span> <span class="n">gfn</span> <span class="o">=</span> <span class="n">gpa</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">seg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">offset_in_page</span><span class="p">(</span><span class="n">gpa</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">seg</span> <span class="o">=</span> <span class="n">next_segment</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">offset</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">kvm_write_guest_page</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">seg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">seg</span><span class="p">;</span>
		<span class="n">data</span> <span class="o">+=</span> <span class="n">seg</span><span class="p">;</span>
		<span class="o">++</span><span class="n">gfn</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_gfn_to_hva_cache_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gfn_to_hva_cache</span> <span class="o">*</span><span class="n">ghc</span><span class="p">,</span>
			      <span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_memslots</span> <span class="o">*</span><span class="n">slots</span> <span class="o">=</span> <span class="n">kvm_memslots</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">offset_in_page</span><span class="p">(</span><span class="n">gpa</span><span class="p">);</span>
	<span class="n">gfn_t</span> <span class="n">gfn</span> <span class="o">=</span> <span class="n">gpa</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="n">ghc</span><span class="o">-&gt;</span><span class="n">gpa</span> <span class="o">=</span> <span class="n">gpa</span><span class="p">;</span>
	<span class="n">ghc</span><span class="o">-&gt;</span><span class="n">generation</span> <span class="o">=</span> <span class="n">slots</span><span class="o">-&gt;</span><span class="n">generation</span><span class="p">;</span>
	<span class="n">ghc</span><span class="o">-&gt;</span><span class="n">memslot</span> <span class="o">=</span> <span class="n">gfn_to_memslot</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
	<span class="n">ghc</span><span class="o">-&gt;</span><span class="n">hva</span> <span class="o">=</span> <span class="n">gfn_to_hva_many</span><span class="p">(</span><span class="n">ghc</span><span class="o">-&gt;</span><span class="n">memslot</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm_is_error_hva</span><span class="p">(</span><span class="n">ghc</span><span class="o">-&gt;</span><span class="n">hva</span><span class="p">))</span>
		<span class="n">ghc</span><span class="o">-&gt;</span><span class="n">hva</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_gfn_to_hva_cache_init</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">kvm_write_guest_cached</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gfn_to_hva_cache</span> <span class="o">*</span><span class="n">ghc</span><span class="p">,</span>
			   <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_memslots</span> <span class="o">*</span><span class="n">slots</span> <span class="o">=</span> <span class="n">kvm_memslots</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">slots</span><span class="o">-&gt;</span><span class="n">generation</span> <span class="o">!=</span> <span class="n">ghc</span><span class="o">-&gt;</span><span class="n">generation</span><span class="p">)</span>
		<span class="n">kvm_gfn_to_hva_cache_init</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">ghc</span><span class="p">,</span> <span class="n">ghc</span><span class="o">-&gt;</span><span class="n">gpa</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_is_error_hva</span><span class="p">(</span><span class="n">ghc</span><span class="o">-&gt;</span><span class="n">hva</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">__copy_to_user</span><span class="p">((</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">ghc</span><span class="o">-&gt;</span><span class="n">hva</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="n">mark_page_dirty_in_slot</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">ghc</span><span class="o">-&gt;</span><span class="n">memslot</span><span class="p">,</span> <span class="n">ghc</span><span class="o">-&gt;</span><span class="n">gpa</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_write_guest_cached</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">kvm_read_guest_cached</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gfn_to_hva_cache</span> <span class="o">*</span><span class="n">ghc</span><span class="p">,</span>
			   <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_memslots</span> <span class="o">*</span><span class="n">slots</span> <span class="o">=</span> <span class="n">kvm_memslots</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">slots</span><span class="o">-&gt;</span><span class="n">generation</span> <span class="o">!=</span> <span class="n">ghc</span><span class="o">-&gt;</span><span class="n">generation</span><span class="p">)</span>
		<span class="n">kvm_gfn_to_hva_cache_init</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">ghc</span><span class="p">,</span> <span class="n">ghc</span><span class="o">-&gt;</span><span class="n">gpa</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_is_error_hva</span><span class="p">(</span><span class="n">ghc</span><span class="o">-&gt;</span><span class="n">hva</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">__copy_from_user</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">ghc</span><span class="o">-&gt;</span><span class="n">hva</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_read_guest_cached</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">kvm_clear_guest_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kvm_write_guest_page</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">empty_zero_page</span><span class="p">,</span>
				    <span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_clear_guest_page</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">kvm_clear_guest</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">gfn_t</span> <span class="n">gfn</span> <span class="o">=</span> <span class="n">gpa</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">seg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">offset_in_page</span><span class="p">(</span><span class="n">gpa</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">((</span><span class="n">seg</span> <span class="o">=</span> <span class="n">next_segment</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">offset</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">kvm_clear_guest_page</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">seg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">seg</span><span class="p">;</span>
		<span class="o">++</span><span class="n">gfn</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_clear_guest</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">mark_page_dirty_in_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">memslot</span><span class="p">,</span>
			     <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memslot</span> <span class="o">&amp;&amp;</span> <span class="n">memslot</span><span class="o">-&gt;</span><span class="n">dirty_bitmap</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rel_gfn</span> <span class="o">=</span> <span class="n">gfn</span> <span class="o">-</span> <span class="n">memslot</span><span class="o">-&gt;</span><span class="n">base_gfn</span><span class="p">;</span>

		<span class="cm">/* TODO: introduce set_bit_le() and use it */</span>
		<span class="n">test_and_set_bit_le</span><span class="p">(</span><span class="n">rel_gfn</span><span class="p">,</span> <span class="n">memslot</span><span class="o">-&gt;</span><span class="n">dirty_bitmap</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">mark_page_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">memslot</span><span class="p">;</span>

	<span class="n">memslot</span> <span class="o">=</span> <span class="n">gfn_to_memslot</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
	<span class="n">mark_page_dirty_in_slot</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">memslot</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The vCPU has executed a HLT instruction with in-kernel mode enabled.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">kvm_vcpu_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DEFINE_WAIT</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">prepare_to_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_arch_vcpu_runnable</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_UNHALT</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_cpu_has_pending_timer</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">schedule</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">finish_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifndef CONFIG_S390</span>
<span class="cm">/*</span>
<span class="cm"> * Kick a sleeping VCPU, or a guest VCPU in guest mode, into host kernel mode.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">kvm_vcpu_kick</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">me</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">wqp</span><span class="p">;</span>

	<span class="n">wqp</span> <span class="o">=</span> <span class="n">kvm_arch_vcpu_wq</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="n">wqp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="n">wqp</span><span class="p">);</span>
		<span class="o">++</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">halt_wakeup</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">me</span> <span class="o">=</span> <span class="n">get_cpu</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">me</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">cpu</span> <span class="o">&lt;</span> <span class="n">nr_cpu_ids</span> <span class="o">&amp;&amp;</span> <span class="n">cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_arch_vcpu_should_kick</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
			<span class="n">smp_send_reschedule</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">put_cpu</span><span class="p">();</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* !CONFIG_S390 */</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">kvm_resched</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">need_resched</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">cond_resched</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_resched</span><span class="p">);</span>

<span class="n">bool</span> <span class="nf">kvm_vcpu_yield_to</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">pid</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pid</span><span class="p">)</span>
		<span class="n">task</span> <span class="o">=</span> <span class="n">get_pid_task</span><span class="p">(</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">PIDTYPE_PID</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_VCPU</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">yield_to</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_vcpu_yield_to</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">kvm_vcpu_on_spin</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">me</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last_boosted_vcpu</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">last_boosted_vcpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">yielded</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pass</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We boost the priority of a VCPU that is runnable but not</span>
<span class="cm">	 * currently running, because it got preempted by something</span>
<span class="cm">	 * else and called schedule in __vcpu_run.  Hopefully that</span>
<span class="cm">	 * VCPU is holding the lock that we need and will release it.</span>
<span class="cm">	 * We approximate round-robin by starting at the last boosted VCPU.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">pass</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pass</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">yielded</span><span class="p">;</span> <span class="n">pass</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kvm_for_each_vcpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">,</span> <span class="n">kvm</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pass</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">last_boosted_vcpu</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">i</span> <span class="o">=</span> <span class="n">last_boosted_vcpu</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pass</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">last_boosted_vcpu</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span> <span class="o">==</span> <span class="n">me</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">kvm_vcpu_yield_to</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">last_boosted_vcpu</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
				<span class="n">yielded</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_vcpu_on_spin</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_vcpu_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">pgoff</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_X86</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">pgoff</span> <span class="o">==</span> <span class="n">KVM_PIO_PAGE_OFFSET</span><span class="p">)</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">pio_data</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef KVM_COALESCED_MMIO_PAGE_OFFSET</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">pgoff</span> <span class="o">==</span> <span class="n">KVM_COALESCED_MMIO_PAGE_OFFSET</span><span class="p">)</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">coalesced_mmio_ring</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">kvm_arch_vcpu_fault</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vmf</span><span class="p">);</span>
	<span class="n">get_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">vmf</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">vm_operations_struct</span> <span class="n">kvm_vcpu_vm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">fault</span> <span class="o">=</span> <span class="n">kvm_vcpu_fault</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_vcpu_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kvm_vcpu_vm_ops</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_vcpu_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">kvm_put_kvm</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">kvm_vcpu_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">release</span>        <span class="o">=</span> <span class="n">kvm_vcpu_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span> <span class="o">=</span> <span class="n">kvm_vcpu_ioctl</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="p">.</span><span class="n">compat_ioctl</span>   <span class="o">=</span> <span class="n">kvm_vcpu_compat_ioctl</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">mmap</span>           <span class="o">=</span> <span class="n">kvm_vcpu_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">noop_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Allocates an inode for the vcpu.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">create_vcpu_fd</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">anon_inode_getfd</span><span class="p">(</span><span class="s">&quot;kvm-vcpu&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kvm_vcpu_fops</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Creates some virtual cpus.  Good luck creating more than one.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_vm_ioctl_create_vcpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">u32</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">*</span><span class="n">v</span><span class="p">;</span>

	<span class="n">vcpu</span> <span class="o">=</span> <span class="n">kvm_arch_vcpu_create</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="n">preempt_notifier_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">preempt_notifier</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kvm_preempt_ops</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_arch_vcpu_setup</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">vcpu_destroy</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm_vcpu_compatible</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock_vcpu_destroy</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">online_vcpus</span><span class="p">)</span> <span class="o">==</span> <span class="n">KVM_MAX_VCPUS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock_vcpu_destroy</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kvm_for_each_vcpu</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">kvm</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">vcpu_id</span> <span class="o">==</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">unlock_vcpu_destroy</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">vcpus</span><span class="p">[</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">online_vcpus</span><span class="p">)]);</span>

	<span class="cm">/* Now it&#39;s all set up, let userspace reach it */</span>
	<span class="n">kvm_get_kvm</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">create_vcpu_fd</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kvm_put_kvm</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">unlock_vcpu_destroy</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">vcpus</span><span class="p">[</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">online_vcpus</span><span class="p">)]</span> <span class="o">=</span> <span class="n">vcpu</span><span class="p">;</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">online_vcpus</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

<span class="nl">unlock_vcpu_destroy:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="nl">vcpu_destroy:</span>
	<span class="n">kvm_arch_vcpu_destroy</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_vcpu_ioctl_set_sigmask</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">sigset_t</span> <span class="o">*</span><span class="n">sigset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sigset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sigdelsetmask</span><span class="p">(</span><span class="n">sigset</span><span class="p">,</span> <span class="n">sigmask</span><span class="p">(</span><span class="n">SIGKILL</span><span class="p">)</span><span class="o">|</span><span class="n">sigmask</span><span class="p">(</span><span class="n">SIGSTOP</span><span class="p">));</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">sigset_active</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">sigset</span> <span class="o">=</span> <span class="o">*</span><span class="n">sigset</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">sigset_active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">kvm_vcpu_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ioctl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_fpu</span> <span class="o">*</span><span class="n">fpu</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_sregs</span> <span class="o">*</span><span class="n">kvm_sregs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">!=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

<span class="cp">#if defined(CONFIG_S390) || defined(CONFIG_PPC)</span>
	<span class="cm">/*</span>
<span class="cm">	 * Special cases: vcpu ioctls that are asynchronous to vcpu execution,</span>
<span class="cm">	 * so vcpu_load() would break it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioctl</span> <span class="o">==</span> <span class="n">KVM_S390_INTERRUPT</span> <span class="o">||</span> <span class="n">ioctl</span> <span class="o">==</span> <span class="n">KVM_INTERRUPT</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">kvm_arch_vcpu_ioctl</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">ioctl</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
<span class="cp">#endif</span>


	<span class="n">vcpu_load</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ioctl</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">KVM_RUN</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">arg</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_arch_vcpu_ioctl_run</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">);</span>
		<span class="n">trace_kvm_userspace_exit</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">exit_reason</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">KVM_GET_REGS</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_regs</span> <span class="o">*</span><span class="n">kvm_regs</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">kvm_regs</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_regs</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm_regs</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_arch_vcpu_ioctl_get_regs</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">kvm_regs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free1</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="n">kvm_regs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_regs</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">out_free1</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_free1:</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">kvm_regs</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_SET_REGS</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_regs</span> <span class="o">*</span><span class="n">kvm_regs</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">kvm_regs</span> <span class="o">=</span> <span class="n">memdup_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">kvm_regs</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">kvm_regs</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">kvm_regs</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_arch_vcpu_ioctl_set_regs</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">kvm_regs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free2</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_free2:</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">kvm_regs</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_GET_SREGS</span>: <span class="p">{</span>
		<span class="n">kvm_sregs</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_sregs</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm_sregs</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_arch_vcpu_ioctl_get_sregs</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">kvm_sregs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="n">kvm_sregs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_sregs</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_SET_SREGS</span>: <span class="p">{</span>
		<span class="n">kvm_sregs</span> <span class="o">=</span> <span class="n">memdup_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">kvm_sregs</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">kvm_sregs</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">kvm_sregs</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_arch_vcpu_ioctl_set_sregs</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">kvm_sregs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_GET_MP_STATE</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_mp_state</span> <span class="n">mp_state</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_arch_vcpu_ioctl_get_mpstate</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mp_state</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mp_state</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">mp_state</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_SET_MP_STATE</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_mp_state</span> <span class="n">mp_state</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp_state</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">mp_state</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_arch_vcpu_ioctl_set_mpstate</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mp_state</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_TRANSLATE</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_translation</span> <span class="n">tr</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tr</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">tr</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_arch_vcpu_ioctl_translate</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tr</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">tr</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_SET_GUEST_DEBUG</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_guest_debug</span> <span class="n">dbg</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dbg</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">dbg</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_arch_vcpu_ioctl_set_guest_debug</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dbg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_SET_SIGNAL_MASK</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_signal_mask</span> <span class="n">__user</span> <span class="o">*</span><span class="n">sigmask_arg</span> <span class="o">=</span> <span class="n">argp</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">kvm_signal_mask</span> <span class="n">kvm_sigmask</span><span class="p">;</span>
		<span class="n">sigset_t</span> <span class="n">sigset</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

		<span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">argp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_sigmask</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span>
					   <span class="k">sizeof</span> <span class="n">kvm_sigmask</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">kvm_sigmask</span><span class="p">.</span><span class="n">len</span> <span class="o">!=</span> <span class="k">sizeof</span> <span class="n">sigset</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sigset</span><span class="p">,</span> <span class="n">sigmask_arg</span><span class="o">-&gt;</span><span class="n">sigset</span><span class="p">,</span>
					   <span class="k">sizeof</span> <span class="n">sigset</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sigset</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vcpu_ioctl_set_sigmask</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_GET_FPU</span>: <span class="p">{</span>
		<span class="n">fpu</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_fpu</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fpu</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_arch_vcpu_ioctl_get_fpu</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">fpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="n">fpu</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_fpu</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_SET_FPU</span>: <span class="p">{</span>
		<span class="n">fpu</span> <span class="o">=</span> <span class="n">memdup_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">fpu</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">fpu</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">fpu</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_arch_vcpu_ioctl_set_fpu</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">fpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="nl">default:</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_arch_vcpu_ioctl</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">ioctl</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">vcpu_put</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">fpu</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">kvm_sregs</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_COMPAT</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">kvm_vcpu_compat_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ioctl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span> <span class="o">=</span> <span class="n">compat_ptr</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">!=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ioctl</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">KVM_SET_SIGNAL_MASK</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_signal_mask</span> <span class="n">__user</span> <span class="o">*</span><span class="n">sigmask_arg</span> <span class="o">=</span> <span class="n">argp</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">kvm_signal_mask</span> <span class="n">kvm_sigmask</span><span class="p">;</span>
		<span class="n">compat_sigset_t</span> <span class="n">csigset</span><span class="p">;</span>
		<span class="n">sigset_t</span> <span class="n">sigset</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">argp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_sigmask</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span>
					   <span class="k">sizeof</span> <span class="n">kvm_sigmask</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">kvm_sigmask</span><span class="p">.</span><span class="n">len</span> <span class="o">!=</span> <span class="k">sizeof</span> <span class="n">csigset</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">csigset</span><span class="p">,</span> <span class="n">sigmask_arg</span><span class="o">-&gt;</span><span class="n">sigset</span><span class="p">,</span>
					   <span class="k">sizeof</span> <span class="n">csigset</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sigset_from_compat</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sigset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">csigset</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vcpu_ioctl_set_sigmask</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigset</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="nl">default:</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vcpu_ioctl</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">ioctl</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">kvm_vm_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ioctl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">!=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ioctl</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">KVM_CREATE_VCPU</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vm_ioctl_create_vcpu</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">KVM_SET_USER_MEMORY_REGION</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_userspace_memory_region</span> <span class="n">kvm_userspace_mem</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_userspace_mem</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span>
						<span class="k">sizeof</span> <span class="n">kvm_userspace_mem</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vm_ioctl_set_memory_region</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kvm_userspace_mem</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_GET_DIRTY_LOG</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_dirty_log</span> <span class="n">log</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">log</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vm_ioctl_get_dirty_log</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef KVM_COALESCED_MMIO_PAGE_OFFSET</span>
	<span class="k">case</span> <span class="n">KVM_REGISTER_COALESCED_MMIO</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_coalesced_mmio_zone</span> <span class="n">zone</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">zone</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vm_ioctl_register_coalesced_mmio</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zone</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_UNREGISTER_COALESCED_MMIO</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_coalesced_mmio_zone</span> <span class="n">zone</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">zone</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vm_ioctl_unregister_coalesced_mmio</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zone</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">case</span> <span class="n">KVM_IRQFD</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_irqfd</span> <span class="n">data</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">data</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_irqfd</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">fd</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">gsi</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_IOEVENTFD</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_ioeventfd</span> <span class="n">data</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">data</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_ioeventfd</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef CONFIG_KVM_APIC_ARCHITECTURE</span>
	<span class="k">case</span> <span class="n">KVM_SET_BOOT_CPU_ID</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">online_vcpus</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">bsp_vcpu_id</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_HAVE_KVM_MSI</span>
	<span class="k">case</span> <span class="n">KVM_SIGNAL_MSI</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_msi</span> <span class="n">msi</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msi</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">msi</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_send_userspace_msi</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msi</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="nl">default:</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_arch_vm_ioctl</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">ioctl</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">)</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vm_ioctl_assigned_device</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">ioctl</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_COMPAT</span>
<span class="k">struct</span> <span class="n">compat_kvm_dirty_log</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">slot</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">padding1</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">compat_uptr_t</span> <span class="n">dirty_bitmap</span><span class="p">;</span> <span class="cm">/* one bit per page */</span>
		<span class="n">__u64</span> <span class="n">padding2</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">kvm_vm_compat_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ioctl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">!=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ioctl</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">KVM_GET_DIRTY_LOG</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">compat_kvm_dirty_log</span> <span class="n">compat_log</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">kvm_dirty_log</span> <span class="n">log</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">compat_log</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span>
				   <span class="k">sizeof</span><span class="p">(</span><span class="n">compat_log</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">log</span><span class="p">.</span><span class="n">slot</span>	 <span class="o">=</span> <span class="n">compat_log</span><span class="p">.</span><span class="n">slot</span><span class="p">;</span>
		<span class="n">log</span><span class="p">.</span><span class="n">padding1</span>	 <span class="o">=</span> <span class="n">compat_log</span><span class="p">.</span><span class="n">padding1</span><span class="p">;</span>
		<span class="n">log</span><span class="p">.</span><span class="n">padding2</span>	 <span class="o">=</span> <span class="n">compat_log</span><span class="p">.</span><span class="n">padding2</span><span class="p">;</span>
		<span class="n">log</span><span class="p">.</span><span class="n">dirty_bitmap</span> <span class="o">=</span> <span class="n">compat_ptr</span><span class="p">(</span><span class="n">compat_log</span><span class="p">.</span><span class="n">dirty_bitmap</span><span class="p">);</span>

		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vm_ioctl_get_dirty_log</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="nl">default:</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vm_ioctl</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">ioctl</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_vm_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">npages</span><span class="p">;</span>
	<span class="n">gfn_t</span> <span class="n">gfn</span> <span class="o">=</span> <span class="n">vmf</span><span class="o">-&gt;</span><span class="n">pgoff</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">gfn_to_hva</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_is_error_hva</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">VM_FAULT_SIGBUS</span><span class="p">;</span>

	<span class="n">npages</span> <span class="o">=</span> <span class="n">get_user_pages</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span>
				<span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">npages</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">VM_FAULT_SIGBUS</span><span class="p">;</span>

	<span class="n">vmf</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">page</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">vm_operations_struct</span> <span class="n">kvm_vm_vm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">fault</span> <span class="o">=</span> <span class="n">kvm_vm_fault</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_vm_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kvm_vm_vm_ops</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">kvm_vm_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">release</span>        <span class="o">=</span> <span class="n">kvm_vm_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span> <span class="o">=</span> <span class="n">kvm_vm_ioctl</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="p">.</span><span class="n">compat_ioctl</span>   <span class="o">=</span> <span class="n">kvm_vm_compat_ioctl</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">mmap</span>           <span class="o">=</span> <span class="n">kvm_vm_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">noop_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_dev_ioctl_create_vm</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">;</span>

	<span class="n">kvm</span> <span class="o">=</span> <span class="n">kvm_create_vm</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">kvm</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
<span class="cp">#ifdef KVM_COALESCED_MMIO_PAGE_OFFSET</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_coalesced_mmio_init</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kvm_put_kvm</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">anon_inode_getfd</span><span class="p">(</span><span class="s">&quot;kvm-vm&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kvm_vm_fops</span><span class="p">,</span> <span class="n">kvm</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">kvm_put_kvm</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">kvm_dev_ioctl_check_extension_generic</span><span class="p">(</span><span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">KVM_CAP_USER_MEMORY</span>:
	<span class="k">case</span> <span class="n">KVM_CAP_DESTROY_MEMORY_REGION_WORKS</span>:
	<span class="k">case</span> <span class="n">KVM_CAP_JOIN_MEMORY_REGIONS_WORKS</span>:
<span class="cp">#ifdef CONFIG_KVM_APIC_ARCHITECTURE</span>
	<span class="k">case</span> <span class="n">KVM_CAP_SET_BOOT_CPU_ID</span>:
<span class="cp">#endif</span>
	<span class="k">case</span> <span class="n">KVM_CAP_INTERNAL_ERROR_DATA</span>:
<span class="cp">#ifdef CONFIG_HAVE_KVM_MSI</span>
	<span class="k">case</span> <span class="n">KVM_CAP_SIGNAL_MSI</span>:
<span class="cp">#endif</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_HAVE_KVM_IRQCHIP</span>
	<span class="k">case</span> <span class="n">KVM_CAP_IRQ_ROUTING</span>:
		<span class="k">return</span> <span class="n">KVM_MAX_IRQ_ROUTES</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">kvm_dev_ioctl_check_extension</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">kvm_dev_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ioctl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ioctl</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">KVM_GET_API_VERSION</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">arg</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">KVM_API_VERSION</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">KVM_CREATE_VM</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_dev_ioctl_create_vm</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">KVM_CHECK_EXTENSION</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_dev_ioctl_check_extension_generic</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">KVM_GET_VCPU_MMAP_SIZE</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">arg</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>     <span class="cm">/* struct kvm_run */</span>
<span class="cp">#ifdef CONFIG_X86</span>
		<span class="n">r</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>    <span class="cm">/* pio data page */</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef KVM_COALESCED_MMIO_PAGE_OFFSET</span>
		<span class="n">r</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>    <span class="cm">/* coalesced mmio ring page */</span>
<span class="cp">#endif</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">KVM_TRACE_ENABLE</span>:
	<span class="k">case</span> <span class="n">KVM_TRACE_PAUSE</span>:
	<span class="k">case</span> <span class="n">KVM_TRACE_DISABLE</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">kvm_arch_dev_ioctl</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">ioctl</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">kvm_chardev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span> <span class="o">=</span> <span class="n">kvm_dev_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">compat_ioctl</span>   <span class="o">=</span> <span class="n">kvm_dev_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">noop_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">miscdevice</span> <span class="n">kvm_dev</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">KVM_MINOR</span><span class="p">,</span>
	<span class="s">&quot;kvm&quot;</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">kvm_chardev_ops</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hardware_enable_nolock</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">junk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">raw_smp_processor_id</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpus_hardware_enabled</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpus_hardware_enabled</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_arch_hardware_enable</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpus_hardware_enabled</span><span class="p">);</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hardware_enable_failed</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;kvm: enabling virtualization on &quot;</span>
				 <span class="s">&quot;CPU%d failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hardware_enable</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">junk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_lock</span><span class="p">);</span>
	<span class="n">hardware_enable_nolock</span><span class="p">(</span><span class="n">junk</span><span class="p">);</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hardware_disable_nolock</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">junk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">raw_smp_processor_id</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpus_hardware_enabled</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpus_hardware_enabled</span><span class="p">);</span>
	<span class="n">kvm_arch_hardware_disable</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hardware_disable</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">junk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_lock</span><span class="p">);</span>
	<span class="n">hardware_disable_nolock</span><span class="p">(</span><span class="n">junk</span><span class="p">);</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hardware_disable_all_nolock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">kvm_usage_count</span><span class="p">);</span>

	<span class="n">kvm_usage_count</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm_usage_count</span><span class="p">)</span>
		<span class="n">on_each_cpu</span><span class="p">(</span><span class="n">hardware_disable_nolock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hardware_disable_all</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_lock</span><span class="p">);</span>
	<span class="n">hardware_disable_all_nolock</span><span class="p">();</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hardware_enable_all</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_lock</span><span class="p">);</span>

	<span class="n">kvm_usage_count</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_usage_count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hardware_enable_failed</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">on_each_cpu</span><span class="p">(</span><span class="n">hardware_enable_nolock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hardware_enable_failed</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">hardware_disable_all_nolock</span><span class="p">();</span>
			<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_cpu_hotplug</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">notifier</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span>
			   <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">v</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm_usage_count</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CPU_TASKS_FROZEN</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_DYING</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;kvm: disabling virtualization on CPU%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">cpu</span><span class="p">);</span>
		<span class="n">hardware_disable</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CPU_STARTING</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;kvm: enabling virtualization on CPU%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">cpu</span><span class="p">);</span>
		<span class="n">hardware_enable</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">asmlinkage</span> <span class="kt">void</span> <span class="nf">kvm_spurious_fault</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Fault while not rebooting.  We want the trace. */</span>
	<span class="n">BUG</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_spurious_fault</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_reboot</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">notifier</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span>
		      <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Some (well, at least mine) BIOSes hang on reboot if</span>
<span class="cm">	 * in vmx root mode.</span>
<span class="cm">	 *</span>
<span class="cm">	 * And Intel TXT required VMX off for all cpu when system shutdown.</span>
<span class="cm">	 */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;kvm: exiting hardware virtualization</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">kvm_rebooting</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">on_each_cpu</span><span class="p">(</span><span class="n">hardware_disable_nolock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">kvm_reboot_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">kvm_reboot</span><span class="p">,</span>
	<span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_io_bus_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_io_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">dev_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_io_device</span> <span class="o">*</span><span class="n">pos</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">range</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dev</span><span class="p">;</span>

		<span class="n">kvm_iodevice_destructor</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_io_bus_sort_cmp</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">kvm_io_range</span> <span class="o">*</span><span class="n">r1</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">kvm_io_range</span> <span class="o">*</span><span class="n">r2</span> <span class="o">=</span> <span class="n">p2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r1</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="n">r2</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r1</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">+</span> <span class="n">r1</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">r2</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">+</span> <span class="n">r2</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_io_bus_insert_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_io_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_io_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			  <span class="n">gpa_t</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">range</span><span class="p">[</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">dev_count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">kvm_io_range</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">,</span>
		<span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">,</span>
		<span class="p">.</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="n">sort</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">range</span><span class="p">,</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">dev_count</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_io_range</span><span class="p">),</span>
		<span class="n">kvm_io_bus_sort_cmp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_io_bus_get_first_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_io_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
			     <span class="n">gpa_t</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_io_range</span> <span class="o">*</span><span class="n">range</span><span class="p">,</span> <span class="n">key</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">off</span><span class="p">;</span>

	<span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">kvm_io_range</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">,</span>
		<span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="n">range</span> <span class="o">=</span> <span class="n">bsearch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">range</span><span class="p">,</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">dev_count</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_io_range</span><span class="p">),</span> <span class="n">kvm_io_bus_sort_cmp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">range</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="n">off</span> <span class="o">=</span> <span class="n">range</span> <span class="o">-</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">range</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">off</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">kvm_io_bus_sort_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">range</span><span class="p">[</span><span class="n">off</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">off</span><span class="o">--</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">off</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* kvm_io_bus_write - called under kvm-&gt;slots_lock */</span>
<span class="kt">int</span> <span class="nf">kvm_io_bus_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">enum</span> <span class="n">kvm_bus</span> <span class="n">bus_idx</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">addr</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_io_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_io_range</span> <span class="n">range</span><span class="p">;</span>

	<span class="n">range</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">kvm_io_range</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">,</span>
		<span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="n">bus</span> <span class="o">=</span> <span class="n">srcu_dereference</span><span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">buses</span><span class="p">[</span><span class="n">bus_idx</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">);</span>
	<span class="n">idx</span> <span class="o">=</span> <span class="n">kvm_io_bus_get_first_dev</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">dev_count</span> <span class="o">&amp;&amp;</span>
		<span class="n">kvm_io_bus_sort_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">range</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">range</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm_iodevice_write</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">range</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">dev</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">idx</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* kvm_io_bus_read - called under kvm-&gt;slots_lock */</span>
<span class="kt">int</span> <span class="nf">kvm_io_bus_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">enum</span> <span class="n">kvm_bus</span> <span class="n">bus_idx</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">addr</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_io_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_io_range</span> <span class="n">range</span><span class="p">;</span>

	<span class="n">range</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">kvm_io_range</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">,</span>
		<span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="n">bus</span> <span class="o">=</span> <span class="n">srcu_dereference</span><span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">buses</span><span class="p">[</span><span class="n">bus_idx</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">);</span>
	<span class="n">idx</span> <span class="o">=</span> <span class="n">kvm_io_bus_get_first_dev</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">dev_count</span> <span class="o">&amp;&amp;</span>
		<span class="n">kvm_io_bus_sort_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">range</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">range</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm_iodevice_read</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">range</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">dev</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">idx</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Caller must hold slots_lock. */</span>
<span class="kt">int</span> <span class="nf">kvm_io_bus_register_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">enum</span> <span class="n">kvm_bus</span> <span class="n">bus_idx</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">addr</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_io_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_io_bus</span> <span class="o">*</span><span class="n">new_bus</span><span class="p">,</span> <span class="o">*</span><span class="n">bus</span><span class="p">;</span>

	<span class="n">bus</span> <span class="o">=</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">buses</span><span class="p">[</span><span class="n">bus_idx</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">dev_count</span> <span class="o">&gt;</span> <span class="n">NR_IOBUS_DEVS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>

	<span class="n">new_bus</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bus</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">dev_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span>
			  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_io_range</span><span class="p">)),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_bus</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">new_bus</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bus</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">dev_count</span> <span class="o">*</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_io_range</span><span class="p">)));</span>
	<span class="n">kvm_io_bus_insert_dev</span><span class="p">(</span><span class="n">new_bus</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">buses</span><span class="p">[</span><span class="n">bus_idx</span><span class="p">],</span> <span class="n">new_bus</span><span class="p">);</span>
	<span class="n">synchronize_srcu_expedited</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Caller must hold slots_lock. */</span>
<span class="kt">int</span> <span class="nf">kvm_io_bus_unregister_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">enum</span> <span class="n">kvm_bus</span> <span class="n">bus_idx</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">kvm_io_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_io_bus</span> <span class="o">*</span><span class="n">new_bus</span><span class="p">,</span> <span class="o">*</span><span class="n">bus</span><span class="p">;</span>

	<span class="n">bus</span> <span class="o">=</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">buses</span><span class="p">[</span><span class="n">bus_idx</span><span class="p">];</span>
	<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">dev_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">range</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dev</span> <span class="o">==</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">new_bus</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bus</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">dev_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span>
			  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_io_range</span><span class="p">)),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_bus</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">new_bus</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bus</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_io_range</span><span class="p">));</span>
	<span class="n">new_bus</span><span class="o">-&gt;</span><span class="n">dev_count</span><span class="o">--</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">new_bus</span><span class="o">-&gt;</span><span class="n">range</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">range</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
	       <span class="p">(</span><span class="n">new_bus</span><span class="o">-&gt;</span><span class="n">dev_count</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_io_range</span><span class="p">));</span>

	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">buses</span><span class="p">[</span><span class="n">bus_idx</span><span class="p">],</span> <span class="n">new_bus</span><span class="p">);</span>
	<span class="n">synchronize_srcu_expedited</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">kvm_cpu_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">kvm_cpu_hotplug</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vm_stat_get</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">_offset</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">_offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">;</span>

	<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vm_list</span><span class="p">,</span> <span class="n">vm_list</span><span class="p">)</span>
		<span class="o">*</span><span class="n">val</span> <span class="o">+=</span> <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">kvm</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">DEFINE_SIMPLE_ATTRIBUTE</span><span class="p">(</span><span class="n">vm_stat_fops</span><span class="p">,</span> <span class="n">vm_stat_get</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;%llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vcpu_stat_get</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">_offset</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">_offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vm_list</span><span class="p">,</span> <span class="n">vm_list</span><span class="p">)</span>
		<span class="n">kvm_for_each_vcpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">,</span> <span class="n">kvm</span><span class="p">)</span>
			<span class="o">*</span><span class="n">val</span> <span class="o">+=</span> <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">vcpu</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>

	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">DEFINE_SIMPLE_ATTRIBUTE</span><span class="p">(</span><span class="n">vcpu_stat_fops</span><span class="p">,</span> <span class="n">vcpu_stat_get</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;%llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span><span class="n">stat_fops</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">KVM_STAT_VCPU</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vcpu_stat_fops</span><span class="p">,</span>
	<span class="p">[</span><span class="n">KVM_STAT_VM</span><span class="p">]</span>   <span class="o">=</span> <span class="o">&amp;</span><span class="n">vm_stat_fops</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_init_debug</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_stats_debugfs_item</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">kvm_debugfs_dir</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="s">&quot;kvm&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_debugfs_dir</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">debugfs_entries</span><span class="p">;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">kvm_debugfs_dir</span><span class="p">,</span>
						<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">long</span><span class="p">)</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span>
						<span class="n">stat_fops</span><span class="p">[</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">kind</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">dentry</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_dir</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_dir:</span>
	<span class="n">debugfs_remove_recursive</span><span class="p">(</span><span class="n">kvm_debugfs_dir</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_exit_debug</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_stats_debugfs_item</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">debugfs_entries</span><span class="p">;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span>
		<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">kvm_debugfs_dir</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_suspend</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_usage_count</span><span class="p">)</span>
		<span class="n">hardware_disable_nolock</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_resume</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_usage_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">raw_spin_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_lock</span><span class="p">));</span>
		<span class="n">hardware_enable_nolock</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">syscore_ops</span> <span class="n">kvm_syscore_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span> <span class="n">kvm_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">kvm_resume</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">bad_page</span><span class="p">;</span>
<span class="n">pfn_t</span> <span class="n">bad_pfn</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="nf">preempt_notifier_to_vcpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">preempt_notifier</span> <span class="o">*</span><span class="n">pn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">pn</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_vcpu</span><span class="p">,</span> <span class="n">preempt_notifier</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_sched_in</span><span class="p">(</span><span class="k">struct</span> <span class="n">preempt_notifier</span> <span class="o">*</span><span class="n">pn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span> <span class="o">=</span> <span class="n">preempt_notifier_to_vcpu</span><span class="p">(</span><span class="n">pn</span><span class="p">);</span>

	<span class="n">kvm_arch_vcpu_load</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_sched_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">preempt_notifier</span> <span class="o">*</span><span class="n">pn</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span> <span class="o">=</span> <span class="n">preempt_notifier_to_vcpu</span><span class="p">(</span><span class="n">pn</span><span class="p">);</span>

	<span class="n">kvm_arch_vcpu_put</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_init</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">opaque</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">vcpu_size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">vcpu_align</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">module</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_arch_init</span><span class="p">(</span><span class="n">opaque</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_fail</span><span class="p">;</span>

	<span class="n">bad_page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_ZERO</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bad_page</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bad_pfn</span> <span class="o">=</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">bad_page</span><span class="p">);</span>

	<span class="n">hwpoison_page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_ZERO</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hwpoison_page</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free_0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hwpoison_pfn</span> <span class="o">=</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">hwpoison_page</span><span class="p">);</span>

	<span class="n">fault_page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_ZERO</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fault_page</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free_0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fault_pfn</span> <span class="o">=</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">fault_page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zalloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpus_hardware_enabled</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free_0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_arch_hardware_setup</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_0a</span><span class="p">;</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">smp_call_function_single</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span>
				<span class="n">kvm_arch_check_processor_compat</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free_1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">register_cpu_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_cpu_notifier</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_2</span><span class="p">;</span>
	<span class="n">register_reboot_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_reboot_notifier</span><span class="p">);</span>

	<span class="cm">/* A kmem cache lets us meet the alignment requirements of fx_save. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vcpu_align</span><span class="p">)</span>
		<span class="n">vcpu_align</span> <span class="o">=</span> <span class="n">__alignof__</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span><span class="p">);</span>
	<span class="n">kvm_vcpu_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;kvm_vcpu&quot;</span><span class="p">,</span> <span class="n">vcpu_size</span><span class="p">,</span> <span class="n">vcpu_align</span><span class="p">,</span>
					   <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm_vcpu_cache</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free_3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_async_pf_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="n">kvm_chardev_ops</span><span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">module</span><span class="p">;</span>
	<span class="n">kvm_vm_fops</span><span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">module</span><span class="p">;</span>
	<span class="n">kvm_vcpu_fops</span><span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">module</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">misc_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;kvm: misc device register failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unreg</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">register_syscore_ops</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_syscore_ops</span><span class="p">);</span>

	<span class="n">kvm_preempt_ops</span><span class="p">.</span><span class="n">sched_in</span> <span class="o">=</span> <span class="n">kvm_sched_in</span><span class="p">;</span>
	<span class="n">kvm_preempt_ops</span><span class="p">.</span><span class="n">sched_out</span> <span class="o">=</span> <span class="n">kvm_sched_out</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_init_debug</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;kvm: create debugfs files failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_undebugfs</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_undebugfs:</span>
	<span class="n">unregister_syscore_ops</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_syscore_ops</span><span class="p">);</span>
<span class="nl">out_unreg:</span>
	<span class="n">kvm_async_pf_deinit</span><span class="p">();</span>
<span class="nl">out_free:</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">kvm_vcpu_cache</span><span class="p">);</span>
<span class="nl">out_free_3:</span>
	<span class="n">unregister_reboot_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_reboot_notifier</span><span class="p">);</span>
	<span class="n">unregister_cpu_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_cpu_notifier</span><span class="p">);</span>
<span class="nl">out_free_2:</span>
<span class="nl">out_free_1:</span>
	<span class="n">kvm_arch_hardware_unsetup</span><span class="p">();</span>
<span class="nl">out_free_0a:</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">cpus_hardware_enabled</span><span class="p">);</span>
<span class="nl">out_free_0:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fault_page</span><span class="p">)</span>
		<span class="n">__free_page</span><span class="p">(</span><span class="n">fault_page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hwpoison_page</span><span class="p">)</span>
		<span class="n">__free_page</span><span class="p">(</span><span class="n">hwpoison_page</span><span class="p">);</span>
	<span class="n">__free_page</span><span class="p">(</span><span class="n">bad_page</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">kvm_arch_exit</span><span class="p">();</span>
<span class="nl">out_fail:</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_init</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">kvm_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_exit_debug</span><span class="p">();</span>
	<span class="n">misc_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_dev</span><span class="p">);</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">kvm_vcpu_cache</span><span class="p">);</span>
	<span class="n">kvm_async_pf_deinit</span><span class="p">();</span>
	<span class="n">unregister_syscore_ops</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_syscore_ops</span><span class="p">);</span>
	<span class="n">unregister_reboot_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_reboot_notifier</span><span class="p">);</span>
	<span class="n">unregister_cpu_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_cpu_notifier</span><span class="p">);</span>
	<span class="n">on_each_cpu</span><span class="p">(</span><span class="n">hardware_disable_nolock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">kvm_arch_hardware_unsetup</span><span class="p">();</span>
	<span class="n">kvm_arch_exit</span><span class="p">();</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">cpus_hardware_enabled</span><span class="p">);</span>
	<span class="n">__free_page</span><span class="p">(</span><span class="n">hwpoison_page</span><span class="p">);</span>
	<span class="n">__free_page</span><span class="p">(</span><span class="n">bad_page</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_exit</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
