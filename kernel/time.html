<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › time.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>time.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/kernel/time.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1991, 1992  Linus Torvalds</span>
<span class="cm"> *</span>
<span class="cm"> *  This file contains the interface functions for the various</span>
<span class="cm"> *  time related system calls: time, stime, gettimeofday, settimeofday,</span>
<span class="cm"> *			       adjtime</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm"> * Modification history kernel/time.c</span>
<span class="cm"> *</span>
<span class="cm"> * 1993-09-02    Philip Gladstone</span>
<span class="cm"> *      Created file with time related functions from sched.c and adjtimex()</span>
<span class="cm"> * 1993-10-08    Torsten Duwe</span>
<span class="cm"> *      adjtime interface update and CMOS clock write code</span>
<span class="cm"> * 1995-08-13    Torsten Duwe</span>
<span class="cm"> *      kernel PLL updated to 1994-12-13 specs (rfc-1589)</span>
<span class="cm"> * 1999-01-16    Ulrich Windl</span>
<span class="cm"> *	Introduced error checking for many cases in adjtimex().</span>
<span class="cm"> *	Updated NTP code according to technical memorandum Jan &#39;96</span>
<span class="cm"> *	&quot;A Kernel Model for Precision Timekeeping&quot; by Dave Mills</span>
<span class="cm"> *	Allow time_constant larger than MAXTC(6) for NTP v4 (MAXTC == 10)</span>
<span class="cm"> *	(Even though the technical memorandum forbids it)</span>
<span class="cm"> * 2004-07-14	 Christoph Lameter</span>
<span class="cm"> *	Added getnstimeofday to allow the posix timer functions to return</span>
<span class="cm"> *	with nanosecond accuracy</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/timex.h&gt;</span>
<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/clocksource.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/math64.h&gt;</span>
<span class="cp">#include &lt;linux/ptrace.h&gt;</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/unistd.h&gt;</span>

<span class="cp">#include &quot;timeconst.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * The timezone where the local system is located.  Used as a default by some</span>
<span class="cm"> * programs who obtain this value by using gettimeofday.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">timezone</span> <span class="n">sys_tz</span><span class="p">;</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sys_tz</span><span class="p">);</span>

<span class="cp">#ifdef __ARCH_WANT_SYS_TIME</span>

<span class="cm">/*</span>
<span class="cm"> * sys_time() can be implemented in user-level using</span>
<span class="cm"> * sys_gettimeofday().  Is this for backwards compatibility?  If so,</span>
<span class="cm"> * why not move it into the appropriate arch directory (for those</span>
<span class="cm"> * architectures that need it).</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="kt">time_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">tloc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">time_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tloc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">tloc</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">force_successful_syscall_return</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sys_stime() can be implemented in user-level using</span>
<span class="cm"> * sys_settimeofday().  Is this for backwards compatibility?  If so,</span>
<span class="cm"> * why not move it into the appropriate arch directory (for those</span>
<span class="cm"> * architectures that need it).</span>
<span class="cm"> */</span>

<span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">stime</span><span class="p">,</span> <span class="kt">time_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">tptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">tv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span> <span class="n">tptr</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">tv</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">security_settime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tv</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">do_settimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tv</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* __ARCH_WANT_SYS_TIME */</span><span class="cp"></span>

<span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">gettimeofday</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timeval</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">tv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">timezone</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">tz</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">tv</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">timeval</span> <span class="n">ktv</span><span class="p">;</span>
		<span class="n">do_gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ktv</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">tv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ktv</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ktv</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tz</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">tz</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sys_tz</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sys_tz</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Adjust the time obtained from the CMOS to be UTC time instead of</span>
<span class="cm"> * local time.</span>
<span class="cm"> *</span>
<span class="cm"> * This is ugly, but preferable to the alternatives.  Otherwise we</span>
<span class="cm"> * would either need to write a program to do it in /etc/rc (and risk</span>
<span class="cm"> * confusion if the program gets run more than once; it would also be</span>
<span class="cm"> * hard to make the program warp the clock precisely n hours)  or</span>
<span class="cm"> * compile in the timezone information into the kernel.  Bad, bad....</span>
<span class="cm"> *</span>
<span class="cm"> *						- TYT, 1992-01-01</span>
<span class="cm"> *</span>
<span class="cm"> * The best thing to do is to keep the CMOS clock in universal time (UTC)</span>
<span class="cm"> * as real UNIX machines always do it. This avoids all headaches about</span>
<span class="cm"> * daylight saving times and warping kernel clocks.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">warp_clock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">adjust</span><span class="p">;</span>

	<span class="n">adjust</span> <span class="o">=</span> <span class="n">current_kernel_time</span><span class="p">();</span>
	<span class="n">adjust</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">+=</span> <span class="n">sys_tz</span><span class="p">.</span><span class="n">tz_minuteswest</span> <span class="o">*</span> <span class="mi">60</span><span class="p">;</span>
	<span class="n">do_settimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adjust</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * In case for some reason the CMOS clock has not already been running</span>
<span class="cm"> * in UTC, but in some local time: The first time we set the timezone,</span>
<span class="cm"> * we will warp the clock so that it is ticking UTC time instead of</span>
<span class="cm"> * local time. Presumably, if someone is setting the timezone then we</span>
<span class="cm"> * are running in an environment where the programs understand about</span>
<span class="cm"> * timezones. This should be done at boot time in the /etc/rc script,</span>
<span class="cm"> * as soon as possible, so that the clock can be set right. Otherwise,</span>
<span class="cm"> * various programs will get confused when the clock gets warped.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="n">do_sys_settimeofday</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">tv</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">timezone</span> <span class="o">*</span><span class="n">tz</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">firsttime</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tv</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">timespec_valid</span><span class="p">(</span><span class="n">tv</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">security_settime</span><span class="p">(</span><span class="n">tv</span><span class="p">,</span> <span class="n">tz</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tz</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sys_tz</span> <span class="o">=</span> <span class="o">*</span><span class="n">tz</span><span class="p">;</span>
		<span class="n">update_vsyscall_tz</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">firsttime</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">firsttime</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tv</span><span class="p">)</span>
				<span class="n">warp_clock</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tv</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">do_settimeofday</span><span class="p">(</span><span class="n">tv</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">settimeofday</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timeval</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">tv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">timezone</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">tz</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">user_tv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span>	<span class="n">new_ts</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timezone</span> <span class="n">new_tz</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tv</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user_tv</span><span class="p">,</span> <span class="n">tv</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tv</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">new_ts</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">user_tv</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>
		<span class="n">new_ts</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">user_tv</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">*</span> <span class="n">NSEC_PER_USEC</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tz</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_tz</span><span class="p">,</span> <span class="n">tz</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tz</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">do_sys_settimeofday</span><span class="p">(</span><span class="n">tv</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">new_ts</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">tz</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">new_tz</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">adjtimex</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timex</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">txc_p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timex</span> <span class="n">txc</span><span class="p">;</span>		<span class="cm">/* Local copy of parameter */</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Copy the user data space into the kernel copy</span>
<span class="cm">	 * structure. But bear in mind that the structures</span>
<span class="cm">	 * may change</span>
<span class="cm">	 */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txc</span><span class="p">,</span> <span class="n">txc_p</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">timex</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">do_adjtimex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">txc_p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txc</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">timex</span><span class="p">))</span> <span class="o">?</span> <span class="o">-</span><span class="n">EFAULT</span> <span class="o">:</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * current_fs_time - Return FS time</span>
<span class="cm"> * @sb: Superblock.</span>
<span class="cm"> *</span>
<span class="cm"> * Return the current time truncated to the time granularity supported by</span>
<span class="cm"> * the fs.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">timespec</span> <span class="n">current_fs_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">now</span> <span class="o">=</span> <span class="n">current_kernel_time</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">timespec_trunc</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_time_gran</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">current_fs_time</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Convert jiffies to milliseconds and back.</span>
<span class="cm"> *</span>
<span class="cm"> * Avoid unnecessary multiplications/divisions in the</span>
<span class="cm"> * two most common HZ cases:</span>
<span class="cm"> */</span>
<span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">jiffies_to_msecs</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if HZ &lt;= MSEC_PER_SEC &amp;&amp; !(MSEC_PER_SEC % HZ)</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">MSEC_PER_SEC</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">)</span> <span class="o">*</span> <span class="n">j</span><span class="p">;</span>
<span class="cp">#elif HZ &gt; MSEC_PER_SEC &amp;&amp; !(HZ % MSEC_PER_SEC)</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="p">(</span><span class="n">HZ</span> <span class="o">/</span> <span class="n">MSEC_PER_SEC</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">HZ</span> <span class="o">/</span> <span class="n">MSEC_PER_SEC</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp"># if BITS_PER_LONG == 32</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">HZ_TO_MSEC_MUL32</span> <span class="o">*</span> <span class="n">j</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">HZ_TO_MSEC_SHR32</span><span class="p">;</span>
<span class="cp"># else</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">j</span> <span class="o">*</span> <span class="n">HZ_TO_MSEC_NUM</span><span class="p">)</span> <span class="o">/</span> <span class="n">HZ_TO_MSEC_DEN</span><span class="p">;</span>
<span class="cp"># endif</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jiffies_to_msecs</span><span class="p">);</span>

<span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">jiffies_to_usecs</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if HZ &lt;= USEC_PER_SEC &amp;&amp; !(USEC_PER_SEC % HZ)</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">USEC_PER_SEC</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">)</span> <span class="o">*</span> <span class="n">j</span><span class="p">;</span>
<span class="cp">#elif HZ &gt; USEC_PER_SEC &amp;&amp; !(HZ % USEC_PER_SEC)</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="p">(</span><span class="n">HZ</span> <span class="o">/</span> <span class="n">USEC_PER_SEC</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">HZ</span> <span class="o">/</span> <span class="n">USEC_PER_SEC</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp"># if BITS_PER_LONG == 32</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">HZ_TO_USEC_MUL32</span> <span class="o">*</span> <span class="n">j</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">HZ_TO_USEC_SHR32</span><span class="p">;</span>
<span class="cp"># else</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">j</span> <span class="o">*</span> <span class="n">HZ_TO_USEC_NUM</span><span class="p">)</span> <span class="o">/</span> <span class="n">HZ_TO_USEC_DEN</span><span class="p">;</span>
<span class="cp"># endif</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jiffies_to_usecs</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * timespec_trunc - Truncate timespec to a granularity</span>
<span class="cm"> * @t: Timespec</span>
<span class="cm"> * @gran: Granularity in ns.</span>
<span class="cm"> *</span>
<span class="cm"> * Truncate a timespec to a granularity. gran must be smaller than a second.</span>
<span class="cm"> * Always rounds down.</span>
<span class="cm"> *</span>
<span class="cm"> * This function should be only used for timestamps returned by</span>
<span class="cm"> * current_kernel_time() or CURRENT_TIME, not with do_gettimeofday() because</span>
<span class="cm"> * it doesn&#39;t handle the better resolution of the latter.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">timespec</span> <span class="nf">timespec_trunc</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="n">t</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">gran</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Division is pretty slow so avoid it for common cases.</span>
<span class="cm">	 * Currently current_kernel_time() never returns better than</span>
<span class="cm">	 * jiffies resolution. Exploit that.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gran</span> <span class="o">&lt;=</span> <span class="n">jiffies_to_usecs</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* nothing */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">gran</span> <span class="o">==</span> <span class="mi">1000000000</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">t</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">t</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">-=</span> <span class="n">t</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">%</span> <span class="n">gran</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">timespec_trunc</span><span class="p">);</span>

<span class="cm">/* Converts Gregorian date to seconds since 1970-01-01 00:00:00.</span>
<span class="cm"> * Assumes input in normal date format, i.e. 1980-12-31 23:59:59</span>
<span class="cm"> * =&gt; year=1980, mon=12, day=31, hour=23, min=59, sec=59.</span>
<span class="cm"> *</span>
<span class="cm"> * [For the Julian calendar (which was used in Russia before 1917,</span>
<span class="cm"> * Britain &amp; colonies before 1752, anywhere else before 1582,</span>
<span class="cm"> * and is still in use by some communities) leave out the</span>
<span class="cm"> * -year/100+year/400 terms, and add 10.]</span>
<span class="cm"> *</span>
<span class="cm"> * This algorithm was first published by Gauss (I think).</span>
<span class="cm"> *</span>
<span class="cm"> * WARNING: this function will overflow on 2106-02-07 06:28:16 on</span>
<span class="cm"> * machines where long is 32-bit! (However, as time_t is signed, we</span>
<span class="cm"> * will already get problems at other places on 2038-01-19 03:14:08)</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">mktime</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">year0</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mon0</span><span class="p">,</span>
       <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">day</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hour</span><span class="p">,</span>
       <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">min</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mon</span> <span class="o">=</span> <span class="n">mon0</span><span class="p">,</span> <span class="n">year</span> <span class="o">=</span> <span class="n">year0</span><span class="p">;</span>

	<span class="cm">/* 1..12 -&gt; 11,12,1..10 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">mon</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mon</span> <span class="o">+=</span> <span class="mi">12</span><span class="p">;</span>	<span class="cm">/* Puts Feb last since it has leap day */</span>
		<span class="n">year</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">((((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span>
		  <span class="p">(</span><span class="n">year</span><span class="o">/</span><span class="mi">4</span> <span class="o">-</span> <span class="n">year</span><span class="o">/</span><span class="mi">100</span> <span class="o">+</span> <span class="n">year</span><span class="o">/</span><span class="mi">400</span> <span class="o">+</span> <span class="mi">367</span><span class="o">*</span><span class="n">mon</span><span class="o">/</span><span class="mi">12</span> <span class="o">+</span> <span class="n">day</span><span class="p">)</span> <span class="o">+</span>
		  <span class="n">year</span><span class="o">*</span><span class="mi">365</span> <span class="o">-</span> <span class="mi">719499</span>
	    <span class="p">)</span><span class="o">*</span><span class="mi">24</span> <span class="o">+</span> <span class="n">hour</span> <span class="cm">/* now have hours */</span>
	  <span class="p">)</span><span class="o">*</span><span class="mi">60</span> <span class="o">+</span> <span class="n">min</span> <span class="cm">/* now have minutes */</span>
	<span class="p">)</span><span class="o">*</span><span class="mi">60</span> <span class="o">+</span> <span class="n">sec</span><span class="p">;</span> <span class="cm">/* finally seconds */</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">mktime</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * set_normalized_timespec - set timespec sec and nsec parts and normalize</span>
<span class="cm"> *</span>
<span class="cm"> * @ts:		pointer to timespec variable to be set</span>
<span class="cm"> * @sec:	seconds to set</span>
<span class="cm"> * @nsec:	nanoseconds to set</span>
<span class="cm"> *</span>
<span class="cm"> * Set seconds and nanoseconds field of a timespec variable and</span>
<span class="cm"> * normalize to the timespec storage format</span>
<span class="cm"> *</span>
<span class="cm"> * Note: The tv_nsec part is always in the range of</span>
<span class="cm"> *	0 &lt;= tv_nsec &lt; NSEC_PER_SEC</span>
<span class="cm"> * For negative values only the tv_sec field is negative !</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">set_normalized_timespec</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">,</span> <span class="kt">time_t</span> <span class="n">sec</span><span class="p">,</span> <span class="n">s64</span> <span class="n">nsec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">nsec</span> <span class="o">&gt;=</span> <span class="n">NSEC_PER_SEC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The following asm() prevents the compiler from</span>
<span class="cm">		 * optimising this loop into a modulo operation. See</span>
<span class="cm">		 * also __iter_div_u64_rem() in include/linux/time.h</span>
<span class="cm">		 */</span>
		<span class="n">asm</span><span class="p">(</span><span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;+rm&quot;</span><span class="p">(</span><span class="n">nsec</span><span class="p">));</span>
		<span class="n">nsec</span> <span class="o">-=</span> <span class="n">NSEC_PER_SEC</span><span class="p">;</span>
		<span class="o">++</span><span class="n">sec</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">nsec</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asm</span><span class="p">(</span><span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;+rm&quot;</span><span class="p">(</span><span class="n">nsec</span><span class="p">));</span>
		<span class="n">nsec</span> <span class="o">+=</span> <span class="n">NSEC_PER_SEC</span><span class="p">;</span>
		<span class="o">--</span><span class="n">sec</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ts</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">sec</span><span class="p">;</span>
	<span class="n">ts</span><span class="o">-&gt;</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">nsec</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">set_normalized_timespec</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ns_to_timespec - Convert nanoseconds to timespec</span>
<span class="cm"> * @nsec:       the nanoseconds value to be converted</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the timespec representation of the nsec parameter.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">timespec</span> <span class="nf">ns_to_timespec</span><span class="p">(</span><span class="k">const</span> <span class="n">s64</span> <span class="n">nsec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">ts</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">rem</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nsec</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span><span class="p">)</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>

	<span class="n">ts</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">div_s64_rem</span><span class="p">(</span><span class="n">nsec</span><span class="p">,</span> <span class="n">NSEC_PER_SEC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rem</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ts</span><span class="p">.</span><span class="n">tv_sec</span><span class="o">--</span><span class="p">;</span>
		<span class="n">rem</span> <span class="o">+=</span> <span class="n">NSEC_PER_SEC</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ts</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">rem</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ts</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ns_to_timespec</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ns_to_timeval - Convert nanoseconds to timeval</span>
<span class="cm"> * @nsec:       the nanoseconds value to be converted</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the timeval representation of the nsec parameter.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">timeval</span> <span class="nf">ns_to_timeval</span><span class="p">(</span><span class="k">const</span> <span class="n">s64</span> <span class="n">nsec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">ns_to_timespec</span><span class="p">(</span><span class="n">nsec</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">tv</span><span class="p">;</span>

	<span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">ts</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>
	<span class="n">tv</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="p">(</span><span class="n">suseconds_t</span><span class="p">)</span> <span class="n">ts</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">tv</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ns_to_timeval</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * When we convert to jiffies then we interpret incoming values</span>
<span class="cm"> * the following way:</span>
<span class="cm"> *</span>
<span class="cm"> * - negative values mean &#39;infinite timeout&#39; (MAX_JIFFY_OFFSET)</span>
<span class="cm"> *</span>
<span class="cm"> * - &#39;too large&#39; values [that would result in larger than</span>
<span class="cm"> *   MAX_JIFFY_OFFSET values] mean &#39;infinite timeout&#39; too.</span>
<span class="cm"> *</span>
<span class="cm"> * - all other values are converted to jiffies by either multiplying</span>
<span class="cm"> *   the input value by a factor or dividing it with a factor</span>
<span class="cm"> *</span>
<span class="cm"> * We must also be careful about 32-bit overflows.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">msecs_to_jiffies</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Negative value, means infinite timeout:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">MAX_JIFFY_OFFSET</span><span class="p">;</span>

<span class="cp">#if HZ &lt;= MSEC_PER_SEC &amp;&amp; !(MSEC_PER_SEC % HZ)</span>
	<span class="cm">/*</span>
<span class="cm">	 * HZ is equal to or smaller than 1000, and 1000 is a nice</span>
<span class="cm">	 * round multiple of HZ, divide with the factor between them,</span>
<span class="cm">	 * but round upwards:</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="p">(</span><span class="n">MSEC_PER_SEC</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">MSEC_PER_SEC</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">);</span>
<span class="cp">#elif HZ &gt; MSEC_PER_SEC &amp;&amp; !(HZ % MSEC_PER_SEC)</span>
	<span class="cm">/*</span>
<span class="cm">	 * HZ is larger than 1000, and HZ is a nice round multiple of</span>
<span class="cm">	 * 1000 - simply multiply with the factor between them.</span>
<span class="cm">	 *</span>
<span class="cm">	 * But first make sure the multiplication result cannot</span>
<span class="cm">	 * overflow:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">MAX_JIFFY_OFFSET</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">MAX_JIFFY_OFFSET</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="n">HZ</span> <span class="o">/</span> <span class="n">MSEC_PER_SEC</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="cm">/*</span>
<span class="cm">	 * Generic case - multiply, round and divide. But first</span>
<span class="cm">	 * check that if we are doing a net multiplication, that</span>
<span class="cm">	 * we wouldn&#39;t overflow:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HZ</span> <span class="o">&gt;</span> <span class="n">MSEC_PER_SEC</span> <span class="o">&amp;&amp;</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">MAX_JIFFY_OFFSET</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">MAX_JIFFY_OFFSET</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">MSEC_TO_HZ_MUL32</span> <span class="o">*</span> <span class="n">m</span> <span class="o">+</span> <span class="n">MSEC_TO_HZ_ADJ32</span><span class="p">)</span>
		<span class="o">&gt;&gt;</span> <span class="n">MSEC_TO_HZ_SHR32</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">msecs_to_jiffies</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">usecs_to_jiffies</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">u</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">&gt;</span> <span class="n">jiffies_to_usecs</span><span class="p">(</span><span class="n">MAX_JIFFY_OFFSET</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">MAX_JIFFY_OFFSET</span><span class="p">;</span>
<span class="cp">#if HZ &lt;= USEC_PER_SEC &amp;&amp; !(USEC_PER_SEC % HZ)</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">u</span> <span class="o">+</span> <span class="p">(</span><span class="n">USEC_PER_SEC</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">USEC_PER_SEC</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">);</span>
<span class="cp">#elif HZ &gt; USEC_PER_SEC &amp;&amp; !(HZ % USEC_PER_SEC)</span>
	<span class="k">return</span> <span class="n">u</span> <span class="o">*</span> <span class="p">(</span><span class="n">HZ</span> <span class="o">/</span> <span class="n">USEC_PER_SEC</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">USEC_TO_HZ_MUL32</span> <span class="o">*</span> <span class="n">u</span> <span class="o">+</span> <span class="n">USEC_TO_HZ_ADJ32</span><span class="p">)</span>
		<span class="o">&gt;&gt;</span> <span class="n">USEC_TO_HZ_SHR32</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">usecs_to_jiffies</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The TICK_NSEC - 1 rounds up the value to the next resolution.  Note</span>
<span class="cm"> * that a remainder subtract here would not do the right thing as the</span>
<span class="cm"> * resolution values don&#39;t fall on second boundries.  I.e. the line:</span>
<span class="cm"> * nsec -= nsec % TICK_NSEC; is NOT a correct resolution rounding.</span>
<span class="cm"> *</span>
<span class="cm"> * Rather, we just shift the bits off the right.</span>
<span class="cm"> *</span>
<span class="cm"> * The &gt;&gt; (NSEC_JIFFIE_SC - SEC_JIFFIE_SC) converts the scaled nsec</span>
<span class="cm"> * value to a scaled second value.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">timespec_to_jiffies</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sec</span> <span class="o">=</span> <span class="n">value</span><span class="o">-&gt;</span><span class="n">tv_sec</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">nsec</span> <span class="o">=</span> <span class="n">value</span><span class="o">-&gt;</span><span class="n">tv_nsec</span> <span class="o">+</span> <span class="n">TICK_NSEC</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sec</span> <span class="o">&gt;=</span> <span class="n">MAX_SEC_IN_JIFFIES</span><span class="p">){</span>
		<span class="n">sec</span> <span class="o">=</span> <span class="n">MAX_SEC_IN_JIFFIES</span><span class="p">;</span>
		<span class="n">nsec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(((</span><span class="n">u64</span><span class="p">)</span><span class="n">sec</span> <span class="o">*</span> <span class="n">SEC_CONVERSION</span><span class="p">)</span> <span class="o">+</span>
		<span class="p">(((</span><span class="n">u64</span><span class="p">)</span><span class="n">nsec</span> <span class="o">*</span> <span class="n">NSEC_CONVERSION</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
		 <span class="p">(</span><span class="n">NSEC_JIFFIE_SC</span> <span class="o">-</span> <span class="n">SEC_JIFFIE_SC</span><span class="p">)))</span> <span class="o">&gt;&gt;</span> <span class="n">SEC_JIFFIE_SC</span><span class="p">;</span>

<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">timespec_to_jiffies</span><span class="p">);</span>

<span class="kt">void</span>
<span class="nf">jiffies_to_timespec</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">jiffies</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Convert jiffies to nanoseconds and separate with</span>
<span class="cm">	 * one divide.</span>
<span class="cm">	 */</span>
	<span class="n">u32</span> <span class="n">rem</span><span class="p">;</span>
	<span class="n">value</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">div_u64_rem</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">jiffies</span> <span class="o">*</span> <span class="n">TICK_NSEC</span><span class="p">,</span>
				    <span class="n">NSEC_PER_SEC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem</span><span class="p">);</span>
	<span class="n">value</span><span class="o">-&gt;</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">rem</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jiffies_to_timespec</span><span class="p">);</span>

<span class="cm">/* Same for &quot;timeval&quot;</span>
<span class="cm"> *</span>
<span class="cm"> * Well, almost.  The problem here is that the real system resolution is</span>
<span class="cm"> * in nanoseconds and the value being converted is in micro seconds.</span>
<span class="cm"> * Also for some machines (those that use HZ = 1024, in-particular),</span>
<span class="cm"> * there is a LARGE error in the tick size in microseconds.</span>

<span class="cm"> * The solution we use is to do the rounding AFTER we convert the</span>
<span class="cm"> * microsecond part.  Thus the USEC_ROUND, the bits to be shifted off.</span>
<span class="cm"> * Instruction wise, this should cost only an additional add with carry</span>
<span class="cm"> * instruction above the way it was done above.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">timeval_to_jiffies</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sec</span> <span class="o">=</span> <span class="n">value</span><span class="o">-&gt;</span><span class="n">tv_sec</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">usec</span> <span class="o">=</span> <span class="n">value</span><span class="o">-&gt;</span><span class="n">tv_usec</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sec</span> <span class="o">&gt;=</span> <span class="n">MAX_SEC_IN_JIFFIES</span><span class="p">){</span>
		<span class="n">sec</span> <span class="o">=</span> <span class="n">MAX_SEC_IN_JIFFIES</span><span class="p">;</span>
		<span class="n">usec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(((</span><span class="n">u64</span><span class="p">)</span><span class="n">sec</span> <span class="o">*</span> <span class="n">SEC_CONVERSION</span><span class="p">)</span> <span class="o">+</span>
		<span class="p">(((</span><span class="n">u64</span><span class="p">)</span><span class="n">usec</span> <span class="o">*</span> <span class="n">USEC_CONVERSION</span> <span class="o">+</span> <span class="n">USEC_ROUND</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
		 <span class="p">(</span><span class="n">USEC_JIFFIE_SC</span> <span class="o">-</span> <span class="n">SEC_JIFFIE_SC</span><span class="p">)))</span> <span class="o">&gt;&gt;</span> <span class="n">SEC_JIFFIE_SC</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">timeval_to_jiffies</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">jiffies_to_timeval</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">jiffies</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Convert jiffies to nanoseconds and separate with</span>
<span class="cm">	 * one divide.</span>
<span class="cm">	 */</span>
	<span class="n">u32</span> <span class="n">rem</span><span class="p">;</span>

	<span class="n">value</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">div_u64_rem</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">jiffies</span> <span class="o">*</span> <span class="n">TICK_NSEC</span><span class="p">,</span>
				    <span class="n">NSEC_PER_SEC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem</span><span class="p">);</span>
	<span class="n">value</span><span class="o">-&gt;</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="n">rem</span> <span class="o">/</span> <span class="n">NSEC_PER_USEC</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jiffies_to_timeval</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Convert jiffies/jiffies_64 to clock_t and back.</span>
<span class="cm"> */</span>
<span class="kt">clock_t</span> <span class="nf">jiffies_to_clock_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if (TICK_NSEC % (NSEC_PER_SEC / USER_HZ)) == 0</span>
<span class="cp"># if HZ &lt; USER_HZ</span>
	<span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="n">USER_HZ</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">);</span>
<span class="cp"># else</span>
	<span class="k">return</span> <span class="n">x</span> <span class="o">/</span> <span class="p">(</span><span class="n">HZ</span> <span class="o">/</span> <span class="n">USER_HZ</span><span class="p">);</span>
<span class="cp"># endif</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="n">div_u64</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">x</span> <span class="o">*</span> <span class="n">TICK_NSEC</span><span class="p">,</span> <span class="n">NSEC_PER_SEC</span> <span class="o">/</span> <span class="n">USER_HZ</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jiffies_to_clock_t</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">clock_t_to_jiffies</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if (HZ % USER_HZ)==0</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="o">~</span><span class="mi">0UL</span> <span class="o">/</span> <span class="p">(</span><span class="n">HZ</span> <span class="o">/</span> <span class="n">USER_HZ</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="n">HZ</span> <span class="o">/</span> <span class="n">USER_HZ</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="cm">/* Don&#39;t worry about loss of precision here .. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="o">~</span><span class="mi">0UL</span> <span class="o">/</span> <span class="n">HZ</span> <span class="o">*</span> <span class="n">USER_HZ</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span>

	<span class="cm">/* .. but do try to contain it here */</span>
	<span class="k">return</span> <span class="n">div_u64</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">x</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">,</span> <span class="n">USER_HZ</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">clock_t_to_jiffies</span><span class="p">);</span>

<span class="n">u64</span> <span class="nf">jiffies_64_to_clock_t</span><span class="p">(</span><span class="n">u64</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if (TICK_NSEC % (NSEC_PER_SEC / USER_HZ)) == 0</span>
<span class="cp"># if HZ &lt; USER_HZ</span>
	<span class="n">x</span> <span class="o">=</span> <span class="n">div_u64</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">USER_HZ</span><span class="p">,</span> <span class="n">HZ</span><span class="p">);</span>
<span class="cp"># elif HZ &gt; USER_HZ</span>
	<span class="n">x</span> <span class="o">=</span> <span class="n">div_u64</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">HZ</span> <span class="o">/</span> <span class="n">USER_HZ</span><span class="p">);</span>
<span class="cp"># else</span>
	<span class="cm">/* Nothing to do */</span>
<span class="cp"># endif</span>
<span class="cp">#else</span>
	<span class="cm">/*</span>
<span class="cm">	 * There are better ways that don&#39;t overflow early,</span>
<span class="cm">	 * but even this doesn&#39;t overflow in hundreds of years</span>
<span class="cm">	 * in 64 bits, so..</span>
<span class="cm">	 */</span>
	<span class="n">x</span> <span class="o">=</span> <span class="n">div_u64</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">TICK_NSEC</span><span class="p">,</span> <span class="p">(</span><span class="n">NSEC_PER_SEC</span> <span class="o">/</span> <span class="n">USER_HZ</span><span class="p">));</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jiffies_64_to_clock_t</span><span class="p">);</span>

<span class="n">u64</span> <span class="nf">nsec_to_clock_t</span><span class="p">(</span><span class="n">u64</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if (NSEC_PER_SEC % USER_HZ) == 0</span>
	<span class="k">return</span> <span class="n">div_u64</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">NSEC_PER_SEC</span> <span class="o">/</span> <span class="n">USER_HZ</span><span class="p">);</span>
<span class="cp">#elif (USER_HZ % 512) == 0</span>
	<span class="k">return</span> <span class="n">div_u64</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">USER_HZ</span> <span class="o">/</span> <span class="mi">512</span><span class="p">,</span> <span class="n">NSEC_PER_SEC</span> <span class="o">/</span> <span class="mi">512</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="cm">/*</span>
<span class="cm">         * max relative error 5.7e-8 (1.8s per year) for USER_HZ &lt;= 1024,</span>
<span class="cm">         * overflow after 64.99 years.</span>
<span class="cm">         * exact for HZ=60, 72, 90, 120, 144, 180, 300, 600, 900, ...</span>
<span class="cm">         */</span>
	<span class="k">return</span> <span class="n">div_u64</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="mi">9</span><span class="p">,</span> <span class="p">(</span><span class="mi">9ull</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span> <span class="o">+</span> <span class="p">(</span><span class="n">USER_HZ</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="n">USER_HZ</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nsecs_to_jiffies64 - Convert nsecs in u64 to jiffies64</span>
<span class="cm"> *</span>
<span class="cm"> * @n:	nsecs in u64</span>
<span class="cm"> *</span>
<span class="cm"> * Unlike {m,u}secs_to_jiffies, type of input is not unsigned int but u64.</span>
<span class="cm"> * And this doesn&#39;t return MAX_JIFFY_OFFSET since this function is designed</span>
<span class="cm"> * for scheduler, not for use in device drivers to calculate timeout value.</span>
<span class="cm"> *</span>
<span class="cm"> * note:</span>
<span class="cm"> *   NSEC_PER_SEC = 10^9 = (5^9 * 2^9) = (1953125 * 512)</span>
<span class="cm"> *   ULLONG_MAX ns = 18446744073.709551615 secs = about 584 years</span>
<span class="cm"> */</span>
<span class="n">u64</span> <span class="nf">nsecs_to_jiffies64</span><span class="p">(</span><span class="n">u64</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if (NSEC_PER_SEC % HZ) == 0</span>
	<span class="cm">/* Common case, HZ = 100, 128, 200, 250, 256, 500, 512, 1000 etc. */</span>
	<span class="k">return</span> <span class="n">div_u64</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">NSEC_PER_SEC</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">);</span>
<span class="cp">#elif (HZ % 512) == 0</span>
	<span class="cm">/* overflow after 292 years if HZ = 1024 */</span>
	<span class="k">return</span> <span class="n">div_u64</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">512</span><span class="p">,</span> <span class="n">NSEC_PER_SEC</span> <span class="o">/</span> <span class="mi">512</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="cm">/*</span>
<span class="cm">	 * Generic case - optimized for cases where HZ is a multiple of 3.</span>
<span class="cm">	 * overflow after 64.99 years, exact for HZ = 60, 72, 90, 120 etc.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">div_u64</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="mi">9</span><span class="p">,</span> <span class="p">(</span><span class="mi">9ull</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span> <span class="o">+</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nsecs_to_jiffies - Convert nsecs in u64 to jiffies</span>
<span class="cm"> *</span>
<span class="cm"> * @n:	nsecs in u64</span>
<span class="cm"> *</span>
<span class="cm"> * Unlike {m,u}secs_to_jiffies, type of input is not unsigned int but u64.</span>
<span class="cm"> * And this doesn&#39;t return MAX_JIFFY_OFFSET since this function is designed</span>
<span class="cm"> * for scheduler, not for use in device drivers to calculate timeout value.</span>
<span class="cm"> *</span>
<span class="cm"> * note:</span>
<span class="cm"> *   NSEC_PER_SEC = 10^9 = (5^9 * 2^9) = (1953125 * 512)</span>
<span class="cm"> *   ULLONG_MAX ns = 18446744073.709551615 secs = about 584 years</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">nsecs_to_jiffies</span><span class="p">(</span><span class="n">u64</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">nsecs_to_jiffies64</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Add two timespec values and do a safety check for overflow.</span>
<span class="cm"> * It&#39;s assumed that both values are valid (&gt;= 0)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">timespec</span> <span class="nf">timespec_add_safe</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="n">lhs</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">set_normalized_timespec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="p">,</span> <span class="n">lhs</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">+</span> <span class="n">rhs</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span>
				<span class="n">lhs</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">+</span> <span class="n">rhs</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">&lt;</span> <span class="n">lhs</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">||</span> <span class="n">res</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">)</span>
		<span class="n">res</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">TIME_T_MAX</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
