<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › ptrace.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>ptrace.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * linux/kernel/ptrace.c</span>
<span class="cm"> *</span>
<span class="cm"> * (C) Copyright 1999 Linus Torvalds</span>
<span class="cm"> *</span>
<span class="cm"> * Common interfaces for &quot;ptrace()&quot; which we do not want</span>
<span class="cm"> * to continually duplicate across every architecture.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/ptrace.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/signal.h&gt;</span>
<span class="cp">#include &lt;linux/audit.h&gt;</span>
<span class="cp">#include &lt;linux/pid_namespace.h&gt;</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/regset.h&gt;</span>
<span class="cp">#include &lt;linux/hw_breakpoint.h&gt;</span>
<span class="cp">#include &lt;linux/cn_proc.h&gt;</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">ptrace_trapping_sleep_fn</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">schedule</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ptrace a task: make the debugger its new parent and</span>
<span class="cm"> * move it to the ptrace list.</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called with the tasklist lock write-held.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__ptrace_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">new_parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">ptrace_entry</span><span class="p">));</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">ptrace_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_parent</span><span class="o">-&gt;</span><span class="n">ptraced</span><span class="p">);</span>
	<span class="n">child</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">new_parent</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __ptrace_unlink - unlink ptracee and restore its execution state</span>
<span class="cm"> * @child: ptracee to be unlinked</span>
<span class="cm"> *</span>
<span class="cm"> * Remove @child from the ptrace list, move it back to the original parent,</span>
<span class="cm"> * and restore the execution state so that it conforms to the group stop</span>
<span class="cm"> * state.</span>
<span class="cm"> *</span>
<span class="cm"> * Unlinking can happen via two paths - explicit PTRACE_DETACH or ptracer</span>
<span class="cm"> * exiting.  For PTRACE_DETACH, unless the ptracee has been killed between</span>
<span class="cm"> * ptrace_check_attach() and here, it&#39;s guaranteed to be in TASK_TRACED.</span>
<span class="cm"> * If the ptracer is exiting, the ptracee can be in any state.</span>
<span class="cm"> *</span>
<span class="cm"> * After detach, the ptracee should be in a state which conforms to the</span>
<span class="cm"> * group stop.  If the group is stopped or in the process of stopping, the</span>
<span class="cm"> * ptracee should be put into TASK_STOPPED; otherwise, it should be woken</span>
<span class="cm"> * up from TASK_TRACED.</span>
<span class="cm"> *</span>
<span class="cm"> * If the ptracee is in TASK_TRACED and needs to be moved to TASK_STOPPED,</span>
<span class="cm"> * it goes through TRACED -&gt; RUNNING -&gt; STOPPED transition which is similar</span>
<span class="cm"> * to but in the opposite direction of what happens while attaching to a</span>
<span class="cm"> * stopped task.  However, in this direction, the intermediate RUNNING</span>
<span class="cm"> * state is not hidden even from the current ptracer and if it immediately</span>
<span class="cm"> * re-attaches and performs a WNOHANG wait(2), it may fail.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * write_lock_irq(tasklist_lock)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__ptrace_unlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">ptrace</span><span class="p">);</span>

	<span class="n">child</span><span class="o">-&gt;</span><span class="n">ptrace</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">child</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">real_parent</span><span class="p">;</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">ptrace_entry</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear all pending traps and TRAPPING.  TRAPPING should be</span>
<span class="cm">	 * cleared regardless of JOBCTL_STOP_PENDING.  Do it explicitly.</span>
<span class="cm">	 */</span>
	<span class="n">task_clear_jobctl_pending</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">JOBCTL_TRAP_MASK</span><span class="p">);</span>
	<span class="n">task_clear_jobctl_trapping</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reinstate JOBCTL_STOP_PENDING if group stop is in effect and</span>
<span class="cm">	 * @child isn&#39;t dead.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_EXITING</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SIGNAL_STOP_STOPPED</span> <span class="o">||</span>
	     <span class="n">child</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">group_stop_count</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">child</span><span class="o">-&gt;</span><span class="n">jobctl</span> <span class="o">|=</span> <span class="n">JOBCTL_STOP_PENDING</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * This is only possible if this thread was cloned by the</span>
<span class="cm">		 * traced task running in the stopped group, set the signal</span>
<span class="cm">		 * for the future reports.</span>
<span class="cm">		 * FIXME: we should change ptrace_init_task() to handle this</span>
<span class="cm">		 * case.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">jobctl</span> <span class="o">&amp;</span> <span class="n">JOBCTL_STOP_SIGMASK</span><span class="p">))</span>
			<span class="n">child</span><span class="o">-&gt;</span><span class="n">jobctl</span> <span class="o">|=</span> <span class="n">SIGSTOP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If transition to TASK_STOPPED is pending or in TASK_TRACED, kick</span>
<span class="cm">	 * @child in the butt.  Note that @resume should be used iff @child</span>
<span class="cm">	 * is in TASK_TRACED; otherwise, we might unduly disrupt</span>
<span class="cm">	 * TASK_KILLABLE sleeps.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">jobctl</span> <span class="o">&amp;</span> <span class="n">JOBCTL_STOP_PENDING</span> <span class="o">||</span> <span class="n">task_is_traced</span><span class="p">(</span><span class="n">child</span><span class="p">))</span>
		<span class="n">signal_wake_up</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">task_is_traced</span><span class="p">(</span><span class="n">child</span><span class="p">));</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ptrace_check_attach - check whether ptracee is ready for ptrace operation</span>
<span class="cm"> * @child: ptracee to check for</span>
<span class="cm"> * @ignore_state: don&#39;t check whether @child is currently %TASK_TRACED</span>
<span class="cm"> *</span>
<span class="cm"> * Check whether @child is being ptraced by %current and ready for further</span>
<span class="cm"> * ptrace operations.  If @ignore_state is %false, @child also should be in</span>
<span class="cm"> * %TASK_TRACED state and on return the child is guaranteed to be traced</span>
<span class="cm"> * and not executing.  If @ignore_state is %true, @child can be in any</span>
<span class="cm"> * state.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * Grabs and releases tasklist_lock and @child-&gt;sighand-&gt;siglock.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * 0 on success, -ESRCH if %child is not ready.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ptrace_check_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span> <span class="n">bool</span> <span class="n">ignore_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We take the read lock around doing both checks to close a</span>
<span class="cm">	 * possible race where someone else was tracing our child and</span>
<span class="cm">	 * detached between these two checks.  After this locked check,</span>
<span class="cm">	 * we are sure that this is our traced child and that can only</span>
<span class="cm">	 * be changed by us so it&#39;s not changing right after this.</span>
<span class="cm">	 */</span>
	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">ptrace</span> <span class="o">&amp;</span> <span class="n">PT_PTRACED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">==</span> <span class="n">current</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * child-&gt;sighand can&#39;t be NULL, release_task()</span>
<span class="cm">		 * does ptrace_unlink() before __exit_signal().</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">task_is_stopped</span><span class="p">(</span><span class="n">child</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ignore_state</span> <span class="o">||</span> <span class="p">(</span><span class="n">task_is_traced</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				     <span class="o">!</span><span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">jobctl</span> <span class="o">&amp;</span> <span class="n">JOBCTL_LISTENING</span><span class="p">)))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ignore_state</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">wait_task_inactive</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">TASK_TRACED</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>

	<span class="cm">/* All systems go.. */</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ptrace_has_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">PTRACE_MODE_NOAUDIT</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">has_ns_capability_noaudit</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">CAP_SYS_PTRACE</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">has_ns_capability</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">CAP_SYS_PTRACE</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">__ptrace_may_access</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">(),</span> <span class="o">*</span><span class="n">tcred</span><span class="p">;</span>

	<span class="cm">/* May we inspect the given task?</span>
<span class="cm">	 * This check is used both for attaching with ptrace</span>
<span class="cm">	 * and for allowing access to sensitive information in /proc.</span>
<span class="cm">	 *</span>
<span class="cm">	 * ptrace_attach denies several cases that /proc allows</span>
<span class="cm">	 * because setting up the necessary parent/child relationship</span>
<span class="cm">	 * or halting the specified task is impossible.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">dumpable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Don&#39;t let security modules deny introspection */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span> <span class="o">==</span> <span class="n">current</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">tcred</span> <span class="o">=</span> <span class="n">__task_cred</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">,</span> <span class="n">tcred</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">uid_eq</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">,</span> <span class="n">tcred</span><span class="o">-&gt;</span><span class="n">suid</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">uid_eq</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">,</span> <span class="n">tcred</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">)</span>  <span class="o">&amp;&amp;</span>
	    <span class="n">gid_eq</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">gid</span><span class="p">,</span> <span class="n">tcred</span><span class="o">-&gt;</span><span class="n">egid</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">gid_eq</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">gid</span><span class="p">,</span> <span class="n">tcred</span><span class="o">-&gt;</span><span class="n">sgid</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">gid_eq</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">gid</span><span class="p">,</span> <span class="n">tcred</span><span class="o">-&gt;</span><span class="n">gid</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">ok</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ptrace_has_cap</span><span class="p">(</span><span class="n">tcred</span><span class="o">-&gt;</span><span class="n">user_ns</span><span class="p">,</span> <span class="n">mode</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">ok</span><span class="p">;</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
<span class="nl">ok:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="n">smp_rmb</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span>
		<span class="n">dumpable</span> <span class="o">=</span> <span class="n">get_dumpable</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dumpable</span>  <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ptrace_has_cap</span><span class="p">(</span><span class="n">task_user_ns</span><span class="p">(</span><span class="n">task</span><span class="p">),</span> <span class="n">mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">security_ptrace_access_check</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">ptrace_may_access</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">task_lock</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">__ptrace_may_access</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="n">task_unlock</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ptrace_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">long</span> <span class="n">request</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">seize</span> <span class="o">=</span> <span class="p">(</span><span class="n">request</span> <span class="o">==</span> <span class="n">PTRACE_SEIZE</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">seize</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">PTRACE_O_MASK</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">PT_PTRACED</span> <span class="o">|</span> <span class="n">PT_SEIZED</span> <span class="o">|</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&lt;&lt;</span> <span class="n">PT_OPT_FLAG_SHIFT</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">PT_PTRACED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">audit_ptrace</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_KTHREAD</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">same_thread_group</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">current</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Protect exec&#39;s credential calculations against our interference;</span>
<span class="cm">	 * SUID, SGID and LSM creds get determined differently</span>
<span class="cm">	 * under ptrace.</span>
<span class="cm">	 */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTARTNOINTR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mutex_lock_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">cred_guard_mutex</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">task_lock</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">__ptrace_may_access</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">PTRACE_MODE_ATTACH</span><span class="p">);</span>
	<span class="n">task_unlock</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlock_creds</span><span class="p">;</span>

	<span class="n">write_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">exit_state</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">unlock_tasklist</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">ptrace</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlock_tasklist</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">seize</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">PT_SEIZED</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ns_capable</span><span class="p">(</span><span class="n">task_user_ns</span><span class="p">(</span><span class="n">task</span><span class="p">),</span> <span class="n">CAP_SYS_PTRACE</span><span class="p">))</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">PT_PTRACE_CAP</span><span class="p">;</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">ptrace</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">__ptrace_link</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>

	<span class="cm">/* SEIZE doesn&#39;t trap tracee on attach */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">seize</span><span class="p">)</span>
		<span class="n">send_sig_info</span><span class="p">(</span><span class="n">SIGSTOP</span><span class="p">,</span> <span class="n">SEND_SIG_FORCED</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the task is already STOPPED, set JOBCTL_TRAP_STOP and</span>
<span class="cm">	 * TRAPPING, and kick it so that it transits to TRACED.  TRAPPING</span>
<span class="cm">	 * will be cleared if the child completes the transition or any</span>
<span class="cm">	 * event which clears the group stop states happens.  We&#39;ll wait</span>
<span class="cm">	 * for the transition to complete before returning from this</span>
<span class="cm">	 * function.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This hides STOPPED -&gt; RUNNING -&gt; TRACED transition from the</span>
<span class="cm">	 * attaching thread but a different thread in the same group can</span>
<span class="cm">	 * still observe the transient RUNNING state.  IOW, if another</span>
<span class="cm">	 * thread&#39;s WNOHANG wait(2) on the stopped tracee races against</span>
<span class="cm">	 * ATTACH, the wait(2) may fail due to the transient RUNNING.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The following task_is_stopped() test is safe as both transitions</span>
<span class="cm">	 * in and out of STOPPED are protected by siglock.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task_is_stopped</span><span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">task_set_jobctl_pending</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">JOBCTL_TRAP_STOP</span> <span class="o">|</span> <span class="n">JOBCTL_TRAPPING</span><span class="p">))</span>
		<span class="n">signal_wake_up</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">unlock_tasklist:</span>
	<span class="n">write_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
<span class="nl">unlock_creds:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">cred_guard_mutex</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wait_on_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">jobctl</span><span class="p">,</span> <span class="n">JOBCTL_TRAPPING_BIT</span><span class="p">,</span>
			    <span class="n">ptrace_trapping_sleep_fn</span><span class="p">,</span> <span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
		<span class="n">proc_ptrace_connector</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">PTRACE_ATTACH</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ptrace_traceme  --  helper for PTRACE_TRACEME</span>
<span class="cm"> *</span>
<span class="cm"> * Performs checks and sets PT_PTRACED.</span>
<span class="cm"> * Should be used by all ptrace implementations for PTRACE_TRACEME.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ptrace_traceme</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">write_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="cm">/* Are we already being traced? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">ptrace</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">security_ptrace_traceme</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Check PF_EXITING to ensure -&gt;real_parent has not passed</span>
<span class="cm">		 * exit_ptrace(). Otherwise we don&#39;t report the error but</span>
<span class="cm">		 * pretend -&gt;real_parent untraces us right after return.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">real_parent</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_EXITING</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">ptrace</span> <span class="o">=</span> <span class="n">PT_PTRACED</span><span class="p">;</span>
			<span class="n">__ptrace_link</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">real_parent</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">write_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called with irqs disabled, returns true if childs should reap themselves.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ignoring_children</span><span class="p">(</span><span class="k">struct</span> <span class="n">sighand_struct</span> <span class="o">*</span><span class="n">sigh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sigh</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">sigh</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">[</span><span class="n">SIGCHLD</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">==</span> <span class="n">SIG_IGN</span><span class="p">)</span> <span class="o">||</span>
	      <span class="p">(</span><span class="n">sigh</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">[</span><span class="n">SIGCHLD</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">&amp;</span> <span class="n">SA_NOCLDWAIT</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sigh</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called with tasklist_lock held for writing.</span>
<span class="cm"> * Unlink a traced task, and clean it up if it was a traced zombie.</span>
<span class="cm"> * Return true if it needs to be reaped with release_task().</span>
<span class="cm"> * (We can&#39;t call release_task() here because we already hold tasklist_lock.)</span>
<span class="cm"> *</span>
<span class="cm"> * If it&#39;s a zombie, our attachedness prevented normal parent notification</span>
<span class="cm"> * or self-reaping.  Do notification now if it would have happened earlier.</span>
<span class="cm"> * If it should reap itself, return true.</span>
<span class="cm"> *</span>
<span class="cm"> * If it&#39;s our own child, there is no notification to do. But if our normal</span>
<span class="cm"> * children self-reap, then this child was prevented by ptrace and we must</span>
<span class="cm"> * reap it now, in that case we must also wake up sub-threads sleeping in</span>
<span class="cm"> * do_wait().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">__ptrace_detach</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tracer</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">dead</span><span class="p">;</span>

	<span class="n">__ptrace_unlink</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">exit_state</span> <span class="o">!=</span> <span class="n">EXIT_ZOMBIE</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">dead</span> <span class="o">=</span> <span class="o">!</span><span class="n">thread_group_leader</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dead</span> <span class="o">&amp;&amp;</span> <span class="n">thread_group_empty</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">same_thread_group</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">real_parent</span><span class="p">,</span> <span class="n">tracer</span><span class="p">))</span>
			<span class="n">dead</span> <span class="o">=</span> <span class="n">do_notify_parent</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">exit_signal</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ignoring_children</span><span class="p">(</span><span class="n">tracer</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">__wake_up_parent</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tracer</span><span class="p">);</span>
			<span class="n">dead</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Mark it as in the process of being reaped. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dead</span><span class="p">)</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">exit_state</span> <span class="o">=</span> <span class="n">EXIT_DEAD</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">dead</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ptrace_detach</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">dead</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">valid_signal</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="cm">/* Architecture-specific hardware disable .. */</span>
	<span class="n">ptrace_disable</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
	<span class="n">clear_tsk_thread_flag</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">TIF_SYSCALL_TRACE</span><span class="p">);</span>

	<span class="n">write_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * This child can be already killed. Make sure de_thread() or</span>
<span class="cm">	 * our sub-thread doing do_wait() didn&#39;t do release_task() yet.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">ptrace</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">child</span><span class="o">-&gt;</span><span class="n">exit_code</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
		<span class="n">dead</span> <span class="o">=</span> <span class="n">__ptrace_detach</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">write_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>

	<span class="n">proc_ptrace_connector</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">PTRACE_DETACH</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dead</span><span class="p">))</span>
		<span class="n">release_task</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Detach all tasks we were using ptrace on. Called with tasklist held</span>
<span class="cm"> * for writing, and returns with it held too. But note it can release</span>
<span class="cm"> * and reacquire the lock.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">exit_ptrace</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tracer</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">)</span>
	<span class="n">__acquires</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">ptrace_dead</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tracer</span><span class="o">-&gt;</span><span class="n">ptraced</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tracer</span><span class="o">-&gt;</span><span class="n">ptraced</span><span class="p">,</span> <span class="n">ptrace_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__ptrace_detach</span><span class="p">(</span><span class="n">tracer</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ptrace_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptrace_dead</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">write_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tracer</span><span class="o">-&gt;</span><span class="n">ptraced</span><span class="p">));</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptrace_dead</span><span class="p">,</span> <span class="n">ptrace_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ptrace_entry</span><span class="p">);</span>
		<span class="n">release_task</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">write_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ptrace_readdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">src</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">copied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">this_len</span><span class="p">,</span> <span class="n">retval</span><span class="p">;</span>

		<span class="n">this_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span> <span class="o">?</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">:</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">access_process_vm</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">this_len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copied</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">retval</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">copied</span> <span class="o">+=</span> <span class="n">retval</span><span class="p">;</span>
		<span class="n">src</span> <span class="o">+=</span> <span class="n">retval</span><span class="p">;</span>
		<span class="n">dst</span> <span class="o">+=</span> <span class="n">retval</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">copied</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ptrace_writedata</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dst</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">copied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">this_len</span><span class="p">,</span> <span class="n">retval</span><span class="p">;</span>

		<span class="n">this_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span> <span class="o">?</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">:</span> <span class="n">len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">this_len</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">access_process_vm</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">this_len</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copied</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">copied</span> <span class="o">+=</span> <span class="n">retval</span><span class="p">;</span>
		<span class="n">src</span> <span class="o">+=</span> <span class="n">retval</span><span class="p">;</span>
		<span class="n">dst</span> <span class="o">+=</span> <span class="n">retval</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">copied</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ptrace_setoptions</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">PTRACE_O_MASK</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Avoid intermediate state when all opts are cleared */</span>
	<span class="n">flags</span> <span class="o">=</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">ptrace</span><span class="p">;</span>
	<span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">PTRACE_O_MASK</span> <span class="o">&lt;&lt;</span> <span class="n">PT_OPT_FLAG_SHIFT</span><span class="p">);</span>
	<span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="n">PT_OPT_FLAG_SHIFT</span><span class="p">);</span>
	<span class="n">child</span><span class="o">-&gt;</span><span class="n">ptrace</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ptrace_getsiginfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span> <span class="n">siginfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lock_task_sighand</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">last_siginfo</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="o">*</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">last_siginfo</span><span class="p">;</span>
			<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">unlock_task_sighand</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ptrace_setsiginfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span> <span class="k">const</span> <span class="n">siginfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lock_task_sighand</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">last_siginfo</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">last_siginfo</span> <span class="o">=</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
			<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">unlock_task_sighand</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>


<span class="cp">#ifdef PTRACE_SINGLESTEP</span>
<span class="cp">#define is_singlestep(request)		((request) == PTRACE_SINGLESTEP)</span>
<span class="cp">#else</span>
<span class="cp">#define is_singlestep(request)		0</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef PTRACE_SINGLEBLOCK</span>
<span class="cp">#define is_singleblock(request)		((request) == PTRACE_SINGLEBLOCK)</span>
<span class="cp">#else</span>
<span class="cp">#define is_singleblock(request)		0</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef PTRACE_SYSEMU</span>
<span class="cp">#define is_sysemu_singlestep(request)	((request) == PTRACE_SYSEMU_SINGLESTEP)</span>
<span class="cp">#else</span>
<span class="cp">#define is_sysemu_singlestep(request)	0</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ptrace_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span> <span class="kt">long</span> <span class="n">request</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">valid_signal</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">request</span> <span class="o">==</span> <span class="n">PTRACE_SYSCALL</span><span class="p">)</span>
		<span class="n">set_tsk_thread_flag</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">TIF_SYSCALL_TRACE</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">clear_tsk_thread_flag</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">TIF_SYSCALL_TRACE</span><span class="p">);</span>

<span class="cp">#ifdef TIF_SYSCALL_EMU</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">request</span> <span class="o">==</span> <span class="n">PTRACE_SYSEMU</span> <span class="o">||</span> <span class="n">request</span> <span class="o">==</span> <span class="n">PTRACE_SYSEMU_SINGLESTEP</span><span class="p">)</span>
		<span class="n">set_tsk_thread_flag</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">TIF_SYSCALL_EMU</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">clear_tsk_thread_flag</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">TIF_SYSCALL_EMU</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_singleblock</span><span class="p">(</span><span class="n">request</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">arch_has_block_step</span><span class="p">()))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="n">user_enable_block_step</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_singlestep</span><span class="p">(</span><span class="n">request</span><span class="p">)</span> <span class="o">||</span> <span class="n">is_sysemu_singlestep</span><span class="p">(</span><span class="n">request</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">arch_has_single_step</span><span class="p">()))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="n">user_enable_single_step</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">user_disable_single_step</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">child</span><span class="o">-&gt;</span><span class="n">exit_code</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">wake_up_state</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">__TASK_TRACED</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HAVE_ARCH_TRACEHOOK</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">user_regset</span> <span class="o">*</span>
<span class="nf">find_regset</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">user_regset_view</span> <span class="o">*</span><span class="n">view</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">user_regset</span> <span class="o">*</span><span class="n">regset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">view</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">regset</span> <span class="o">=</span> <span class="n">view</span><span class="o">-&gt;</span><span class="n">regsets</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">regset</span><span class="o">-&gt;</span><span class="n">core_note_type</span> <span class="o">==</span> <span class="n">type</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">regset</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ptrace_regset</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">int</span> <span class="n">req</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">kiov</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">user_regset_view</span> <span class="o">*</span><span class="n">view</span> <span class="o">=</span> <span class="n">task_user_regset_view</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">user_regset</span> <span class="o">*</span><span class="n">regset</span> <span class="o">=</span> <span class="n">find_regset</span><span class="p">(</span><span class="n">view</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">regset_no</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">regset</span> <span class="o">||</span> <span class="p">(</span><span class="n">kiov</span><span class="o">-&gt;</span><span class="n">iov_len</span> <span class="o">%</span> <span class="n">regset</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">regset_no</span> <span class="o">=</span> <span class="n">regset</span> <span class="o">-</span> <span class="n">view</span><span class="o">-&gt;</span><span class="n">regsets</span><span class="p">;</span>
	<span class="n">kiov</span><span class="o">-&gt;</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">kiov</span><span class="o">-&gt;</span><span class="n">iov_len</span><span class="p">,</span>
			    <span class="p">(</span><span class="n">__kernel_size_t</span><span class="p">)</span> <span class="p">(</span><span class="n">regset</span><span class="o">-&gt;</span><span class="n">n</span> <span class="o">*</span> <span class="n">regset</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span> <span class="o">==</span> <span class="n">PTRACE_GETREGSET</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">copy_regset_to_user</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">regset_no</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					   <span class="n">kiov</span><span class="o">-&gt;</span><span class="n">iov_len</span><span class="p">,</span> <span class="n">kiov</span><span class="o">-&gt;</span><span class="n">iov_base</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">copy_regset_from_user</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">regset_no</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					     <span class="n">kiov</span><span class="o">-&gt;</span><span class="n">iov_len</span><span class="p">,</span> <span class="n">kiov</span><span class="o">-&gt;</span><span class="n">iov_base</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="kt">int</span> <span class="nf">ptrace_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span> <span class="kt">long</span> <span class="n">request</span><span class="p">,</span>
		   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">seized</span> <span class="o">=</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">ptrace</span> <span class="o">&amp;</span> <span class="n">PT_SEIZED</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="n">siginfo_t</span> <span class="n">siginfo</span><span class="p">,</span> <span class="o">*</span><span class="n">si</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">datavp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="n">datalp</span> <span class="o">=</span> <span class="n">datavp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">request</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PTRACE_PEEKTEXT</span>:
	<span class="k">case</span> <span class="n">PTRACE_PEEKDATA</span>:
		<span class="k">return</span> <span class="n">generic_ptrace_peekdata</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">PTRACE_POKETEXT</span>:
	<span class="k">case</span> <span class="n">PTRACE_POKEDATA</span>:
		<span class="k">return</span> <span class="n">generic_ptrace_pokedata</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

<span class="cp">#ifdef PTRACE_OLDSETOPTIONS</span>
	<span class="k">case</span> <span class="n">PTRACE_OLDSETOPTIONS</span>:
<span class="cp">#endif</span>
	<span class="k">case</span> <span class="n">PTRACE_SETOPTIONS</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ptrace_setoptions</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PTRACE_GETEVENTMSG</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">ptrace_message</span><span class="p">,</span> <span class="n">datalp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PTRACE_GETSIGINFO</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ptrace_getsiginfo</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">siginfo</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">copy_siginfo_to_user</span><span class="p">(</span><span class="n">datavp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">siginfo</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PTRACE_SETSIGINFO</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">siginfo</span><span class="p">,</span> <span class="n">datavp</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">siginfo</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">ptrace_setsiginfo</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">siginfo</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PTRACE_INTERRUPT</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Stop tracee without any side-effect on signal or job</span>
<span class="cm">		 * control.  At least one trap is guaranteed to happen</span>
<span class="cm">		 * after this request.  If @child is already trapped, the</span>
<span class="cm">		 * current trap is not disturbed and another trap will</span>
<span class="cm">		 * happen after the current trap is ended with PTRACE_CONT.</span>
<span class="cm">		 *</span>
<span class="cm">		 * The actual trap might not be PTRACE_EVENT_STOP trap but</span>
<span class="cm">		 * the pending condition is cleared regardless.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">seized</span> <span class="o">||</span> <span class="o">!</span><span class="n">lock_task_sighand</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * INTERRUPT doesn&#39;t disturb existing trap sans one</span>
<span class="cm">		 * exception.  If ptracer issued LISTEN for the current</span>
<span class="cm">		 * STOP, this INTERRUPT should clear LISTEN and re-trap</span>
<span class="cm">		 * tracee into STOP.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">task_set_jobctl_pending</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">JOBCTL_TRAP_STOP</span><span class="p">)))</span>
			<span class="n">signal_wake_up</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">jobctl</span> <span class="o">&amp;</span> <span class="n">JOBCTL_LISTENING</span><span class="p">);</span>

		<span class="n">unlock_task_sighand</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PTRACE_LISTEN</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Listen for events.  Tracee must be in STOP.  It&#39;s not</span>
<span class="cm">		 * resumed per-se but is not considered to be in TRACED by</span>
<span class="cm">		 * wait(2) or ptrace(2).  If an async event (e.g. group</span>
<span class="cm">		 * stop state change) happens, tracee will enter STOP trap</span>
<span class="cm">		 * again.  Alternatively, ptracer can issue INTERRUPT to</span>
<span class="cm">		 * finish listening and re-trap tracee into STOP.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">seized</span> <span class="o">||</span> <span class="o">!</span><span class="n">lock_task_sighand</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">si</span> <span class="o">=</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">last_siginfo</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">si</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">si_code</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">==</span> <span class="n">PTRACE_EVENT_STOP</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">child</span><span class="o">-&gt;</span><span class="n">jobctl</span> <span class="o">|=</span> <span class="n">JOBCTL_LISTENING</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * If NOTIFY is set, it means event happened between</span>
<span class="cm">			 * start of this trap and now.  Trigger re-trap.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">jobctl</span> <span class="o">&amp;</span> <span class="n">JOBCTL_TRAP_NOTIFY</span><span class="p">)</span>
				<span class="n">signal_wake_up</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">unlock_task_sighand</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PTRACE_DETACH</span>:	 <span class="cm">/* detach a process that was attached. */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ptrace_detach</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_BINFMT_ELF_FDPIC</span>
	<span class="k">case</span> <span class="n">PTRACE_GETFDPIC</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">get_task_mm</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">PTRACE_GETFDPIC_EXEC</span>:
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">exec_fdpic_loadmap</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">PTRACE_GETFDPIC_INTERP</span>:
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">interp_fdpic_loadmap</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mmput</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">datalp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef PTRACE_SINGLESTEP</span>
	<span class="k">case</span> <span class="n">PTRACE_SINGLESTEP</span>:
<span class="cp">#endif</span>
<span class="cp">#ifdef PTRACE_SINGLEBLOCK</span>
	<span class="k">case</span> <span class="n">PTRACE_SINGLEBLOCK</span>:
<span class="cp">#endif</span>
<span class="cp">#ifdef PTRACE_SYSEMU</span>
	<span class="k">case</span> <span class="n">PTRACE_SYSEMU</span>:
	<span class="k">case</span> <span class="n">PTRACE_SYSEMU_SINGLESTEP</span>:
<span class="cp">#endif</span>
	<span class="k">case</span> <span class="n">PTRACE_SYSCALL</span>:
	<span class="k">case</span> <span class="n">PTRACE_CONT</span>:
		<span class="k">return</span> <span class="n">ptrace_resume</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">PTRACE_KILL</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">exit_state</span><span class="p">)</span>	<span class="cm">/* already dead */</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ptrace_resume</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">SIGKILL</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_HAVE_ARCH_TRACEHOOK</span>
	<span class="k">case</span> <span class="n">PTRACE_GETREGSET</span>:
	<span class="k">case</span> <span class="n">PTRACE_SETREGSET</span>:
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">iovec</span> <span class="n">kiov</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">iovec</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uiov</span> <span class="o">=</span> <span class="n">datavp</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="n">uiov</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">uiov</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">__get_user</span><span class="p">(</span><span class="n">kiov</span><span class="p">.</span><span class="n">iov_base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uiov</span><span class="o">-&gt;</span><span class="n">iov_base</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">__get_user</span><span class="p">(</span><span class="n">kiov</span><span class="p">.</span><span class="n">iov_len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uiov</span><span class="o">-&gt;</span><span class="n">iov_len</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">ptrace_regset</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kiov</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">kiov</span><span class="p">.</span><span class="n">iov_len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uiov</span><span class="o">-&gt;</span><span class="n">iov_len</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">ptrace_get_task_struct</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">child</span> <span class="o">=</span> <span class="n">find_task_by_vpid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">child</span><span class="p">)</span>
		<span class="n">get_task_struct</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">child</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ESRCH</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">child</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifndef arch_ptrace_attach</span>
<span class="cp">#define arch_ptrace_attach(child)	do { } while (0)</span>
<span class="cp">#endif</span>

<span class="n">SYSCALL_DEFINE4</span><span class="p">(</span><span class="n">ptrace</span><span class="p">,</span> <span class="kt">long</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="kt">long</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">request</span> <span class="o">==</span> <span class="n">PTRACE_TRACEME</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ptrace_traceme</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">arch_ptrace_attach</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">child</span> <span class="o">=</span> <span class="n">ptrace_get_task_struct</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">child</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">request</span> <span class="o">==</span> <span class="n">PTRACE_ATTACH</span> <span class="o">||</span> <span class="n">request</span> <span class="o">==</span> <span class="n">PTRACE_SEIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ptrace_attach</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Some architectures need to do book-keeping after</span>
<span class="cm">		 * a ptrace attach.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">arch_ptrace_attach</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_put_task_struct</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ptrace_check_attach</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">request</span> <span class="o">==</span> <span class="n">PTRACE_KILL</span> <span class="o">||</span>
				  <span class="n">request</span> <span class="o">==</span> <span class="n">PTRACE_INTERRUPT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_put_task_struct</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">arch_ptrace</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

 <span class="nl">out_put_task_struct:</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">generic_ptrace_peekdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">copied</span><span class="p">;</span>

	<span class="n">copied</span> <span class="o">=</span> <span class="n">access_process_vm</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copied</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">generic_ptrace_pokedata</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">copied</span><span class="p">;</span>

	<span class="n">copied</span> <span class="o">=</span> <span class="n">access_process_vm</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">copied</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if defined CONFIG_COMPAT</span>
<span class="cp">#include &lt;linux/compat.h&gt;</span>

<span class="kt">int</span> <span class="n">compat_ptrace_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span> <span class="n">compat_long_t</span> <span class="n">request</span><span class="p">,</span>
			  <span class="n">compat_ulong_t</span> <span class="n">addr</span><span class="p">,</span> <span class="n">compat_ulong_t</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">compat_ulong_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">datap</span> <span class="o">=</span> <span class="n">compat_ptr</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="n">compat_ulong_t</span> <span class="n">word</span><span class="p">;</span>
	<span class="n">siginfo_t</span> <span class="n">siginfo</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">request</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PTRACE_PEEKTEXT</span>:
	<span class="k">case</span> <span class="n">PTRACE_PEEKDATA</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">access_process_vm</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">word</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">word</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">word</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">datap</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PTRACE_POKETEXT</span>:
	<span class="k">case</span> <span class="n">PTRACE_POKEDATA</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">access_process_vm</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="n">EIO</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PTRACE_GETEVENTMSG</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">((</span><span class="n">compat_ulong_t</span><span class="p">)</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">ptrace_message</span><span class="p">,</span> <span class="n">datap</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PTRACE_GETSIGINFO</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ptrace_getsiginfo</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">siginfo</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">copy_siginfo_to_user32</span><span class="p">(</span>
				<span class="p">(</span><span class="k">struct</span> <span class="n">compat_siginfo</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">datap</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">siginfo</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PTRACE_SETSIGINFO</span>:
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">siginfo</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">siginfo</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_siginfo_from_user32</span><span class="p">(</span>
			    <span class="o">&amp;</span><span class="n">siginfo</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">compat_siginfo</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">datap</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">ptrace_setsiginfo</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">siginfo</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_HAVE_ARCH_TRACEHOOK</span>
	<span class="k">case</span> <span class="n">PTRACE_GETREGSET</span>:
	<span class="k">case</span> <span class="n">PTRACE_SETREGSET</span>:
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">iovec</span> <span class="n">kiov</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">compat_iovec</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uiov</span> <span class="o">=</span>
			<span class="p">(</span><span class="k">struct</span> <span class="n">compat_iovec</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">datap</span><span class="p">;</span>
		<span class="n">compat_uptr_t</span> <span class="n">ptr</span><span class="p">;</span>
		<span class="n">compat_size_t</span> <span class="n">len</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="n">uiov</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">uiov</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">__get_user</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uiov</span><span class="o">-&gt;</span><span class="n">iov_base</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">__get_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uiov</span><span class="o">-&gt;</span><span class="n">iov_len</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="n">kiov</span><span class="p">.</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">compat_ptr</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
		<span class="n">kiov</span><span class="p">.</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">ptrace_regset</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kiov</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">kiov</span><span class="p">.</span><span class="n">iov_len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uiov</span><span class="o">-&gt;</span><span class="n">iov_len</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ptrace_request</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">asmlinkage</span> <span class="kt">long</span> <span class="n">compat_sys_ptrace</span><span class="p">(</span><span class="n">compat_long_t</span> <span class="n">request</span><span class="p">,</span> <span class="n">compat_long_t</span> <span class="n">pid</span><span class="p">,</span>
				  <span class="n">compat_long_t</span> <span class="n">addr</span><span class="p">,</span> <span class="n">compat_long_t</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">request</span> <span class="o">==</span> <span class="n">PTRACE_TRACEME</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ptrace_traceme</span><span class="p">();</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">child</span> <span class="o">=</span> <span class="n">ptrace_get_task_struct</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">child</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">request</span> <span class="o">==</span> <span class="n">PTRACE_ATTACH</span> <span class="o">||</span> <span class="n">request</span> <span class="o">==</span> <span class="n">PTRACE_SEIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ptrace_attach</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Some architectures need to do book-keeping after</span>
<span class="cm">		 * a ptrace attach.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">arch_ptrace_attach</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_put_task_struct</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ptrace_check_attach</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">request</span> <span class="o">==</span> <span class="n">PTRACE_KILL</span> <span class="o">||</span>
				  <span class="n">request</span> <span class="o">==</span> <span class="n">PTRACE_INTERRUPT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">compat_arch_ptrace</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

 <span class="nl">out_put_task_struct:</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_COMPAT */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_HAVE_HW_BREAKPOINT</span>
<span class="kt">int</span> <span class="n">ptrace_get_breakpoints</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">ptrace_bp_refcnt</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ptrace_put_breakpoints</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">ptrace_bp_refcnt</span><span class="p">))</span>
		<span class="n">flush_ptrace_hw_breakpoint</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HAVE_HW_BREAKPOINT */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
