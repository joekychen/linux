<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › srcu.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>srcu.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Sleepable Read-Copy Update mechanism for mutual exclusion.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) IBM Corporation, 2006</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Paul McKenney &lt;paulmck@us.ibm.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * For detailed explanation of Read-Copy Update mechanism see -</span>
<span class="cm"> * 		Documentation/RCU/ *.txt</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/preempt.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/srcu.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize an rcu_batch structure to empty.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rcu_batch_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_batch</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Enqueue a callback onto the tail of the specified rcu_batch structure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rcu_batch_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_batch</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Is the specified rcu_batch structure empty?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">rcu_batch_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_batch</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove the callback at the head of the specified rcu_batch structure</span>
<span class="cm"> * and return a pointer to it, or return NULL if the structure is empty.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="nf">rcu_batch_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_batch</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rcu_batch_empty</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">head</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
		<span class="n">rcu_batch_init</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Move all callbacks from the rcu_batch structure specified by &quot;from&quot; to</span>
<span class="cm"> * the structure specified by &quot;to&quot;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rcu_batch_move</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_batch</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rcu_batch</span> <span class="o">*</span><span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rcu_batch_empty</span><span class="p">(</span><span class="n">from</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
		<span class="n">to</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">;</span>
		<span class="n">rcu_batch_init</span><span class="p">(</span><span class="n">from</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* single-thread state-machine */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">process_srcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_srcu_struct_fields</span><span class="p">(</span><span class="k">struct</span> <span class="n">srcu_struct</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">completed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">rcu_batch_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">batch_queue</span><span class="p">);</span>
	<span class="n">rcu_batch_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">batch_check0</span><span class="p">);</span>
	<span class="n">rcu_batch_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">batch_check1</span><span class="p">);</span>
	<span class="n">rcu_batch_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">batch_done</span><span class="p">);</span>
	<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">process_srcu</span><span class="p">);</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">per_cpu_ref</span> <span class="o">=</span> <span class="n">alloc_percpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">srcu_struct_array</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">per_cpu_ref</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_DEBUG_LOCK_ALLOC</span>

<span class="kt">int</span> <span class="nf">__init_srcu_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">srcu_struct</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Don&#39;t re-initialize a lock while it is held. */</span>
	<span class="n">debug_check_no_locks_freed</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">sp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sp</span><span class="p">));</span>
	<span class="n">lockdep_init_map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">dep_map</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">init_srcu_struct_fields</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__init_srcu_struct</span><span class="p">);</span>

<span class="cp">#else </span><span class="cm">/* #ifdef CONFIG_DEBUG_LOCK_ALLOC */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * init_srcu_struct - initialize a sleep-RCU structure</span>
<span class="cm"> * @sp: structure to initialize.</span>
<span class="cm"> *</span>
<span class="cm"> * Must invoke this on a given srcu_struct before passing that srcu_struct</span>
<span class="cm"> * to any other function.  Each srcu_struct represents a separate domain</span>
<span class="cm"> * of SRCU protection.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">init_srcu_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">srcu_struct</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">init_srcu_struct_fields</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">init_srcu_struct</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* #else #ifdef CONFIG_DEBUG_LOCK_ALLOC */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Returns approximate total of the readers&#39; -&gt;seq[] values for the</span>
<span class="cm"> * rank of per-CPU counters specified by idx.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">srcu_readers_seq_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">srcu_struct</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">t</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">per_cpu_ref</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">[</span><span class="n">idx</span><span class="p">]);</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">t</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Returns approximate number of readers active on the specified rank</span>
<span class="cm"> * of the per-CPU -&gt;c[] counters.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">srcu_readers_active_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">srcu_struct</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">t</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">per_cpu_ref</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="n">idx</span><span class="p">]);</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">t</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return true if the number of pre-existing readers is determined to</span>
<span class="cm"> * be stably zero.  An example unstable zero can occur if the call</span>
<span class="cm"> * to srcu_readers_active_idx() misses an __srcu_read_lock() increment,</span>
<span class="cm"> * but due to task migration, sees the corresponding __srcu_read_unlock()</span>
<span class="cm"> * decrement.  This can happen because srcu_readers_active_idx() takes</span>
<span class="cm"> * time to sum the array, and might in fact be interrupted or preempted</span>
<span class="cm"> * partway through the summation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">srcu_readers_active_idx_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">srcu_struct</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">seq</span><span class="p">;</span>

	<span class="n">seq</span> <span class="o">=</span> <span class="n">srcu_readers_seq_idx</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The following smp_mb() A pairs with the smp_mb() B located in</span>
<span class="cm">	 * __srcu_read_lock().  This pairing ensures that if an</span>
<span class="cm">	 * __srcu_read_lock() increments its counter after the summation</span>
<span class="cm">	 * in srcu_readers_active_idx(), then the corresponding SRCU read-side</span>
<span class="cm">	 * critical section will see any changes made prior to the start</span>
<span class="cm">	 * of the current SRCU grace period.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Also, if the above call to srcu_readers_seq_idx() saw the</span>
<span class="cm">	 * increment of -&gt;seq[], then the call to srcu_readers_active_idx()</span>
<span class="cm">	 * must see the increment of -&gt;c[].</span>
<span class="cm">	 */</span>
	<span class="n">smp_mb</span><span class="p">();</span> <span class="cm">/* A */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note that srcu_readers_active_idx() can incorrectly return</span>
<span class="cm">	 * zero even though there is a pre-existing reader throughout.</span>
<span class="cm">	 * To see this, suppose that task A is in a very long SRCU</span>
<span class="cm">	 * read-side critical section that started on CPU 0, and that</span>
<span class="cm">	 * no other reader exists, so that the sum of the counters</span>
<span class="cm">	 * is equal to one.  Then suppose that task B starts executing</span>
<span class="cm">	 * srcu_readers_active_idx(), summing up to CPU 1, and then that</span>
<span class="cm">	 * task C starts reading on CPU 0, so that its increment is not</span>
<span class="cm">	 * summed, but finishes reading on CPU 2, so that its decrement</span>
<span class="cm">	 * -is- summed.  Then when task B completes its sum, it will</span>
<span class="cm">	 * incorrectly get zero, despite the fact that task A has been</span>
<span class="cm">	 * in its SRCU read-side critical section the whole time.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We therefore do a validation step should srcu_readers_active_idx()</span>
<span class="cm">	 * return zero.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">srcu_readers_active_idx</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The remainder of this function is the validation step.</span>
<span class="cm">	 * The following smp_mb() D pairs with the smp_mb() C in</span>
<span class="cm">	 * __srcu_read_unlock().  If the __srcu_read_unlock() was seen</span>
<span class="cm">	 * by srcu_readers_active_idx() above, then any destructive</span>
<span class="cm">	 * operation performed after the grace period will happen after</span>
<span class="cm">	 * the corresponding SRCU read-side critical section.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note that there can be at most NR_CPUS worth of readers using</span>
<span class="cm">	 * the old index, which is not enough to overflow even a 32-bit</span>
<span class="cm">	 * integer.  (Yes, this does mean that systems having more than</span>
<span class="cm">	 * a billion or so CPUs need to be 64-bit systems.)  Therefore,</span>
<span class="cm">	 * the sum of the -&gt;seq[] counters cannot possibly overflow.</span>
<span class="cm">	 * Therefore, the only way that the return values of the two</span>
<span class="cm">	 * calls to srcu_readers_seq_idx() can be equal is if there were</span>
<span class="cm">	 * no increments of the corresponding rank of -&gt;seq[] counts</span>
<span class="cm">	 * in the interim.  But the missed-increment scenario laid out</span>
<span class="cm">	 * above includes an increment of the -&gt;seq[] counter by</span>
<span class="cm">	 * the corresponding __srcu_read_lock().  Therefore, if this</span>
<span class="cm">	 * scenario occurs, the return values from the two calls to</span>
<span class="cm">	 * srcu_readers_seq_idx() will differ, and thus the validation</span>
<span class="cm">	 * step below suffices.</span>
<span class="cm">	 */</span>
	<span class="n">smp_mb</span><span class="p">();</span> <span class="cm">/* D */</span>

	<span class="k">return</span> <span class="n">srcu_readers_seq_idx</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="n">seq</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * srcu_readers_active - returns approximate number of readers.</span>
<span class="cm"> * @sp: which srcu_struct to count active readers (holding srcu_read_lock).</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this is not an atomic primitive, and can therefore suffer</span>
<span class="cm"> * severe errors when invoked on an active srcu_struct.  That said, it</span>
<span class="cm"> * can be useful as an error check at cleanup time.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">srcu_readers_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">srcu_struct</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">per_cpu_ref</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">per_cpu_ref</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cleanup_srcu_struct - deconstruct a sleep-RCU structure</span>
<span class="cm"> * @sp: structure to clean up.</span>
<span class="cm"> *</span>
<span class="cm"> * Must invoke this after you are finished using a given srcu_struct that</span>
<span class="cm"> * was initialized via init_srcu_struct(), else you leak memory.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">cleanup_srcu_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">srcu_struct</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">sum</span><span class="p">;</span>

	<span class="n">sum</span> <span class="o">=</span> <span class="n">srcu_readers_active</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">sum</span><span class="p">);</span>  <span class="cm">/* Leakage unless caller handles error. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">free_percpu</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">per_cpu_ref</span><span class="p">);</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">per_cpu_ref</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">cleanup_srcu_struct</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Counts the new reader in the appropriate per-CPU element of the</span>
<span class="cm"> * srcu_struct.  Must be called from process context.</span>
<span class="cm"> * Returns an index that must be passed to the matching srcu_read_unlock().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__srcu_read_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">srcu_struct</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>

	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">idx</span> <span class="o">=</span> <span class="n">rcu_dereference_index_check</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">completed</span><span class="p">,</span>
					  <span class="n">rcu_read_lock_sched_held</span><span class="p">())</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">;</span>
	<span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">this_cpu_ptr</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">per_cpu_ref</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">smp_mb</span><span class="p">();</span> <span class="cm">/* B */</span>  <span class="cm">/* Avoid leaking the critical section. */</span>
	<span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">this_cpu_ptr</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">per_cpu_ref</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">idx</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__srcu_read_lock</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Removes the count for the old reader from the appropriate per-CPU</span>
<span class="cm"> * element of the srcu_struct.  Note that this may well be a different</span>
<span class="cm"> * CPU than that which was incremented by the corresponding srcu_read_lock().</span>
<span class="cm"> * Must be called from process context.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__srcu_read_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">srcu_struct</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">smp_mb</span><span class="p">();</span> <span class="cm">/* C */</span>  <span class="cm">/* Avoid leaking the critical section. */</span>
	<span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">this_cpu_ptr</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">per_cpu_ref</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__srcu_read_unlock</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * We use an adaptive strategy for synchronize_srcu() and especially for</span>
<span class="cm"> * synchronize_srcu_expedited().  We spin for a fixed time period</span>
<span class="cm"> * (defined below) to allow SRCU readers to exit their read-side critical</span>
<span class="cm"> * sections.  If there are still some readers after 10 microseconds,</span>
<span class="cm"> * we repeatedly block for 1-millisecond time periods.  This approach</span>
<span class="cm"> * has done well in testing, so there is no need for a config parameter.</span>
<span class="cm"> */</span>
<span class="cp">#define SRCU_RETRY_CHECK_DELAY		5</span>
<span class="cp">#define SYNCHRONIZE_SRCU_TRYCOUNT	2</span>
<span class="cp">#define SYNCHRONIZE_SRCU_EXP_TRYCOUNT	12</span>

<span class="cm">/*</span>
<span class="cm"> * @@@ Wait until all pre-existing readers complete.  Such readers</span>
<span class="cm"> * will have used the index specified by &quot;idx&quot;.</span>
<span class="cm"> * the caller should ensures the -&gt;completed is not changed while checking</span>
<span class="cm"> * and idx = (-&gt;completed &amp; 1) ^ 1</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">try_check_zero</span><span class="p">(</span><span class="k">struct</span> <span class="n">srcu_struct</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">trycount</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">srcu_readers_active_idx_check</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">trycount</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">SRCU_RETRY_CHECK_DELAY</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Increment the -&gt;completed counter so that future SRCU readers will</span>
<span class="cm"> * use the other rank of the -&gt;c[] and -&gt;seq[] arrays.  This allows</span>
<span class="cm"> * us to wait for pre-existing readers in a starvation-free manner.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">srcu_flip</span><span class="p">(</span><span class="k">struct</span> <span class="n">srcu_struct</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">completed</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Enqueue an SRCU callback on the specified srcu_struct structure,</span>
<span class="cm"> * initiating grace-period processing if it is not already running.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">call_srcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">srcu_struct</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
		<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">head</span><span class="o">-&gt;</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">rcu_batch_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">batch_queue</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">running</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">system_nrt_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">call_srcu</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">rcu_synchronize</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">completion</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Awaken the corresponding synchronize_srcu() instance now that a</span>
<span class="cm"> * grace period has elapsed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wakeme_after_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rcu_synchronize</span> <span class="o">*</span><span class="n">rcu</span><span class="p">;</span>

	<span class="n">rcu</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rcu_synchronize</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu</span><span class="o">-&gt;</span><span class="n">completion</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">srcu_advance_batches</span><span class="p">(</span><span class="k">struct</span> <span class="n">srcu_struct</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">trycount</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">srcu_reschedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">srcu_struct</span> <span class="o">*</span><span class="n">sp</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Helper function for synchronize_srcu() and synchronize_srcu_expedited().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__synchronize_srcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">srcu_struct</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">trycount</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rcu_synchronize</span> <span class="n">rcu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rcu</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">done</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">rcu_lockdep_assert</span><span class="p">(</span><span class="o">!</span><span class="n">lock_is_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">dep_map</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			   <span class="o">!</span><span class="n">lock_is_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu_bh_lock_map</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			   <span class="o">!</span><span class="n">lock_is_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu_lock_map</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			   <span class="o">!</span><span class="n">lock_is_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu_sched_lock_map</span><span class="p">),</span>
			   <span class="s">&quot;Illegal synchronize_srcu() in same-type SRCU (or RCU) read-side critical section&quot;</span><span class="p">);</span>

	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu</span><span class="p">.</span><span class="n">completion</span><span class="p">);</span>

	<span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">head</span><span class="o">-&gt;</span><span class="n">func</span> <span class="o">=</span> <span class="n">wakeme_after_rcu</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">running</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* steal the processing owner */</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">rcu_batch_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">batch_check0</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>

		<span class="n">srcu_advance_batches</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">trycount</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rcu_batch_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">batch_done</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">batch_done</span><span class="p">.</span><span class="n">head</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>
			<span class="n">rcu_batch_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">batch_done</span><span class="p">);</span>
			<span class="n">done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* give the processing owner to work_struct */</span>
		<span class="n">srcu_reschedule</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rcu_batch_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">batch_queue</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">)</span>
		<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu</span><span class="p">.</span><span class="n">completion</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * synchronize_srcu - wait for prior SRCU read-side critical-section completion</span>
<span class="cm"> * @sp: srcu_struct with which to synchronize.</span>
<span class="cm"> *</span>
<span class="cm"> * Flip the completed counter, and wait for the old count to drain to zero.</span>
<span class="cm"> * As with classic RCU, the updater must use some separate means of</span>
<span class="cm"> * synchronizing concurrent updates.  Can block; must be called from</span>
<span class="cm"> * process context.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that it is illegal to call synchronize_srcu() from the corresponding</span>
<span class="cm"> * SRCU read-side critical section; doing so will result in deadlock.</span>
<span class="cm"> * However, it is perfectly legal to call synchronize_srcu() on one</span>
<span class="cm"> * srcu_struct from some other srcu_struct&#39;s read-side critical section.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">synchronize_srcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">srcu_struct</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__synchronize_srcu</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">SYNCHRONIZE_SRCU_TRYCOUNT</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">synchronize_srcu</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * synchronize_srcu_expedited - Brute-force SRCU grace period</span>
<span class="cm"> * @sp: srcu_struct with which to synchronize.</span>
<span class="cm"> *</span>
<span class="cm"> * Wait for an SRCU grace period to elapse, but be more aggressive about</span>
<span class="cm"> * spinning rather than blocking when waiting.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that it is illegal to call this function while holding any lock</span>
<span class="cm"> * that is acquired by a CPU-hotplug notifier.  It is also illegal to call</span>
<span class="cm"> * synchronize_srcu_expedited() from the corresponding SRCU read-side</span>
<span class="cm"> * critical section; doing so will result in deadlock.  However, it is</span>
<span class="cm"> * perfectly legal to call synchronize_srcu_expedited() on one srcu_struct</span>
<span class="cm"> * from some other srcu_struct&#39;s read-side critical section, as long as</span>
<span class="cm"> * the resulting graph of srcu_structs is acyclic.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">synchronize_srcu_expedited</span><span class="p">(</span><span class="k">struct</span> <span class="n">srcu_struct</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__synchronize_srcu</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">SYNCHRONIZE_SRCU_EXP_TRYCOUNT</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">synchronize_srcu_expedited</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * srcu_barrier - Wait until all in-flight call_srcu() callbacks complete.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">srcu_barrier</span><span class="p">(</span><span class="k">struct</span> <span class="n">srcu_struct</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">synchronize_srcu</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">srcu_barrier</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * srcu_batches_completed - return batches completed.</span>
<span class="cm"> * @sp: srcu_struct on which to report batch completion.</span>
<span class="cm"> *</span>
<span class="cm"> * Report the number of batches, correlated with, but not necessarily</span>
<span class="cm"> * precisely the same as, the number of grace periods that have elapsed.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="nf">srcu_batches_completed</span><span class="p">(</span><span class="k">struct</span> <span class="n">srcu_struct</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">completed</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">srcu_batches_completed</span><span class="p">);</span>

<span class="cp">#define SRCU_CALLBACK_BATCH	10</span>
<span class="cp">#define SRCU_INTERVAL		1</span>

<span class="cm">/*</span>
<span class="cm"> * Move any new SRCU callbacks to the first stage of the SRCU grace</span>
<span class="cm"> * period pipeline.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">srcu_collect_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">srcu_struct</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rcu_batch_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">batch_queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
		<span class="n">rcu_batch_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">batch_check0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">batch_queue</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Core SRCU state machine.  Advance callbacks from -&gt;batch_check0 to</span>
<span class="cm"> * -&gt;batch_check1 and then to -&gt;batch_done as readers drain.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">srcu_advance_batches</span><span class="p">(</span><span class="k">struct</span> <span class="n">srcu_struct</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">trycount</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">^</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">completed</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Because readers might be delayed for an extended period after</span>
<span class="cm">	 * fetching -&gt;completed for their index, at any point in time there</span>
<span class="cm">	 * might well be readers using both idx=0 and idx=1.  We therefore</span>
<span class="cm">	 * need to wait for readers to clear from both index values before</span>
<span class="cm">	 * invoking a callback.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rcu_batch_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">batch_check0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">rcu_batch_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">batch_check1</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span> <span class="cm">/* no callbacks need to be advanced */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">try_check_zero</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">trycount</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span> <span class="cm">/* failed to advance, will try after SRCU_INTERVAL */</span>

	<span class="cm">/*</span>
<span class="cm">	 * The callbacks in -&gt;batch_check1 have already done with their</span>
<span class="cm">	 * first zero check and flip back when they were enqueued on</span>
<span class="cm">	 * -&gt;batch_check0 in a previous invocation of srcu_advance_batches().</span>
<span class="cm">	 * (Presumably try_check_zero() returned false during that</span>
<span class="cm">	 * invocation, leaving the callbacks stranded on -&gt;batch_check1.)</span>
<span class="cm">	 * They are therefore ready to invoke, so move them to -&gt;batch_done.</span>
<span class="cm">	 */</span>
	<span class="n">rcu_batch_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">batch_done</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">batch_check1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rcu_batch_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">batch_check0</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span> <span class="cm">/* no callbacks need to be advanced */</span>
	<span class="n">srcu_flip</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The callbacks in -&gt;batch_check0 just finished their</span>
<span class="cm">	 * first check zero and flip, so move them to -&gt;batch_check1</span>
<span class="cm">	 * for future checking on the other idx.</span>
<span class="cm">	 */</span>
	<span class="n">rcu_batch_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">batch_check1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">batch_check0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * SRCU read-side critical sections are normally short, so check</span>
<span class="cm">	 * at least twice in quick succession after a flip.</span>
<span class="cm">	 */</span>
	<span class="n">trycount</span> <span class="o">=</span> <span class="n">trycount</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="n">trycount</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">try_check_zero</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">idx</span><span class="o">^</span><span class="mi">1</span><span class="p">,</span> <span class="n">trycount</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span> <span class="cm">/* failed to advance, will try after SRCU_INTERVAL */</span>

	<span class="cm">/*</span>
<span class="cm">	 * The callbacks in -&gt;batch_check1 have now waited for all</span>
<span class="cm">	 * pre-existing readers using both idx values.  They are therefore</span>
<span class="cm">	 * ready to invoke, so move them to -&gt;batch_done.</span>
<span class="cm">	 */</span>
	<span class="n">rcu_batch_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">batch_done</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">batch_check1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Invoke a limited number of SRCU callbacks that have passed through</span>
<span class="cm"> * their grace period.  If there are more to do, SRCU will reschedule</span>
<span class="cm"> * the workqueue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">srcu_invoke_callbacks</span><span class="p">(</span><span class="k">struct</span> <span class="n">srcu_struct</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SRCU_CALLBACK_BATCH</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">head</span> <span class="o">=</span> <span class="n">rcu_batch_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">batch_done</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">head</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">local_bh_disable</span><span class="p">();</span>
		<span class="n">head</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
		<span class="n">local_bh_enable</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Finished one round of SRCU grace period.  Start another if there are</span>
<span class="cm"> * more SRCU callbacks queued, otherwise put SRCU into not-running state.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">srcu_reschedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">srcu_struct</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">pending</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rcu_batch_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">batch_done</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">rcu_batch_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">batch_check1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">rcu_batch_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">batch_check0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">rcu_batch_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">batch_queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rcu_batch_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">batch_done</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">rcu_batch_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">batch_check1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">rcu_batch_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">batch_check0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">rcu_batch_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">batch_queue</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sp</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="n">pending</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pending</span><span class="p">)</span>
		<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">system_nrt_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">SRCU_INTERVAL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is the work-queue function that handles SRCU grace periods.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">process_srcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">srcu_struct</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>

	<span class="n">sp</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">srcu_struct</span><span class="p">,</span> <span class="n">work</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>

	<span class="n">srcu_collect_new</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
	<span class="n">srcu_advance_batches</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">srcu_invoke_callbacks</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
	<span class="n">srcu_reschedule</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
