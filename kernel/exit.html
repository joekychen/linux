<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › exit.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>exit.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/kernel/exit.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1991, 1992  Linus Torvalds</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/personality.h&gt;</span>
<span class="cp">#include &lt;linux/tty.h&gt;</span>
<span class="cp">#include &lt;linux/iocontext.h&gt;</span>
<span class="cp">#include &lt;linux/key.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/acct.h&gt;</span>
<span class="cp">#include &lt;linux/tsacct_kern.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/fdtable.h&gt;</span>
<span class="cp">#include &lt;linux/binfmts.h&gt;</span>
<span class="cp">#include &lt;linux/nsproxy.h&gt;</span>
<span class="cp">#include &lt;linux/pid_namespace.h&gt;</span>
<span class="cp">#include &lt;linux/ptrace.h&gt;</span>
<span class="cp">#include &lt;linux/profile.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/mempolicy.h&gt;</span>
<span class="cp">#include &lt;linux/taskstats_kern.h&gt;</span>
<span class="cp">#include &lt;linux/delayacct.h&gt;</span>
<span class="cp">#include &lt;linux/freezer.h&gt;</span>
<span class="cp">#include &lt;linux/cgroup.h&gt;</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/signal.h&gt;</span>
<span class="cp">#include &lt;linux/posix-timers.h&gt;</span>
<span class="cp">#include &lt;linux/cn_proc.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/futex.h&gt;</span>
<span class="cp">#include &lt;linux/pipe_fs_i.h&gt;</span>
<span class="cp">#include &lt;linux/audit.h&gt; </span><span class="cm">/* for audit_free() */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/resource.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/task_io_accounting_ops.h&gt;</span>
<span class="cp">#include &lt;linux/tracehook.h&gt;</span>
<span class="cp">#include &lt;linux/fs_struct.h&gt;</span>
<span class="cp">#include &lt;linux/init_task.h&gt;</span>
<span class="cp">#include &lt;linux/perf_event.h&gt;</span>
<span class="cp">#include &lt;trace/events/sched.h&gt;</span>
<span class="cp">#include &lt;linux/hw_breakpoint.h&gt;</span>
<span class="cp">#include &lt;linux/oom.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>
<span class="cp">#include &lt;linux/shm.h&gt;</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/unistd.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;asm/mmu_context.h&gt;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">exit_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span> <span class="n">tsk</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__unhash_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">bool</span> <span class="n">group_dead</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nr_threads</span><span class="o">--</span><span class="p">;</span>
	<span class="n">detach_pid</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">PIDTYPE_PID</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">group_dead</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">detach_pid</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">PIDTYPE_PGID</span><span class="p">);</span>
		<span class="n">detach_pid</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">PIDTYPE_SID</span><span class="p">);</span>

		<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">tasks</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sibling</span><span class="p">);</span>
		<span class="n">__this_cpu_dec</span><span class="p">(</span><span class="n">process_counts</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we are the last child process in a pid namespace to be</span>
<span class="cm">		 * reaped, notify the reaper sleeping zap_pid_ns_processes().</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_PID_NS</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">real_parent</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">task_active_pid_ns</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">child_reaper</span> <span class="o">==</span> <span class="n">parent</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_EXITING</span><span class="p">))</span>
				<span class="n">wake_up_process</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">thread_group</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function expects the tasklist_lock write-locked.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__exit_signal</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">signal_struct</span> <span class="o">*</span><span class="n">sig</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">group_dead</span> <span class="o">=</span> <span class="n">thread_group_leader</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sighand_struct</span> <span class="o">*</span><span class="n">sighand</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">uninitialized_var</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>

	<span class="n">sighand</span> <span class="o">=</span> <span class="n">rcu_dereference_check</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="p">,</span>
					<span class="n">lockdep_tasklist_lock_is_held</span><span class="p">());</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>

	<span class="n">posix_cpu_timers_exit</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">group_dead</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">posix_cpu_timers_exit_group</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
		<span class="n">tty</span> <span class="o">=</span> <span class="n">sig</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">;</span>
		<span class="n">sig</span><span class="o">-&gt;</span><span class="n">tty</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This can only happen if the caller is de_thread().</span>
<span class="cm">		 * FIXME: this is the temporary hack, we should teach</span>
<span class="cm">		 * posix-cpu-timers to handle this case correctly.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">has_group_leader_pid</span><span class="p">(</span><span class="n">tsk</span><span class="p">)))</span>
			<span class="n">posix_cpu_timers_exit_group</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If there is any task waiting for the group exit</span>
<span class="cm">		 * then notify it:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">notify_count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!--</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">notify_count</span><span class="p">)</span>
			<span class="n">wake_up_process</span><span class="p">(</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">group_exit_task</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span> <span class="o">==</span> <span class="n">sig</span><span class="o">-&gt;</span><span class="n">curr_target</span><span class="p">)</span>
			<span class="n">sig</span><span class="o">-&gt;</span><span class="n">curr_target</span> <span class="o">=</span> <span class="n">next_thread</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Accumulate here the counters for all threads but the</span>
<span class="cm">		 * group leader as they die, so they can be added into</span>
<span class="cm">		 * the process-wide totals when those are taken.</span>
<span class="cm">		 * The group leader stays around as a zombie as long</span>
<span class="cm">		 * as there are other threads.  When it gets reaped,</span>
<span class="cm">		 * the exit.c code will add its counts into these totals.</span>
<span class="cm">		 * We won&#39;t ever get here for the group leader, since it</span>
<span class="cm">		 * will have been the last reference on the signal_struct.</span>
<span class="cm">		 */</span>
		<span class="n">sig</span><span class="o">-&gt;</span><span class="n">utime</span> <span class="o">+=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">utime</span><span class="p">;</span>
		<span class="n">sig</span><span class="o">-&gt;</span><span class="n">stime</span> <span class="o">+=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">stime</span><span class="p">;</span>
		<span class="n">sig</span><span class="o">-&gt;</span><span class="n">gtime</span> <span class="o">+=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">gtime</span><span class="p">;</span>
		<span class="n">sig</span><span class="o">-&gt;</span><span class="n">min_flt</span> <span class="o">+=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">min_flt</span><span class="p">;</span>
		<span class="n">sig</span><span class="o">-&gt;</span><span class="n">maj_flt</span> <span class="o">+=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">maj_flt</span><span class="p">;</span>
		<span class="n">sig</span><span class="o">-&gt;</span><span class="n">nvcsw</span> <span class="o">+=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">nvcsw</span><span class="p">;</span>
		<span class="n">sig</span><span class="o">-&gt;</span><span class="n">nivcsw</span> <span class="o">+=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">nivcsw</span><span class="p">;</span>
		<span class="n">sig</span><span class="o">-&gt;</span><span class="n">inblock</span> <span class="o">+=</span> <span class="n">task_io_get_inblock</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
		<span class="n">sig</span><span class="o">-&gt;</span><span class="n">oublock</span> <span class="o">+=</span> <span class="n">task_io_get_oublock</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
		<span class="n">task_io_accounting_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">ioac</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">ioac</span><span class="p">);</span>
		<span class="n">sig</span><span class="o">-&gt;</span><span class="n">sum_sched_runtime</span> <span class="o">+=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">sum_exec_runtime</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sig</span><span class="o">-&gt;</span><span class="n">nr_threads</span><span class="o">--</span><span class="p">;</span>
	<span class="n">__unhash_process</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">group_dead</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do this under -&gt;siglock, we can race with another thread</span>
<span class="cm">	 * doing sigqueue_free() if we have SIGQUEUE_PREALLOC signals.</span>
<span class="cm">	 */</span>
	<span class="n">flush_sigqueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">);</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sighand</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>

	<span class="n">__cleanup_sighand</span><span class="p">(</span><span class="n">sighand</span><span class="p">);</span>
	<span class="n">clear_tsk_thread_flag</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span><span class="n">TIF_SIGPENDING</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">group_dead</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flush_sigqueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">shared_pending</span><span class="p">);</span>
		<span class="n">tty_kref_put</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">delayed_put_task_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">rhp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">rhp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span><span class="p">,</span> <span class="n">rcu</span><span class="p">);</span>

	<span class="n">perf_event_delayed_put</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">trace_sched_process_free</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">release_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">leader</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">zap_leader</span><span class="p">;</span>
<span class="nl">repeat:</span>
	<span class="cm">/* don&#39;t need to get the RCU readlock here - the process is dead and</span>
<span class="cm">	 * can&#39;t be modifying its own credentials. But shut RCU-lockdep up */</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">__task_cred</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">processes</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="n">proc_flush_task</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="n">write_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="n">ptrace_release_task</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">__exit_signal</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we are the last non-leader member of the thread</span>
<span class="cm">	 * group, and the leader is zombie, then notify the</span>
<span class="cm">	 * group leader&#39;s parent process. (if it wants notification.)</span>
<span class="cm">	 */</span>
	<span class="n">zap_leader</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">leader</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">leader</span> <span class="o">!=</span> <span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">thread_group_empty</span><span class="p">(</span><span class="n">leader</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">leader</span><span class="o">-&gt;</span><span class="n">exit_state</span> <span class="o">==</span> <span class="n">EXIT_ZOMBIE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we were the last child thread and the leader has</span>
<span class="cm">		 * exited already, and the leader&#39;s parent ignores SIGCHLD,</span>
<span class="cm">		 * then we are the one who should release the leader.</span>
<span class="cm">		 */</span>
		<span class="n">zap_leader</span> <span class="o">=</span> <span class="n">do_notify_parent</span><span class="p">(</span><span class="n">leader</span><span class="p">,</span> <span class="n">leader</span><span class="o">-&gt;</span><span class="n">exit_signal</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">zap_leader</span><span class="p">)</span>
			<span class="n">leader</span><span class="o">-&gt;</span><span class="n">exit_state</span> <span class="o">=</span> <span class="n">EXIT_DEAD</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">write_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="n">release_thread</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rcu</span><span class="p">,</span> <span class="n">delayed_put_task_struct</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">leader</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">zap_leader</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This checks not only the pgrp, but falls back on the pid if no</span>
<span class="cm"> * satisfactory pgrp is found. I dunno - gdb doesn&#39;t work correctly</span>
<span class="cm"> * without this...</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must hold rcu lock or the tasklist lock.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="nf">session_of_pgrp</span><span class="p">(</span><span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pgrp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">sid</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">pid_task</span><span class="p">(</span><span class="n">pgrp</span><span class="p">,</span> <span class="n">PIDTYPE_PGID</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">pid_task</span><span class="p">(</span><span class="n">pgrp</span><span class="p">,</span> <span class="n">PIDTYPE_PID</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">sid</span> <span class="o">=</span> <span class="n">task_session</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sid</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Determine if a process group is &quot;orphaned&quot;, according to the POSIX</span>
<span class="cm"> * definition in 2.2.2.52.  Orphaned process groups are not to be affected</span>
<span class="cm"> * by terminal-generated stop signals.  Newly orphaned process groups are</span>
<span class="cm"> * to receive a SIGHUP and a SIGCONT.</span>
<span class="cm"> *</span>
<span class="cm"> * &quot;I ask you, have you ever known what it is to be an orphan?&quot;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">will_become_orphaned_pgrp</span><span class="p">(</span><span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">ignored_task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">do_each_pid_task</span><span class="p">(</span><span class="n">pgrp</span><span class="p">,</span> <span class="n">PIDTYPE_PGID</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">p</span> <span class="o">==</span> <span class="n">ignored_task</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">exit_state</span> <span class="o">&amp;&amp;</span> <span class="n">thread_group_empty</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">||</span>
		    <span class="n">is_global_init</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">real_parent</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">task_pgrp</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">real_parent</span><span class="p">)</span> <span class="o">!=</span> <span class="n">pgrp</span> <span class="o">&amp;&amp;</span>
		    <span class="n">task_session</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">real_parent</span><span class="p">)</span> <span class="o">==</span> <span class="n">task_session</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">while_each_pid_task</span><span class="p">(</span><span class="n">pgrp</span><span class="p">,</span> <span class="n">PIDTYPE_PGID</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">is_current_pgrp_orphaned</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">will_become_orphaned_pgrp</span><span class="p">(</span><span class="n">task_pgrp</span><span class="p">(</span><span class="n">current</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">has_stopped_jobs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pgrp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">do_each_pid_task</span><span class="p">(</span><span class="n">pgrp</span><span class="p">,</span> <span class="n">PIDTYPE_PGID</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SIGNAL_STOP_STOPPED</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">while_each_pid_task</span><span class="p">(</span><span class="n">pgrp</span><span class="p">,</span> <span class="n">PIDTYPE_PGID</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check to see if any process groups have become orphaned as</span>
<span class="cm"> * a result of our exiting, and if they have any stopped jobs,</span>
<span class="cm"> * send them a SIGHUP and then a SIGCONT. (POSIX 3.2.2.2)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">kill_orphaned_pgrp</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pgrp</span> <span class="o">=</span> <span class="n">task_pgrp</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">ignored_task</span> <span class="o">=</span> <span class="n">tsk</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent</span><span class="p">)</span>
		 <span class="cm">/* exit: our father is in a different pgrp than</span>
<span class="cm">		  * we are and we were the only connection outside.</span>
<span class="cm">		  */</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">real_parent</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="cm">/* reparent: our child is in a different pgrp than</span>
<span class="cm">		 * we are, and it was the only connection outside.</span>
<span class="cm">		 */</span>
		<span class="n">ignored_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task_pgrp</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="o">!=</span> <span class="n">pgrp</span> <span class="o">&amp;&amp;</span>
	    <span class="n">task_session</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="o">==</span> <span class="n">task_session</span><span class="p">(</span><span class="n">tsk</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">will_become_orphaned_pgrp</span><span class="p">(</span><span class="n">pgrp</span><span class="p">,</span> <span class="n">ignored_task</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">has_stopped_jobs</span><span class="p">(</span><span class="n">pgrp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__kill_pgrp_info</span><span class="p">(</span><span class="n">SIGHUP</span><span class="p">,</span> <span class="n">SEND_SIG_PRIV</span><span class="p">,</span> <span class="n">pgrp</span><span class="p">);</span>
		<span class="n">__kill_pgrp_info</span><span class="p">(</span><span class="n">SIGCONT</span><span class="p">,</span> <span class="n">SEND_SIG_PRIV</span><span class="p">,</span> <span class="n">pgrp</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * reparent_to_kthreadd - Reparent the calling kernel thread to kthreadd</span>
<span class="cm"> *</span>
<span class="cm"> * If a kernel thread is launched as a result of a system call, or if</span>
<span class="cm"> * it ever exits, it should generally reparent itself to kthreadd so it</span>
<span class="cm"> * isn&#39;t in the way of other processes and is correctly cleaned up on exit.</span>
<span class="cm"> *</span>
<span class="cm"> * The various task state such as scheduling policy and priority may have</span>
<span class="cm"> * been inherited from a user process, so we reset them to sane values here.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE that reparent_to_kthreadd() gives the caller full capabilities.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">reparent_to_kthreadd</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">write_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>

	<span class="n">ptrace_unlink</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="cm">/* Reparent to init */</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">real_parent</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">kthreadd_task</span><span class="p">;</span>
	<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sibling</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">real_parent</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">);</span>

	<span class="cm">/* Set the exit signal to SIGCHLD so we signal init on exit */</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">exit_signal</span> <span class="o">=</span> <span class="n">SIGCHLD</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task_nice</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">set_user_nice</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/* cpus_allowed? */</span>
	<span class="cm">/* rt_priority? */</span>
	<span class="cm">/* signals? */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">rlim</span><span class="p">,</span> <span class="n">init_task</span><span class="p">.</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">rlim</span><span class="p">,</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">rlim</span><span class="p">));</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_cred</span><span class="p">.</span><span class="n">usage</span><span class="p">);</span>
	<span class="n">commit_creds</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_cred</span><span class="p">);</span>
	<span class="n">write_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__set_special_pids</span><span class="p">(</span><span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task_session</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span> <span class="o">!=</span> <span class="n">pid</span><span class="p">)</span>
		<span class="n">change_pid</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">PIDTYPE_SID</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task_pgrp</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span> <span class="o">!=</span> <span class="n">pid</span><span class="p">)</span>
		<span class="n">change_pid</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">PIDTYPE_PGID</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_special_pids</span><span class="p">(</span><span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">write_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="n">__set_special_pids</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
	<span class="n">write_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Let kernel threads use this to say that they allow a certain signal.</span>
<span class="cm"> * Must not be used if kthread was cloned with CLONE_SIGHAND.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">allow_signal</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">valid_signal</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="o">||</span> <span class="n">sig</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="cm">/* This is only needed for daemonize()&#39;ed kthreads */</span>
	<span class="n">sigdelset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">,</span> <span class="n">sig</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Kernel threads handle their own signals. Let the signal code</span>
<span class="cm">	 * know it&#39;ll be handled, so that they don&#39;t get converted to</span>
<span class="cm">	 * SIGKILL or just silently dropped.</span>
<span class="cm">	 */</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">[(</span><span class="n">sig</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="mi">2</span><span class="p">;</span>
	<span class="n">recalc_sigpending</span><span class="p">();</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">allow_signal</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">disallow_signal</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">valid_signal</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="o">||</span> <span class="n">sig</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">[(</span><span class="n">sig</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">=</span> <span class="n">SIG_IGN</span><span class="p">;</span>
	<span class="n">recalc_sigpending</span><span class="p">();</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">disallow_signal</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	Put all the gunge required to become a kernel thread without</span>
<span class="cm"> *	attached user resources in one place where it belongs.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">daemonize</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
	<span class="n">sigset_t</span> <span class="n">blocked</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="n">vsnprintf</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">),</span> <span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we were started as result of loading a module, close all of the</span>
<span class="cm">	 * user space pages.  We don&#39;t need them, and if we didn&#39;t close them</span>
<span class="cm">	 * they would be locked into memory.</span>
<span class="cm">	 */</span>
	<span class="n">exit_mm</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * We don&#39;t want to get frozen, in case system-wide hibernation</span>
<span class="cm">	 * or suspend transition begins right now.</span>
<span class="cm">	 */</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">PF_NOFREEZE</span> <span class="o">|</span> <span class="n">PF_KTHREAD</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">nsproxy</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">init_nsproxy</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">get_nsproxy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_nsproxy</span><span class="p">);</span>
		<span class="n">switch_task_namespaces</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">init_nsproxy</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">set_special_pids</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_struct_pid</span><span class="p">);</span>
	<span class="n">proc_clear_tty</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>

	<span class="cm">/* Block and flush all signals */</span>
	<span class="n">sigfillset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blocked</span><span class="p">);</span>
	<span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_BLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blocked</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">flush_signals</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>

	<span class="cm">/* Become as one with the init task */</span>

	<span class="n">daemonize_fs_struct</span><span class="p">();</span>
	<span class="n">exit_files</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">files</span> <span class="o">=</span> <span class="n">init_task</span><span class="p">.</span><span class="n">files</span><span class="p">;</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">files</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>

	<span class="n">reparent_to_kthreadd</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">daemonize</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">close_files</span><span class="p">(</span><span class="k">struct</span> <span class="n">files_struct</span> <span class="o">*</span> <span class="n">files</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fdtable</span> <span class="o">*</span><span class="n">fdt</span><span class="p">;</span>

	<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * It is safe to dereference the fd table without RCU or</span>
<span class="cm">	 * -&gt;file_lock because this is the last reference to the</span>
<span class="cm">	 * files structure.  But use RCU to shut RCU-lockdep up.</span>
<span class="cm">	 */</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">fdt</span> <span class="o">=</span> <span class="n">files_fdtable</span><span class="p">(</span><span class="n">files</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">set</span><span class="p">;</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">*</span> <span class="n">__NFDBITS</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">fdt</span><span class="o">-&gt;</span><span class="n">max_fds</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">set</span> <span class="o">=</span> <span class="n">fdt</span><span class="o">-&gt;</span><span class="n">open_fds</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">set</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">set</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">file</span> <span class="o">=</span> <span class="n">xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fdt</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">filp_close</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">files</span><span class="p">);</span>
					<span class="n">cond_resched</span><span class="p">();</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="n">set</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">files_struct</span> <span class="o">*</span><span class="nf">get_files_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">files_struct</span> <span class="o">*</span><span class="n">files</span><span class="p">;</span>

	<span class="n">task_lock</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">files</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">files</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">files</span><span class="p">)</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">files</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
	<span class="n">task_unlock</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">files</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">put_files_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">files_struct</span> <span class="o">*</span><span class="n">files</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fdtable</span> <span class="o">*</span><span class="n">fdt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">files</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">close_files</span><span class="p">(</span><span class="n">files</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Free the fd and fdset arrays if we expanded them.</span>
<span class="cm">		 * If the fdtable was embedded, pass files for freeing</span>
<span class="cm">		 * at the end of the RCU grace period. Otherwise,</span>
<span class="cm">		 * you can free files immediately.</span>
<span class="cm">		 */</span>
		<span class="n">rcu_read_lock</span><span class="p">();</span>
		<span class="n">fdt</span> <span class="o">=</span> <span class="n">files_fdtable</span><span class="p">(</span><span class="n">files</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fdt</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">files</span><span class="o">-&gt;</span><span class="n">fdtab</span><span class="p">)</span>
			<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">files_cachep</span><span class="p">,</span> <span class="n">files</span><span class="p">);</span>
		<span class="n">free_fdtable</span><span class="p">(</span><span class="n">fdt</span><span class="p">);</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">reset_files_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">files_struct</span> <span class="o">*</span><span class="n">files</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">files_struct</span> <span class="o">*</span><span class="n">old</span><span class="p">;</span>

	<span class="n">old</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">files</span><span class="p">;</span>
	<span class="n">task_lock</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">files</span> <span class="o">=</span> <span class="n">files</span><span class="p">;</span>
	<span class="n">task_unlock</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">put_files_struct</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">exit_files</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">files_struct</span> <span class="o">*</span> <span class="n">files</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">files</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">files</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">task_lock</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
		<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">files</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">task_unlock</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
		<span class="n">put_files_struct</span><span class="p">(</span><span class="n">files</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_MM_OWNER</span>
<span class="cm">/*</span>
<span class="cm"> * A task is exiting.   If it owned this mm, find a new owner for the mm.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">mm_update_next_owner</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="o">*</span><span class="n">g</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

<span class="nl">retry:</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the exiting or execing task is not the owner, it&#39;s</span>
<span class="cm">	 * someone else&#39;s problem.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">!=</span> <span class="n">p</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * The current owner is exiting/execing and there are no other</span>
<span class="cm">	 * candidates.  Do not leave the mm pointing to a possibly</span>
<span class="cm">	 * freed task structure.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_users</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mm</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Search in the children</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">,</span> <span class="n">sibling</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">==</span> <span class="n">mm</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">assign_new_owner</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Search in the siblings</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">real_parent</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">,</span> <span class="n">sibling</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">==</span> <span class="n">mm</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">assign_new_owner</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Search through everything else. We should not get</span>
<span class="cm">	 * here often</span>
<span class="cm">	 */</span>
	<span class="n">do_each_thread</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">==</span> <span class="n">mm</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">assign_new_owner</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">while_each_thread</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>

	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * We found no owner yet mm_users &gt; 1: this implies that we are</span>
<span class="cm">	 * most likely racing with swapoff (try_to_unuse()) or /proc or</span>
<span class="cm">	 * ptrace or page migration (get_task_mm()).  Mark owner as NULL.</span>
<span class="cm">	 */</span>
	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">assign_new_owner:</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">get_task_struct</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * The task_lock protects c-&gt;mm from changing.</span>
<span class="cm">	 * We always want mm-&gt;owner-&gt;mm == mm</span>
<span class="cm">	 */</span>
	<span class="n">task_lock</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Delay read_unlock() till we have the task_lock()</span>
<span class="cm">	 * to ensure that c does not slip away underneath us</span>
<span class="cm">	 */</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">!=</span> <span class="n">mm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">task_unlock</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="n">put_task_struct</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
	<span class="n">task_unlock</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MM_OWNER */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Turn us into a lazy TLB process if we</span>
<span class="cm"> * aren&#39;t already..</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">exit_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span> <span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">core_state</span> <span class="o">*</span><span class="n">core_state</span><span class="p">;</span>

	<span class="n">mm_release</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">mm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">sync_mm_rss</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Serialize with any possible pending coredump.</span>
<span class="cm">	 * We must hold mmap_sem around checking core_state</span>
<span class="cm">	 * and clearing tsk-&gt;mm.  The core-inducing thread</span>
<span class="cm">	 * will increment -&gt;nr_threads for each thread in the</span>
<span class="cm">	 * group with -&gt;mm != NULL.</span>
<span class="cm">	 */</span>
	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="n">core_state</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">core_state</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">core_state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">core_thread</span> <span class="n">self</span><span class="p">;</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>

		<span class="n">self</span><span class="p">.</span><span class="n">task</span> <span class="o">=</span> <span class="n">tsk</span><span class="p">;</span>
		<span class="n">self</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">core_state</span><span class="o">-&gt;</span><span class="n">dumper</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Implies mb(), the result of xchg() must be visible</span>
<span class="cm">		 * to core_state-&gt;dumper.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">core_state</span><span class="o">-&gt;</span><span class="n">nr_threads</span><span class="p">))</span>
			<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">core_state</span><span class="o">-&gt;</span><span class="n">startup</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
			<span class="n">set_task_state</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="p">.</span><span class="n">task</span><span class="p">)</span> <span class="cm">/* see coredump_finish() */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">schedule</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="n">__set_task_state</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">TASK_RUNNING</span><span class="p">);</span>
		<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_count</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">mm</span> <span class="o">!=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="p">);</span>
	<span class="cm">/* more a memory barrier than a real lock */</span>
	<span class="n">task_lock</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="n">enter_lazy_tlb</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="n">task_unlock</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">mm_update_next_owner</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="n">mmput</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When we die, we re-parent all our children, and try to:</span>
<span class="cm"> * 1. give them to another thread in our thread group, if such a member exists</span>
<span class="cm"> * 2. give it to the first ancestor process which prctl&#39;d itself as a</span>
<span class="cm"> *    child_subreaper for its children (like a service manager)</span>
<span class="cm"> * 3. give it to the init process (PID 1) in our pid namespace</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">find_new_reaper</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">father</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">)</span>
	<span class="n">__acquires</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pid_namespace</span> <span class="o">*</span><span class="n">pid_ns</span> <span class="o">=</span> <span class="n">task_active_pid_ns</span><span class="p">(</span><span class="n">father</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="kr">thread</span><span class="p">;</span>

	<span class="kr">thread</span> <span class="o">=</span> <span class="n">father</span><span class="p">;</span>
	<span class="n">while_each_thread</span><span class="p">(</span><span class="n">father</span><span class="p">,</span> <span class="kr">thread</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="kr">thread</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_EXITING</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pid_ns</span><span class="o">-&gt;</span><span class="n">child_reaper</span> <span class="o">==</span> <span class="n">father</span><span class="p">))</span>
			<span class="n">pid_ns</span><span class="o">-&gt;</span><span class="n">child_reaper</span> <span class="o">=</span> <span class="kr">thread</span><span class="p">;</span>
		<span class="k">return</span> <span class="kr">thread</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pid_ns</span><span class="o">-&gt;</span><span class="n">child_reaper</span> <span class="o">==</span> <span class="n">father</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">write_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pid_ns</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">init_pid_ns</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Attempted to kill init! exitcode=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">father</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">group_exit_code</span> <span class="o">?:</span>
					<span class="n">father</span><span class="o">-&gt;</span><span class="n">exit_code</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">zap_pid_ns_processes</span><span class="p">(</span><span class="n">pid_ns</span><span class="p">);</span>
		<span class="n">write_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">father</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">has_child_subreaper</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">reaper</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Find the first ancestor marked as child_subreaper.</span>
<span class="cm">		 * Note that the code below checks same_thread_group(reaper,</span>
<span class="cm">		 * pid_ns-&gt;child_reaper).  This is what we need to DTRT in a</span>
<span class="cm">		 * PID namespace. However we still need the check above, see</span>
<span class="cm">		 * http://marc.info/?l=linux-kernel&amp;m=131385460420380</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">reaper</span> <span class="o">=</span> <span class="n">father</span><span class="o">-&gt;</span><span class="n">real_parent</span><span class="p">;</span>
		     <span class="n">reaper</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">init_task</span><span class="p">;</span>
		     <span class="n">reaper</span> <span class="o">=</span> <span class="n">reaper</span><span class="o">-&gt;</span><span class="n">real_parent</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">same_thread_group</span><span class="p">(</span><span class="n">reaper</span><span class="p">,</span> <span class="n">pid_ns</span><span class="o">-&gt;</span><span class="n">child_reaper</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reaper</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">is_child_subreaper</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="kr">thread</span> <span class="o">=</span> <span class="n">reaper</span><span class="p">;</span>
			<span class="k">do</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="kr">thread</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_EXITING</span><span class="p">))</span>
					<span class="k">return</span> <span class="n">reaper</span><span class="p">;</span>
			<span class="p">}</span> <span class="n">while_each_thread</span><span class="p">(</span><span class="n">reaper</span><span class="p">,</span> <span class="kr">thread</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">pid_ns</span><span class="o">-&gt;</span><span class="n">child_reaper</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">* Any that need to be release_task&#39;d are put on the @dead list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">reparent_leader</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">father</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">dead</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sibling</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">real_parent</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">exit_state</span> <span class="o">==</span> <span class="n">EXIT_DEAD</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If this is a threaded reparent there is no need to</span>
<span class="cm">	 * notify anyone anything has happened.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">same_thread_group</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">real_parent</span><span class="p">,</span> <span class="n">father</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* We don&#39;t want people slaying init.  */</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">exit_signal</span> <span class="o">=</span> <span class="n">SIGCHLD</span><span class="p">;</span>

	<span class="cm">/* If it has exited notify the new parent about this child&#39;s death. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ptrace</span> <span class="o">&amp;&amp;</span>
	    <span class="n">p</span><span class="o">-&gt;</span><span class="n">exit_state</span> <span class="o">==</span> <span class="n">EXIT_ZOMBIE</span> <span class="o">&amp;&amp;</span> <span class="n">thread_group_empty</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">do_notify_parent</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">exit_signal</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">exit_state</span> <span class="o">=</span> <span class="n">EXIT_DEAD</span><span class="p">;</span>
			<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sibling</span><span class="p">,</span> <span class="n">dead</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">kill_orphaned_pgrp</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">father</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">forget_original_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">father</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="o">*</span><span class="n">reaper</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">dead_children</span><span class="p">);</span>

	<span class="n">write_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Note that exit_ptrace() and find_new_reaper() might</span>
<span class="cm">	 * drop tasklist_lock and reacquire it.</span>
<span class="cm">	 */</span>
	<span class="n">exit_ptrace</span><span class="p">(</span><span class="n">father</span><span class="p">);</span>
	<span class="n">reaper</span> <span class="o">=</span> <span class="n">find_new_reaper</span><span class="p">(</span><span class="n">father</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">father</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">,</span> <span class="n">sibling</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">t</span><span class="o">-&gt;</span><span class="n">real_parent</span> <span class="o">=</span> <span class="n">reaper</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">==</span> <span class="n">father</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">ptrace</span><span class="p">);</span>
				<span class="n">t</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">real_parent</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">pdeath_signal</span><span class="p">)</span>
				<span class="n">group_send_sig_info</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">pdeath_signal</span><span class="p">,</span>
						    <span class="n">SEND_SIG_NOINFO</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
		<span class="p">}</span> <span class="n">while_each_thread</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
		<span class="n">reparent_leader</span><span class="p">(</span><span class="n">father</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dead_children</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">write_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">father</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">));</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dead_children</span><span class="p">,</span> <span class="n">sibling</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sibling</span><span class="p">);</span>
		<span class="n">release_task</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Send signals to all our closest relatives so that they know</span>
<span class="cm"> * to properly mourn us..</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">exit_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">group_dead</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">autoreap</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This does two things:</span>
<span class="cm">	 *</span>
<span class="cm">  	 * A.  Make init inherit all the child processes</span>
<span class="cm">	 * B.  Check to see if any process groups have become orphaned</span>
<span class="cm">	 *	as a result of our exiting, and if they have any stopped</span>
<span class="cm">	 *	jobs, send them a SIGHUP and then a SIGCONT.  (POSIX 3.2.2.2)</span>
<span class="cm">	 */</span>
	<span class="n">forget_original_parent</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">exit_task_namespaces</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>

	<span class="n">write_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">group_dead</span><span class="p">)</span>
		<span class="n">kill_orphaned_pgrp</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">ptrace</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">sig</span> <span class="o">=</span> <span class="n">thread_group_leader</span><span class="p">(</span><span class="n">tsk</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="n">thread_group_empty</span><span class="p">(</span><span class="n">tsk</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="o">!</span><span class="n">ptrace_reparented</span><span class="p">(</span><span class="n">tsk</span><span class="p">)</span> <span class="o">?</span>
			<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">exit_signal</span> <span class="o">:</span> <span class="n">SIGCHLD</span><span class="p">;</span>
		<span class="n">autoreap</span> <span class="o">=</span> <span class="n">do_notify_parent</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">sig</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">thread_group_leader</span><span class="p">(</span><span class="n">tsk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">autoreap</span> <span class="o">=</span> <span class="n">thread_group_empty</span><span class="p">(</span><span class="n">tsk</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">do_notify_parent</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">exit_signal</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">autoreap</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">exit_state</span> <span class="o">=</span> <span class="n">autoreap</span> <span class="o">?</span> <span class="n">EXIT_DEAD</span> <span class="o">:</span> <span class="n">EXIT_ZOMBIE</span><span class="p">;</span>

	<span class="cm">/* mt-exec, de_thread() is waiting for group leader */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">notify_count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">wake_up_process</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">group_exit_task</span><span class="p">);</span>
	<span class="n">write_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>

	<span class="cm">/* If the process is dead, release it - nobody will wait for it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">autoreap</span><span class="p">)</span>
		<span class="n">release_task</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_DEBUG_STACK_USAGE</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_stack_usage</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">low_water_lock</span><span class="p">);</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">lowest_to_date</span> <span class="o">=</span> <span class="n">THREAD_SIZE</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">free</span><span class="p">;</span>

	<span class="n">free</span> <span class="o">=</span> <span class="n">stack_not_used</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">free</span> <span class="o">&gt;=</span> <span class="n">lowest_to_date</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">low_water_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">free</span> <span class="o">&lt;</span> <span class="n">lowest_to_date</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s (%d) used greatest stack depth: &quot;</span>
				<span class="s">&quot;%lu bytes left</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">),</span> <span class="n">free</span><span class="p">);</span>
		<span class="n">lowest_to_date</span> <span class="o">=</span> <span class="n">free</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">low_water_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">check_stack_usage</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="nf">do_exit</span><span class="p">(</span><span class="kt">long</span> <span class="n">code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">group_dead</span><span class="p">;</span>

	<span class="n">profile_task_exit</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">blk_needs_flush_plug</span><span class="p">(</span><span class="n">tsk</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">in_interrupt</span><span class="p">()))</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Aiee, killing interrupt handler!&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">))</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Attempted to kill the idle task!&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If do_exit is called because this processes oopsed, it&#39;s possible</span>
<span class="cm">	 * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before</span>
<span class="cm">	 * continuing. Amongst other possible reasons, this is to prevent</span>
<span class="cm">	 * mm_release()-&gt;clear_child_tid() from writing to a user-controlled</span>
<span class="cm">	 * kernel address.</span>
<span class="cm">	 */</span>
	<span class="n">set_fs</span><span class="p">(</span><span class="n">USER_DS</span><span class="p">);</span>

	<span class="n">ptrace_event</span><span class="p">(</span><span class="n">PTRACE_EVENT_EXIT</span><span class="p">,</span> <span class="n">code</span><span class="p">);</span>

	<span class="n">validate_creds_for_do_exit</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We&#39;re taking recursive faults here in do_exit. Safest is to just</span>
<span class="cm">	 * leave this task alone and wait for reboot.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_EXITING</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span>
			<span class="s">&quot;Fixing recursive fault but reboot is needed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * We can do this unlocked here. The futex code uses</span>
<span class="cm">		 * this flag just to verify whether the pi state</span>
<span class="cm">		 * cleanup has been done or not. In the worst case it</span>
<span class="cm">		 * loops once more. We pretend that the cleanup was</span>
<span class="cm">		 * done as there is no way to return. Either the</span>
<span class="cm">		 * OWNER_DIED bit is set by now or we push the blocked</span>
<span class="cm">		 * task into the wait for ever nirwana as well.</span>
<span class="cm">		 */</span>
		<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PF_EXITPIDONE</span><span class="p">;</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
		<span class="n">schedule</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">exit_signals</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>  <span class="cm">/* sets PF_EXITING */</span>
	<span class="cm">/*</span>
<span class="cm">	 * tsk-&gt;flags are checked in the futex code to protect against</span>
<span class="cm">	 * an exiting task cleaning up the robust pi futexes, and in</span>
<span class="cm">	 * task_work_add() to avoid the race with exit_task_work().</span>
<span class="cm">	 */</span>
	<span class="n">smp_mb</span><span class="p">();</span>
	<span class="n">raw_spin_unlock_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>

	<span class="n">exit_task_work</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">in_atomic</span><span class="p">()))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;note: %s[%d] exited with preempt_count %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">),</span>
				<span class="n">preempt_count</span><span class="p">());</span>

	<span class="n">acct_update_integrals</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="cm">/* sync mm&#39;s RSS info before statistics gathering */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span>
		<span class="n">sync_mm_rss</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
	<span class="n">group_dead</span> <span class="o">=</span> <span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">live</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">group_dead</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hrtimer_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">real_timer</span><span class="p">);</span>
		<span class="n">exit_itimers</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span>
			<span class="n">setmax_mm_hiwater_rss</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">maxrss</span><span class="p">,</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">acct_collect</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">group_dead</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">group_dead</span><span class="p">)</span>
		<span class="n">tty_audit_exit</span><span class="p">();</span>
	<span class="n">audit_free</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>

	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">exit_code</span> <span class="o">=</span> <span class="n">code</span><span class="p">;</span>
	<span class="n">taskstats_exit</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">group_dead</span><span class="p">);</span>

	<span class="n">exit_mm</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">group_dead</span><span class="p">)</span>
		<span class="n">acct_process</span><span class="p">();</span>
	<span class="n">trace_sched_process_exit</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>

	<span class="n">exit_sem</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">exit_shm</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">exit_files</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">exit_fs</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">check_stack_usage</span><span class="p">();</span>
	<span class="n">exit_thread</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Flush inherited counters to the parent - before the parent</span>
<span class="cm">	 * gets woken up by child-exit notifications.</span>
<span class="cm">	 *</span>
<span class="cm">	 * because of cgroup mode, must be called before cgroup_exit()</span>
<span class="cm">	 */</span>
	<span class="n">perf_event_exit_task</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>

	<span class="n">cgroup_exit</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">group_dead</span><span class="p">)</span>
		<span class="n">disassociate_ctty</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">module_put</span><span class="p">(</span><span class="n">task_thread_info</span><span class="p">(</span><span class="n">tsk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">exec_domain</span><span class="o">-&gt;</span><span class="n">module</span><span class="p">);</span>

	<span class="n">proc_exit_connector</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * FIXME: do that only when needed, using sched_exit tracepoint</span>
<span class="cm">	 */</span>
	<span class="n">ptrace_put_breakpoints</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>

	<span class="n">exit_notify</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">group_dead</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_NUMA</span>
	<span class="n">task_lock</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">mpol_put</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">mempolicy</span><span class="p">);</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">mempolicy</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">task_unlock</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_FUTEX</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">pi_state_cache</span><span class="p">))</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">pi_state_cache</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 * Make sure we are holding no locks:</span>
<span class="cm">	 */</span>
	<span class="n">debug_check_no_locks_held</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * We can do this unlocked here. The futex code uses this flag</span>
<span class="cm">	 * just to verify whether the pi state cleanup has been done</span>
<span class="cm">	 * or not. In the worst case it loops once more.</span>
<span class="cm">	 */</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PF_EXITPIDONE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">io_context</span><span class="p">)</span>
		<span class="n">exit_io_context</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">splice_pipe</span><span class="p">)</span>
		<span class="n">__free_pipe_info</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">splice_pipe</span><span class="p">);</span>

	<span class="n">validate_creds_for_do_exit</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>

	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">nr_dirtied</span><span class="p">)</span>
		<span class="n">__this_cpu_add</span><span class="p">(</span><span class="n">dirty_throttle_leaks</span><span class="p">,</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">nr_dirtied</span><span class="p">);</span>
	<span class="n">exit_rcu</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * The setting of TASK_RUNNING by try_to_wake_up() may be delayed</span>
<span class="cm">	 * when the following two conditions become true.</span>
<span class="cm">	 *   - There is race condition of mmap_sem (It is acquired by</span>
<span class="cm">	 *     exit_mm()), and</span>
<span class="cm">	 *   - SMI occurs before setting TASK_RUNINNG.</span>
<span class="cm">	 *     (or hypervisor of virtual machine switches to other guest)</span>
<span class="cm">	 *  As a result, we may become TASK_RUNNING after becoming TASK_DEAD</span>
<span class="cm">	 *</span>
<span class="cm">	 * To avoid it, we have to wait for releasing tsk-&gt;pi_lock which</span>
<span class="cm">	 * is held by try_to_wake_up()</span>
<span class="cm">	 */</span>
	<span class="n">smp_mb</span><span class="p">();</span>
	<span class="n">raw_spin_unlock_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>

	<span class="cm">/* causes final put_task_struct in finish_task_switch(). */</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_DEAD</span><span class="p">;</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PF_NOFREEZE</span><span class="p">;</span>	<span class="cm">/* tell freezer to ignore us */</span>
	<span class="n">schedule</span><span class="p">();</span>
	<span class="n">BUG</span><span class="p">();</span>
	<span class="cm">/* Avoid &quot;noreturn function does return&quot;.  */</span>
	<span class="k">for</span> <span class="p">(;;)</span>
		<span class="n">cpu_relax</span><span class="p">();</span>	<span class="cm">/* For when BUG is null */</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">do_exit</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">complete_and_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">comp</span><span class="p">,</span> <span class="kt">long</span> <span class="n">code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">comp</span><span class="p">)</span>
		<span class="n">complete</span><span class="p">(</span><span class="n">comp</span><span class="p">);</span>

	<span class="n">do_exit</span><span class="p">(</span><span class="n">code</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">complete_and_exit</span><span class="p">);</span>

<span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">exit</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">error_code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">do_exit</span><span class="p">((</span><span class="n">error_code</span><span class="o">&amp;</span><span class="mh">0xff</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Take down every thread in the group.  This is called by fatal signals</span>
<span class="cm"> * as well as by sys_exit_group (below).</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="n">do_group_exit</span><span class="p">(</span><span class="kt">int</span> <span class="n">exit_code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">signal_struct</span> <span class="o">*</span><span class="n">sig</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">exit_code</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">);</span> <span class="cm">/* core dumps don&#39;t get here */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">signal_group_exit</span><span class="p">(</span><span class="n">sig</span><span class="p">))</span>
		<span class="n">exit_code</span> <span class="o">=</span> <span class="n">sig</span><span class="o">-&gt;</span><span class="n">group_exit_code</span><span class="p">;</span>
	<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">thread_group_empty</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sighand_struct</span> <span class="o">*</span><span class="k">const</span> <span class="n">sighand</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="p">;</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_group_exit</span><span class="p">(</span><span class="n">sig</span><span class="p">))</span>
			<span class="cm">/* Another thread got here before we took the lock.  */</span>
			<span class="n">exit_code</span> <span class="o">=</span> <span class="n">sig</span><span class="o">-&gt;</span><span class="n">group_exit_code</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">sig</span><span class="o">-&gt;</span><span class="n">group_exit_code</span> <span class="o">=</span> <span class="n">exit_code</span><span class="p">;</span>
			<span class="n">sig</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">SIGNAL_GROUP_EXIT</span><span class="p">;</span>
			<span class="n">zap_other_threads</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">do_exit</span><span class="p">(</span><span class="n">exit_code</span><span class="p">);</span>
	<span class="cm">/* NOTREACHED */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this kills every thread in the thread group. Note that any externally</span>
<span class="cm"> * wait4()-ing process will get the correct exit code - even if this</span>
<span class="cm"> * thread is not the thread group leader.</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">exit_group</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">error_code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">do_group_exit</span><span class="p">((</span><span class="n">error_code</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="cm">/* NOTREACHED */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">wait_opts</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">pid_type</span>		<span class="n">wo_type</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">wo_flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pid</span>		<span class="o">*</span><span class="n">wo_pid</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">siginfo</span> <span class="n">__user</span>	<span class="o">*</span><span class="n">wo_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">__user</span>		<span class="o">*</span><span class="n">wo_stat</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rusage</span> <span class="n">__user</span>	<span class="o">*</span><span class="n">wo_rusage</span><span class="p">;</span>

	<span class="n">wait_queue_t</span>		<span class="n">child_wait</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">notask_error</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="nf">task_pid_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">enum</span> <span class="n">pid_type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">PIDTYPE_PID</span><span class="p">)</span>
		<span class="n">task</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">pids</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">pid</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">eligible_pid</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_opts</span> <span class="o">*</span><span class="n">wo</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span>	<span class="n">wo</span><span class="o">-&gt;</span><span class="n">wo_type</span> <span class="o">==</span> <span class="n">PIDTYPE_MAX</span> <span class="o">||</span>
		<span class="n">task_pid_type</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">wo</span><span class="o">-&gt;</span><span class="n">wo_type</span><span class="p">)</span> <span class="o">==</span> <span class="n">wo</span><span class="o">-&gt;</span><span class="n">wo_pid</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">eligible_child</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_opts</span> <span class="o">*</span><span class="n">wo</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eligible_pid</span><span class="p">(</span><span class="n">wo</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Wait for all children (clone and not) if __WALL is set;</span>
<span class="cm">	 * otherwise, wait for clone children *only* if __WCLONE is</span>
<span class="cm">	 * set; otherwise, wait for non-clone children *only*.  (Note:</span>
<span class="cm">	 * A &quot;clone&quot; child here is one that reports to its parent</span>
<span class="cm">	 * using a signal other than SIGCHLD.) */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">exit_signal</span> <span class="o">!=</span> <span class="n">SIGCHLD</span><span class="p">)</span> <span class="o">^</span> <span class="o">!!</span><span class="p">(</span><span class="n">wo</span><span class="o">-&gt;</span><span class="n">wo_flags</span> <span class="o">&amp;</span> <span class="n">__WCLONE</span><span class="p">))</span>
	    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">wo</span><span class="o">-&gt;</span><span class="n">wo_flags</span> <span class="o">&amp;</span> <span class="n">__WALL</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">wait_noreap_copyout</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_opts</span> <span class="o">*</span><span class="n">wo</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
				<span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="n">uid_t</span> <span class="n">uid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">why</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">siginfo</span> <span class="n">__user</span> <span class="o">*</span><span class="n">infop</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="n">wo</span><span class="o">-&gt;</span><span class="n">wo_rusage</span>
		<span class="o">?</span> <span class="n">getrusage</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">RUSAGE_BOTH</span><span class="p">,</span> <span class="n">wo</span><span class="o">-&gt;</span><span class="n">wo_rusage</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">infop</span> <span class="o">=</span> <span class="n">wo</span><span class="o">-&gt;</span><span class="n">wo_info</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">infop</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="n">SIGCHLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">infop</span><span class="o">-&gt;</span><span class="n">si_signo</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">infop</span><span class="o">-&gt;</span><span class="n">si_errno</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">((</span><span class="kt">short</span><span class="p">)</span><span class="n">why</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">infop</span><span class="o">-&gt;</span><span class="n">si_code</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">infop</span><span class="o">-&gt;</span><span class="n">si_pid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="n">uid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">infop</span><span class="o">-&gt;</span><span class="n">si_uid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">infop</span><span class="o">-&gt;</span><span class="n">si_status</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">pid</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle sys_wait4 work for one task in state EXIT_ZOMBIE.  We hold</span>
<span class="cm"> * read_lock(&amp;tasklist_lock) on entry.  If we return zero, we still hold</span>
<span class="cm"> * the lock and this task is uninteresting.  If we return nonzero, we have</span>
<span class="cm"> * released the lock and the system call should return.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">wait_task_zombie</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_opts</span> <span class="o">*</span><span class="n">wo</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">traced</span><span class="p">;</span>
	<span class="n">pid_t</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">task_pid_vnr</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">uid_t</span> <span class="n">uid</span> <span class="o">=</span> <span class="n">from_kuid_munged</span><span class="p">(</span><span class="n">current_user_ns</span><span class="p">(),</span> <span class="n">task_uid</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
	<span class="k">struct</span> <span class="n">siginfo</span> <span class="n">__user</span> <span class="o">*</span><span class="n">infop</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">likely</span><span class="p">(</span><span class="n">wo</span><span class="o">-&gt;</span><span class="n">wo_flags</span> <span class="o">&amp;</span> <span class="n">WEXITED</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">wo</span><span class="o">-&gt;</span><span class="n">wo_flags</span> <span class="o">&amp;</span> <span class="n">WNOWAIT</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">exit_code</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">exit_code</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">why</span><span class="p">;</span>

		<span class="n">get_task_struct</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">exit_code</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">why</span> <span class="o">=</span> <span class="n">CLD_EXITED</span><span class="p">;</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">exit_code</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">why</span> <span class="o">=</span> <span class="p">(</span><span class="n">exit_code</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="o">?</span> <span class="n">CLD_DUMPED</span> <span class="o">:</span> <span class="n">CLD_KILLED</span><span class="p">;</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">exit_code</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">wait_noreap_copyout</span><span class="p">(</span><span class="n">wo</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="n">why</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Try to move the task&#39;s state to DEAD</span>
<span class="cm">	 * only one thread is allowed to do this:</span>
<span class="cm">	 */</span>
	<span class="n">state</span> <span class="o">=</span> <span class="n">xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">exit_state</span><span class="p">,</span> <span class="n">EXIT_DEAD</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">!=</span> <span class="n">EXIT_ZOMBIE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">state</span> <span class="o">!=</span> <span class="n">EXIT_DEAD</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">traced</span> <span class="o">=</span> <span class="n">ptrace_reparented</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * It can be ptraced but not reparented, check</span>
<span class="cm">	 * thread_group_leader() to filter out sub-threads.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">traced</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">thread_group_leader</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">signal_struct</span> <span class="o">*</span><span class="n">psig</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">signal_struct</span> <span class="o">*</span><span class="n">sig</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">maxrss</span><span class="p">;</span>
		<span class="n">cputime_t</span> <span class="n">tgutime</span><span class="p">,</span> <span class="n">tgstime</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * The resource counters for the group leader are in its</span>
<span class="cm">		 * own task_struct.  Those for dead threads in the group</span>
<span class="cm">		 * are in its signal_struct, as are those for the child</span>
<span class="cm">		 * processes it has previously reaped.  All these</span>
<span class="cm">		 * accumulate in the parent&#39;s signal_struct c* fields.</span>
<span class="cm">		 *</span>
<span class="cm">		 * We don&#39;t bother to take a lock here to protect these</span>
<span class="cm">		 * p-&gt;signal fields, because they are only touched by</span>
<span class="cm">		 * __exit_signal, which runs with tasklist_lock</span>
<span class="cm">		 * write-locked anyway, and so is excluded here.  We do</span>
<span class="cm">		 * need to protect the access to parent-&gt;signal fields,</span>
<span class="cm">		 * as other threads in the parent group can be right</span>
<span class="cm">		 * here reaping other children at the same time.</span>
<span class="cm">		 *</span>
<span class="cm">		 * We use thread_group_times() to get times for the thread</span>
<span class="cm">		 * group, which consolidates times for all threads in the</span>
<span class="cm">		 * group including the group leader.</span>
<span class="cm">		 */</span>
		<span class="n">thread_group_times</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tgutime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tgstime</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">real_parent</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
		<span class="n">psig</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">real_parent</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">;</span>
		<span class="n">sig</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">;</span>
		<span class="n">psig</span><span class="o">-&gt;</span><span class="n">cutime</span> <span class="o">+=</span> <span class="n">tgutime</span> <span class="o">+</span> <span class="n">sig</span><span class="o">-&gt;</span><span class="n">cutime</span><span class="p">;</span>
		<span class="n">psig</span><span class="o">-&gt;</span><span class="n">cstime</span> <span class="o">+=</span> <span class="n">tgstime</span> <span class="o">+</span> <span class="n">sig</span><span class="o">-&gt;</span><span class="n">cstime</span><span class="p">;</span>
		<span class="n">psig</span><span class="o">-&gt;</span><span class="n">cgtime</span> <span class="o">+=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">gtime</span> <span class="o">+</span> <span class="n">sig</span><span class="o">-&gt;</span><span class="n">gtime</span> <span class="o">+</span> <span class="n">sig</span><span class="o">-&gt;</span><span class="n">cgtime</span><span class="p">;</span>
		<span class="n">psig</span><span class="o">-&gt;</span><span class="n">cmin_flt</span> <span class="o">+=</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">min_flt</span> <span class="o">+</span> <span class="n">sig</span><span class="o">-&gt;</span><span class="n">min_flt</span> <span class="o">+</span> <span class="n">sig</span><span class="o">-&gt;</span><span class="n">cmin_flt</span><span class="p">;</span>
		<span class="n">psig</span><span class="o">-&gt;</span><span class="n">cmaj_flt</span> <span class="o">+=</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">maj_flt</span> <span class="o">+</span> <span class="n">sig</span><span class="o">-&gt;</span><span class="n">maj_flt</span> <span class="o">+</span> <span class="n">sig</span><span class="o">-&gt;</span><span class="n">cmaj_flt</span><span class="p">;</span>
		<span class="n">psig</span><span class="o">-&gt;</span><span class="n">cnvcsw</span> <span class="o">+=</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">nvcsw</span> <span class="o">+</span> <span class="n">sig</span><span class="o">-&gt;</span><span class="n">nvcsw</span> <span class="o">+</span> <span class="n">sig</span><span class="o">-&gt;</span><span class="n">cnvcsw</span><span class="p">;</span>
		<span class="n">psig</span><span class="o">-&gt;</span><span class="n">cnivcsw</span> <span class="o">+=</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">nivcsw</span> <span class="o">+</span> <span class="n">sig</span><span class="o">-&gt;</span><span class="n">nivcsw</span> <span class="o">+</span> <span class="n">sig</span><span class="o">-&gt;</span><span class="n">cnivcsw</span><span class="p">;</span>
		<span class="n">psig</span><span class="o">-&gt;</span><span class="n">cinblock</span> <span class="o">+=</span>
			<span class="n">task_io_get_inblock</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span>
			<span class="n">sig</span><span class="o">-&gt;</span><span class="n">inblock</span> <span class="o">+</span> <span class="n">sig</span><span class="o">-&gt;</span><span class="n">cinblock</span><span class="p">;</span>
		<span class="n">psig</span><span class="o">-&gt;</span><span class="n">coublock</span> <span class="o">+=</span>
			<span class="n">task_io_get_oublock</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span>
			<span class="n">sig</span><span class="o">-&gt;</span><span class="n">oublock</span> <span class="o">+</span> <span class="n">sig</span><span class="o">-&gt;</span><span class="n">coublock</span><span class="p">;</span>
		<span class="n">maxrss</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">maxrss</span><span class="p">,</span> <span class="n">sig</span><span class="o">-&gt;</span><span class="n">cmaxrss</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">psig</span><span class="o">-&gt;</span><span class="n">cmaxrss</span> <span class="o">&lt;</span> <span class="n">maxrss</span><span class="p">)</span>
			<span class="n">psig</span><span class="o">-&gt;</span><span class="n">cmaxrss</span> <span class="o">=</span> <span class="n">maxrss</span><span class="p">;</span>
		<span class="n">task_io_accounting_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">psig</span><span class="o">-&gt;</span><span class="n">ioac</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ioac</span><span class="p">);</span>
		<span class="n">task_io_accounting_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">psig</span><span class="o">-&gt;</span><span class="n">ioac</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">ioac</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">real_parent</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now we are sure this task is interesting, and no other</span>
<span class="cm">	 * thread can reap it because we set its state to EXIT_DEAD.</span>
<span class="cm">	 */</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">wo</span><span class="o">-&gt;</span><span class="n">wo_rusage</span>
		<span class="o">?</span> <span class="n">getrusage</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">RUSAGE_BOTH</span><span class="p">,</span> <span class="n">wo</span><span class="o">-&gt;</span><span class="n">wo_rusage</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SIGNAL_GROUP_EXIT</span><span class="p">)</span>
		<span class="o">?</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">group_exit_code</span> <span class="o">:</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">exit_code</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span> <span class="o">&amp;&amp;</span> <span class="n">wo</span><span class="o">-&gt;</span><span class="n">wo_stat</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">wo</span><span class="o">-&gt;</span><span class="n">wo_stat</span><span class="p">);</span>

	<span class="n">infop</span> <span class="o">=</span> <span class="n">wo</span><span class="o">-&gt;</span><span class="n">wo_info</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span> <span class="o">&amp;&amp;</span> <span class="n">infop</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="n">SIGCHLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">infop</span><span class="o">-&gt;</span><span class="n">si_signo</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span> <span class="o">&amp;&amp;</span> <span class="n">infop</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">infop</span><span class="o">-&gt;</span><span class="n">si_errno</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span> <span class="o">&amp;&amp;</span> <span class="n">infop</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">why</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">why</span> <span class="o">=</span> <span class="n">CLD_EXITED</span><span class="p">;</span>
			<span class="n">status</span> <span class="o">&gt;&gt;=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">why</span> <span class="o">=</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="o">?</span> <span class="n">CLD_DUMPED</span> <span class="o">:</span> <span class="n">CLD_KILLED</span><span class="p">;</span>
			<span class="n">status</span> <span class="o">&amp;=</span> <span class="mh">0x7f</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">((</span><span class="kt">short</span><span class="p">)</span><span class="n">why</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">infop</span><span class="o">-&gt;</span><span class="n">si_code</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">infop</span><span class="o">-&gt;</span><span class="n">si_status</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span> <span class="o">&amp;&amp;</span> <span class="n">infop</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">infop</span><span class="o">-&gt;</span><span class="n">si_pid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span> <span class="o">&amp;&amp;</span> <span class="n">infop</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="n">uid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">infop</span><span class="o">-&gt;</span><span class="n">si_uid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">pid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">traced</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">write_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
		<span class="cm">/* We dropped tasklist, ptracer could die and untrace */</span>
		<span class="n">ptrace_unlink</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If this is not a sub-thread, notify the parent.</span>
<span class="cm">		 * If parent wants a zombie, don&#39;t release it now.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">thread_group_leader</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">do_notify_parent</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">exit_signal</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">exit_state</span> <span class="o">=</span> <span class="n">EXIT_ZOMBIE</span><span class="p">;</span>
			<span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">write_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">release_task</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="o">*</span><span class="nf">task_stopped_code</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">bool</span> <span class="n">ptrace</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ptrace</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">task_is_stopped_or_traced</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">jobctl</span> <span class="o">&amp;</span> <span class="n">JOBCTL_LISTENING</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">exit_code</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SIGNAL_STOP_STOPPED</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">group_exit_code</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * wait_task_stopped - Wait for %TASK_STOPPED or %TASK_TRACED</span>
<span class="cm"> * @wo: wait options</span>
<span class="cm"> * @ptrace: is the wait for ptrace</span>
<span class="cm"> * @p: task to wait for</span>
<span class="cm"> *</span>
<span class="cm"> * Handle sys_wait4() work for %p in state %TASK_STOPPED or %TASK_TRACED.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * read_lock(&amp;tasklist_lock), which is released if return value is</span>
<span class="cm"> * non-zero.  Also, grabs and releases @p-&gt;sighand-&gt;siglock.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * 0 if wait condition didn&#39;t exist and search for other wait conditions</span>
<span class="cm"> * should continue.  Non-zero return, -errno on failure and @p&#39;s pid on</span>
<span class="cm"> * success, implies that tasklist_lock is released and wait condition</span>
<span class="cm"> * search should terminate.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">wait_task_stopped</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_opts</span> <span class="o">*</span><span class="n">wo</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">ptrace</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">siginfo</span> <span class="n">__user</span> <span class="o">*</span><span class="n">infop</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">,</span> <span class="n">exit_code</span><span class="p">,</span> <span class="o">*</span><span class="n">p_code</span><span class="p">,</span> <span class="n">why</span><span class="p">;</span>
	<span class="n">uid_t</span> <span class="n">uid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* unneeded, required by compiler */</span>
	<span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Traditionally we see ptrace&#39;d stopped tasks regardless of options.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptrace</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">wo</span><span class="o">-&gt;</span><span class="n">wo_flags</span> <span class="o">&amp;</span> <span class="n">WUNTRACED</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task_stopped_code</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptrace</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">exit_code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>

	<span class="n">p_code</span> <span class="o">=</span> <span class="n">task_stopped_code</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptrace</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">p_code</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">unlock_sig</span><span class="p">;</span>

	<span class="n">exit_code</span> <span class="o">=</span> <span class="o">*</span><span class="n">p_code</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">exit_code</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlock_sig</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">unlikely</span><span class="p">(</span><span class="n">wo</span><span class="o">-&gt;</span><span class="n">wo_flags</span> <span class="o">&amp;</span> <span class="n">WNOWAIT</span><span class="p">))</span>
		<span class="o">*</span><span class="n">p_code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">uid</span> <span class="o">=</span> <span class="n">from_kuid_munged</span><span class="p">(</span><span class="n">current_user_ns</span><span class="p">(),</span> <span class="n">task_uid</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
<span class="nl">unlock_sig:</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">exit_code</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now we are pretty sure this task is interesting.</span>
<span class="cm">	 * Make sure it doesn&#39;t get reaped out from under us while we</span>
<span class="cm">	 * give up the lock and then examine it below.  We don&#39;t want to</span>
<span class="cm">	 * keep holding onto the tasklist_lock while we call getrusage and</span>
<span class="cm">	 * possibly take page faults for user memory.</span>
<span class="cm">	 */</span>
	<span class="n">get_task_struct</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">pid</span> <span class="o">=</span> <span class="n">task_pid_vnr</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">why</span> <span class="o">=</span> <span class="n">ptrace</span> <span class="o">?</span> <span class="n">CLD_TRAPPED</span> <span class="o">:</span> <span class="n">CLD_STOPPED</span><span class="p">;</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">wo</span><span class="o">-&gt;</span><span class="n">wo_flags</span> <span class="o">&amp;</span> <span class="n">WNOWAIT</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">wait_noreap_copyout</span><span class="p">(</span><span class="n">wo</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="n">why</span><span class="p">,</span> <span class="n">exit_code</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">wo</span><span class="o">-&gt;</span><span class="n">wo_rusage</span>
		<span class="o">?</span> <span class="n">getrusage</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">RUSAGE_BOTH</span><span class="p">,</span> <span class="n">wo</span><span class="o">-&gt;</span><span class="n">wo_rusage</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span> <span class="o">&amp;&amp;</span> <span class="n">wo</span><span class="o">-&gt;</span><span class="n">wo_stat</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">((</span><span class="n">exit_code</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x7f</span><span class="p">,</span> <span class="n">wo</span><span class="o">-&gt;</span><span class="n">wo_stat</span><span class="p">);</span>

	<span class="n">infop</span> <span class="o">=</span> <span class="n">wo</span><span class="o">-&gt;</span><span class="n">wo_info</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span> <span class="o">&amp;&amp;</span> <span class="n">infop</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="n">SIGCHLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">infop</span><span class="o">-&gt;</span><span class="n">si_signo</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span> <span class="o">&amp;&amp;</span> <span class="n">infop</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">infop</span><span class="o">-&gt;</span><span class="n">si_errno</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span> <span class="o">&amp;&amp;</span> <span class="n">infop</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">((</span><span class="kt">short</span><span class="p">)</span><span class="n">why</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">infop</span><span class="o">-&gt;</span><span class="n">si_code</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span> <span class="o">&amp;&amp;</span> <span class="n">infop</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="n">exit_code</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">infop</span><span class="o">-&gt;</span><span class="n">si_status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span> <span class="o">&amp;&amp;</span> <span class="n">infop</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">infop</span><span class="o">-&gt;</span><span class="n">si_pid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span> <span class="o">&amp;&amp;</span> <span class="n">infop</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="n">uid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">infop</span><span class="o">-&gt;</span><span class="n">si_uid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">pid</span><span class="p">;</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle do_wait work for one task in a live, non-stopped state.</span>
<span class="cm"> * read_lock(&amp;tasklist_lock) on entry.  If we return zero, we still hold</span>
<span class="cm"> * the lock and this task is uninteresting.  If we return nonzero, we have</span>
<span class="cm"> * released the lock and the system call should return.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">wait_task_continued</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_opts</span> <span class="o">*</span><span class="n">wo</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>
	<span class="n">uid_t</span> <span class="n">uid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">unlikely</span><span class="p">(</span><span class="n">wo</span><span class="o">-&gt;</span><span class="n">wo_flags</span> <span class="o">&amp;</span> <span class="n">WCONTINUED</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SIGNAL_STOP_CONTINUED</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="cm">/* Re-check with the lock held.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SIGNAL_STOP_CONTINUED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">unlikely</span><span class="p">(</span><span class="n">wo</span><span class="o">-&gt;</span><span class="n">wo_flags</span> <span class="o">&amp;</span> <span class="n">WNOWAIT</span><span class="p">))</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SIGNAL_STOP_CONTINUED</span><span class="p">;</span>
	<span class="n">uid</span> <span class="o">=</span> <span class="n">from_kuid_munged</span><span class="p">(</span><span class="n">current_user_ns</span><span class="p">(),</span> <span class="n">task_uid</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>

	<span class="n">pid</span> <span class="o">=</span> <span class="n">task_pid_vnr</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">get_task_struct</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wo</span><span class="o">-&gt;</span><span class="n">wo_info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">wo</span><span class="o">-&gt;</span><span class="n">wo_rusage</span>
			<span class="o">?</span> <span class="n">getrusage</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">RUSAGE_BOTH</span><span class="p">,</span> <span class="n">wo</span><span class="o">-&gt;</span><span class="n">wo_rusage</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">put_task_struct</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span> <span class="o">&amp;&amp;</span> <span class="n">wo</span><span class="o">-&gt;</span><span class="n">wo_stat</span><span class="p">)</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="mh">0xffff</span><span class="p">,</span> <span class="n">wo</span><span class="o">-&gt;</span><span class="n">wo_stat</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">pid</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">wait_noreap_copyout</span><span class="p">(</span><span class="n">wo</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span>
					     <span class="n">CLD_CONTINUED</span><span class="p">,</span> <span class="n">SIGCONT</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Consider @p for a wait by @parent.</span>
<span class="cm"> *</span>
<span class="cm"> * -ECHILD should be in -&gt;notask_error before the first call.</span>
<span class="cm"> * Returns nonzero for a final return, when we have unlocked tasklist_lock.</span>
<span class="cm"> * Returns zero if the search for a child should continue;</span>
<span class="cm"> * then -&gt;notask_error is 0 if @p is an eligible child,</span>
<span class="cm"> * or another error from security_task_wait(), or still -ECHILD.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">wait_consider_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_opts</span> <span class="o">*</span><span class="n">wo</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ptrace</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">eligible_child</span><span class="p">(</span><span class="n">wo</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">security_task_wait</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we have not yet seen any eligible child,</span>
<span class="cm">		 * then let this error code replace -ECHILD.</span>
<span class="cm">		 * A permission error will give the user a clue</span>
<span class="cm">		 * to look for security policy problems, rather</span>
<span class="cm">		 * than for mysterious wait bugs.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wo</span><span class="o">-&gt;</span><span class="n">notask_error</span><span class="p">)</span>
			<span class="n">wo</span><span class="o">-&gt;</span><span class="n">notask_error</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* dead body doesn&#39;t have much to contribute */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">exit_state</span> <span class="o">==</span> <span class="n">EXIT_DEAD</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * But do not ignore this task until the tracer does</span>
<span class="cm">		 * wait_task_zombie()-&gt;do_notify_parent().</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">ptrace</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">ptrace_reparented</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span>
			<span class="n">wo</span><span class="o">-&gt;</span><span class="n">notask_error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* slay zombie? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">exit_state</span> <span class="o">==</span> <span class="n">EXIT_ZOMBIE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * A zombie ptracee is only visible to its ptracer.</span>
<span class="cm">		 * Notification and reaping will be cascaded to the real</span>
<span class="cm">		 * parent when the ptracer detaches.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">ptrace</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ptrace</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* it will become visible, clear notask_error */</span>
			<span class="n">wo</span><span class="o">-&gt;</span><span class="n">notask_error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* we don&#39;t reap group leaders with subthreads */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">delay_group_leader</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">wait_task_zombie</span><span class="p">(</span><span class="n">wo</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Allow access to stopped/continued state via zombie by</span>
<span class="cm">		 * falling through.  Clearing of notask_error is complex.</span>
<span class="cm">		 *</span>
<span class="cm">		 * When !@ptrace:</span>
<span class="cm">		 *</span>
<span class="cm">		 * If WEXITED is set, notask_error should naturally be</span>
<span class="cm">		 * cleared.  If not, subset of WSTOPPED|WCONTINUED is set,</span>
<span class="cm">		 * so, if there are live subthreads, there are events to</span>
<span class="cm">		 * wait for.  If all subthreads are dead, it&#39;s still safe</span>
<span class="cm">		 * to clear - this function will be called again in finite</span>
<span class="cm">		 * amount time once all the subthreads are released and</span>
<span class="cm">		 * will then return without clearing.</span>
<span class="cm">		 *</span>
<span class="cm">		 * When @ptrace:</span>
<span class="cm">		 *</span>
<span class="cm">		 * Stopped state is per-task and thus can&#39;t change once the</span>
<span class="cm">		 * target task dies.  Only continued and exited can happen.</span>
<span class="cm">		 * Clear notask_error if WCONTINUED | WEXITED.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">ptrace</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">wo</span><span class="o">-&gt;</span><span class="n">wo_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">WCONTINUED</span> <span class="o">|</span> <span class="n">WEXITED</span><span class="p">)))</span>
			<span class="n">wo</span><span class="o">-&gt;</span><span class="n">notask_error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If @p is ptraced by a task in its real parent&#39;s group,</span>
<span class="cm">		 * hide group stop/continued state when looking at @p as</span>
<span class="cm">		 * the real parent; otherwise, a single stop can be</span>
<span class="cm">		 * reported twice as group and ptrace stops.</span>
<span class="cm">		 *</span>
<span class="cm">		 * If a ptracer wants to distinguish the two events for its</span>
<span class="cm">		 * own children, it should create a separate process which</span>
<span class="cm">		 * takes the role of real parent.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">ptrace</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ptrace</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ptrace_reparented</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * @p is alive and it&#39;s gonna stop, continue or exit, so</span>
<span class="cm">		 * there always is something to wait for.</span>
<span class="cm">		 */</span>
		<span class="n">wo</span><span class="o">-&gt;</span><span class="n">notask_error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait for stopped.  Depending on @ptrace, different stopped state</span>
<span class="cm">	 * is used and the two don&#39;t interact with each other.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">wait_task_stopped</span><span class="p">(</span><span class="n">wo</span><span class="p">,</span> <span class="n">ptrace</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait for continued.  There&#39;s only one continued state and the</span>
<span class="cm">	 * ptracer can consume it which can confuse the real parent.  Don&#39;t</span>
<span class="cm">	 * use WCONTINUED from ptracer.  You don&#39;t need or want it.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">wait_task_continued</span><span class="p">(</span><span class="n">wo</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Do the work of do_wait() for one thread in the group, @tsk.</span>
<span class="cm"> *</span>
<span class="cm"> * -ECHILD should be in -&gt;notask_error before the first call.</span>
<span class="cm"> * Returns nonzero for a final return, when we have unlocked tasklist_lock.</span>
<span class="cm"> * Returns zero if the search for a child should continue; then</span>
<span class="cm"> * -&gt;notask_error is 0 if there were any eligible children,</span>
<span class="cm"> * or another error from security_task_wait(), or still -ECHILD.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_wait_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_opts</span> <span class="o">*</span><span class="n">wo</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">,</span> <span class="n">sibling</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">wait_consider_task</span><span class="p">(</span><span class="n">wo</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ptrace_do_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_opts</span> <span class="o">*</span><span class="n">wo</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">ptraced</span><span class="p">,</span> <span class="n">ptrace_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">wait_consider_task</span><span class="p">(</span><span class="n">wo</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">child_wait_callback</span><span class="p">(</span><span class="n">wait_queue_t</span> <span class="o">*</span><span class="n">wait</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">mode</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">sync</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wait_opts</span> <span class="o">*</span><span class="n">wo</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wait_opts</span><span class="p">,</span>
						<span class="n">child_wait</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eligible_pid</span><span class="p">(</span><span class="n">wo</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">wo</span><span class="o">-&gt;</span><span class="n">wo_flags</span> <span class="o">&amp;</span> <span class="n">__WNOTHREAD</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">wait</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">!=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">default_wake_function</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">sync</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__wake_up_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__wake_up_sync_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">wait_chldexit</span><span class="p">,</span>
				<span class="n">TASK_INTERRUPTIBLE</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">do_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_opts</span> <span class="o">*</span><span class="n">wo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">trace_sched_process_wait</span><span class="p">(</span><span class="n">wo</span><span class="o">-&gt;</span><span class="n">wo_pid</span><span class="p">);</span>

	<span class="n">init_waitqueue_func_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wo</span><span class="o">-&gt;</span><span class="n">child_wait</span><span class="p">,</span> <span class="n">child_wait_callback</span><span class="p">);</span>
	<span class="n">wo</span><span class="o">-&gt;</span><span class="n">child_wait</span><span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">wait_chldexit</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wo</span><span class="o">-&gt;</span><span class="n">child_wait</span><span class="p">);</span>
<span class="nl">repeat:</span>
	<span class="cm">/*</span>
<span class="cm">	 * If there is nothing that can match our critiera just get out.</span>
<span class="cm">	 * We will clear -&gt;notask_error to zero if we see any child that</span>
<span class="cm">	 * might later match our criteria, even if we are not able to reap</span>
<span class="cm">	 * it yet.</span>
<span class="cm">	 */</span>
	<span class="n">wo</span><span class="o">-&gt;</span><span class="n">notask_error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ECHILD</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">wo</span><span class="o">-&gt;</span><span class="n">wo_type</span> <span class="o">&lt;</span> <span class="n">PIDTYPE_MAX</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	   <span class="p">(</span><span class="o">!</span><span class="n">wo</span><span class="o">-&gt;</span><span class="n">wo_pid</span> <span class="o">||</span> <span class="n">hlist_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wo</span><span class="o">-&gt;</span><span class="n">wo_pid</span><span class="o">-&gt;</span><span class="n">tasks</span><span class="p">[</span><span class="n">wo</span><span class="o">-&gt;</span><span class="n">wo_type</span><span class="p">])))</span>
		<span class="k">goto</span> <span class="n">notask</span><span class="p">;</span>

	<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">do_wait_thread</span><span class="p">(</span><span class="n">wo</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">end</span><span class="p">;</span>

		<span class="n">retval</span> <span class="o">=</span> <span class="n">ptrace_do_wait</span><span class="p">(</span><span class="n">wo</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">end</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">wo</span><span class="o">-&gt;</span><span class="n">wo_flags</span> <span class="o">&amp;</span> <span class="n">__WNOTHREAD</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">while_each_thread</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>

<span class="nl">notask:</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">wo</span><span class="o">-&gt;</span><span class="n">notask_error</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">wo</span><span class="o">-&gt;</span><span class="n">wo_flags</span> <span class="o">&amp;</span> <span class="n">WNOHANG</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">schedule</span><span class="p">();</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">end:</span>
	<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
	<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">wait_chldexit</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wo</span><span class="o">-&gt;</span><span class="n">child_wait</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE5</span><span class="p">(</span><span class="n">waitid</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">which</span><span class="p">,</span> <span class="n">pid_t</span><span class="p">,</span> <span class="n">upid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">siginfo</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span>
		<span class="n">infop</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rusage</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">ru</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wait_opts</span> <span class="n">wo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">pid_type</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">options</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">WNOHANG</span><span class="o">|</span><span class="n">WNOWAIT</span><span class="o">|</span><span class="n">WEXITED</span><span class="o">|</span><span class="n">WSTOPPED</span><span class="o">|</span><span class="n">WCONTINUED</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">options</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">WEXITED</span><span class="o">|</span><span class="n">WSTOPPED</span><span class="o">|</span><span class="n">WCONTINUED</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">which</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">P_ALL</span>:
		<span class="n">type</span> <span class="o">=</span> <span class="n">PIDTYPE_MAX</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">P_PID</span>:
		<span class="n">type</span> <span class="o">=</span> <span class="n">PIDTYPE_PID</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">upid</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">P_PGID</span>:
		<span class="n">type</span> <span class="o">=</span> <span class="n">PIDTYPE_PGID</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">upid</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&lt;</span> <span class="n">PIDTYPE_MAX</span><span class="p">)</span>
		<span class="n">pid</span> <span class="o">=</span> <span class="n">find_get_pid</span><span class="p">(</span><span class="n">upid</span><span class="p">);</span>

	<span class="n">wo</span><span class="p">.</span><span class="n">wo_type</span>	<span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">wo</span><span class="p">.</span><span class="n">wo_pid</span>	<span class="o">=</span> <span class="n">pid</span><span class="p">;</span>
	<span class="n">wo</span><span class="p">.</span><span class="n">wo_flags</span>	<span class="o">=</span> <span class="n">options</span><span class="p">;</span>
	<span class="n">wo</span><span class="p">.</span><span class="n">wo_info</span>	<span class="o">=</span> <span class="n">infop</span><span class="p">;</span>
	<span class="n">wo</span><span class="p">.</span><span class="n">wo_stat</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">wo</span><span class="p">.</span><span class="n">wo_rusage</span>	<span class="o">=</span> <span class="n">ru</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">do_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wo</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">infop</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * For a WNOHANG return, clear out all the fields</span>
<span class="cm">		 * we would set so the user can easily tell the</span>
<span class="cm">		 * difference.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">infop</span><span class="o">-&gt;</span><span class="n">si_signo</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">infop</span><span class="o">-&gt;</span><span class="n">si_errno</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">infop</span><span class="o">-&gt;</span><span class="n">si_code</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">infop</span><span class="o">-&gt;</span><span class="n">si_pid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">infop</span><span class="o">-&gt;</span><span class="n">si_uid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">infop</span><span class="o">-&gt;</span><span class="n">si_status</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">put_pid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>

	<span class="cm">/* avoid REGPARM breakage on x86: */</span>
	<span class="n">asmlinkage_protect</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">which</span><span class="p">,</span> <span class="n">upid</span><span class="p">,</span> <span class="n">infop</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">ru</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE4</span><span class="p">(</span><span class="n">wait4</span><span class="p">,</span> <span class="n">pid_t</span><span class="p">,</span> <span class="n">upid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">stat_addr</span><span class="p">,</span>
		<span class="kt">int</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rusage</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">ru</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wait_opts</span> <span class="n">wo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">pid_type</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">options</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">WNOHANG</span><span class="o">|</span><span class="n">WUNTRACED</span><span class="o">|</span><span class="n">WCONTINUED</span><span class="o">|</span>
			<span class="n">__WNOTHREAD</span><span class="o">|</span><span class="n">__WCLONE</span><span class="o">|</span><span class="n">__WALL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">upid</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">PIDTYPE_MAX</span><span class="p">;</span>
	<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">upid</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">PIDTYPE_PGID</span><span class="p">;</span>
		<span class="n">pid</span> <span class="o">=</span> <span class="n">find_get_pid</span><span class="p">(</span><span class="o">-</span><span class="n">upid</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">upid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">PIDTYPE_PGID</span><span class="p">;</span>
		<span class="n">pid</span> <span class="o">=</span> <span class="n">get_task_pid</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">PIDTYPE_PGID</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="cm">/* upid &gt; 0 */</span> <span class="p">{</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">PIDTYPE_PID</span><span class="p">;</span>
		<span class="n">pid</span> <span class="o">=</span> <span class="n">find_get_pid</span><span class="p">(</span><span class="n">upid</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">wo</span><span class="p">.</span><span class="n">wo_type</span>	<span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">wo</span><span class="p">.</span><span class="n">wo_pid</span>	<span class="o">=</span> <span class="n">pid</span><span class="p">;</span>
	<span class="n">wo</span><span class="p">.</span><span class="n">wo_flags</span>	<span class="o">=</span> <span class="n">options</span> <span class="o">|</span> <span class="n">WEXITED</span><span class="p">;</span>
	<span class="n">wo</span><span class="p">.</span><span class="n">wo_info</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">wo</span><span class="p">.</span><span class="n">wo_stat</span>	<span class="o">=</span> <span class="n">stat_addr</span><span class="p">;</span>
	<span class="n">wo</span><span class="p">.</span><span class="n">wo_rusage</span>	<span class="o">=</span> <span class="n">ru</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">do_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wo</span><span class="p">);</span>
	<span class="n">put_pid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>

	<span class="cm">/* avoid REGPARM breakage on x86: */</span>
	<span class="n">asmlinkage_protect</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">upid</span><span class="p">,</span> <span class="n">stat_addr</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">ru</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef __ARCH_WANT_SYS_WAITPID</span>

<span class="cm">/*</span>
<span class="cm"> * sys_waitpid() remains for compatibility. waitpid() should be</span>
<span class="cm"> * implemented by calling sys_wait4() from libc.a.</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">waitpid</span><span class="p">,</span> <span class="n">pid_t</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">stat_addr</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sys_wait4</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">stat_addr</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
