<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › cpuset.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>cpuset.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  kernel/cpuset.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Processor and Memory placement constraints for sets of tasks.</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 2003 BULL SA.</span>
<span class="cm"> *  Copyright (C) 2004-2007 Silicon Graphics, Inc.</span>
<span class="cm"> *  Copyright (C) 2006 Google, Inc</span>
<span class="cm"> *</span>
<span class="cm"> *  Portions derived from Patrick Mochel&#39;s sysfs code.</span>
<span class="cm"> *  sysfs is Copyright (c) 2001-3 Patrick Mochel</span>
<span class="cm"> *</span>
<span class="cm"> *  2003-10-10 Written by Simon Derr.</span>
<span class="cm"> *  2003-10-22 Updates by Stephen Hemminger.</span>
<span class="cm"> *  2004 May-July Rework by Paul Jackson.</span>
<span class="cm"> *  2006 Rework by Paul Menage to use generic cgroups</span>
<span class="cm"> *  2008 Rework of the scheduler domains and CPU hotplug handling</span>
<span class="cm"> *       by Max Krasnyansky</span>
<span class="cm"> *</span>
<span class="cm"> *  This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> *  License.  See the file COPYING in the main directory of the Linux</span>
<span class="cm"> *  distribution for more details.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/cpumask.h&gt;</span>
<span class="cp">#include &lt;linux/cpuset.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/kmod.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/mempolicy.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/memory.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &lt;linux/namei.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/stat.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/backing-dev.h&gt;</span>
<span class="cp">#include &lt;linux/sort.h&gt;</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/cgroup.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Workqueue for cpuset related tasks.</span>
<span class="cm"> *</span>
<span class="cm"> * Using kevent workqueue may cause deadlock when memory_migrate</span>
<span class="cm"> * is set. So we create a separate workqueue thread for cpuset.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">cpuset_wq</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Tracks how many cpusets are currently defined in system.</span>
<span class="cm"> * When there is only one cpuset (the root cpuset) we can</span>
<span class="cm"> * short circuit some hooks.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">number_of_cpusets</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cm">/* Forward declare cgroup structures */</span>
<span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="n">cpuset_subsys</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">cpuset</span><span class="p">;</span>

<span class="cm">/* See &quot;Frequency meter&quot; comments, below. */</span>

<span class="k">struct</span> <span class="n">fmeter</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>		<span class="cm">/* unprocessed events count */</span>
	<span class="kt">int</span> <span class="n">val</span><span class="p">;</span>		<span class="cm">/* most recent output value */</span>
	<span class="kt">time_t</span> <span class="n">time</span><span class="p">;</span>		<span class="cm">/* clock (secs) when val computed */</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>	<span class="cm">/* guards read or write of above */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">cpuset</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="n">css</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>		<span class="cm">/* &quot;unsigned long&quot; so bitops work */</span>
	<span class="n">cpumask_var_t</span> <span class="n">cpus_allowed</span><span class="p">;</span>	<span class="cm">/* CPUs allowed to tasks in cpuset */</span>
	<span class="n">nodemask_t</span> <span class="n">mems_allowed</span><span class="p">;</span>	<span class="cm">/* Memory Nodes allowed to tasks */</span>

	<span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>		<span class="cm">/* my parent */</span>

	<span class="k">struct</span> <span class="n">fmeter</span> <span class="n">fmeter</span><span class="p">;</span>		<span class="cm">/* memory_pressure filter */</span>

	<span class="cm">/* partition number for rebuild_sched_domains() */</span>
	<span class="kt">int</span> <span class="n">pn</span><span class="p">;</span>

	<span class="cm">/* for custom sched domain */</span>
	<span class="kt">int</span> <span class="n">relax_domain_level</span><span class="p">;</span>

	<span class="cm">/* used for walking a cpuset hierarchy */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">stack_list</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Retrieve the cpuset for a cgroup */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="nf">cgroup_cs</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cont</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">cgroup_subsys_state</span><span class="p">(</span><span class="n">cont</span><span class="p">,</span> <span class="n">cpuset_subsys_id</span><span class="p">),</span>
			    <span class="k">struct</span> <span class="n">cpuset</span><span class="p">,</span> <span class="n">css</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Retrieve the cpuset for a task */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="nf">task_cs</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">task_subsys_state</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">cpuset_subsys_id</span><span class="p">),</span>
			    <span class="k">struct</span> <span class="n">cpuset</span><span class="p">,</span> <span class="n">css</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NUMA</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">task_has_mempolicy</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">mempolicy</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">task_has_mempolicy</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>


<span class="cm">/* bits in struct cpuset flags field */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">CS_CPU_EXCLUSIVE</span><span class="p">,</span>
	<span class="n">CS_MEM_EXCLUSIVE</span><span class="p">,</span>
	<span class="n">CS_MEM_HARDWALL</span><span class="p">,</span>
	<span class="n">CS_MEMORY_MIGRATE</span><span class="p">,</span>
	<span class="n">CS_SCHED_LOAD_BALANCE</span><span class="p">,</span>
	<span class="n">CS_SPREAD_PAGE</span><span class="p">,</span>
	<span class="n">CS_SPREAD_SLAB</span><span class="p">,</span>
<span class="p">}</span> <span class="n">cpuset_flagbits_t</span><span class="p">;</span>

<span class="cm">/* convenient tests for these bits */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_cpu_exclusive</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">CS_CPU_EXCLUSIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_mem_exclusive</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">CS_MEM_EXCLUSIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_mem_hardwall</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">CS_MEM_HARDWALL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_sched_load_balance</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">CS_SCHED_LOAD_BALANCE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_memory_migrate</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">CS_MEMORY_MIGRATE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_spread_page</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">CS_SPREAD_PAGE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_spread_slab</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">CS_SPREAD_SLAB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cpuset</span> <span class="n">top_cpuset</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">CS_CPU_EXCLUSIVE</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">CS_MEM_EXCLUSIVE</span><span class="p">)),</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * There are two global mutexes guarding cpuset structures.  The first</span>
<span class="cm"> * is the main control groups cgroup_mutex, accessed via</span>
<span class="cm"> * cgroup_lock()/cgroup_unlock().  The second is the cpuset-specific</span>
<span class="cm"> * callback_mutex, below. They can nest.  It is ok to first take</span>
<span class="cm"> * cgroup_mutex, then nest callback_mutex.  We also require taking</span>
<span class="cm"> * task_lock() when dereferencing a task&#39;s cpuset pointer.  See &quot;The</span>
<span class="cm"> * task_lock() exception&quot;, at the end of this comment.</span>
<span class="cm"> *</span>
<span class="cm"> * A task must hold both mutexes to modify cpusets.  If a task</span>
<span class="cm"> * holds cgroup_mutex, then it blocks others wanting that mutex,</span>
<span class="cm"> * ensuring that it is the only task able to also acquire callback_mutex</span>
<span class="cm"> * and be able to modify cpusets.  It can perform various checks on</span>
<span class="cm"> * the cpuset structure first, knowing nothing will change.  It can</span>
<span class="cm"> * also allocate memory while just holding cgroup_mutex.  While it is</span>
<span class="cm"> * performing these checks, various callback routines can briefly</span>
<span class="cm"> * acquire callback_mutex to query cpusets.  Once it is ready to make</span>
<span class="cm"> * the changes, it takes callback_mutex, blocking everyone else.</span>
<span class="cm"> *</span>
<span class="cm"> * Calls to the kernel memory allocator can not be made while holding</span>
<span class="cm"> * callback_mutex, as that would risk double tripping on callback_mutex</span>
<span class="cm"> * from one of the callbacks into the cpuset code from within</span>
<span class="cm"> * __alloc_pages().</span>
<span class="cm"> *</span>
<span class="cm"> * If a task is only holding callback_mutex, then it has read-only</span>
<span class="cm"> * access to cpusets.</span>
<span class="cm"> *</span>
<span class="cm"> * Now, the task_struct fields mems_allowed and mempolicy may be changed</span>
<span class="cm"> * by other task, we use alloc_lock in the task_struct fields to protect</span>
<span class="cm"> * them.</span>
<span class="cm"> *</span>
<span class="cm"> * The cpuset_common_file_read() handlers only hold callback_mutex across</span>
<span class="cm"> * small pieces of code, such as when reading out possibly multi-word</span>
<span class="cm"> * cpumasks and nodemasks.</span>
<span class="cm"> *</span>
<span class="cm"> * Accessing a task&#39;s cpuset should be done in accordance with the</span>
<span class="cm"> * guidelines for accessing subsystem state in kernel/cgroup.c</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">callback_mutex</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * cpuset_buffer_lock protects both the cpuset_name and cpuset_nodelist</span>
<span class="cm"> * buffers.  They are statically allocated to prevent using excess stack</span>
<span class="cm"> * when calling cpuset_print_task_mems_allowed().</span>
<span class="cm"> */</span>
<span class="cp">#define CPUSET_NAME_LEN		(128)</span>
<span class="cp">#define	CPUSET_NODELIST_LEN	(256)</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">cpuset_name</span><span class="p">[</span><span class="n">CPUSET_NAME_LEN</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">cpuset_nodelist</span><span class="p">[</span><span class="n">CPUSET_NODELIST_LEN</span><span class="p">];</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">cpuset_buffer_lock</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * This is ugly, but preserves the userspace API for existing cpuset</span>
<span class="cm"> * users. If someone tries to mount the &quot;cpuset&quot; filesystem, we</span>
<span class="cm"> * silently switch it to mount &quot;cgroup&quot; instead</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">cpuset_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">fs_type</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">unused_dev_name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">cgroup_fs</span> <span class="o">=</span> <span class="n">get_fs_type</span><span class="p">(</span><span class="s">&quot;cgroup&quot;</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cgroup_fs</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">mountopts</span><span class="p">[]</span> <span class="o">=</span>
			<span class="s">&quot;cpuset,noprefix,&quot;</span>
			<span class="s">&quot;release_agent=/sbin/cpuset_release_agent&quot;</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">cgroup_fs</span><span class="o">-&gt;</span><span class="n">mount</span><span class="p">(</span><span class="n">cgroup_fs</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span>
					   <span class="n">unused_dev_name</span><span class="p">,</span> <span class="n">mountopts</span><span class="p">);</span>
		<span class="n">put_filesystem</span><span class="p">(</span><span class="n">cgroup_fs</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">file_system_type</span> <span class="n">cpuset_fs_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;cpuset&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mount</span> <span class="o">=</span> <span class="n">cpuset_mount</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Return in pmask the portion of a cpusets&#39;s cpus_allowed that</span>
<span class="cm"> * are online.  If none are online, walk up the cpuset hierarchy</span>
<span class="cm"> * until we find one that does have some online cpus.  If we get</span>
<span class="cm"> * all the way to the top and still haven&#39;t found any online cpus,</span>
<span class="cm"> * return cpu_online_mask.  Or if passed a NULL cs from an exit&#39;ing</span>
<span class="cm"> * task, return cpu_online_mask.</span>
<span class="cm"> *</span>
<span class="cm"> * One way or another, we guarantee to return some non-empty subset</span>
<span class="cm"> * of cpu_online_mask.</span>
<span class="cm"> *</span>
<span class="cm"> * Call with callback_mutex held.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">guarantee_online_cpus</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cs</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">pmask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cs</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cpumask_intersects</span><span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">,</span> <span class="n">cpu_online_mask</span><span class="p">))</span>
		<span class="n">cs</span> <span class="o">=</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cs</span><span class="p">)</span>
		<span class="n">cpumask_and</span><span class="p">(</span><span class="n">pmask</span><span class="p">,</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">,</span> <span class="n">cpu_online_mask</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">pmask</span><span class="p">,</span> <span class="n">cpu_online_mask</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cpumask_intersects</span><span class="p">(</span><span class="n">pmask</span><span class="p">,</span> <span class="n">cpu_online_mask</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return in *pmask the portion of a cpusets&#39;s mems_allowed that</span>
<span class="cm"> * are online, with memory.  If none are online with memory, walk</span>
<span class="cm"> * up the cpuset hierarchy until we find one that does have some</span>
<span class="cm"> * online mems.  If we get all the way to the top and still haven&#39;t</span>
<span class="cm"> * found any online mems, return node_states[N_HIGH_MEMORY].</span>
<span class="cm"> *</span>
<span class="cm"> * One way or another, we guarantee to return some non-empty subset</span>
<span class="cm"> * of node_states[N_HIGH_MEMORY].</span>
<span class="cm"> *</span>
<span class="cm"> * Call with callback_mutex held.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">guarantee_online_mems</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cs</span><span class="p">,</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">pmask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cs</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">nodes_intersects</span><span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">,</span>
					<span class="n">node_states</span><span class="p">[</span><span class="n">N_HIGH_MEMORY</span><span class="p">]))</span>
		<span class="n">cs</span> <span class="o">=</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cs</span><span class="p">)</span>
		<span class="n">nodes_and</span><span class="p">(</span><span class="o">*</span><span class="n">pmask</span><span class="p">,</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">,</span>
					<span class="n">node_states</span><span class="p">[</span><span class="n">N_HIGH_MEMORY</span><span class="p">]);</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">pmask</span> <span class="o">=</span> <span class="n">node_states</span><span class="p">[</span><span class="n">N_HIGH_MEMORY</span><span class="p">];</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">nodes_intersects</span><span class="p">(</span><span class="o">*</span><span class="n">pmask</span><span class="p">,</span> <span class="n">node_states</span><span class="p">[</span><span class="n">N_HIGH_MEMORY</span><span class="p">]));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * update task&#39;s spread flag if cpuset&#39;s page/slab spread flag is set</span>
<span class="cm"> *</span>
<span class="cm"> * Called with callback_mutex/cgroup_mutex held</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cpuset_update_task_spread_flag</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cs</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_spread_page</span><span class="p">(</span><span class="n">cs</span><span class="p">))</span>
		<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PF_SPREAD_PAGE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PF_SPREAD_PAGE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_spread_slab</span><span class="p">(</span><span class="n">cs</span><span class="p">))</span>
		<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PF_SPREAD_SLAB</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PF_SPREAD_SLAB</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * is_cpuset_subset(p, q) - Is cpuset p a subset of cpuset q?</span>
<span class="cm"> *</span>
<span class="cm"> * One cpuset is a subset of another if all its allowed CPUs and</span>
<span class="cm"> * Memory Nodes are a subset of the other, and its exclusive flags</span>
<span class="cm"> * are only set if the other&#39;s are set.  Call holding cgroup_mutex.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_cpuset_subset</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span>	<span class="n">cpumask_subset</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">nodes_subset</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">is_cpu_exclusive</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">is_cpu_exclusive</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">is_mem_exclusive</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">is_mem_exclusive</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * alloc_trial_cpuset - allocate a trial cpuset</span>
<span class="cm"> * @cs: the cpuset that the trial cpuset duplicates</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="nf">alloc_trial_cpuset</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">trial</span><span class="p">;</span>

	<span class="n">trial</span> <span class="o">=</span> <span class="n">kmemdup</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cs</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trial</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trial</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">trial</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">trial</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">,</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">trial</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * free_trial_cpuset - free the trial cpuset</span>
<span class="cm"> * @trial: the trial cpuset to be freed</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_trial_cpuset</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">trial</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">trial</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">trial</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * validate_change() - Used to validate that any proposed cpuset change</span>
<span class="cm"> *		       follows the structural rules for cpusets.</span>
<span class="cm"> *</span>
<span class="cm"> * If we replaced the flag and mask values of the current cpuset</span>
<span class="cm"> * (cur) with those values in the trial cpuset (trial), would</span>
<span class="cm"> * our various subset and exclusive rules still be valid?  Presumes</span>
<span class="cm"> * cgroup_mutex held.</span>
<span class="cm"> *</span>
<span class="cm"> * &#39;cur&#39; is the address of an actual, in-use cpuset.  Operations</span>
<span class="cm"> * such as list traversal that depend on the actual address of the</span>
<span class="cm"> * cpuset in the list must use cur below, not trial.</span>
<span class="cm"> *</span>
<span class="cm"> * &#39;trial&#39; is the address of bulk structure copy of cur, with</span>
<span class="cm"> * perhaps one or more of the fields cpus_allowed, mems_allowed,</span>
<span class="cm"> * or flags changed to new, trial values.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if valid, -errno if not.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">validate_change</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cur</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">trial</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cont</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="o">*</span><span class="n">par</span><span class="p">;</span>

	<span class="cm">/* Each of our child cpusets must be a subset of us */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">cont</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">.</span><span class="n">cgroup</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">,</span> <span class="n">sibling</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_cpuset_subset</span><span class="p">(</span><span class="n">cgroup_cs</span><span class="p">(</span><span class="n">cont</span><span class="p">),</span> <span class="n">trial</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Remaining checks don&#39;t apply to root cpuset */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cur</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">top_cpuset</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">par</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>

	<span class="cm">/* We must be a subset of our parent cpuset */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_cpuset_subset</span><span class="p">(</span><span class="n">trial</span><span class="p">,</span> <span class="n">par</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If either I or some sibling (!= me) is exclusive, we can&#39;t</span>
<span class="cm">	 * overlap</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">cont</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">par</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">.</span><span class="n">cgroup</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">,</span> <span class="n">sibling</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">cgroup_cs</span><span class="p">(</span><span class="n">cont</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">is_cpu_exclusive</span><span class="p">(</span><span class="n">trial</span><span class="p">)</span> <span class="o">||</span> <span class="n">is_cpu_exclusive</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		    <span class="n">c</span> <span class="o">!=</span> <span class="n">cur</span> <span class="o">&amp;&amp;</span>
		    <span class="n">cpumask_intersects</span><span class="p">(</span><span class="n">trial</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">is_mem_exclusive</span><span class="p">(</span><span class="n">trial</span><span class="p">)</span> <span class="o">||</span> <span class="n">is_mem_exclusive</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		    <span class="n">c</span> <span class="o">!=</span> <span class="n">cur</span> <span class="o">&amp;&amp;</span>
		    <span class="n">nodes_intersects</span><span class="p">(</span><span class="n">trial</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Cpusets with tasks can&#39;t have empty cpus_allowed or mems_allowed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cgroup_task_count</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">.</span><span class="n">cgroup</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="n">trial</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">nodes_empty</span><span class="p">(</span><span class="n">trial</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cm">/*</span>
<span class="cm"> * Helper routine for generate_sched_domains().</span>
<span class="cm"> * Do cpusets a, b have overlapping cpus_allowed masks?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cpusets_overlap</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cpumask_intersects</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">update_domain_attr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain_attr</span> <span class="o">*</span><span class="n">dattr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dattr</span><span class="o">-&gt;</span><span class="n">relax_domain_level</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">relax_domain_level</span><span class="p">)</span>
		<span class="n">dattr</span><span class="o">-&gt;</span><span class="n">relax_domain_level</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">relax_domain_level</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">update_domain_attr_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain_attr</span> <span class="o">*</span><span class="n">dattr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">stack_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cont</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>

		<span class="n">cp</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cpuset</span><span class="p">,</span> <span class="n">stack_list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_sched_load_balance</span><span class="p">(</span><span class="n">cp</span><span class="p">))</span>
			<span class="n">update_domain_attr</span><span class="p">(</span><span class="n">dattr</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>

		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">cont</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">.</span><span class="n">cgroup</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">,</span> <span class="n">sibling</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">child</span> <span class="o">=</span> <span class="n">cgroup_cs</span><span class="p">(</span><span class="n">cont</span><span class="p">);</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">stack_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * generate_sched_domains()</span>
<span class="cm"> *</span>
<span class="cm"> * This function builds a partial partition of the systems CPUs</span>
<span class="cm"> * A &#39;partial partition&#39; is a set of non-overlapping subsets whose</span>
<span class="cm"> * union is a subset of that set.</span>
<span class="cm"> * The output of this function needs to be passed to kernel/sched.c</span>
<span class="cm"> * partition_sched_domains() routine, which will rebuild the scheduler&#39;s</span>
<span class="cm"> * load balancing domains (sched domains) as specified by that partial</span>
<span class="cm"> * partition.</span>
<span class="cm"> *</span>
<span class="cm"> * See &quot;What is sched_load_balance&quot; in Documentation/cgroups/cpusets.txt</span>
<span class="cm"> * for a background explanation of this.</span>
<span class="cm"> *</span>
<span class="cm"> * Does not return errors, on the theory that the callers of this</span>
<span class="cm"> * routine would rather not worry about failures to rebuild sched</span>
<span class="cm"> * domains when operating in the severe memory shortage situations</span>
<span class="cm"> * that could cause allocation failures below.</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called with cgroup_lock held.</span>
<span class="cm"> *</span>
<span class="cm"> * The three key local variables below are:</span>
<span class="cm"> *    q  - a linked-list queue of cpuset pointers, used to implement a</span>
<span class="cm"> *	   top-down scan of all cpusets.  This scan loads a pointer</span>
<span class="cm"> *	   to each cpuset marked is_sched_load_balance into the</span>
<span class="cm"> *	   array &#39;csa&#39;.  For our purposes, rebuilding the schedulers</span>
<span class="cm"> *	   sched domains, we can ignore !is_sched_load_balance cpusets.</span>
<span class="cm"> *  csa  - (for CpuSet Array) Array of pointers to all the cpusets</span>
<span class="cm"> *	   that need to be load balanced, for convenient iterative</span>
<span class="cm"> *	   access by the subsequent code that finds the best partition,</span>
<span class="cm"> *	   i.e the set of domains (subsets) of CPUs such that the</span>
<span class="cm"> *	   cpus_allowed of every cpuset marked is_sched_load_balance</span>
<span class="cm"> *	   is a subset of one of these domains, while there are as</span>
<span class="cm"> *	   many such domains as possible, each as small as possible.</span>
<span class="cm"> * doms  - Conversion of &#39;csa&#39; to an array of cpumasks, for passing to</span>
<span class="cm"> *	   the kernel/sched.c routine partition_sched_domains() in a</span>
<span class="cm"> *	   convenient format, that can be easily compared to the prior</span>
<span class="cm"> *	   value to determine what partition elements (sched domains)</span>
<span class="cm"> *	   were changed (added or removed.)</span>
<span class="cm"> *</span>
<span class="cm"> * Finding the best partition (set of domains):</span>
<span class="cm"> *	The triple nested loops below over i, j, k scan over the</span>
<span class="cm"> *	load balanced cpusets (using the array of cpuset pointers in</span>
<span class="cm"> *	csa[]) looking for pairs of cpusets that have overlapping</span>
<span class="cm"> *	cpus_allowed, but which don&#39;t have the same &#39;pn&#39; partition</span>
<span class="cm"> *	number and gives them in the same partition number.  It keeps</span>
<span class="cm"> *	looping on the &#39;restart&#39; label until it can no longer find</span>
<span class="cm"> *	any such pairs.</span>
<span class="cm"> *</span>
<span class="cm"> *	The union of the cpus_allowed masks from the set of</span>
<span class="cm"> *	all cpusets having the same &#39;pn&#39; value then form the one</span>
<span class="cm"> *	element of the partition (one sched domain) to be passed to</span>
<span class="cm"> *	partition_sched_domains().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">generate_sched_domains</span><span class="p">(</span><span class="n">cpumask_var_t</span> <span class="o">**</span><span class="n">domains</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">sched_domain_attr</span> <span class="o">**</span><span class="n">attributes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>		<span class="cm">/* queue of cpusets to be scanned */</span>
	<span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>	<span class="cm">/* scans q */</span>
	<span class="k">struct</span> <span class="n">cpuset</span> <span class="o">**</span><span class="n">csa</span><span class="p">;</span>	<span class="cm">/* array of all cpuset ptrs */</span>
	<span class="kt">int</span> <span class="n">csn</span><span class="p">;</span>		<span class="cm">/* how many cpuset ptrs in csa so far */</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>		<span class="cm">/* indices for partition finding loops */</span>
	<span class="n">cpumask_var_t</span> <span class="o">*</span><span class="n">doms</span><span class="p">;</span>	<span class="cm">/* resulting partition; i.e. sched domains */</span>
	<span class="k">struct</span> <span class="n">sched_domain_attr</span> <span class="o">*</span><span class="n">dattr</span><span class="p">;</span>  <span class="cm">/* attributes for custom domains */</span>
	<span class="kt">int</span> <span class="n">ndoms</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* number of sched domains in result */</span>
	<span class="kt">int</span> <span class="n">nslot</span><span class="p">;</span>		<span class="cm">/* next empty doms[] struct cpumask slot */</span>

	<span class="n">doms</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dattr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">csa</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Special case for the 99% of systems with one, full, sched domain */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_sched_load_balance</span><span class="p">(</span><span class="o">&amp;</span><span class="n">top_cpuset</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ndoms</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">doms</span> <span class="o">=</span> <span class="n">alloc_sched_domains</span><span class="p">(</span><span class="n">ndoms</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">doms</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

		<span class="n">dattr</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain_attr</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dattr</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">dattr</span> <span class="o">=</span> <span class="n">SD_ATTR_INIT</span><span class="p">;</span>
			<span class="n">update_domain_attr_tree</span><span class="p">(</span><span class="n">dattr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">top_cpuset</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">doms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">top_cpuset</span><span class="p">.</span><span class="n">cpus_allowed</span><span class="p">);</span>

		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">csa</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">number_of_cpusets</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cp</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">csa</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="n">csn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">top_cpuset</span><span class="p">.</span><span class="n">stack_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cont</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>   <span class="cm">/* scans child cpusets of cp */</span>

		<span class="n">cp</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cpuset</span><span class="p">,</span> <span class="n">stack_list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * All child cpusets contain a subset of the parent&#39;s cpus, so</span>
<span class="cm">		 * just skip them, and then we call update_domain_attr_tree()</span>
<span class="cm">		 * to calc relax_domain_level of the corresponding sched</span>
<span class="cm">		 * domain.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_sched_load_balance</span><span class="p">(</span><span class="n">cp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">csa</span><span class="p">[</span><span class="n">csn</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">cp</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">cont</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">.</span><span class="n">cgroup</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">,</span> <span class="n">sibling</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">child</span> <span class="o">=</span> <span class="n">cgroup_cs</span><span class="p">(</span><span class="n">cont</span><span class="p">);</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">stack_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">);</span>
		<span class="p">}</span>
  	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">csn</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">csa</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">pn</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">ndoms</span> <span class="o">=</span> <span class="n">csn</span><span class="p">;</span>

<span class="nl">restart:</span>
	<span class="cm">/* Find the best partition (set of sched domains) */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">csn</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="n">csa</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">apn</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">pn</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">csn</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">csa</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
			<span class="kt">int</span> <span class="n">bpn</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">pn</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">apn</span> <span class="o">!=</span> <span class="n">bpn</span> <span class="o">&amp;&amp;</span> <span class="n">cpusets_overlap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">csn</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">csa</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>

					<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">pn</span> <span class="o">==</span> <span class="n">bpn</span><span class="p">)</span>
						<span class="n">c</span><span class="o">-&gt;</span><span class="n">pn</span> <span class="o">=</span> <span class="n">apn</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">ndoms</span><span class="o">--</span><span class="p">;</span>	<span class="cm">/* one less element */</span>
				<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now we know how many domains to create.</span>
<span class="cm">	 * Convert &lt;csn, csa&gt; to &lt;ndoms, doms&gt; and populate cpu masks.</span>
<span class="cm">	 */</span>
	<span class="n">doms</span> <span class="o">=</span> <span class="n">alloc_sched_domains</span><span class="p">(</span><span class="n">ndoms</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">doms</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The rest of the code, including the scheduler, can deal with</span>
<span class="cm">	 * dattr==NULL case. No need to abort if alloc fails.</span>
<span class="cm">	 */</span>
	<span class="n">dattr</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">ndoms</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain_attr</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">nslot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">csn</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="n">csa</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">apn</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">pn</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">apn</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Skip completed partitions */</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">dp</span> <span class="o">=</span> <span class="n">doms</span><span class="p">[</span><span class="n">nslot</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nslot</span> <span class="o">==</span> <span class="n">ndoms</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">static</span> <span class="kt">int</span> <span class="n">warnings</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">warnings</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
				 <span class="s">&quot;rebuild_sched_domains confused:&quot;</span>
				  <span class="s">&quot; nslot %d, ndoms %d, csn %d, i %d,&quot;</span>
				  <span class="s">&quot; apn %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">nslot</span><span class="p">,</span> <span class="n">ndoms</span><span class="p">,</span> <span class="n">csn</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">apn</span><span class="p">);</span>
				<span class="n">warnings</span><span class="o">--</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">cpumask_clear</span><span class="p">(</span><span class="n">dp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dattr</span><span class="p">)</span>
			<span class="o">*</span><span class="p">(</span><span class="n">dattr</span> <span class="o">+</span> <span class="n">nslot</span><span class="p">)</span> <span class="o">=</span> <span class="n">SD_ATTR_INIT</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">csn</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">csa</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">apn</span> <span class="o">==</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">pn</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cpumask_or</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">dattr</span><span class="p">)</span>
					<span class="n">update_domain_attr_tree</span><span class="p">(</span><span class="n">dattr</span> <span class="o">+</span> <span class="n">nslot</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>

				<span class="cm">/* Done with this partition */</span>
				<span class="n">b</span><span class="o">-&gt;</span><span class="n">pn</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">nslot</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">nslot</span> <span class="o">!=</span> <span class="n">ndoms</span><span class="p">);</span>

<span class="nl">done:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">csa</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fallback to the default domain if kmalloc() failed.</span>
<span class="cm">	 * See comments in partition_sched_domains().</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">doms</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">ndoms</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="o">*</span><span class="n">domains</span>    <span class="o">=</span> <span class="n">doms</span><span class="p">;</span>
	<span class="o">*</span><span class="n">attributes</span> <span class="o">=</span> <span class="n">dattr</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ndoms</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Rebuild scheduler domains.</span>
<span class="cm"> *</span>
<span class="cm"> * Call with neither cgroup_mutex held nor within get_online_cpus().</span>
<span class="cm"> * Takes both cgroup_mutex and get_online_cpus().</span>
<span class="cm"> *</span>
<span class="cm"> * Cannot be directly called from cpuset code handling changes</span>
<span class="cm"> * to the cpuset pseudo-filesystem, because it cannot be called</span>
<span class="cm"> * from code that already holds cgroup_mutex.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_rebuild_sched_domains</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_domain_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">;</span>
	<span class="n">cpumask_var_t</span> <span class="o">*</span><span class="n">doms</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ndoms</span><span class="p">;</span>

	<span class="n">get_online_cpus</span><span class="p">();</span>

	<span class="cm">/* Generate domain masks and attrs */</span>
	<span class="n">cgroup_lock</span><span class="p">();</span>
	<span class="n">ndoms</span> <span class="o">=</span> <span class="n">generate_sched_domains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">doms</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
	<span class="n">cgroup_unlock</span><span class="p">();</span>

	<span class="cm">/* Have scheduler rebuild the domains */</span>
	<span class="n">partition_sched_domains</span><span class="p">(</span><span class="n">ndoms</span><span class="p">,</span> <span class="n">doms</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>

	<span class="n">put_online_cpus</span><span class="p">();</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* !CONFIG_SMP */</span><span class="cp"></span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_rebuild_sched_domains</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">generate_sched_domains</span><span class="p">(</span><span class="n">cpumask_var_t</span> <span class="o">**</span><span class="n">domains</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">sched_domain_attr</span> <span class="o">**</span><span class="n">attributes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">domains</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="k">static</span> <span class="n">DECLARE_WORK</span><span class="p">(</span><span class="n">rebuild_sched_domains_work</span><span class="p">,</span> <span class="n">do_rebuild_sched_domains</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Rebuild scheduler domains, asynchronously via workqueue.</span>
<span class="cm"> *</span>
<span class="cm"> * If the flag &#39;sched_load_balance&#39; of any cpuset with non-empty</span>
<span class="cm"> * &#39;cpus&#39; changes, or if the &#39;cpus&#39; allowed changes in any cpuset</span>
<span class="cm"> * which has that flag enabled, or if any cpuset with a non-empty</span>
<span class="cm"> * &#39;cpus&#39; is removed, then call this routine to rebuild the</span>
<span class="cm"> * scheduler&#39;s dynamic sched domains.</span>
<span class="cm"> *</span>
<span class="cm"> * The rebuild_sched_domains() and partition_sched_domains()</span>
<span class="cm"> * routines must nest cgroup_lock() inside get_online_cpus(),</span>
<span class="cm"> * but such cpuset changes as these must nest that locking the</span>
<span class="cm"> * other way, holding cgroup_lock() for much of the code.</span>
<span class="cm"> *</span>
<span class="cm"> * So in order to avoid an ABBA deadlock, the cpuset code handling</span>
<span class="cm"> * these user changes delegates the actual sched domain rebuilding</span>
<span class="cm"> * to a separate workqueue thread, which ends up processing the</span>
<span class="cm"> * above do_rebuild_sched_domains() function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">async_rebuild_sched_domains</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">queue_work</span><span class="p">(</span><span class="n">cpuset_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rebuild_sched_domains_work</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Accomplishes the same scheduler domain rebuild as the above</span>
<span class="cm"> * async_rebuild_sched_domains(), however it directly calls the</span>
<span class="cm"> * rebuild routine synchronously rather than calling it via an</span>
<span class="cm"> * asynchronous work thread.</span>
<span class="cm"> *</span>
<span class="cm"> * This can only be called from code that is not holding</span>
<span class="cm"> * cgroup_mutex (not nested in a cgroup_lock() call.)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">rebuild_sched_domains</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">do_rebuild_sched_domains</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpuset_test_cpumask - test a task&#39;s cpus_allowed versus its cpuset&#39;s</span>
<span class="cm"> * @tsk: task to test</span>
<span class="cm"> * @scan: struct cgroup_scanner contained in its struct cpuset_hotplug_scanner</span>
<span class="cm"> *</span>
<span class="cm"> * Call with cgroup_mutex held.  May take callback_mutex during call.</span>
<span class="cm"> * Called for each task in a cgroup by cgroup_scan_tasks().</span>
<span class="cm"> * Return nonzero if this tasks&#39;s cpus_allowed mask should be changed (in other</span>
<span class="cm"> * words, if its mask is not equal to its cpuset&#39;s mask).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cpuset_test_cpumask</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">cgroup_scanner</span> <span class="o">*</span><span class="n">scan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">cpumask_equal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">,</span>
			<span class="p">(</span><span class="n">cgroup_cs</span><span class="p">(</span><span class="n">scan</span><span class="o">-&gt;</span><span class="n">cg</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpuset_change_cpumask - make a task&#39;s cpus_allowed the same as its cpuset&#39;s</span>
<span class="cm"> * @tsk: task to test</span>
<span class="cm"> * @scan: struct cgroup_scanner containing the cgroup of the task</span>
<span class="cm"> *</span>
<span class="cm"> * Called by cgroup_scan_tasks() for each task in a cgroup whose</span>
<span class="cm"> * cpus_allowed mask needs to be changed.</span>
<span class="cm"> *</span>
<span class="cm"> * We don&#39;t need to re-check for the cgroup/cpuset membership, since we&#39;re</span>
<span class="cm"> * holding cgroup_lock() at this point.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cpuset_change_cpumask</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">cgroup_scanner</span> <span class="o">*</span><span class="n">scan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_cpus_allowed_ptr</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="p">((</span><span class="n">cgroup_cs</span><span class="p">(</span><span class="n">scan</span><span class="o">-&gt;</span><span class="n">cg</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * update_tasks_cpumask - Update the cpumasks of tasks in the cpuset.</span>
<span class="cm"> * @cs: the cpuset in which each task&#39;s cpus_allowed mask needs to be changed</span>
<span class="cm"> * @heap: if NULL, defer allocating heap memory to cgroup_scan_tasks()</span>
<span class="cm"> *</span>
<span class="cm"> * Called with cgroup_mutex held</span>
<span class="cm"> *</span>
<span class="cm"> * The cgroup_scan_tasks() function will scan all the tasks in a cgroup,</span>
<span class="cm"> * calling callback functions for each.</span>
<span class="cm"> *</span>
<span class="cm"> * No return value. It&#39;s guaranteed that cgroup_scan_tasks() always returns 0</span>
<span class="cm"> * if @heap != NULL.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_tasks_cpumask</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ptr_heap</span> <span class="o">*</span><span class="n">heap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup_scanner</span> <span class="n">scan</span><span class="p">;</span>

	<span class="n">scan</span><span class="p">.</span><span class="n">cg</span> <span class="o">=</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">.</span><span class="n">cgroup</span><span class="p">;</span>
	<span class="n">scan</span><span class="p">.</span><span class="n">test_task</span> <span class="o">=</span> <span class="n">cpuset_test_cpumask</span><span class="p">;</span>
	<span class="n">scan</span><span class="p">.</span><span class="n">process_task</span> <span class="o">=</span> <span class="n">cpuset_change_cpumask</span><span class="p">;</span>
	<span class="n">scan</span><span class="p">.</span><span class="n">heap</span> <span class="o">=</span> <span class="n">heap</span><span class="p">;</span>
	<span class="n">cgroup_scan_tasks</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scan</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * update_cpumask - update the cpus_allowed mask of a cpuset and all tasks in it</span>
<span class="cm"> * @cs: the cpuset to consider</span>
<span class="cm"> * @buf: buffer of cpu numbers written to this cpuset</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">update_cpumask</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">trialcs</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ptr_heap</span> <span class="n">heap</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_load_balanced</span><span class="p">;</span>

	<span class="cm">/* top_cpuset.cpus_allowed tracks cpu_online_mask; it&#39;s read-only */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cs</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">top_cpuset</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * An empty cpus_allowed is ok only if the cpuset has no tasks.</span>
<span class="cm">	 * Since cpulist_parse() fails on an empty mask, we special case</span>
<span class="cm">	 * that parsing.  The validate_change() call ensures that cpusets</span>
<span class="cm">	 * with tasks have cpus.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpumask_clear</span><span class="p">(</span><span class="n">trialcs</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">cpulist_parse</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">trialcs</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_subset</span><span class="p">(</span><span class="n">trialcs</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">,</span> <span class="n">cpu_active_mask</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">validate_change</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">trialcs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="cm">/* Nothing to do if the cpus didn&#39;t change */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_equal</span><span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">,</span> <span class="n">trialcs</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">heap_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">heap</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">is_load_balanced</span> <span class="o">=</span> <span class="n">is_sched_load_balance</span><span class="p">(</span><span class="n">trialcs</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callback_mutex</span><span class="p">);</span>
	<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">,</span> <span class="n">trialcs</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callback_mutex</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Scan tasks in the cpuset, and update the cpumasks of any</span>
<span class="cm">	 * that need an update.</span>
<span class="cm">	 */</span>
	<span class="n">update_tasks_cpumask</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">heap</span><span class="p">);</span>

	<span class="n">heap_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">heap</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_load_balanced</span><span class="p">)</span>
		<span class="n">async_rebuild_sched_domains</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * cpuset_migrate_mm</span>
<span class="cm"> *</span>
<span class="cm"> *    Migrate memory region from one set of nodes to another.</span>
<span class="cm"> *</span>
<span class="cm"> *    Temporarilly set tasks mems_allowed to target nodes of migration,</span>
<span class="cm"> *    so that the migration code can allocate pages on these nodes.</span>
<span class="cm"> *</span>
<span class="cm"> *    Call holding cgroup_mutex, so current&#39;s cpuset won&#39;t change</span>
<span class="cm"> *    during this call, as manage_mutex holds off any cpuset_attach()</span>
<span class="cm"> *    calls.  Therefore we don&#39;t need to take task_lock around the</span>
<span class="cm"> *    call to guarantee_online_mems(), as we know no one is changing</span>
<span class="cm"> *    our task&#39;s cpuset.</span>
<span class="cm"> *</span>
<span class="cm"> *    While the mm_struct we are migrating is typically from some</span>
<span class="cm"> *    other task, the task_struct mems_allowed that we are hacking</span>
<span class="cm"> *    is for our current task, which must allocate new pages for that</span>
<span class="cm"> *    migrating memory region.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cpuset_migrate_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span>
							<span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">to</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">mems_allowed</span> <span class="o">=</span> <span class="o">*</span><span class="n">to</span><span class="p">;</span>

	<span class="n">do_migrate_pages</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">MPOL_MF_MOVE_ALL</span><span class="p">);</span>

	<span class="n">guarantee_online_mems</span><span class="p">(</span><span class="n">task_cs</span><span class="p">(</span><span class="n">tsk</span><span class="p">),</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * cpuset_change_task_nodemask - change task&#39;s mems_allowed and mempolicy</span>
<span class="cm"> * @tsk: the task to change</span>
<span class="cm"> * @newmems: new nodes that the task will be set</span>
<span class="cm"> *</span>
<span class="cm"> * In order to avoid seeing no nodes if the old and new nodes are disjoint,</span>
<span class="cm"> * we structure updates as setting all new allowed nodes, then clearing newly</span>
<span class="cm"> * disallowed ones.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cpuset_change_task_nodemask</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
					<span class="n">nodemask_t</span> <span class="o">*</span><span class="n">newmems</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">need_loop</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allow tasks that have access to memory reserves because they have</span>
<span class="cm">	 * been OOM killed to get memory anywhere.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">test_thread_flag</span><span class="p">(</span><span class="n">TIF_MEMDIE</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_EXITING</span><span class="p">)</span> <span class="cm">/* Let dying task have memory */</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">task_lock</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Determine if a loop is necessary if another thread is doing</span>
<span class="cm">	 * get_mems_allowed().  If at least one node remains unchanged and</span>
<span class="cm">	 * tsk does not have a mempolicy, then an empty nodemask will not be</span>
<span class="cm">	 * possible when mems_allowed is larger than a word.</span>
<span class="cm">	 */</span>
	<span class="n">need_loop</span> <span class="o">=</span> <span class="n">task_has_mempolicy</span><span class="p">(</span><span class="n">tsk</span><span class="p">)</span> <span class="o">||</span>
			<span class="o">!</span><span class="n">nodes_intersects</span><span class="p">(</span><span class="o">*</span><span class="n">newmems</span><span class="p">,</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">need_loop</span><span class="p">)</span>
		<span class="n">write_seqcount_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">mems_allowed_seq</span><span class="p">);</span>

	<span class="n">nodes_or</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">,</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">,</span> <span class="o">*</span><span class="n">newmems</span><span class="p">);</span>
	<span class="n">mpol_rebind_task</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">newmems</span><span class="p">,</span> <span class="n">MPOL_REBIND_STEP1</span><span class="p">);</span>

	<span class="n">mpol_rebind_task</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">newmems</span><span class="p">,</span> <span class="n">MPOL_REBIND_STEP2</span><span class="p">);</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">mems_allowed</span> <span class="o">=</span> <span class="o">*</span><span class="n">newmems</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">need_loop</span><span class="p">)</span>
		<span class="n">write_seqcount_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">mems_allowed_seq</span><span class="p">);</span>

	<span class="n">task_unlock</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Update task&#39;s mems_allowed and rebind its mempolicy and vmas&#39; mempolicy</span>
<span class="cm"> * of it to cpuset&#39;s new mems_allowed, and migrate pages to new nodes if</span>
<span class="cm"> * memory_migrate flag is set. Called with cgroup_mutex held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cpuset_change_nodemask</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">cgroup_scanner</span> <span class="o">*</span><span class="n">scan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">migrate</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">oldmem</span> <span class="o">=</span> <span class="n">scan</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">static</span> <span class="n">nodemask_t</span> <span class="n">newmems</span><span class="p">;</span>	<span class="cm">/* protected by cgroup_mutex */</span>

	<span class="n">cs</span> <span class="o">=</span> <span class="n">cgroup_cs</span><span class="p">(</span><span class="n">scan</span><span class="o">-&gt;</span><span class="n">cg</span><span class="p">);</span>
	<span class="n">guarantee_online_mems</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newmems</span><span class="p">);</span>

	<span class="n">cpuset_change_task_nodemask</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newmems</span><span class="p">);</span>

	<span class="n">mm</span> <span class="o">=</span> <span class="n">get_task_mm</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">migrate</span> <span class="o">=</span> <span class="n">is_memory_migrate</span><span class="p">(</span><span class="n">cs</span><span class="p">);</span>

	<span class="n">mpol_rebind_mm</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">migrate</span><span class="p">)</span>
		<span class="n">cpuset_migrate_mm</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">oldmem</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">);</span>
	<span class="n">mmput</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cpuset_being_rebound</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * update_tasks_nodemask - Update the nodemasks of tasks in the cpuset.</span>
<span class="cm"> * @cs: the cpuset in which each task&#39;s mems_allowed mask needs to be changed</span>
<span class="cm"> * @oldmem: old mems_allowed of cpuset cs</span>
<span class="cm"> * @heap: if NULL, defer allocating heap memory to cgroup_scan_tasks()</span>
<span class="cm"> *</span>
<span class="cm"> * Called with cgroup_mutex held</span>
<span class="cm"> * No return value. It&#39;s guaranteed that cgroup_scan_tasks() always returns 0</span>
<span class="cm"> * if @heap != NULL.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_tasks_nodemask</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cs</span><span class="p">,</span> <span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">oldmem</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">ptr_heap</span> <span class="o">*</span><span class="n">heap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup_scanner</span> <span class="n">scan</span><span class="p">;</span>

	<span class="n">cpuset_being_rebound</span> <span class="o">=</span> <span class="n">cs</span><span class="p">;</span>		<span class="cm">/* causes mpol_dup() rebind */</span>

	<span class="n">scan</span><span class="p">.</span><span class="n">cg</span> <span class="o">=</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">.</span><span class="n">cgroup</span><span class="p">;</span>
	<span class="n">scan</span><span class="p">.</span><span class="n">test_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">scan</span><span class="p">.</span><span class="n">process_task</span> <span class="o">=</span> <span class="n">cpuset_change_nodemask</span><span class="p">;</span>
	<span class="n">scan</span><span class="p">.</span><span class="n">heap</span> <span class="o">=</span> <span class="n">heap</span><span class="p">;</span>
	<span class="n">scan</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">nodemask_t</span> <span class="o">*</span><span class="p">)</span><span class="n">oldmem</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The mpol_rebind_mm() call takes mmap_sem, which we couldn&#39;t</span>
<span class="cm">	 * take while holding tasklist_lock.  Forks can happen - the</span>
<span class="cm">	 * mpol_dup() cpuset_being_rebound check will catch such forks,</span>
<span class="cm">	 * and rebind their vma mempolicies too.  Because we still hold</span>
<span class="cm">	 * the global cgroup_mutex, we know that no other rebind effort</span>
<span class="cm">	 * will be contending for the global variable cpuset_being_rebound.</span>
<span class="cm">	 * It&#39;s ok if we rebind the same mm twice; mpol_rebind_mm()</span>
<span class="cm">	 * is idempotent.  Also migrate pages in each mm to new nodes.</span>
<span class="cm">	 */</span>
	<span class="n">cgroup_scan_tasks</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scan</span><span class="p">);</span>

	<span class="cm">/* We&#39;re done rebinding vmas to this cpuset&#39;s new mems_allowed. */</span>
	<span class="n">cpuset_being_rebound</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle user request to change the &#39;mems&#39; memory placement</span>
<span class="cm"> * of a cpuset.  Needs to validate the request, update the</span>
<span class="cm"> * cpusets mems_allowed, and for each task in the cpuset,</span>
<span class="cm"> * update mems_allowed and rebind task&#39;s mempolicy and any vma</span>
<span class="cm"> * mempolicies and if the cpuset is marked &#39;memory_migrate&#39;,</span>
<span class="cm"> * migrate the tasks pages to the new memory.</span>
<span class="cm"> *</span>
<span class="cm"> * Call with cgroup_mutex held.  May take callback_mutex during call.</span>
<span class="cm"> * Will take tasklist_lock, scan tasklist for tasks in cpuset cs,</span>
<span class="cm"> * lock each such tasks mm-&gt;mmap_sem, scan its vma&#39;s and rebind</span>
<span class="cm"> * their mempolicies to the cpusets new mems_allowed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">update_nodemask</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">trialcs</span><span class="p">,</span>
			   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">NODEMASK_ALLOC</span><span class="p">(</span><span class="n">nodemask_t</span><span class="p">,</span> <span class="n">oldmem</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ptr_heap</span> <span class="n">heap</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oldmem</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * top_cpuset.mems_allowed tracks node_stats[N_HIGH_MEMORY];</span>
<span class="cm">	 * it&#39;s read-only</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cs</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">top_cpuset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * An empty mems_allowed is ok iff there are no tasks in the cpuset.</span>
<span class="cm">	 * Since nodelist_parse() fails on an empty mask, we special case</span>
<span class="cm">	 * that parsing.  The validate_change() call ensures that cpusets</span>
<span class="cm">	 * with tasks have memory.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nodes_clear</span><span class="p">(</span><span class="n">trialcs</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">nodelist_parse</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">trialcs</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nodes_subset</span><span class="p">(</span><span class="n">trialcs</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">,</span>
				<span class="n">node_states</span><span class="p">[</span><span class="n">N_HIGH_MEMORY</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span>  <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">oldmem</span> <span class="o">=</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nodes_equal</span><span class="p">(</span><span class="o">*</span><span class="n">oldmem</span><span class="p">,</span> <span class="n">trialcs</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* Too easy - nothing to do */</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">validate_change</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">trialcs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">heap_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">heap</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callback_mutex</span><span class="p">);</span>
	<span class="n">cs</span><span class="o">-&gt;</span><span class="n">mems_allowed</span> <span class="o">=</span> <span class="n">trialcs</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callback_mutex</span><span class="p">);</span>

	<span class="n">update_tasks_nodemask</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">oldmem</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">heap</span><span class="p">);</span>

	<span class="n">heap_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">heap</span><span class="p">);</span>
<span class="nl">done:</span>
	<span class="n">NODEMASK_FREE</span><span class="p">(</span><span class="n">oldmem</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">current_cpuset_is_being_rebound</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">task_cs</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">==</span> <span class="n">cpuset_being_rebound</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">update_relax_domain_level</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cs</span><span class="p">,</span> <span class="n">s64</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">val</span> <span class="o">&gt;=</span> <span class="n">sched_domain_level_max</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">!=</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">relax_domain_level</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cs</span><span class="o">-&gt;</span><span class="n">relax_domain_level</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">is_sched_load_balance</span><span class="p">(</span><span class="n">cs</span><span class="p">))</span>
			<span class="n">async_rebuild_sched_domains</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * cpuset_change_flag - make a task&#39;s spread flags the same as its cpuset&#39;s</span>
<span class="cm"> * @tsk: task to be updated</span>
<span class="cm"> * @scan: struct cgroup_scanner containing the cgroup of the task</span>
<span class="cm"> *</span>
<span class="cm"> * Called by cgroup_scan_tasks() for each task in a cgroup.</span>
<span class="cm"> *</span>
<span class="cm"> * We don&#39;t need to re-check for the cgroup/cpuset membership, since we&#39;re</span>
<span class="cm"> * holding cgroup_lock() at this point.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cpuset_change_flag</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">cgroup_scanner</span> <span class="o">*</span><span class="n">scan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpuset_update_task_spread_flag</span><span class="p">(</span><span class="n">cgroup_cs</span><span class="p">(</span><span class="n">scan</span><span class="o">-&gt;</span><span class="n">cg</span><span class="p">),</span> <span class="n">tsk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * update_tasks_flags - update the spread flags of tasks in the cpuset.</span>
<span class="cm"> * @cs: the cpuset in which each task&#39;s spread flags needs to be changed</span>
<span class="cm"> * @heap: if NULL, defer allocating heap memory to cgroup_scan_tasks()</span>
<span class="cm"> *</span>
<span class="cm"> * Called with cgroup_mutex held</span>
<span class="cm"> *</span>
<span class="cm"> * The cgroup_scan_tasks() function will scan all the tasks in a cgroup,</span>
<span class="cm"> * calling callback functions for each.</span>
<span class="cm"> *</span>
<span class="cm"> * No return value. It&#39;s guaranteed that cgroup_scan_tasks() always returns 0</span>
<span class="cm"> * if @heap != NULL.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_tasks_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ptr_heap</span> <span class="o">*</span><span class="n">heap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup_scanner</span> <span class="n">scan</span><span class="p">;</span>

	<span class="n">scan</span><span class="p">.</span><span class="n">cg</span> <span class="o">=</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">.</span><span class="n">cgroup</span><span class="p">;</span>
	<span class="n">scan</span><span class="p">.</span><span class="n">test_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">scan</span><span class="p">.</span><span class="n">process_task</span> <span class="o">=</span> <span class="n">cpuset_change_flag</span><span class="p">;</span>
	<span class="n">scan</span><span class="p">.</span><span class="n">heap</span> <span class="o">=</span> <span class="n">heap</span><span class="p">;</span>
	<span class="n">cgroup_scan_tasks</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scan</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * update_flag - read a 0 or a 1 in a file and update associated flag</span>
<span class="cm"> * bit:		the bit to update (see cpuset_flagbits_t)</span>
<span class="cm"> * cs:		the cpuset to update</span>
<span class="cm"> * turning_on: 	whether the flag is being set or cleared</span>
<span class="cm"> *</span>
<span class="cm"> * Call with cgroup_mutex held.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">update_flag</span><span class="p">(</span><span class="n">cpuset_flagbits_t</span> <span class="n">bit</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cs</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">turning_on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">trialcs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">balance_flag_changed</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">spread_flag_changed</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ptr_heap</span> <span class="n">heap</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">trialcs</span> <span class="o">=</span> <span class="n">alloc_trial_cpuset</span><span class="p">(</span><span class="n">cs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trialcs</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">turning_on</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">bit</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trialcs</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">bit</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trialcs</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">validate_change</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">trialcs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">heap_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">heap</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">balance_flag_changed</span> <span class="o">=</span> <span class="p">(</span><span class="n">is_sched_load_balance</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span> <span class="o">!=</span>
				<span class="n">is_sched_load_balance</span><span class="p">(</span><span class="n">trialcs</span><span class="p">));</span>

	<span class="n">spread_flag_changed</span> <span class="o">=</span> <span class="p">((</span><span class="n">is_spread_slab</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span> <span class="o">!=</span> <span class="n">is_spread_slab</span><span class="p">(</span><span class="n">trialcs</span><span class="p">))</span>
			<span class="o">||</span> <span class="p">(</span><span class="n">is_spread_page</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span> <span class="o">!=</span> <span class="n">is_spread_page</span><span class="p">(</span><span class="n">trialcs</span><span class="p">)));</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callback_mutex</span><span class="p">);</span>
	<span class="n">cs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">trialcs</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callback_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="n">trialcs</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">balance_flag_changed</span><span class="p">)</span>
		<span class="n">async_rebuild_sched_domains</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spread_flag_changed</span><span class="p">)</span>
		<span class="n">update_tasks_flags</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">heap</span><span class="p">);</span>
	<span class="n">heap_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">heap</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">free_trial_cpuset</span><span class="p">(</span><span class="n">trialcs</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Frequency meter - How fast is some event occurring?</span>
<span class="cm"> *</span>
<span class="cm"> * These routines manage a digitally filtered, constant time based,</span>
<span class="cm"> * event frequency meter.  There are four routines:</span>
<span class="cm"> *   fmeter_init() - initialize a frequency meter.</span>
<span class="cm"> *   fmeter_markevent() - called each time the event happens.</span>
<span class="cm"> *   fmeter_getrate() - returns the recent rate of such events.</span>
<span class="cm"> *   fmeter_update() - internal routine used to update fmeter.</span>
<span class="cm"> *</span>
<span class="cm"> * A common data structure is passed to each of these routines,</span>
<span class="cm"> * which is used to keep track of the state required to manage the</span>
<span class="cm"> * frequency meter and its digital filter.</span>
<span class="cm"> *</span>
<span class="cm"> * The filter works on the number of events marked per unit time.</span>
<span class="cm"> * The filter is single-pole low-pass recursive (IIR).  The time unit</span>
<span class="cm"> * is 1 second.  Arithmetic is done using 32-bit integers scaled to</span>
<span class="cm"> * simulate 3 decimal digits of precision (multiplied by 1000).</span>
<span class="cm"> *</span>
<span class="cm"> * With an FM_COEF of 933, and a time base of 1 second, the filter</span>
<span class="cm"> * has a half-life of 10 seconds, meaning that if the events quit</span>
<span class="cm"> * happening, then the rate returned from the fmeter_getrate()</span>
<span class="cm"> * will be cut in half each 10 seconds, until it converges to zero.</span>
<span class="cm"> *</span>
<span class="cm"> * It is not worth doing a real infinitely recursive filter.  If more</span>
<span class="cm"> * than FM_MAXTICKS ticks have elapsed since the last filter event,</span>
<span class="cm"> * just compute FM_MAXTICKS ticks worth, by which point the level</span>
<span class="cm"> * will be stable.</span>
<span class="cm"> *</span>
<span class="cm"> * Limit the count of unprocessed events to FM_MAXCNT, so as to avoid</span>
<span class="cm"> * arithmetic overflow in the fmeter_update() routine.</span>
<span class="cm"> *</span>
<span class="cm"> * Given the simple 32 bit integer arithmetic used, this meter works</span>
<span class="cm"> * best for reporting rates between one per millisecond (msec) and</span>
<span class="cm"> * one per 32 (approx) seconds.  At constant rates faster than one</span>
<span class="cm"> * per msec it maxes out at values just under 1,000,000.  At constant</span>
<span class="cm"> * rates between one per msec, and one per second it will stabilize</span>
<span class="cm"> * to a value N*1000, where N is the rate of events per second.</span>
<span class="cm"> * At constant rates between one per second and one per 32 seconds,</span>
<span class="cm"> * it will be choppy, moving up on the seconds that have an event,</span>
<span class="cm"> * and then decaying until the next event.  At rates slower than</span>
<span class="cm"> * about one in 32 seconds, it decays all the way back to zero between</span>
<span class="cm"> * each event.</span>
<span class="cm"> */</span>

<span class="cp">#define FM_COEF 933		</span><span class="cm">/* coefficient for half-life of 10 secs */</span><span class="cp"></span>
<span class="cp">#define FM_MAXTICKS ((time_t)99) </span><span class="cm">/* useless computing more ticks than this */</span><span class="cp"></span>
<span class="cp">#define FM_MAXCNT 1000000	</span><span class="cm">/* limit cnt to avoid overflow */</span><span class="cp"></span>
<span class="cp">#define FM_SCALE 1000		</span><span class="cm">/* faux fixed point scale */</span><span class="cp"></span>

<span class="cm">/* Initialize a frequency meter */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fmeter_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">fmeter</span> <span class="o">*</span><span class="n">fmp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fmp</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fmp</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fmp</span><span class="o">-&gt;</span><span class="n">time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fmp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Internal meter update - process cnt events and update value */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fmeter_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">fmeter</span> <span class="o">*</span><span class="n">fmp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">time_t</span> <span class="n">now</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">();</span>
	<span class="kt">time_t</span> <span class="n">ticks</span> <span class="o">=</span> <span class="n">now</span> <span class="o">-</span> <span class="n">fmp</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ticks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ticks</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">FM_MAXTICKS</span><span class="p">,</span> <span class="n">ticks</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ticks</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">fmp</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">FM_COEF</span> <span class="o">*</span> <span class="n">fmp</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="o">/</span> <span class="n">FM_SCALE</span><span class="p">;</span>
	<span class="n">fmp</span><span class="o">-&gt;</span><span class="n">time</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>

	<span class="n">fmp</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">+=</span> <span class="p">((</span><span class="n">FM_SCALE</span> <span class="o">-</span> <span class="n">FM_COEF</span><span class="p">)</span> <span class="o">*</span> <span class="n">fmp</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">)</span> <span class="o">/</span> <span class="n">FM_SCALE</span><span class="p">;</span>
	<span class="n">fmp</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Process any previous ticks, then bump cnt by one (times scale). */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fmeter_markevent</span><span class="p">(</span><span class="k">struct</span> <span class="n">fmeter</span> <span class="o">*</span><span class="n">fmp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fmp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">fmeter_update</span><span class="p">(</span><span class="n">fmp</span><span class="p">);</span>
	<span class="n">fmp</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">FM_MAXCNT</span><span class="p">,</span> <span class="n">fmp</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">+</span> <span class="n">FM_SCALE</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fmp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Process any previous ticks, then return current value. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fmeter_getrate</span><span class="p">(</span><span class="k">struct</span> <span class="n">fmeter</span> <span class="o">*</span><span class="n">fmp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fmp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">fmeter_update</span><span class="p">(</span><span class="n">fmp</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">fmp</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fmp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Protected by cgroup_lock. The nodemasks must be stored globally because</span>
<span class="cm"> * dynamically allocating them is not allowed in can_attach, and they must</span>
<span class="cm"> * persist until attach.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">cpumask_var_t</span> <span class="n">cpus_attach</span><span class="p">;</span>
<span class="k">static</span> <span class="n">nodemask_t</span> <span class="n">cpuset_attach_nodemask_from</span><span class="p">;</span>
<span class="k">static</span> <span class="n">nodemask_t</span> <span class="n">cpuset_attach_nodemask_to</span><span class="p">;</span>

<span class="cm">/* Called by cgroups to determine if a cpuset is usable; cgroup_mutex held */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cpuset_can_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cgroup_taskset</span> <span class="o">*</span><span class="n">tset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cs</span> <span class="o">=</span> <span class="n">cgroup_cs</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">)</span> <span class="o">||</span> <span class="n">nodes_empty</span><span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>

	<span class="n">cgroup_taskset_for_each</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">cgrp</span><span class="p">,</span> <span class="n">tset</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Kthreads bound to specific cpus cannot be moved to a new</span>
<span class="cm">		 * cpuset; we cannot change their cpu affinity and</span>
<span class="cm">		 * isolating such threads by their set of allowed nodes is</span>
<span class="cm">		 * unnecessary.  Thus, cpusets are not applicable for such</span>
<span class="cm">		 * threads.  This prevents checking for success of</span>
<span class="cm">		 * set_cpus_allowed_ptr() on all attached tasks before</span>
<span class="cm">		 * cpus_allowed may be changed.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_THREAD_BOUND</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">security_task_setscheduler</span><span class="p">(</span><span class="n">task</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* prepare for attach */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cs</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">top_cpuset</span><span class="p">)</span>
		<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">cpus_attach</span><span class="p">,</span> <span class="n">cpu_possible_mask</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">guarantee_online_cpus</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">cpus_attach</span><span class="p">);</span>

	<span class="n">guarantee_online_mems</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpuset_attach_nodemask_to</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cpuset_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cgroup_taskset</span> <span class="o">*</span><span class="n">tset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">leader</span> <span class="o">=</span> <span class="n">cgroup_taskset_first</span><span class="p">(</span><span class="n">tset</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">oldcgrp</span> <span class="o">=</span> <span class="n">cgroup_taskset_cur_cgroup</span><span class="p">(</span><span class="n">tset</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cs</span> <span class="o">=</span> <span class="n">cgroup_cs</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">oldcs</span> <span class="o">=</span> <span class="n">cgroup_cs</span><span class="p">(</span><span class="n">oldcgrp</span><span class="p">);</span>

	<span class="n">cgroup_taskset_for_each</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">cgrp</span><span class="p">,</span> <span class="n">tset</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * can_attach beforehand should guarantee that this doesn&#39;t</span>
<span class="cm">		 * fail.  TODO: have a better way to handle failure here</span>
<span class="cm">		 */</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">set_cpus_allowed_ptr</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">cpus_attach</span><span class="p">));</span>

		<span class="n">cpuset_change_task_nodemask</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpuset_attach_nodemask_to</span><span class="p">);</span>
		<span class="n">cpuset_update_task_spread_flag</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Change mm, possibly for multiple threads in a threadgroup. This is</span>
<span class="cm">	 * expensive and may sleep.</span>
<span class="cm">	 */</span>
	<span class="n">cpuset_attach_nodemask_from</span> <span class="o">=</span> <span class="n">oldcs</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">;</span>
	<span class="n">cpuset_attach_nodemask_to</span> <span class="o">=</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">;</span>
	<span class="n">mm</span> <span class="o">=</span> <span class="n">get_task_mm</span><span class="p">(</span><span class="n">leader</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mpol_rebind_mm</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpuset_attach_nodemask_to</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_memory_migrate</span><span class="p">(</span><span class="n">cs</span><span class="p">))</span>
			<span class="n">cpuset_migrate_mm</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpuset_attach_nodemask_from</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">cpuset_attach_nodemask_to</span><span class="p">);</span>
		<span class="n">mmput</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* The various types of files and directories in a cpuset file system */</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">FILE_MEMORY_MIGRATE</span><span class="p">,</span>
	<span class="n">FILE_CPULIST</span><span class="p">,</span>
	<span class="n">FILE_MEMLIST</span><span class="p">,</span>
	<span class="n">FILE_CPU_EXCLUSIVE</span><span class="p">,</span>
	<span class="n">FILE_MEM_EXCLUSIVE</span><span class="p">,</span>
	<span class="n">FILE_MEM_HARDWALL</span><span class="p">,</span>
	<span class="n">FILE_SCHED_LOAD_BALANCE</span><span class="p">,</span>
	<span class="n">FILE_SCHED_RELAX_DOMAIN_LEVEL</span><span class="p">,</span>
	<span class="n">FILE_MEMORY_PRESSURE_ENABLED</span><span class="p">,</span>
	<span class="n">FILE_MEMORY_PRESSURE</span><span class="p">,</span>
	<span class="n">FILE_SPREAD_PAGE</span><span class="p">,</span>
	<span class="n">FILE_SPREAD_SLAB</span><span class="p">,</span>
<span class="p">}</span> <span class="n">cpuset_filetype_t</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cpuset_write_u64</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span> <span class="n">u64</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cs</span> <span class="o">=</span> <span class="n">cgroup_cs</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>
	<span class="n">cpuset_filetype_t</span> <span class="n">type</span> <span class="o">=</span> <span class="n">cft</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cgroup_lock_live_group</span><span class="p">(</span><span class="n">cgrp</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FILE_CPU_EXCLUSIVE</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">update_flag</span><span class="p">(</span><span class="n">CS_CPU_EXCLUSIVE</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FILE_MEM_EXCLUSIVE</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">update_flag</span><span class="p">(</span><span class="n">CS_MEM_EXCLUSIVE</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FILE_MEM_HARDWALL</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">update_flag</span><span class="p">(</span><span class="n">CS_MEM_HARDWALL</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FILE_SCHED_LOAD_BALANCE</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">update_flag</span><span class="p">(</span><span class="n">CS_SCHED_LOAD_BALANCE</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FILE_MEMORY_MIGRATE</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">update_flag</span><span class="p">(</span><span class="n">CS_MEMORY_MIGRATE</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FILE_MEMORY_PRESSURE_ENABLED</span>:
		<span class="n">cpuset_memory_pressure_enabled</span> <span class="o">=</span> <span class="o">!!</span><span class="n">val</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FILE_MEMORY_PRESSURE</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FILE_SPREAD_PAGE</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">update_flag</span><span class="p">(</span><span class="n">CS_SPREAD_PAGE</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FILE_SPREAD_SLAB</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">update_flag</span><span class="p">(</span><span class="n">CS_SPREAD_SLAB</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cgroup_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cpuset_write_s64</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span> <span class="n">s64</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cs</span> <span class="o">=</span> <span class="n">cgroup_cs</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>
	<span class="n">cpuset_filetype_t</span> <span class="n">type</span> <span class="o">=</span> <span class="n">cft</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cgroup_lock_live_group</span><span class="p">(</span><span class="n">cgrp</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FILE_SCHED_RELAX_DOMAIN_LEVEL</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">update_relax_domain_level</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cgroup_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Common handling for a write to a &quot;cpus&quot; or &quot;mems&quot; file.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cpuset_write_resmask</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cs</span> <span class="o">=</span> <span class="n">cgroup_cs</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">trialcs</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cgroup_lock_live_group</span><span class="p">(</span><span class="n">cgrp</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">trialcs</span> <span class="o">=</span> <span class="n">alloc_trial_cpuset</span><span class="p">(</span><span class="n">cs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trialcs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cft</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FILE_CPULIST</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">update_cpumask</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">trialcs</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FILE_MEMLIST</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">update_nodemask</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">trialcs</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">free_trial_cpuset</span><span class="p">(</span><span class="n">trialcs</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">cgroup_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * These ascii lists should be read in a single call, by using a user</span>
<span class="cm"> * buffer large enough to hold the entire map.  If read in smaller</span>
<span class="cm"> * chunks, there is no guarantee of atomicity.  Since the display format</span>
<span class="cm"> * used, list of ranges of sequential numbers, is variable length,</span>
<span class="cm"> * and since these maps can change value dynamically, one could read</span>
<span class="cm"> * gibberish by doing partial reads while a list was changing.</span>
<span class="cm"> * A single large read to a buffer that crosses a page boundary is</span>
<span class="cm"> * ok, because the result being copied to user land is not recomputed</span>
<span class="cm"> * across a page fault.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">cpuset_sprintf_cpulist</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callback_mutex</span><span class="p">);</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">cpulist_scnprintf</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callback_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">cpuset_sprintf_memlist</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callback_mutex</span><span class="p">);</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">nodelist_scnprintf</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callback_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">cpuset_common_file_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cont</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
				       <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				       <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cs</span> <span class="o">=</span> <span class="n">cgroup_cs</span><span class="p">(</span><span class="n">cont</span><span class="p">);</span>
	<span class="n">cpuset_filetype_t</span> <span class="n">type</span> <span class="o">=</span> <span class="n">cft</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">page</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_TEMPORARY</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FILE_CPULIST</span>:
		<span class="n">s</span> <span class="o">+=</span> <span class="n">cpuset_sprintf_cpulist</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">cs</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FILE_MEMLIST</span>:
		<span class="n">s</span> <span class="o">+=</span> <span class="n">cpuset_sprintf_memlist</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">cs</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">s</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">s</span> <span class="o">-</span> <span class="n">page</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">cpuset_read_u64</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cont</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cs</span> <span class="o">=</span> <span class="n">cgroup_cs</span><span class="p">(</span><span class="n">cont</span><span class="p">);</span>
	<span class="n">cpuset_filetype_t</span> <span class="n">type</span> <span class="o">=</span> <span class="n">cft</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FILE_CPU_EXCLUSIVE</span>:
		<span class="k">return</span> <span class="n">is_cpu_exclusive</span><span class="p">(</span><span class="n">cs</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">FILE_MEM_EXCLUSIVE</span>:
		<span class="k">return</span> <span class="n">is_mem_exclusive</span><span class="p">(</span><span class="n">cs</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">FILE_MEM_HARDWALL</span>:
		<span class="k">return</span> <span class="n">is_mem_hardwall</span><span class="p">(</span><span class="n">cs</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">FILE_SCHED_LOAD_BALANCE</span>:
		<span class="k">return</span> <span class="n">is_sched_load_balance</span><span class="p">(</span><span class="n">cs</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">FILE_MEMORY_MIGRATE</span>:
		<span class="k">return</span> <span class="n">is_memory_migrate</span><span class="p">(</span><span class="n">cs</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">FILE_MEMORY_PRESSURE_ENABLED</span>:
		<span class="k">return</span> <span class="n">cpuset_memory_pressure_enabled</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FILE_MEMORY_PRESSURE</span>:
		<span class="k">return</span> <span class="n">fmeter_getrate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">fmeter</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">FILE_SPREAD_PAGE</span>:
		<span class="k">return</span> <span class="n">is_spread_page</span><span class="p">(</span><span class="n">cs</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">FILE_SPREAD_SLAB</span>:
		<span class="k">return</span> <span class="n">is_spread_slab</span><span class="p">(</span><span class="n">cs</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/* Unreachable but makes gcc happy */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">s64</span> <span class="nf">cpuset_read_s64</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cont</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cs</span> <span class="o">=</span> <span class="n">cgroup_cs</span><span class="p">(</span><span class="n">cont</span><span class="p">);</span>
	<span class="n">cpuset_filetype_t</span> <span class="n">type</span> <span class="o">=</span> <span class="n">cft</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FILE_SCHED_RELAX_DOMAIN_LEVEL</span>:
		<span class="k">return</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">relax_domain_level</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/* Unrechable but makes gcc happy */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * for the common functions, &#39;private&#39; gives the type of file</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="n">files</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;cpus&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">cpuset_common_file_read</span><span class="p">,</span>
		<span class="p">.</span><span class="n">write_string</span> <span class="o">=</span> <span class="n">cpuset_write_resmask</span><span class="p">,</span>
		<span class="p">.</span><span class="n">max_write_len</span> <span class="o">=</span> <span class="p">(</span><span class="mi">100U</span> <span class="o">+</span> <span class="mi">6</span> <span class="o">*</span> <span class="n">NR_CPUS</span><span class="p">),</span>
		<span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">FILE_CPULIST</span><span class="p">,</span>
	<span class="p">},</span>

	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;mems&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">cpuset_common_file_read</span><span class="p">,</span>
		<span class="p">.</span><span class="n">write_string</span> <span class="o">=</span> <span class="n">cpuset_write_resmask</span><span class="p">,</span>
		<span class="p">.</span><span class="n">max_write_len</span> <span class="o">=</span> <span class="p">(</span><span class="mi">100U</span> <span class="o">+</span> <span class="mi">6</span> <span class="o">*</span> <span class="n">MAX_NUMNODES</span><span class="p">),</span>
		<span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">FILE_MEMLIST</span><span class="p">,</span>
	<span class="p">},</span>

	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;cpu_exclusive&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read_u64</span> <span class="o">=</span> <span class="n">cpuset_read_u64</span><span class="p">,</span>
		<span class="p">.</span><span class="n">write_u64</span> <span class="o">=</span> <span class="n">cpuset_write_u64</span><span class="p">,</span>
		<span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">FILE_CPU_EXCLUSIVE</span><span class="p">,</span>
	<span class="p">},</span>

	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;mem_exclusive&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read_u64</span> <span class="o">=</span> <span class="n">cpuset_read_u64</span><span class="p">,</span>
		<span class="p">.</span><span class="n">write_u64</span> <span class="o">=</span> <span class="n">cpuset_write_u64</span><span class="p">,</span>
		<span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">FILE_MEM_EXCLUSIVE</span><span class="p">,</span>
	<span class="p">},</span>

	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;mem_hardwall&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read_u64</span> <span class="o">=</span> <span class="n">cpuset_read_u64</span><span class="p">,</span>
		<span class="p">.</span><span class="n">write_u64</span> <span class="o">=</span> <span class="n">cpuset_write_u64</span><span class="p">,</span>
		<span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">FILE_MEM_HARDWALL</span><span class="p">,</span>
	<span class="p">},</span>

	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;sched_load_balance&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read_u64</span> <span class="o">=</span> <span class="n">cpuset_read_u64</span><span class="p">,</span>
		<span class="p">.</span><span class="n">write_u64</span> <span class="o">=</span> <span class="n">cpuset_write_u64</span><span class="p">,</span>
		<span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">FILE_SCHED_LOAD_BALANCE</span><span class="p">,</span>
	<span class="p">},</span>

	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;sched_relax_domain_level&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read_s64</span> <span class="o">=</span> <span class="n">cpuset_read_s64</span><span class="p">,</span>
		<span class="p">.</span><span class="n">write_s64</span> <span class="o">=</span> <span class="n">cpuset_write_s64</span><span class="p">,</span>
		<span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">FILE_SCHED_RELAX_DOMAIN_LEVEL</span><span class="p">,</span>
	<span class="p">},</span>

	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;memory_migrate&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read_u64</span> <span class="o">=</span> <span class="n">cpuset_read_u64</span><span class="p">,</span>
		<span class="p">.</span><span class="n">write_u64</span> <span class="o">=</span> <span class="n">cpuset_write_u64</span><span class="p">,</span>
		<span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">FILE_MEMORY_MIGRATE</span><span class="p">,</span>
	<span class="p">},</span>

	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;memory_pressure&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read_u64</span> <span class="o">=</span> <span class="n">cpuset_read_u64</span><span class="p">,</span>
		<span class="p">.</span><span class="n">write_u64</span> <span class="o">=</span> <span class="n">cpuset_write_u64</span><span class="p">,</span>
		<span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">FILE_MEMORY_PRESSURE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">S_IRUGO</span><span class="p">,</span>
	<span class="p">},</span>

	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;memory_spread_page&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read_u64</span> <span class="o">=</span> <span class="n">cpuset_read_u64</span><span class="p">,</span>
		<span class="p">.</span><span class="n">write_u64</span> <span class="o">=</span> <span class="n">cpuset_write_u64</span><span class="p">,</span>
		<span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">FILE_SPREAD_PAGE</span><span class="p">,</span>
	<span class="p">},</span>

	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;memory_spread_slab&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read_u64</span> <span class="o">=</span> <span class="n">cpuset_read_u64</span><span class="p">,</span>
		<span class="p">.</span><span class="n">write_u64</span> <span class="o">=</span> <span class="n">cpuset_write_u64</span><span class="p">,</span>
		<span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">FILE_SPREAD_SLAB</span><span class="p">,</span>
	<span class="p">},</span>

	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;memory_pressure_enabled&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">CFTYPE_ONLY_ON_ROOT</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read_u64</span> <span class="o">=</span> <span class="n">cpuset_read_u64</span><span class="p">,</span>
		<span class="p">.</span><span class="n">write_u64</span> <span class="o">=</span> <span class="n">cpuset_write_u64</span><span class="p">,</span>
		<span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">FILE_MEMORY_PRESSURE_ENABLED</span><span class="p">,</span>
	<span class="p">},</span>

	<span class="p">{</span> <span class="p">}</span>	<span class="cm">/* terminate */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * post_clone() is called during cgroup_create() when the</span>
<span class="cm"> * clone_children mount argument was specified.  The cgroup</span>
<span class="cm"> * can not yet have any tasks.</span>
<span class="cm"> *</span>
<span class="cm"> * Currently we refuse to set up the cgroup - thereby</span>
<span class="cm"> * refusing the task to be entered, and as a result refusing</span>
<span class="cm"> * the sys_unshare() or clone() which initiated it - if any</span>
<span class="cm"> * sibling cpusets have exclusive cpus or mem.</span>
<span class="cm"> *</span>
<span class="cm"> * If this becomes a problem for some users who wish to</span>
<span class="cm"> * allow that scenario, then cpuset_post_clone() could be</span>
<span class="cm"> * changed to grant parent-&gt;cpus_allowed-sibling_cpus_exclusive</span>
<span class="cm"> * (and likewise for mems) to the new cgroup. Called with cgroup_mutex</span>
<span class="cm"> * held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cpuset_post_clone</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgroup</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cs</span><span class="p">,</span> <span class="o">*</span><span class="n">parent_cs</span><span class="p">;</span>

	<span class="n">parent</span> <span class="o">=</span> <span class="n">cgroup</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">,</span> <span class="n">sibling</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cs</span> <span class="o">=</span> <span class="n">cgroup_cs</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_mem_exclusive</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span> <span class="o">||</span> <span class="n">is_cpu_exclusive</span><span class="p">(</span><span class="n">cs</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cs</span> <span class="o">=</span> <span class="n">cgroup_cs</span><span class="p">(</span><span class="n">cgroup</span><span class="p">);</span>
	<span class="n">parent_cs</span> <span class="o">=</span> <span class="n">cgroup_cs</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callback_mutex</span><span class="p">);</span>
	<span class="n">cs</span><span class="o">-&gt;</span><span class="n">mems_allowed</span> <span class="o">=</span> <span class="n">parent_cs</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">;</span>
	<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">,</span> <span class="n">parent_cs</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callback_mutex</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	cpuset_create - create a cpuset</span>
<span class="cm"> *	cont:	control group that the new cpuset will be part of</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="nf">cpuset_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cont</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cont</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">top_cpuset</span><span class="p">.</span><span class="n">css</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">parent</span> <span class="o">=</span> <span class="n">cgroup_cs</span><span class="p">(</span><span class="n">cont</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">cs</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cs</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cs</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">cs</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">cs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_spread_page</span><span class="p">(</span><span class="n">parent</span><span class="p">))</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">CS_SPREAD_PAGE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_spread_slab</span><span class="p">(</span><span class="n">parent</span><span class="p">))</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">CS_SPREAD_SLAB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">CS_SCHED_LOAD_BALANCE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">cpumask_clear</span><span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">);</span>
	<span class="n">nodes_clear</span><span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">);</span>
	<span class="n">fmeter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">fmeter</span><span class="p">);</span>
	<span class="n">cs</span><span class="o">-&gt;</span><span class="n">relax_domain_level</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">cs</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
	<span class="n">number_of_cpusets</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">css</span> <span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If the cpuset being removed has its flag &#39;sched_load_balance&#39;</span>
<span class="cm"> * enabled, then simulate turning sched_load_balance off, which</span>
<span class="cm"> * will call async_rebuild_sched_domains().</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cpuset_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cont</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cs</span> <span class="o">=</span> <span class="n">cgroup_cs</span><span class="p">(</span><span class="n">cont</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_sched_load_balance</span><span class="p">(</span><span class="n">cs</span><span class="p">))</span>
		<span class="n">update_flag</span><span class="p">(</span><span class="n">CS_SCHED_LOAD_BALANCE</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">number_of_cpusets</span><span class="o">--</span><span class="p">;</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="n">cpuset_subsys</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;cpuset&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">create</span> <span class="o">=</span> <span class="n">cpuset_create</span><span class="p">,</span>
	<span class="p">.</span><span class="n">destroy</span> <span class="o">=</span> <span class="n">cpuset_destroy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">can_attach</span> <span class="o">=</span> <span class="n">cpuset_can_attach</span><span class="p">,</span>
	<span class="p">.</span><span class="n">attach</span> <span class="o">=</span> <span class="n">cpuset_attach</span><span class="p">,</span>
	<span class="p">.</span><span class="n">post_clone</span> <span class="o">=</span> <span class="n">cpuset_post_clone</span><span class="p">,</span>
	<span class="p">.</span><span class="n">subsys_id</span> <span class="o">=</span> <span class="n">cpuset_subsys_id</span><span class="p">,</span>
	<span class="p">.</span><span class="n">base_cftypes</span> <span class="o">=</span> <span class="n">files</span><span class="p">,</span>
	<span class="p">.</span><span class="n">early_init</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * cpuset_init - initialize cpusets at system boot</span>
<span class="cm"> *</span>
<span class="cm"> * Description: Initialize top_cpuset and the cpuset internal file system,</span>
<span class="cm"> **/</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">cpuset_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">top_cpuset</span><span class="p">.</span><span class="n">cpus_allowed</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="n">cpumask_setall</span><span class="p">(</span><span class="n">top_cpuset</span><span class="p">.</span><span class="n">cpus_allowed</span><span class="p">);</span>
	<span class="n">nodes_setall</span><span class="p">(</span><span class="n">top_cpuset</span><span class="p">.</span><span class="n">mems_allowed</span><span class="p">);</span>

	<span class="n">fmeter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">top_cpuset</span><span class="p">.</span><span class="n">fmeter</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">CS_SCHED_LOAD_BALANCE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">top_cpuset</span><span class="p">.</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">top_cpuset</span><span class="p">.</span><span class="n">relax_domain_level</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">register_filesystem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpuset_fs_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpus_attach</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="n">number_of_cpusets</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpuset_do_move_task - move a given task to another cpuset</span>
<span class="cm"> * @tsk: pointer to task_struct the task to move</span>
<span class="cm"> * @scan: struct cgroup_scanner contained in its struct cpuset_hotplug_scanner</span>
<span class="cm"> *</span>
<span class="cm"> * Called by cgroup_scan_tasks() for each task in a cgroup.</span>
<span class="cm"> * Return nonzero to stop the walk through the tasks.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cpuset_do_move_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">cgroup_scanner</span> <span class="o">*</span><span class="n">scan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">new_cgroup</span> <span class="o">=</span> <span class="n">scan</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="n">cgroup_attach_task</span><span class="p">(</span><span class="n">new_cgroup</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * move_member_tasks_to_cpuset - move tasks from one cpuset to another</span>
<span class="cm"> * @from: cpuset in which the tasks currently reside</span>
<span class="cm"> * @to: cpuset to which the tasks will be moved</span>
<span class="cm"> *</span>
<span class="cm"> * Called with cgroup_mutex held</span>
<span class="cm"> * callback_mutex must not be held, as cpuset_attach() will take it.</span>
<span class="cm"> *</span>
<span class="cm"> * The cgroup_scan_tasks() function will scan all the tasks in a cgroup,</span>
<span class="cm"> * calling callback functions for each.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">move_member_tasks_to_cpuset</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">to</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup_scanner</span> <span class="n">scan</span><span class="p">;</span>

	<span class="n">scan</span><span class="p">.</span><span class="n">cg</span> <span class="o">=</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">.</span><span class="n">cgroup</span><span class="p">;</span>
	<span class="n">scan</span><span class="p">.</span><span class="n">test_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* select all tasks in cgroup */</span>
	<span class="n">scan</span><span class="p">.</span><span class="n">process_task</span> <span class="o">=</span> <span class="n">cpuset_do_move_task</span><span class="p">;</span>
	<span class="n">scan</span><span class="p">.</span><span class="n">heap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">scan</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">to</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">.</span><span class="n">cgroup</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cgroup_scan_tasks</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scan</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;move_member_tasks_to_cpuset: &quot;</span>
				<span class="s">&quot;cgroup_scan_tasks failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If CPU and/or memory hotplug handlers, below, unplug any CPUs</span>
<span class="cm"> * or memory nodes, we need to walk over the cpuset hierarchy,</span>
<span class="cm"> * removing that CPU or node from all cpusets.  If this removes the</span>
<span class="cm"> * last CPU or node from a cpuset, then move the tasks in the empty</span>
<span class="cm"> * cpuset to its next-highest non-empty parent.</span>
<span class="cm"> *</span>
<span class="cm"> * Called with cgroup_mutex held</span>
<span class="cm"> * callback_mutex must not be held, as cpuset_attach() will take it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">remove_tasks_in_empty_cpuset</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The cgroup&#39;s css_sets list is in use if there are tasks</span>
<span class="cm">	 * in the cpuset; the list is empty if there are none;</span>
<span class="cm">	 * the cs-&gt;css.refcnt seems always 0.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">.</span><span class="n">cgroup</span><span class="o">-&gt;</span><span class="n">css_sets</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Find its next-highest non-empty parent, (top cpuset</span>
<span class="cm">	 * has online cpus, so can&#39;t be empty).</span>
<span class="cm">	 */</span>
	<span class="n">parent</span> <span class="o">=</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">nodes_empty</span><span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">))</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>

	<span class="n">move_member_tasks_to_cpuset</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Walk the specified cpuset subtree and look for empty cpusets.</span>
<span class="cm"> * The tasks of such cpuset must be moved to a parent cpuset.</span>
<span class="cm"> *</span>
<span class="cm"> * Called with cgroup_mutex held.  We take callback_mutex to modify</span>
<span class="cm"> * cpus_allowed and mems_allowed.</span>
<span class="cm"> *</span>
<span class="cm"> * This walk processes the tree from top to bottom, completing one layer</span>
<span class="cm"> * before dropping down to the next.  It always processes a node before</span>
<span class="cm"> * any of its children.</span>
<span class="cm"> *</span>
<span class="cm"> * For now, since we lack memory hot unplug, we&#39;ll never see a cpuset</span>
<span class="cm"> * that has tasks along with an empty &#39;mems&#39;.  But if we did see such</span>
<span class="cm"> * a cpuset, we&#39;d handle it just like we do if its &#39;cpus&#39; was empty.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">scan_for_empty_cpusets</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>	<span class="cm">/* scans cpusets being updated */</span>
	<span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>	<span class="cm">/* scans child cpusets of cp */</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cont</span><span class="p">;</span>
	<span class="k">static</span> <span class="n">nodemask_t</span> <span class="n">oldmems</span><span class="p">;</span>	<span class="cm">/* protected by cgroup_mutex */</span>

	<span class="n">list_add_tail</span><span class="p">((</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">stack_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">queue</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cp</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cpuset</span><span class="p">,</span> <span class="n">stack_list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">cont</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">.</span><span class="n">cgroup</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">,</span> <span class="n">sibling</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">child</span> <span class="o">=</span> <span class="n">cgroup_cs</span><span class="p">(</span><span class="n">cont</span><span class="p">);</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">stack_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">queue</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Continue past cpusets with all cpus, mems online */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_subset</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">,</span> <span class="n">cpu_active_mask</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">nodes_subset</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">,</span> <span class="n">node_states</span><span class="p">[</span><span class="n">N_HIGH_MEMORY</span><span class="p">]))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">oldmems</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">;</span>

		<span class="cm">/* Remove offline cpus and mems from this cpuset. */</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callback_mutex</span><span class="p">);</span>
		<span class="n">cpumask_and</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">,</span>
			    <span class="n">cpu_active_mask</span><span class="p">);</span>
		<span class="n">nodes_and</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">,</span>
						<span class="n">node_states</span><span class="p">[</span><span class="n">N_HIGH_MEMORY</span><span class="p">]);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callback_mutex</span><span class="p">);</span>

		<span class="cm">/* Move tasks from the empty cpuset to a parent */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">)</span> <span class="o">||</span>
		     <span class="n">nodes_empty</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">))</span>
			<span class="n">remove_tasks_in_empty_cpuset</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">update_tasks_cpumask</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="n">update_tasks_nodemask</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldmems</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The top_cpuset tracks what CPUs and Memory Nodes are online,</span>
<span class="cm"> * period.  This is necessary in order to make cpusets transparent</span>
<span class="cm"> * (of no affect) on systems that are actively using CPU hotplug</span>
<span class="cm"> * but making no active use of cpusets.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine ensures that top_cpuset.cpus_allowed tracks</span>
<span class="cm"> * cpu_active_mask on each CPU hotplug (cpuhp) event.</span>
<span class="cm"> *</span>
<span class="cm"> * Called within get_online_cpus().  Needs to call cgroup_lock()</span>
<span class="cm"> * before calling generate_sched_domains().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">cpuset_update_active_cpus</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_domain_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">;</span>
	<span class="n">cpumask_var_t</span> <span class="o">*</span><span class="n">doms</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ndoms</span><span class="p">;</span>

	<span class="n">cgroup_lock</span><span class="p">();</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callback_mutex</span><span class="p">);</span>
	<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">top_cpuset</span><span class="p">.</span><span class="n">cpus_allowed</span><span class="p">,</span> <span class="n">cpu_active_mask</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callback_mutex</span><span class="p">);</span>
	<span class="n">scan_for_empty_cpusets</span><span class="p">(</span><span class="o">&amp;</span><span class="n">top_cpuset</span><span class="p">);</span>
	<span class="n">ndoms</span> <span class="o">=</span> <span class="n">generate_sched_domains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">doms</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
	<span class="n">cgroup_unlock</span><span class="p">();</span>

	<span class="cm">/* Have scheduler rebuild the domains */</span>
	<span class="n">partition_sched_domains</span><span class="p">(</span><span class="n">ndoms</span><span class="p">,</span> <span class="n">doms</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_MEMORY_HOTPLUG</span>
<span class="cm">/*</span>
<span class="cm"> * Keep top_cpuset.mems_allowed tracking node_states[N_HIGH_MEMORY].</span>
<span class="cm"> * Call this routine anytime after node_states[N_HIGH_MEMORY] changes.</span>
<span class="cm"> * See also the previous routine cpuset_track_online_cpus().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cpuset_track_online_nodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">nodemask_t</span> <span class="n">oldmems</span><span class="p">;</span>	<span class="cm">/* protected by cgroup_mutex */</span>

	<span class="n">cgroup_lock</span><span class="p">();</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MEM_ONLINE</span>:
		<span class="n">oldmems</span> <span class="o">=</span> <span class="n">top_cpuset</span><span class="p">.</span><span class="n">mems_allowed</span><span class="p">;</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callback_mutex</span><span class="p">);</span>
		<span class="n">top_cpuset</span><span class="p">.</span><span class="n">mems_allowed</span> <span class="o">=</span> <span class="n">node_states</span><span class="p">[</span><span class="n">N_HIGH_MEMORY</span><span class="p">];</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callback_mutex</span><span class="p">);</span>
		<span class="n">update_tasks_nodemask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">top_cpuset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldmems</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MEM_OFFLINE</span>:
		<span class="cm">/*</span>
<span class="cm">		 * needn&#39;t update top_cpuset.mems_allowed explicitly because</span>
<span class="cm">		 * scan_for_empty_cpusets() will update it.</span>
<span class="cm">		 */</span>
		<span class="n">scan_for_empty_cpusets</span><span class="p">(</span><span class="o">&amp;</span><span class="n">top_cpuset</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cgroup_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * cpuset_init_smp - initialize cpus_allowed</span>
<span class="cm"> *</span>
<span class="cm"> * Description: Finish top cpuset after cpu, node maps are initialized</span>
<span class="cm"> **/</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">cpuset_init_smp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">top_cpuset</span><span class="p">.</span><span class="n">cpus_allowed</span><span class="p">,</span> <span class="n">cpu_active_mask</span><span class="p">);</span>
	<span class="n">top_cpuset</span><span class="p">.</span><span class="n">mems_allowed</span> <span class="o">=</span> <span class="n">node_states</span><span class="p">[</span><span class="n">N_HIGH_MEMORY</span><span class="p">];</span>

	<span class="n">hotplug_memory_notifier</span><span class="p">(</span><span class="n">cpuset_track_online_nodes</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>

	<span class="n">cpuset_wq</span> <span class="o">=</span> <span class="n">create_singlethread_workqueue</span><span class="p">(</span><span class="s">&quot;cpuset&quot;</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cpuset_wq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpuset_cpus_allowed - return cpus_allowed mask from a tasks cpuset.</span>
<span class="cm"> * @tsk: pointer to task_struct from which to obtain cpuset-&gt;cpus_allowed.</span>
<span class="cm"> * @pmask: pointer to struct cpumask variable to receive cpus_allowed set.</span>
<span class="cm"> *</span>
<span class="cm"> * Description: Returns the cpumask_var_t cpus_allowed of the cpuset</span>
<span class="cm"> * attached to the specified @tsk.  Guaranteed to return some non-empty</span>
<span class="cm"> * subset of cpu_online_mask, even if this means going outside the</span>
<span class="cm"> * tasks cpuset.</span>
<span class="cm"> **/</span>

<span class="kt">void</span> <span class="nf">cpuset_cpus_allowed</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">pmask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callback_mutex</span><span class="p">);</span>
	<span class="n">task_lock</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">guarantee_online_cpus</span><span class="p">(</span><span class="n">task_cs</span><span class="p">(</span><span class="n">tsk</span><span class="p">),</span> <span class="n">pmask</span><span class="p">);</span>
	<span class="n">task_unlock</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callback_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">cpuset_cpus_allowed_fallback</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cs</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">cs</span> <span class="o">=</span> <span class="n">task_cs</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cs</span><span class="p">)</span>
		<span class="n">do_set_cpus_allowed</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * We own tsk-&gt;cpus_allowed, nobody can change it under us.</span>
<span class="cm">	 *</span>
<span class="cm">	 * But we used cs &amp;&amp; cs-&gt;cpus_allowed lockless and thus can</span>
<span class="cm">	 * race with cgroup_attach_task() or update_cpumask() and get</span>
<span class="cm">	 * the wrong tsk-&gt;cpus_allowed. However, both cases imply the</span>
<span class="cm">	 * subsequent cpuset_change_cpumask()-&gt;set_cpus_allowed_ptr()</span>
<span class="cm">	 * which takes task_rq_lock().</span>
<span class="cm">	 *</span>
<span class="cm">	 * If we are called after it dropped the lock we must see all</span>
<span class="cm">	 * changes in tsk_cs()-&gt;cpus_allowed. Otherwise we can temporary</span>
<span class="cm">	 * set any mask even if it is not right from task_cs() pov,</span>
<span class="cm">	 * the pending set_cpus_allowed_ptr() will fix things.</span>
<span class="cm">	 *</span>
<span class="cm">	 * select_fallback_rq() will fix things ups and set cpu_possible_mask</span>
<span class="cm">	 * if required.</span>
<span class="cm">	 */</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">cpuset_init_current_mems_allowed</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nodes_setall</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpuset_mems_allowed - return mems_allowed mask from a tasks cpuset.</span>
<span class="cm"> * @tsk: pointer to task_struct from which to obtain cpuset-&gt;mems_allowed.</span>
<span class="cm"> *</span>
<span class="cm"> * Description: Returns the nodemask_t mems_allowed of the cpuset</span>
<span class="cm"> * attached to the specified @tsk.  Guaranteed to return some non-empty</span>
<span class="cm"> * subset of node_states[N_HIGH_MEMORY], even if this means going outside the</span>
<span class="cm"> * tasks cpuset.</span>
<span class="cm"> **/</span>

<span class="n">nodemask_t</span> <span class="nf">cpuset_mems_allowed</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nodemask_t</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callback_mutex</span><span class="p">);</span>
	<span class="n">task_lock</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">guarantee_online_mems</span><span class="p">(</span><span class="n">task_cs</span><span class="p">(</span><span class="n">tsk</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">);</span>
	<span class="n">task_unlock</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callback_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpuset_nodemask_valid_mems_allowed - check nodemask vs. curremt mems_allowed</span>
<span class="cm"> * @nodemask: the nodemask to be checked</span>
<span class="cm"> *</span>
<span class="cm"> * Are any of the nodes in the nodemask allowed in current-&gt;mems_allowed?</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cpuset_nodemask_valid_mems_allowed</span><span class="p">(</span><span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodemask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nodes_intersects</span><span class="p">(</span><span class="o">*</span><span class="n">nodemask</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * nearest_hardwall_ancestor() - Returns the nearest mem_exclusive or</span>
<span class="cm"> * mem_hardwall ancestor to the specified cpuset.  Call holding</span>
<span class="cm"> * callback_mutex.  If no ancestor is mem_exclusive or mem_hardwall</span>
<span class="cm"> * (an unusual configuration), then returns the root cpuset.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="nf">nearest_hardwall_ancestor</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">is_mem_exclusive</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span> <span class="o">||</span> <span class="n">is_mem_hardwall</span><span class="p">(</span><span class="n">cs</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">cs</span> <span class="o">=</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cs</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpuset_node_allowed_softwall - Can we allocate on a memory node?</span>
<span class="cm"> * @node: is this an allowed node?</span>
<span class="cm"> * @gfp_mask: memory allocation flags</span>
<span class="cm"> *</span>
<span class="cm"> * If we&#39;re in interrupt, yes, we can always allocate.  If __GFP_THISNODE is</span>
<span class="cm"> * set, yes, we can always allocate.  If node is in our task&#39;s mems_allowed,</span>
<span class="cm"> * yes.  If it&#39;s not a __GFP_HARDWALL request and this node is in the nearest</span>
<span class="cm"> * hardwalled cpuset ancestor to this task&#39;s cpuset, yes.  If the task has been</span>
<span class="cm"> * OOM killed and has access to memory reserves as specified by the TIF_MEMDIE</span>
<span class="cm"> * flag, yes.</span>
<span class="cm"> * Otherwise, no.</span>
<span class="cm"> *</span>
<span class="cm"> * If __GFP_HARDWALL is set, cpuset_node_allowed_softwall() reduces to</span>
<span class="cm"> * cpuset_node_allowed_hardwall().  Otherwise, cpuset_node_allowed_softwall()</span>
<span class="cm"> * might sleep, and might allow a node from an enclosing cpuset.</span>
<span class="cm"> *</span>
<span class="cm"> * cpuset_node_allowed_hardwall() only handles the simpler case of hardwall</span>
<span class="cm"> * cpusets, and never sleeps.</span>
<span class="cm"> *</span>
<span class="cm"> * The __GFP_THISNODE placement logic is really handled elsewhere,</span>
<span class="cm"> * by forcibly using a zonelist starting at a specified node, and by</span>
<span class="cm"> * (in get_page_from_freelist()) refusing to consider the zones for</span>
<span class="cm"> * any node on the zonelist except the first.  By the time any such</span>
<span class="cm"> * calls get to this routine, we should just shut up and say &#39;yes&#39;.</span>
<span class="cm"> *</span>
<span class="cm"> * GFP_USER allocations are marked with the __GFP_HARDWALL bit,</span>
<span class="cm"> * and do not allow allocations outside the current tasks cpuset</span>
<span class="cm"> * unless the task has been OOM killed as is marked TIF_MEMDIE.</span>
<span class="cm"> * GFP_KERNEL allocations are not so marked, so can escape to the</span>
<span class="cm"> * nearest enclosing hardwalled ancestor cpuset.</span>
<span class="cm"> *</span>
<span class="cm"> * Scanning up parent cpusets requires callback_mutex.  The</span>
<span class="cm"> * __alloc_pages() routine only calls here with __GFP_HARDWALL bit</span>
<span class="cm"> * _not_ set if it&#39;s a GFP_KERNEL allocation, and all nodes in the</span>
<span class="cm"> * current tasks mems_allowed came up empty on the first pass over</span>
<span class="cm"> * the zonelist.  So only GFP_KERNEL allocations, if all nodes in the</span>
<span class="cm"> * cpuset are short of memory, might require taking the callback_mutex</span>
<span class="cm"> * mutex.</span>
<span class="cm"> *</span>
<span class="cm"> * The first call here from mm/page_alloc:get_page_from_freelist()</span>
<span class="cm"> * has __GFP_HARDWALL set in gfp_mask, enforcing hardwall cpusets,</span>
<span class="cm"> * so no allocation on a node outside the cpuset is allowed (unless</span>
<span class="cm"> * in interrupt, of course).</span>
<span class="cm"> *</span>
<span class="cm"> * The second pass through get_page_from_freelist() doesn&#39;t even call</span>
<span class="cm"> * here for GFP_ATOMIC calls.  For those calls, the __alloc_pages()</span>
<span class="cm"> * variable &#39;wait&#39; is not set, and the bit ALLOC_CPUSET is not set</span>
<span class="cm"> * in alloc_flags.  That logic and the checks below have the combined</span>
<span class="cm"> * affect that:</span>
<span class="cm"> *	in_interrupt - any node ok (current task context irrelevant)</span>
<span class="cm"> *	GFP_ATOMIC   - any node ok</span>
<span class="cm"> *	TIF_MEMDIE   - any node ok</span>
<span class="cm"> *	GFP_KERNEL   - any node in enclosing hardwalled cpuset ok</span>
<span class="cm"> *	GFP_USER     - only nodes in current tasks mems allowed ok.</span>
<span class="cm"> *</span>
<span class="cm"> * Rule:</span>
<span class="cm"> *    Don&#39;t call cpuset_node_allowed_softwall if you can&#39;t sleep, unless you</span>
<span class="cm"> *    pass in the __GFP_HARDWALL flag set in gfp_flag, which disables</span>
<span class="cm"> *    the code that might scan up ancestor cpusets and sleep.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__cpuset_node_allowed_softwall</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cs</span><span class="p">;</span>	<span class="cm">/* current cpuset ancestors */</span>
	<span class="kt">int</span> <span class="n">allowed</span><span class="p">;</span>			<span class="cm">/* is allocation in zone z allowed? */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">in_interrupt</span><span class="p">()</span> <span class="o">||</span> <span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_THISNODE</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">might_sleep_if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_HARDWALL</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node_isset</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Allow tasks that have access to memory reserves because they have</span>
<span class="cm">	 * been OOM killed to get memory anywhere.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">test_thread_flag</span><span class="p">(</span><span class="n">TIF_MEMDIE</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_HARDWALL</span><span class="p">)</span>	<span class="cm">/* If hardwall request, stop here */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_EXITING</span><span class="p">)</span> <span class="cm">/* Let dying task have memory */</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Not hardwall and node outside mems_allowed: scan up cpusets */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callback_mutex</span><span class="p">);</span>

	<span class="n">task_lock</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">cs</span> <span class="o">=</span> <span class="n">nearest_hardwall_ancestor</span><span class="p">(</span><span class="n">task_cs</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
	<span class="n">task_unlock</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>

	<span class="n">allowed</span> <span class="o">=</span> <span class="n">node_isset</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callback_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">allowed</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * cpuset_node_allowed_hardwall - Can we allocate on a memory node?</span>
<span class="cm"> * @node: is this an allowed node?</span>
<span class="cm"> * @gfp_mask: memory allocation flags</span>
<span class="cm"> *</span>
<span class="cm"> * If we&#39;re in interrupt, yes, we can always allocate.  If __GFP_THISNODE is</span>
<span class="cm"> * set, yes, we can always allocate.  If node is in our task&#39;s mems_allowed,</span>
<span class="cm"> * yes.  If the task has been OOM killed and has access to memory reserves as</span>
<span class="cm"> * specified by the TIF_MEMDIE flag, yes.</span>
<span class="cm"> * Otherwise, no.</span>
<span class="cm"> *</span>
<span class="cm"> * The __GFP_THISNODE placement logic is really handled elsewhere,</span>
<span class="cm"> * by forcibly using a zonelist starting at a specified node, and by</span>
<span class="cm"> * (in get_page_from_freelist()) refusing to consider the zones for</span>
<span class="cm"> * any node on the zonelist except the first.  By the time any such</span>
<span class="cm"> * calls get to this routine, we should just shut up and say &#39;yes&#39;.</span>
<span class="cm"> *</span>
<span class="cm"> * Unlike the cpuset_node_allowed_softwall() variant, above,</span>
<span class="cm"> * this variant requires that the node be in the current task&#39;s</span>
<span class="cm"> * mems_allowed or that we&#39;re in interrupt.  It does not scan up the</span>
<span class="cm"> * cpuset hierarchy for the nearest enclosing mem_exclusive cpuset.</span>
<span class="cm"> * It never sleeps.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__cpuset_node_allowed_hardwall</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in_interrupt</span><span class="p">()</span> <span class="o">||</span> <span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_THISNODE</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node_isset</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Allow tasks that have access to memory reserves because they have</span>
<span class="cm">	 * been OOM killed to get memory anywhere.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">test_thread_flag</span><span class="p">(</span><span class="n">TIF_MEMDIE</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpuset_unlock - release lock on cpuset changes</span>
<span class="cm"> *</span>
<span class="cm"> * Undo the lock taken in a previous cpuset_lock() call.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">cpuset_unlock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callback_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpuset_mem_spread_node() - On which node to begin search for a file page</span>
<span class="cm"> * cpuset_slab_spread_node() - On which node to begin search for a slab page</span>
<span class="cm"> *</span>
<span class="cm"> * If a task is marked PF_SPREAD_PAGE or PF_SPREAD_SLAB (as for</span>
<span class="cm"> * tasks in a cpuset with is_spread_page or is_spread_slab set),</span>
<span class="cm"> * and if the memory allocation used cpuset_mem_spread_node()</span>
<span class="cm"> * to determine on which node to start looking, as it will for</span>
<span class="cm"> * certain page cache or slab cache pages such as used for file</span>
<span class="cm"> * system buffers and inode caches, then instead of starting on the</span>
<span class="cm"> * local node to look for a free page, rather spread the starting</span>
<span class="cm"> * node around the tasks mems_allowed nodes.</span>
<span class="cm"> *</span>
<span class="cm"> * We don&#39;t have to worry about the returned node being offline</span>
<span class="cm"> * because &quot;it can&#39;t happen&quot;, and even if it did, it would be ok.</span>
<span class="cm"> *</span>
<span class="cm"> * The routines calling guarantee_online_mems() are careful to</span>
<span class="cm"> * only set nodes in task-&gt;mems_allowed that are online.  So it</span>
<span class="cm"> * should not be possible for the following code to return an</span>
<span class="cm"> * offline node.  But if it did, that would be ok, as this routine</span>
<span class="cm"> * is not returning the node where the allocation must be, only</span>
<span class="cm"> * the node where the search should start.  The zonelist passed to</span>
<span class="cm"> * __alloc_pages() will include all nodes.  If the slab allocator</span>
<span class="cm"> * is passed an offline node, it will fall back to the local node.</span>
<span class="cm"> * See kmem_cache_alloc_node().</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cpuset_spread_node</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">rotor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>

	<span class="n">node</span> <span class="o">=</span> <span class="n">next_node</span><span class="p">(</span><span class="o">*</span><span class="n">rotor</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="n">MAX_NUMNODES</span><span class="p">)</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">first_node</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">);</span>
	<span class="o">*</span><span class="n">rotor</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">node</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">cpuset_mem_spread_node</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">cpuset_mem_spread_rotor</span> <span class="o">==</span> <span class="n">NUMA_NO_NODE</span><span class="p">)</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">cpuset_mem_spread_rotor</span> <span class="o">=</span>
			<span class="n">node_random</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">cpuset_spread_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">cpuset_mem_spread_rotor</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">cpuset_slab_spread_node</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">cpuset_slab_spread_rotor</span> <span class="o">==</span> <span class="n">NUMA_NO_NODE</span><span class="p">)</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">cpuset_slab_spread_rotor</span> <span class="o">=</span>
			<span class="n">node_random</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">cpuset_spread_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">cpuset_slab_spread_rotor</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">cpuset_mem_spread_node</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cpuset_mems_allowed_intersects - Does @tsk1&#39;s mems_allowed intersect @tsk2&#39;s?</span>
<span class="cm"> * @tsk1: pointer to task_struct of some task.</span>
<span class="cm"> * @tsk2: pointer to task_struct of some other task.</span>
<span class="cm"> *</span>
<span class="cm"> * Description: Return true if @tsk1&#39;s mems_allowed intersects the</span>
<span class="cm"> * mems_allowed of @tsk2.  Used by the OOM killer to determine if</span>
<span class="cm"> * one of the task&#39;s memory usage might impact the memory available</span>
<span class="cm"> * to the other.</span>
<span class="cm"> **/</span>

<span class="kt">int</span> <span class="nf">cpuset_mems_allowed_intersects</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk1</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nodes_intersects</span><span class="p">(</span><span class="n">tsk1</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">,</span> <span class="n">tsk2</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpuset_print_task_mems_allowed - prints task&#39;s cpuset and mems_allowed</span>
<span class="cm"> * @task: pointer to task_struct of some task.</span>
<span class="cm"> *</span>
<span class="cm"> * Description: Prints @task&#39;s name, cpuset name, and cached copy of its</span>
<span class="cm"> * mems_allowed to the kernel log.  Must hold task_lock(task) to allow</span>
<span class="cm"> * dereferencing task_cs(task).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">cpuset_print_task_mems_allowed</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>

	<span class="n">dentry</span> <span class="o">=</span> <span class="n">task_cs</span><span class="p">(</span><span class="n">tsk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">.</span><span class="n">cgroup</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpuset_buffer_lock</span><span class="p">);</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">cpuset_name</span><span class="p">,</span> <span class="n">CPUSET_NAME_LEN</span><span class="p">,</span>
		 <span class="n">dentry</span> <span class="o">?</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span> <span class="o">:</span> <span class="s">&quot;/&quot;</span><span class="p">);</span>
	<span class="n">nodelist_scnprintf</span><span class="p">(</span><span class="n">cpuset_nodelist</span><span class="p">,</span> <span class="n">CPUSET_NODELIST_LEN</span><span class="p">,</span>
			   <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s cpuset=%s mems_allowed=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">cpuset_name</span><span class="p">,</span> <span class="n">cpuset_nodelist</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpuset_buffer_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Collection of memory_pressure is suppressed unless</span>
<span class="cm"> * this flag is enabled by writing &quot;1&quot; to the special</span>
<span class="cm"> * cpuset file &#39;memory_pressure_enabled&#39; in the root cpuset.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="n">cpuset_memory_pressure_enabled</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * cpuset_memory_pressure_bump - keep stats of per-cpuset reclaims.</span>
<span class="cm"> *</span>
<span class="cm"> * Keep a running average of the rate of synchronous (direct)</span>
<span class="cm"> * page reclaim efforts initiated by tasks in each cpuset.</span>
<span class="cm"> *</span>
<span class="cm"> * This represents the rate at which some task in the cpuset</span>
<span class="cm"> * ran low on memory on all nodes it was allowed to use, and</span>
<span class="cm"> * had to enter the kernels page reclaim code in an effort to</span>
<span class="cm"> * create more free memory by tossing clean pages or swapping</span>
<span class="cm"> * or writing dirty pages.</span>
<span class="cm"> *</span>
<span class="cm"> * Display to user space in the per-cpuset read-only file</span>
<span class="cm"> * &quot;memory_pressure&quot;.  Value displayed is an integer</span>
<span class="cm"> * representing the recent rate of entry into the synchronous</span>
<span class="cm"> * (direct) page reclaim by any task attached to the cpuset.</span>
<span class="cm"> **/</span>

<span class="kt">void</span> <span class="nf">__cpuset_memory_pressure_bump</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">task_lock</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">fmeter_markevent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task_cs</span><span class="p">(</span><span class="n">current</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">fmeter</span><span class="p">);</span>
	<span class="n">task_unlock</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PROC_PID_CPUSET</span>
<span class="cm">/*</span>
<span class="cm"> * proc_cpuset_show()</span>
<span class="cm"> *  - Print tasks cpuset path into seq_file.</span>
<span class="cm"> *  - Used for /proc/&lt;pid&gt;/cpuset.</span>
<span class="cm"> *  - No need to task_lock(tsk) on this tsk-&gt;cpuset reference, as it</span>
<span class="cm"> *    doesn&#39;t really matter if tsk-&gt;cpuset changes after we read it,</span>
<span class="cm"> *    and we take cgroup_mutex, keeping cpuset_attach() from changing it</span>
<span class="cm"> *    anyway.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_cpuset_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">unused_v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
	<span class="n">pid</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="n">tsk</span> <span class="o">=</span> <span class="n">get_pid_task</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">PIDTYPE_PID</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tsk</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">cgroup_lock</span><span class="p">();</span>
	<span class="n">css</span> <span class="o">=</span> <span class="n">task_subsys_state</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">cpuset_subsys_id</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">cgroup_path</span><span class="p">(</span><span class="n">css</span><span class="o">-&gt;</span><span class="n">cgroup</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="n">seq_putc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>
<span class="nl">out_unlock:</span>
	<span class="n">cgroup_unlock</span><span class="p">();</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
<span class="nl">out_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cpuset_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span> <span class="o">=</span> <span class="n">PROC_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">proc_cpuset_show</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_cpuset_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">cpuset_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PROC_PID_CPUSET */</span><span class="cp"></span>

<span class="cm">/* Display task mems_allowed in /proc/&lt;pid&gt;/status file. */</span>
<span class="kt">void</span> <span class="nf">cpuset_task_status_allowed</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Mems_allowed:</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">seq_nodemask</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Mems_allowed_list:</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">seq_nodemask_list</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
