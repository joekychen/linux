<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › module.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>module.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">   Copyright (C) 2002 Richard Henderson</span>
<span class="cm">   Copyright (C) 2001 Rusty Russell, 2002, 2010 Rusty Russell IBM.</span>

<span class="cm">    This program is free software; you can redistribute it and/or modify</span>
<span class="cm">    it under the terms of the GNU General Public License as published by</span>
<span class="cm">    the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm">    (at your option) any later version.</span>

<span class="cm">    This program is distributed in the hope that it will be useful,</span>
<span class="cm">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm">    GNU General Public License for more details.</span>

<span class="cm">    You should have received a copy of the GNU General Public License</span>
<span class="cm">    along with this program; if not, write to the Free Software</span>
<span class="cm">    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm">*/</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/moduleloader.h&gt;</span>
<span class="cp">#include &lt;linux/ftrace_event.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/kallsyms.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/sysfs.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/elf.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/fcntl.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>
<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/vermagic.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/stop_machine.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/rculist.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;asm/mmu_context.h&gt;</span>
<span class="cp">#include &lt;linux/license.h&gt;</span>
<span class="cp">#include &lt;asm/sections.h&gt;</span>
<span class="cp">#include &lt;linux/tracepoint.h&gt;</span>
<span class="cp">#include &lt;linux/ftrace.h&gt;</span>
<span class="cp">#include &lt;linux/async.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/kmemleak.h&gt;</span>
<span class="cp">#include &lt;linux/jump_label.h&gt;</span>
<span class="cp">#include &lt;linux/pfn.h&gt;</span>
<span class="cp">#include &lt;linux/bsearch.h&gt;</span>

<span class="cp">#define CREATE_TRACE_POINTS</span>
<span class="cp">#include &lt;trace/events/module.h&gt;</span>

<span class="cp">#ifndef ARCH_SHF_SMALL</span>
<span class="cp">#define ARCH_SHF_SMALL 0</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Modules&#39; sections will be aligned on page boundaries</span>
<span class="cm"> * to ensure complete separation of code and data, but</span>
<span class="cm"> * only when CONFIG_DEBUG_SET_MODULE_RONX=y</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_DEBUG_SET_MODULE_RONX</span>
<span class="cp"># define debug_align(X) ALIGN(X, PAGE_SIZE)</span>
<span class="cp">#else</span>
<span class="cp"># define debug_align(X) (X)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Given BASE and SIZE this macro calculates the number of pages the</span>
<span class="cm"> * memory regions occupies</span>
<span class="cm"> */</span>
<span class="cp">#define MOD_NUMBER_OF_PAGES(BASE, SIZE) (((SIZE) &gt; 0) ?		\</span>
<span class="cp">		(PFN_DOWN((unsigned long)(BASE) + (SIZE) - 1) -	\</span>
<span class="cp">			 PFN_DOWN((unsigned long)BASE) + 1)	\</span>
<span class="cp">		: (0UL))</span>

<span class="cm">/* If this is set, the section belongs in the init part of the module */</span>
<span class="cp">#define INIT_OFFSET_MASK (1UL &lt;&lt; (BITS_PER_LONG-1))</span>

<span class="cm">/*</span>
<span class="cm"> * Mutex protects:</span>
<span class="cm"> * 1) List of modules (also safely readable with preempt_disable),</span>
<span class="cm"> * 2) module_use links,</span>
<span class="cm"> * 3) module_addr_min/module_addr_max.</span>
<span class="cm"> * (delete uses stop_machine/add uses RCU list operations). */</span>
<span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">module_mutex</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">module_mutex</span><span class="p">);</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">modules</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_KGDB_KDB</span>
<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">kdb_modules</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">modules</span><span class="p">;</span> <span class="cm">/* kdb needs the list of modules */</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_KGDB_KDB */</span><span class="cp"></span>


<span class="cm">/* Block module loading/unloading? */</span>
<span class="kt">int</span> <span class="n">modules_disabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">core_param</span><span class="p">(</span><span class="n">nomodule</span><span class="p">,</span> <span class="n">modules_disabled</span><span class="p">,</span> <span class="n">bint</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="cm">/* Waiting for a module to finish initializing? */</span>
<span class="k">static</span> <span class="n">DECLARE_WAIT_QUEUE_HEAD</span><span class="p">(</span><span class="n">module_wq</span><span class="p">);</span>

<span class="k">static</span> <span class="n">BLOCKING_NOTIFIER_HEAD</span><span class="p">(</span><span class="n">module_notify_list</span><span class="p">);</span>

<span class="cm">/* Bounds of module allocation, for speeding __module_address.</span>
<span class="cm"> * Protected by module_mutex. */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">module_addr_min</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1UL</span><span class="p">,</span> <span class="n">module_addr_max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">register_module_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span> <span class="n">nb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">blocking_notifier_chain_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_notify_list</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">register_module_notifier</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">unregister_module_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span> <span class="n">nb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">blocking_notifier_chain_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_notify_list</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">unregister_module_notifier</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">load_info</span> <span class="p">{</span>
	<span class="n">Elf_Ehdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">sechdrs</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">secstrings</span><span class="p">,</span> <span class="o">*</span><span class="n">strtab</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">symoffs</span><span class="p">,</span> <span class="n">stroffs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">_ddebug</span> <span class="o">*</span><span class="n">debug</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_debug</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sym</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span> <span class="n">vers</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">pcpu</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">index</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* We require a truly strong try_module_get(): 0 means failure due to</span>
<span class="cm">   ongoing or failed initialization etc. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">strong_try_module_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mod</span> <span class="o">&amp;&amp;</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">MODULE_STATE_COMING</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">mod</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">add_taint_module</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">add_taint</span><span class="p">(</span><span class="n">flag</span><span class="p">);</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">taints</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="n">flag</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * A thread that wants to hold a reference to a module only while it</span>
<span class="cm"> * is running can call this to safely exit.  nfsd and lockd use this.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__module_put_and_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="kt">long</span> <span class="n">code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
	<span class="n">do_exit</span><span class="p">(</span><span class="n">code</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__module_put_and_exit</span><span class="p">);</span>

<span class="cm">/* Find a module section: 0 means not found. */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">find_sec</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">load_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shnum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">shdr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="cm">/* Alloc bit cleared means &quot;ignore it.&quot; */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">sh_flags</span> <span class="o">&amp;</span> <span class="n">SHF_ALLOC</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">secstrings</span> <span class="o">+</span> <span class="n">shdr</span><span class="o">-&gt;</span><span class="n">sh_name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Find a module section, or NULL. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">section_addr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">load_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Section 0 has sh_addr 0. */</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">find_sec</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">name</span><span class="p">)].</span><span class="n">sh_addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Find a module section, or NULL.  Fill in number of &quot;objects&quot; in section. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">section_objs</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">load_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			  <span class="kt">size_t</span> <span class="n">object_size</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sec</span> <span class="o">=</span> <span class="n">find_sec</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>

	<span class="cm">/* Section 0 has sh_addr 0 and sh_size 0. */</span>
	<span class="o">*</span><span class="n">num</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">sec</span><span class="p">].</span><span class="n">sh_size</span> <span class="o">/</span> <span class="n">object_size</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">sec</span><span class="p">].</span><span class="n">sh_addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Provided by the linker */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_symbol</span> <span class="n">__start___ksymtab</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_symbol</span> <span class="n">__stop___ksymtab</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_symbol</span> <span class="n">__start___ksymtab_gpl</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_symbol</span> <span class="n">__stop___ksymtab_gpl</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_symbol</span> <span class="n">__start___ksymtab_gpl_future</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_symbol</span> <span class="n">__stop___ksymtab_gpl_future</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__start___kcrctab</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__start___kcrctab_gpl</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__start___kcrctab_gpl_future</span><span class="p">[];</span>
<span class="cp">#ifdef CONFIG_UNUSED_SYMBOLS</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_symbol</span> <span class="n">__start___ksymtab_unused</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_symbol</span> <span class="n">__stop___ksymtab_unused</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_symbol</span> <span class="n">__start___ksymtab_unused_gpl</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_symbol</span> <span class="n">__stop___ksymtab_unused_gpl</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__start___kcrctab_unused</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__start___kcrctab_unused_gpl</span><span class="p">[];</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef CONFIG_MODVERSIONS</span>
<span class="cp">#define symversion(base, idx) NULL</span>
<span class="cp">#else</span>
<span class="cp">#define symversion(base, idx) ((base != NULL) ? ((base) + (idx)) : NULL)</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">each_symbol_in_section</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">symsearch</span> <span class="o">*</span><span class="n">arr</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">arrsize</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">,</span>
				   <span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">symsearch</span> <span class="o">*</span><span class="n">syms</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">,</span>
					      <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">),</span>
				   <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">arrsize</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">owner</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Returns true as soon as fn returns true, otherwise false. */</span>
<span class="n">bool</span> <span class="nf">each_symbol_section</span><span class="p">(</span><span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">symsearch</span> <span class="o">*</span><span class="n">arr</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">,</span>
				    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">),</span>
			 <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">symsearch</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">{</span> <span class="n">__start___ksymtab</span><span class="p">,</span> <span class="n">__stop___ksymtab</span><span class="p">,</span> <span class="n">__start___kcrctab</span><span class="p">,</span>
		  <span class="n">NOT_GPL_ONLY</span><span class="p">,</span> <span class="nb">false</span> <span class="p">},</span>
		<span class="p">{</span> <span class="n">__start___ksymtab_gpl</span><span class="p">,</span> <span class="n">__stop___ksymtab_gpl</span><span class="p">,</span>
		  <span class="n">__start___kcrctab_gpl</span><span class="p">,</span>
		  <span class="n">GPL_ONLY</span><span class="p">,</span> <span class="nb">false</span> <span class="p">},</span>
		<span class="p">{</span> <span class="n">__start___ksymtab_gpl_future</span><span class="p">,</span> <span class="n">__stop___ksymtab_gpl_future</span><span class="p">,</span>
		  <span class="n">__start___kcrctab_gpl_future</span><span class="p">,</span>
		  <span class="n">WILL_BE_GPL_ONLY</span><span class="p">,</span> <span class="nb">false</span> <span class="p">},</span>
<span class="cp">#ifdef CONFIG_UNUSED_SYMBOLS</span>
		<span class="p">{</span> <span class="n">__start___ksymtab_unused</span><span class="p">,</span> <span class="n">__stop___ksymtab_unused</span><span class="p">,</span>
		  <span class="n">__start___kcrctab_unused</span><span class="p">,</span>
		  <span class="n">NOT_GPL_ONLY</span><span class="p">,</span> <span class="nb">true</span> <span class="p">},</span>
		<span class="p">{</span> <span class="n">__start___ksymtab_unused_gpl</span><span class="p">,</span> <span class="n">__stop___ksymtab_unused_gpl</span><span class="p">,</span>
		  <span class="n">__start___kcrctab_unused_gpl</span><span class="p">,</span>
		  <span class="n">GPL_ONLY</span><span class="p">,</span> <span class="nb">true</span> <span class="p">},</span>
<span class="cp">#endif</span>
	<span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">each_symbol_in_section</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">modules</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">symsearch</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">{</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">syms</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">syms</span> <span class="o">+</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_syms</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">crcs</span><span class="p">,</span>
			  <span class="n">NOT_GPL_ONLY</span><span class="p">,</span> <span class="nb">false</span> <span class="p">},</span>
			<span class="p">{</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">gpl_syms</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">gpl_syms</span> <span class="o">+</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_gpl_syms</span><span class="p">,</span>
			  <span class="n">mod</span><span class="o">-&gt;</span><span class="n">gpl_crcs</span><span class="p">,</span>
			  <span class="n">GPL_ONLY</span><span class="p">,</span> <span class="nb">false</span> <span class="p">},</span>
			<span class="p">{</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">gpl_future_syms</span><span class="p">,</span>
			  <span class="n">mod</span><span class="o">-&gt;</span><span class="n">gpl_future_syms</span> <span class="o">+</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_gpl_future_syms</span><span class="p">,</span>
			  <span class="n">mod</span><span class="o">-&gt;</span><span class="n">gpl_future_crcs</span><span class="p">,</span>
			  <span class="n">WILL_BE_GPL_ONLY</span><span class="p">,</span> <span class="nb">false</span> <span class="p">},</span>
<span class="cp">#ifdef CONFIG_UNUSED_SYMBOLS</span>
			<span class="p">{</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">unused_syms</span><span class="p">,</span>
			  <span class="n">mod</span><span class="o">-&gt;</span><span class="n">unused_syms</span> <span class="o">+</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_unused_syms</span><span class="p">,</span>
			  <span class="n">mod</span><span class="o">-&gt;</span><span class="n">unused_crcs</span><span class="p">,</span>
			  <span class="n">NOT_GPL_ONLY</span><span class="p">,</span> <span class="nb">true</span> <span class="p">},</span>
			<span class="p">{</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">unused_gpl_syms</span><span class="p">,</span>
			  <span class="n">mod</span><span class="o">-&gt;</span><span class="n">unused_gpl_syms</span> <span class="o">+</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_unused_gpl_syms</span><span class="p">,</span>
			  <span class="n">mod</span><span class="o">-&gt;</span><span class="n">unused_gpl_crcs</span><span class="p">,</span>
			  <span class="n">GPL_ONLY</span><span class="p">,</span> <span class="nb">true</span> <span class="p">},</span>
<span class="cp">#endif</span>
		<span class="p">};</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">each_symbol_in_section</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="n">mod</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">each_symbol_section</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">find_symbol_arg</span> <span class="p">{</span>
	<span class="cm">/* Input */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">gplok</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">warn</span><span class="p">;</span>

	<span class="cm">/* Output */</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">crc</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_symbol</span> <span class="o">*</span><span class="n">sym</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">check_symbol</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">symsearch</span> <span class="o">*</span><span class="n">syms</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">symnum</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">find_symbol_arg</span> <span class="o">*</span><span class="n">fsa</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fsa</span><span class="o">-&gt;</span><span class="n">gplok</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">syms</span><span class="o">-&gt;</span><span class="n">licence</span> <span class="o">==</span> <span class="n">GPL_ONLY</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">syms</span><span class="o">-&gt;</span><span class="n">licence</span> <span class="o">==</span> <span class="n">WILL_BE_GPL_ONLY</span> <span class="o">&amp;&amp;</span> <span class="n">fsa</span><span class="o">-&gt;</span><span class="n">warn</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Symbol %s is being used &quot;</span>
			       <span class="s">&quot;by a non-GPL module, which will not &quot;</span>
			       <span class="s">&quot;be allowed in the future</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fsa</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Please see the file &quot;</span>
			       <span class="s">&quot;Documentation/feature-removal-schedule.txt &quot;</span>
			       <span class="s">&quot;in the kernel source tree for more details.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_UNUSED_SYMBOLS</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">syms</span><span class="o">-&gt;</span><span class="n">unused</span> <span class="o">&amp;&amp;</span> <span class="n">fsa</span><span class="o">-&gt;</span><span class="n">warn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Symbol %s is marked as UNUSED, &quot;</span>
		       <span class="s">&quot;however this module is using it.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fsa</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		       <span class="s">&quot;This symbol will go away in the future.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		       <span class="s">&quot;Please evalute if this is the right api to use and if &quot;</span>
		       <span class="s">&quot;it really is, submit a report the linux kernel &quot;</span>
		       <span class="s">&quot;mailinglist together with submitting your code for &quot;</span>
		       <span class="s">&quot;inclusion.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">fsa</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="n">owner</span><span class="p">;</span>
	<span class="n">fsa</span><span class="o">-&gt;</span><span class="n">crc</span> <span class="o">=</span> <span class="n">symversion</span><span class="p">(</span><span class="n">syms</span><span class="o">-&gt;</span><span class="n">crcs</span><span class="p">,</span> <span class="n">symnum</span><span class="p">);</span>
	<span class="n">fsa</span><span class="o">-&gt;</span><span class="n">sym</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">syms</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">[</span><span class="n">symnum</span><span class="p">];</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cmp_name</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">va</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">vb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_symbol</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
	<span class="n">a</span> <span class="o">=</span> <span class="n">va</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">vb</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">find_symbol_in_section</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">symsearch</span> <span class="o">*</span><span class="n">syms</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">,</span>
				   <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">find_symbol_arg</span> <span class="o">*</span><span class="n">fsa</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kernel_symbol</span> <span class="o">*</span><span class="n">sym</span><span class="p">;</span>

	<span class="n">sym</span> <span class="o">=</span> <span class="n">bsearch</span><span class="p">(</span><span class="n">fsa</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">syms</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">syms</span><span class="o">-&gt;</span><span class="n">stop</span> <span class="o">-</span> <span class="n">syms</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kernel_symbol</span><span class="p">),</span> <span class="n">cmp_name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sym</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">check_symbol</span><span class="p">(</span><span class="n">syms</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">sym</span> <span class="o">-</span> <span class="n">syms</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Find a symbol and return it, along with, (optional) crc and</span>
<span class="cm"> * (optional) module which owns it.  Needs preempt disabled or module_mutex. */</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_symbol</span> <span class="o">*</span><span class="nf">find_symbol</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">module</span> <span class="o">**</span><span class="n">owner</span><span class="p">,</span>
					<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">**</span><span class="n">crc</span><span class="p">,</span>
					<span class="n">bool</span> <span class="n">gplok</span><span class="p">,</span>
					<span class="n">bool</span> <span class="n">warn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">find_symbol_arg</span> <span class="n">fsa</span><span class="p">;</span>

	<span class="n">fsa</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
	<span class="n">fsa</span><span class="p">.</span><span class="n">gplok</span> <span class="o">=</span> <span class="n">gplok</span><span class="p">;</span>
	<span class="n">fsa</span><span class="p">.</span><span class="n">warn</span> <span class="o">=</span> <span class="n">warn</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">each_symbol_section</span><span class="p">(</span><span class="n">find_symbol_in_section</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsa</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">owner</span><span class="p">)</span>
			<span class="o">*</span><span class="n">owner</span> <span class="o">=</span> <span class="n">fsa</span><span class="p">.</span><span class="n">owner</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">crc</span><span class="p">)</span>
			<span class="o">*</span><span class="n">crc</span> <span class="o">=</span> <span class="n">fsa</span><span class="p">.</span><span class="n">crc</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">fsa</span><span class="p">.</span><span class="n">sym</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Failed to find symbol %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">find_symbol</span><span class="p">);</span>

<span class="cm">/* Search for module by name: must hold module_mutex. */</span>
<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="nf">find_module</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">modules</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">mod</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">find_module</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SMP</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">__percpu</span> <span class="o">*</span><span class="nf">mod_percpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">percpu</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">percpu_modalloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">align</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">align</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: per-cpu alignment %li &gt; %li</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
		<span class="n">align</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">percpu</span> <span class="o">=</span> <span class="n">__alloc_reserved_percpu</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">percpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		       <span class="s">&quot;%s: Could not allocate %lu bytes percpu data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">percpu_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">percpu_modfree</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_percpu</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">percpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">find_pcpusec</span><span class="p">(</span><span class="k">struct</span> <span class="n">load_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">find_sec</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;.data..percpu&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">percpu_modcopy</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span>
			   <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">percpu</span><span class="p">,</span> <span class="n">cpu</span><span class="p">),</span> <span class="n">from</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * is_module_percpu_address - test whether address is from module static percpu</span>
<span class="cm"> * @addr: address to test</span>
<span class="cm"> *</span>
<span class="cm"> * Test whether @addr belongs to module static percpu area.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * %true if @addr is from module static percpu area</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">is_module_percpu_address</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">preempt_disable</span><span class="p">();</span>

	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">modules</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">percpu_size</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">percpu</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">start</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="n">start</span> <span class="o">+</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">percpu_size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">preempt_enable</span><span class="p">();</span>
				<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">preempt_enable</span><span class="p">();</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* ... !CONFIG_SMP */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">__percpu</span> <span class="o">*</span><span class="nf">mod_percpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">percpu_modalloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">align</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">percpu_modfree</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">find_pcpusec</span><span class="p">(</span><span class="k">struct</span> <span class="n">load_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">percpu_modcopy</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span>
				  <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* pcpusec should be 0, and size of that section should be 0. */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">bool</span> <span class="nf">is_module_percpu_address</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="cp">#define MODINFO_ATTR(field)	\</span>
<span class="cp">static void setup_modinfo_##field(struct module *mod, const char *s)  \</span>
<span class="cp">{                                                                     \</span>
<span class="cp">	mod-&gt;field = kstrdup(s, GFP_KERNEL);                          \</span>
<span class="cp">}                                                                     \</span>
<span class="cp">static ssize_t show_modinfo_##field(struct module_attribute *mattr,   \</span>
<span class="cp">			struct module_kobject *mk, char *buffer)      \</span>
<span class="cp">{                                                                     \</span>
<span class="cp">	return sprintf(buffer, &quot;%s\n&quot;, mk-&gt;mod-&gt;field);               \</span>
<span class="cp">}                                                                     \</span>
<span class="cp">static int modinfo_##field##_exists(struct module *mod)               \</span>
<span class="cp">{                                                                     \</span>
<span class="cp">	return mod-&gt;field != NULL;                                    \</span>
<span class="cp">}                                                                     \</span>
<span class="cp">static void free_modinfo_##field(struct module *mod)                  \</span>
<span class="cp">{                                                                     \</span>
<span class="cp">	kfree(mod-&gt;field);                                            \</span>
<span class="cp">	mod-&gt;field = NULL;                                            \</span>
<span class="cp">}                                                                     \</span>
<span class="cp">static struct module_attribute modinfo_##field = {                    \</span>
<span class="cp">	.attr = { .name = __stringify(field), .mode = 0444 },         \</span>
<span class="cp">	.show = show_modinfo_##field,                                 \</span>
<span class="cp">	.setup = setup_modinfo_##field,                               \</span>
<span class="cp">	.test = modinfo_##field##_exists,                             \</span>
<span class="cp">	.free = free_modinfo_##field,                                 \</span>
<span class="cp">};</span>

<span class="n">MODINFO_ATTR</span><span class="p">(</span><span class="n">version</span><span class="p">);</span>
<span class="n">MODINFO_ATTR</span><span class="p">(</span><span class="n">srcversion</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">char</span> <span class="n">last_unloaded_module</span><span class="p">[</span><span class="n">MODULE_NAME_LEN</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>

<span class="cp">#ifdef CONFIG_MODULE_UNLOAD</span>

<span class="n">EXPORT_TRACEPOINT_SYMBOL</span><span class="p">(</span><span class="n">module_get</span><span class="p">);</span>

<span class="cm">/* Init the unload section of the module. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">module_unload_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">refptr</span> <span class="o">=</span> <span class="n">alloc_percpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">module_ref</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">refptr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">source_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">target_list</span><span class="p">);</span>

	<span class="cm">/* Hold reference count during initialization. */</span>
	<span class="n">__this_cpu_write</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">refptr</span><span class="o">-&gt;</span><span class="n">incs</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="cm">/* Backwards compatibility macros put refcount during init. */</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">waiter</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Does a already use b? */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">already_uses</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module_use</span> <span class="o">*</span><span class="n">use</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">use</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">source_list</span><span class="p">,</span> <span class="n">source_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">use</span><span class="o">-&gt;</span><span class="n">source</span> <span class="o">==</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s uses %s!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s does not use %s!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Module a uses b</span>
<span class="cm"> *  - we add &#39;a&#39; as a &quot;source&quot;, &#39;b&#39; as a &quot;target&quot; of module use</span>
<span class="cm"> *  - the module_use is added to the list of &#39;b&#39; sources (so</span>
<span class="cm"> *    &#39;b&#39; can walk the list to see who sourced them), and of &#39;a&#39;</span>
<span class="cm"> *    targets (so &#39;a&#39; can see what modules it targets).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">add_module_usage</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module_use</span> <span class="o">*</span><span class="n">use</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Allocating new usage for %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">use</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">use</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">use</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: out of memory loading</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">use</span><span class="o">-&gt;</span><span class="n">source</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
	<span class="n">use</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">use</span><span class="o">-&gt;</span><span class="n">source_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">source_list</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">use</span><span class="o">-&gt;</span><span class="n">target_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">target_list</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Module a uses b: caller needs module_mutex() */</span>
<span class="kt">int</span> <span class="nf">ref_module</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">already_uses</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* If module isn&#39;t available, we fail. */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">strong_try_module_get</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">add_module_usage</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">module_put</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ref_module</span><span class="p">);</span>

<span class="cm">/* Clear the unload stuff of the module. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">module_unload_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module_use</span> <span class="o">*</span><span class="n">use</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">use</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">target_list</span><span class="p">,</span> <span class="n">target_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">use</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">;</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s unusing %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">module_put</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">use</span><span class="o">-&gt;</span><span class="n">source_list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">use</span><span class="o">-&gt;</span><span class="n">target_list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">use</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_mutex</span><span class="p">);</span>

	<span class="n">free_percpu</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">refptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_MODULE_FORCE_UNLOAD</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">try_force_unload</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_TRUNC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">add_taint</span><span class="p">(</span><span class="n">TAINT_FORCED_RMMOD</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">try_force_unload</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MODULE_FORCE_UNLOAD */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">stopref</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">forced</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Whole machine is stopped with interrupts off when this runs. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__try_stop_module</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">_sref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">stopref</span> <span class="o">*</span><span class="n">sref</span> <span class="o">=</span> <span class="n">_sref</span><span class="p">;</span>

	<span class="cm">/* If it&#39;s not unused, quit unless we&#39;re forcing. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">module_refcount</span><span class="p">(</span><span class="n">sref</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">sref</span><span class="o">-&gt;</span><span class="n">forced</span> <span class="o">=</span> <span class="n">try_force_unload</span><span class="p">(</span><span class="n">sref</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EWOULDBLOCK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Mark it as dying. */</span>
	<span class="n">sref</span><span class="o">-&gt;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">MODULE_STATE_GOING</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">try_stop_module</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">forced</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">stopref</span> <span class="n">sref</span> <span class="o">=</span> <span class="p">{</span> <span class="n">mod</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">forced</span> <span class="p">};</span>

		<span class="k">return</span> <span class="n">stop_machine</span><span class="p">(</span><span class="n">__try_stop_module</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sref</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* We don&#39;t need to stop the machine for this. */</span>
		<span class="n">mod</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">MODULE_STATE_GOING</span><span class="p">;</span>
		<span class="n">synchronize_sched</span><span class="p">();</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">module_refcount</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">incs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">decs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">decs</span> <span class="o">+=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">refptr</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">decs</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * ensure the incs are added up after the decs.</span>
<span class="cm">	 * module_put ensures incs are visible before decs with smp_wmb.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This 2-count scheme avoids the situation where the refcount</span>
<span class="cm">	 * for CPU0 is read, then CPU0 increments the module refcount,</span>
<span class="cm">	 * then CPU1 drops that refcount, then the refcount for CPU1 is</span>
<span class="cm">	 * read. We would record a decrement but not its corresponding</span>
<span class="cm">	 * increment so we would see a low count (disaster).</span>
<span class="cm">	 *</span>
<span class="cm">	 * Rare situation? But module_refcount can be preempted, and we</span>
<span class="cm">	 * might be tallying up 4096+ CPUs. So it is not impossible.</span>
<span class="cm">	 */</span>
	<span class="n">smp_rmb</span><span class="p">();</span>
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">incs</span> <span class="o">+=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">refptr</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">incs</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">incs</span> <span class="o">-</span> <span class="n">decs</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">module_refcount</span><span class="p">);</span>

<span class="cm">/* This exists whether we can unload or not */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">free_module</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">wait_for_zero_refcount</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Since we might sleep for some time, release the mutex first */</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_mutex</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Looking at refcount...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">module_refcount</span><span class="p">(</span><span class="n">mod</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">schedule</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_RUNNING</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">delete_module</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">name_user</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">MODULE_NAME_LEN</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">forced</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_MODULE</span><span class="p">)</span> <span class="o">||</span> <span class="n">modules_disabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strncpy_from_user</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">name_user</span><span class="p">,</span> <span class="n">MODULE_NAME_LEN</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="n">name</span><span class="p">[</span><span class="n">MODULE_NAME_LEN</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mutex_lock_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_mutex</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>

	<span class="n">mod</span> <span class="o">=</span> <span class="n">find_module</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mod</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">source_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Other modules depend on us: get rid of them first. */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EWOULDBLOCK</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Doing init or already dying? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">MODULE_STATE_LIVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* FIXME: if (force), slam module count and wake up</span>
<span class="cm">                   waiter --RR */</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s already dying</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If it has an init func, it must have an exit func to unload */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">init</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">exit</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">forced</span> <span class="o">=</span> <span class="n">try_force_unload</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">forced</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* This module can&#39;t be removed */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Set this up before setting mod-&gt;state */</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">waiter</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

	<span class="cm">/* Stop the machine so refcounts can&#39;t move and disable module. */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">try_stop_module</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">forced</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Never wait if forced. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">forced</span> <span class="o">&amp;&amp;</span> <span class="n">module_refcount</span><span class="p">(</span><span class="n">mod</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">wait_for_zero_refcount</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_mutex</span><span class="p">);</span>
	<span class="cm">/* Final destruction now no one is using it. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">exit</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">mod</span><span class="o">-&gt;</span><span class="n">exit</span><span class="p">();</span>
	<span class="n">blocking_notifier_call_chain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_notify_list</span><span class="p">,</span>
				     <span class="n">MODULE_STATE_GOING</span><span class="p">,</span> <span class="n">mod</span><span class="p">);</span>
	<span class="n">async_synchronize_full</span><span class="p">();</span>

	<span class="cm">/* Store the name of the last unloaded module for diagnostic purposes */</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">last_unloaded_module</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">last_unloaded_module</span><span class="p">));</span>

	<span class="n">free_module</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">print_unload_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module_use</span> <span class="o">*</span><span class="n">use</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">printed_something</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; %lu &quot;</span><span class="p">,</span> <span class="n">module_refcount</span><span class="p">(</span><span class="n">mod</span><span class="p">));</span>

	<span class="cm">/* Always include a trailing , so userspace can differentiate</span>
<span class="cm">           between this and the old multi-field proc format. */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">use</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">source_list</span><span class="p">,</span> <span class="n">source_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printed_something</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%s,&quot;</span><span class="p">,</span> <span class="n">use</span><span class="o">-&gt;</span><span class="n">source</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">init</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">exit</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printed_something</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;[permanent],&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">printed_something</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;-&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__symbol_put</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">symbol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>

	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">find_symbol</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">owner</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">owner</span><span class="p">);</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__symbol_put</span><span class="p">);</span>

<span class="cm">/* Note this assumes addr is a function, which it currently always is. */</span>
<span class="kt">void</span> <span class="nf">symbol_put_addr</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">modaddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">dereference_function_descriptor</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">core_kernel_text</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* module_text_address is safe here: we&#39;re supposed to have reference</span>
<span class="cm">	 * to module from symbol_get, so it can&#39;t go away. */</span>
	<span class="n">modaddr</span> <span class="o">=</span> <span class="n">__module_text_address</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">modaddr</span><span class="p">);</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">modaddr</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">symbol_put_addr</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">show_refcnt</span><span class="p">(</span><span class="k">struct</span> <span class="n">module_attribute</span> <span class="o">*</span><span class="n">mattr</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">module_kobject</span> <span class="o">*</span><span class="n">mk</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&quot;%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">module_refcount</span><span class="p">(</span><span class="n">mk</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">module_attribute</span> <span class="n">modinfo_refcnt</span> <span class="o">=</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">refcnt</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">show_refcnt</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">__module_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">module</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">module</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">preempt_disable</span><span class="p">();</span>
		<span class="n">__this_cpu_inc</span><span class="p">(</span><span class="n">module</span><span class="o">-&gt;</span><span class="n">refptr</span><span class="o">-&gt;</span><span class="n">incs</span><span class="p">);</span>
		<span class="n">trace_module_get</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>
		<span class="n">preempt_enable</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__module_get</span><span class="p">);</span>

<span class="n">bool</span> <span class="nf">try_module_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">module</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">module</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">preempt_disable</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">module_is_live</span><span class="p">(</span><span class="n">module</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">__this_cpu_inc</span><span class="p">(</span><span class="n">module</span><span class="o">-&gt;</span><span class="n">refptr</span><span class="o">-&gt;</span><span class="n">incs</span><span class="p">);</span>
			<span class="n">trace_module_get</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

		<span class="n">preempt_enable</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">try_module_get</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">module_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">module</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">module</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">preempt_disable</span><span class="p">();</span>
		<span class="n">smp_wmb</span><span class="p">();</span> <span class="cm">/* see comment in module_refcount */</span>
		<span class="n">__this_cpu_inc</span><span class="p">(</span><span class="n">module</span><span class="o">-&gt;</span><span class="n">refptr</span><span class="o">-&gt;</span><span class="n">decs</span><span class="p">);</span>

		<span class="n">trace_module_put</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>
		<span class="cm">/* Maybe they&#39;re waiting for us to drop reference? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">module_is_live</span><span class="p">(</span><span class="n">module</span><span class="p">)))</span>
			<span class="n">wake_up_process</span><span class="p">(</span><span class="n">module</span><span class="o">-&gt;</span><span class="n">waiter</span><span class="p">);</span>
		<span class="n">preempt_enable</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">module_put</span><span class="p">);</span>

<span class="cp">#else </span><span class="cm">/* !CONFIG_MODULE_UNLOAD */</span><span class="cp"></span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">print_unload_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* We don&#39;t know the usage count, or what modules are using. */</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; - -&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">module_unload_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ref_module</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">strong_try_module_get</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ref_module</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">module_unload_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MODULE_UNLOAD */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">module_flags_taint</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">taints</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">TAINT_PROPRIETARY_MODULE</span><span class="p">))</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">l</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;P&#39;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">taints</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">TAINT_OOT_MODULE</span><span class="p">))</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">l</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;O&#39;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">taints</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">TAINT_FORCED_MODULE</span><span class="p">))</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">l</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;F&#39;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">taints</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">TAINT_CRAP</span><span class="p">))</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">l</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;C&#39;</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * TAINT_FORCED_RMMOD: could be added.</span>
<span class="cm">	 * TAINT_UNSAFE_SMP, TAINT_MACHINE_CHECK, TAINT_BAD_PAGE don&#39;t</span>
<span class="cm">	 * apply to modules.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">l</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">show_initstate</span><span class="p">(</span><span class="k">struct</span> <span class="n">module_attribute</span> <span class="o">*</span><span class="n">mattr</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">module_kobject</span> <span class="o">*</span><span class="n">mk</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="s">&quot;unknown&quot;</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">mk</span><span class="o">-&gt;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MODULE_STATE_LIVE</span>:
		<span class="n">state</span> <span class="o">=</span> <span class="s">&quot;live&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MODULE_STATE_COMING</span>:
		<span class="n">state</span> <span class="o">=</span> <span class="s">&quot;coming&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MODULE_STATE_GOING</span>:
		<span class="n">state</span> <span class="o">=</span> <span class="s">&quot;going&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">module_attribute</span> <span class="n">modinfo_initstate</span> <span class="o">=</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">initstate</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">show_initstate</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">store_uevent</span><span class="p">(</span><span class="k">struct</span> <span class="n">module_attribute</span> <span class="o">*</span><span class="n">mattr</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">module_kobject</span> <span class="o">*</span><span class="n">mk</span><span class="p">,</span>
			    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">kobject_action</span> <span class="n">action</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kobject_action_type</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">action</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">kobject_uevent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mk</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">action</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">module_attribute</span> <span class="n">module_uevent</span> <span class="o">=</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">uevent</span><span class="p">,</span> <span class="mo">0200</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">store_uevent</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">show_coresize</span><span class="p">(</span><span class="k">struct</span> <span class="n">module_attribute</span> <span class="o">*</span><span class="n">mattr</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">module_kobject</span> <span class="o">*</span><span class="n">mk</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mk</span><span class="o">-&gt;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">module_attribute</span> <span class="n">modinfo_coresize</span> <span class="o">=</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">coresize</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">show_coresize</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">show_initsize</span><span class="p">(</span><span class="k">struct</span> <span class="n">module_attribute</span> <span class="o">*</span><span class="n">mattr</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">module_kobject</span> <span class="o">*</span><span class="n">mk</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mk</span><span class="o">-&gt;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">init_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">module_attribute</span> <span class="n">modinfo_initsize</span> <span class="o">=</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">initsize</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">show_initsize</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">show_taint</span><span class="p">(</span><span class="k">struct</span> <span class="n">module_attribute</span> <span class="o">*</span><span class="n">mattr</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">module_kobject</span> <span class="o">*</span><span class="n">mk</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">l</span><span class="p">;</span>

	<span class="n">l</span> <span class="o">=</span> <span class="n">module_flags_taint</span><span class="p">(</span><span class="n">mk</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
	<span class="n">buffer</span><span class="p">[</span><span class="n">l</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">l</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">module_attribute</span> <span class="n">modinfo_taint</span> <span class="o">=</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">taint</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">show_taint</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">module_attribute</span> <span class="o">*</span><span class="n">modinfo_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">module_uevent</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">modinfo_version</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">modinfo_srcversion</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">modinfo_initstate</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">modinfo_coresize</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">modinfo_initsize</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">modinfo_taint</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_MODULE_UNLOAD</span>
	<span class="o">&amp;</span><span class="n">modinfo_refcnt</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">vermagic</span><span class="p">[]</span> <span class="o">=</span> <span class="n">VERMAGIC_STRING</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">try_to_force_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_MODULE_FORCE_LOAD</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_taint</span><span class="p">(</span><span class="n">TAINT_FORCED_MODULE</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: %s: kernel tainted.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">reason</span><span class="p">);</span>
	<span class="n">add_taint_module</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">TAINT_FORCED_MODULE</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_MODVERSIONS</span>
<span class="cm">/* If the arch applies (non-zero) relocations to kernel kcrctab, unapply it. */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">maybe_relocated</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">crc</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">crc_owner</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef ARCH_RELOCATES_KCRCTAB</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">crc_owner</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">crc</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">reloc_start</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">crc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_version</span><span class="p">(</span><span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">sechdrs</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">versindex</span><span class="p">,</span>
			 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">symname</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> 
			 <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">crc</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">crc_owner</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">num_versions</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">modversion_info</span> <span class="o">*</span><span class="n">versions</span><span class="p">;</span>

	<span class="cm">/* Exporting module didn&#39;t supply crcs?  OK, we&#39;re already tainted. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">crc</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* No versions at all?  modprobe --force does this. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">versindex</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">try_to_force_load</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">symname</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">versions</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">versindex</span><span class="p">].</span><span class="n">sh_addr</span><span class="p">;</span>
	<span class="n">num_versions</span> <span class="o">=</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">versindex</span><span class="p">].</span><span class="n">sh_size</span>
		<span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">modversion_info</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_versions</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">versions</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">,</span> <span class="n">symname</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">versions</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">crc</span> <span class="o">==</span> <span class="n">maybe_relocated</span><span class="p">(</span><span class="o">*</span><span class="n">crc</span><span class="p">,</span> <span class="n">crc_owner</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Found checksum %lX vs module %lX</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">maybe_relocated</span><span class="p">(</span><span class="o">*</span><span class="n">crc</span><span class="p">,</span> <span class="n">crc_owner</span><span class="p">),</span> <span class="n">versions</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">crc</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bad_version</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: no symbol version for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">symname</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">bad_version:</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: disagrees about version of symbol %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">symname</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">check_modstruct_version</span><span class="p">(</span><span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">sechdrs</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">versindex</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">crc</span><span class="p">;</span>

	<span class="cm">/* Since this should be found in kernel (which can&#39;t be removed),</span>
<span class="cm">	 * no locking is necessary. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">find_symbol</span><span class="p">(</span><span class="n">MODULE_SYMBOL_PREFIX</span> <span class="s">&quot;module_layout&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
			 <span class="o">&amp;</span><span class="n">crc</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">check_version</span><span class="p">(</span><span class="n">sechdrs</span><span class="p">,</span> <span class="n">versindex</span><span class="p">,</span> <span class="s">&quot;module_layout&quot;</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span> <span class="n">crc</span><span class="p">,</span>
			     <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* First part is kernel version, which we ignore if module has crcs. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">same_magic</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">amagic</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bmagic</span><span class="p">,</span>
			     <span class="n">bool</span> <span class="n">has_crcs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">has_crcs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">amagic</span> <span class="o">+=</span> <span class="n">strcspn</span><span class="p">(</span><span class="n">amagic</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">);</span>
		<span class="n">bmagic</span> <span class="o">+=</span> <span class="n">strcspn</span><span class="p">(</span><span class="n">bmagic</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">amagic</span><span class="p">,</span> <span class="n">bmagic</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">check_version</span><span class="p">(</span><span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">sechdrs</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">versindex</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">symname</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> 
				<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">crc</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">crc_owner</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">check_modstruct_version</span><span class="p">(</span><span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">sechdrs</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">versindex</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">same_magic</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">amagic</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bmagic</span><span class="p">,</span>
			     <span class="n">bool</span> <span class="n">has_crcs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">amagic</span><span class="p">,</span> <span class="n">bmagic</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MODVERSIONS */</span><span class="cp"></span>

<span class="cm">/* Resolve a symbol for this module.  I.e. if we find one, record usage. */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_symbol</span> <span class="o">*</span><span class="nf">resolve_symbol</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span>
						  <span class="k">const</span> <span class="k">struct</span> <span class="n">load_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
						  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
						  <span class="kt">char</span> <span class="n">ownername</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_symbol</span> <span class="o">*</span><span class="n">sym</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">crc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_mutex</span><span class="p">);</span>
	<span class="n">sym</span> <span class="o">=</span> <span class="n">find_symbol</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">owner</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">crc</span><span class="p">,</span>
			  <span class="o">!</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">taints</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">TAINT_PROPRIETARY_MODULE</span><span class="p">)),</span> <span class="nb">true</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sym</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_version</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">vers</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span> <span class="n">crc</span><span class="p">,</span>
			   <span class="n">owner</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sym</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">getname</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ref_module</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">owner</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sym</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">getname</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">getname:</span>
	<span class="cm">/* We must make copy under the lock if we failed to get ref. */</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="n">ownername</span><span class="p">,</span> <span class="n">module_name</span><span class="p">(</span><span class="n">owner</span><span class="p">),</span> <span class="n">MODULE_NAME_LEN</span><span class="p">);</span>
<span class="nl">unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sym</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_symbol</span> <span class="o">*</span>
<span class="nf">resolve_symbol_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span>
		    <span class="k">const</span> <span class="k">struct</span> <span class="n">load_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
		    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_symbol</span> <span class="o">*</span><span class="n">ksym</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">owner</span><span class="p">[</span><span class="n">MODULE_NAME_LEN</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wait_event_interruptible_timeout</span><span class="p">(</span><span class="n">module_wq</span><span class="p">,</span>
			<span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ksym</span> <span class="o">=</span> <span class="n">resolve_symbol</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">owner</span><span class="p">))</span>
			<span class="o">||</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">ksym</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">,</span>
					     <span class="mi">30</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: gave up waiting for init of module %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">owner</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ksym</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * /sys/module/foo/sections stuff</span>
<span class="cm"> * J. Corbet &lt;corbet@lwn.net&gt;</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_SYSFS</span>

<span class="cp">#ifdef CONFIG_KALLSYMS</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">sect_empty</span><span class="p">(</span><span class="k">const</span> <span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">sect</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">sect</span><span class="o">-&gt;</span><span class="n">sh_flags</span> <span class="o">&amp;</span> <span class="n">SHF_ALLOC</span><span class="p">)</span> <span class="o">||</span> <span class="n">sect</span><span class="o">-&gt;</span><span class="n">sh_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">module_sect_attr</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module_attribute</span> <span class="n">mattr</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">module_sect_attrs</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">attribute_group</span> <span class="n">grp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nsections</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">module_sect_attr</span> <span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">module_sect_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">module_attribute</span> <span class="o">*</span><span class="n">mattr</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">module_kobject</span> <span class="o">*</span><span class="n">mk</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module_sect_attr</span> <span class="o">*</span><span class="n">sattr</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">mattr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">module_sect_attr</span><span class="p">,</span> <span class="n">mattr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;0x%pK</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">sattr</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_sect_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">module_sect_attrs</span> <span class="o">*</span><span class="n">sect_attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">section</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">section</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">section</span> <span class="o">&lt;</span> <span class="n">sect_attrs</span><span class="o">-&gt;</span><span class="n">nsections</span><span class="p">;</span> <span class="n">section</span><span class="o">++</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">sect_attrs</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">section</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sect_attrs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_sect_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">load_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nloaded</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">size</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">module_sect_attrs</span> <span class="o">*</span><span class="n">sect_attrs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">module_sect_attr</span> <span class="o">*</span><span class="n">sattr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">attribute</span> <span class="o">**</span><span class="n">gattr</span><span class="p">;</span>

	<span class="cm">/* Count loaded sections and allocate structures */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shnum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sect_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
			<span class="n">nloaded</span><span class="o">++</span><span class="p">;</span>
	<span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sect_attrs</span><span class="p">)</span>
			<span class="o">+</span> <span class="n">nloaded</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sect_attrs</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">sect_attrs</span><span class="o">-&gt;</span><span class="n">grp</span><span class="p">.</span><span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
	<span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">nloaded</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sect_attrs</span><span class="o">-&gt;</span><span class="n">grp</span><span class="p">.</span><span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">sect_attrs</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sect_attrs</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Setup section attributes. */</span>
	<span class="n">sect_attrs</span><span class="o">-&gt;</span><span class="n">grp</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;sections&quot;</span><span class="p">;</span>
	<span class="n">sect_attrs</span><span class="o">-&gt;</span><span class="n">grp</span><span class="p">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">sect_attrs</span> <span class="o">+</span> <span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="n">sect_attrs</span><span class="o">-&gt;</span><span class="n">nsections</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sattr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sect_attrs</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">gattr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sect_attrs</span><span class="o">-&gt;</span><span class="n">grp</span><span class="p">.</span><span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shnum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">sec</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sect_empty</span><span class="p">(</span><span class="n">sec</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">sattr</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">=</span> <span class="n">sec</span><span class="o">-&gt;</span><span class="n">sh_addr</span><span class="p">;</span>
		<span class="n">sattr</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">secstrings</span> <span class="o">+</span> <span class="n">sec</span><span class="o">-&gt;</span><span class="n">sh_name</span><span class="p">,</span>
					<span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sattr</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">sect_attrs</span><span class="o">-&gt;</span><span class="n">nsections</span><span class="o">++</span><span class="p">;</span>
		<span class="n">sysfs_attr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sattr</span><span class="o">-&gt;</span><span class="n">mattr</span><span class="p">.</span><span class="n">attr</span><span class="p">);</span>
		<span class="n">sattr</span><span class="o">-&gt;</span><span class="n">mattr</span><span class="p">.</span><span class="n">show</span> <span class="o">=</span> <span class="n">module_sect_show</span><span class="p">;</span>
		<span class="n">sattr</span><span class="o">-&gt;</span><span class="n">mattr</span><span class="p">.</span><span class="n">store</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">sattr</span><span class="o">-&gt;</span><span class="n">mattr</span><span class="p">.</span><span class="n">attr</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">sattr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
		<span class="n">sattr</span><span class="o">-&gt;</span><span class="n">mattr</span><span class="p">.</span><span class="n">attr</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">S_IRUGO</span><span class="p">;</span>
		<span class="o">*</span><span class="p">(</span><span class="n">gattr</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">sattr</span><span class="o">++</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mattr</span><span class="p">.</span><span class="n">attr</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">gattr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sysfs_create_group</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">mkobj</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sect_attrs</span><span class="o">-&gt;</span><span class="n">grp</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">sect_attrs</span> <span class="o">=</span> <span class="n">sect_attrs</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>
  <span class="nl">out:</span>
	<span class="n">free_sect_attrs</span><span class="p">(</span><span class="n">sect_attrs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">remove_sect_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">sect_attrs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sysfs_remove_group</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">mkobj</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">sect_attrs</span><span class="o">-&gt;</span><span class="n">grp</span><span class="p">);</span>
		<span class="cm">/* We are positive that no one is using any sect attrs</span>
<span class="cm">		 * at this point.  Deallocate immediately. */</span>
		<span class="n">free_sect_attrs</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">sect_attrs</span><span class="p">);</span>
		<span class="n">mod</span><span class="o">-&gt;</span><span class="n">sect_attrs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * /sys/module/foo/notes/.section.name gives contents of SHT_NOTE sections.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">module_notes_attrs</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">dir</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">notes</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bin_attribute</span> <span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">module_notes_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">bin_attribute</span> <span class="o">*</span><span class="n">bin_attr</span><span class="p">,</span>
				 <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The caller checked the pos and count against our size.</span>
<span class="cm">	 */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">bin_attr</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_notes_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">module_notes_attrs</span> <span class="o">*</span><span class="n">notes_attrs</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">notes_attrs</span><span class="o">-&gt;</span><span class="n">dir</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">sysfs_remove_bin_file</span><span class="p">(</span><span class="n">notes_attrs</span><span class="o">-&gt;</span><span class="n">dir</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">notes_attrs</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">kobject_put</span><span class="p">(</span><span class="n">notes_attrs</span><span class="o">-&gt;</span><span class="n">dir</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">notes_attrs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_notes_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">load_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">notes</span><span class="p">,</span> <span class="n">loaded</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">module_notes_attrs</span> <span class="o">*</span><span class="n">notes_attrs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bin_attribute</span> <span class="o">*</span><span class="n">nattr</span><span class="p">;</span>

	<span class="cm">/* failed to create section attributes, so can&#39;t create notes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">sect_attrs</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Count notes sections and allocate structures.  */</span>
	<span class="n">notes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shnum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sect_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_type</span> <span class="o">==</span> <span class="n">SHT_NOTE</span><span class="p">))</span>
			<span class="o">++</span><span class="n">notes</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">notes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">notes_attrs</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">notes_attrs</span><span class="p">)</span>
			      <span class="o">+</span> <span class="n">notes</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">notes_attrs</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
			      <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">notes_attrs</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">notes_attrs</span><span class="o">-&gt;</span><span class="n">notes</span> <span class="o">=</span> <span class="n">notes</span><span class="p">;</span>
	<span class="n">nattr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">notes_attrs</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">loaded</span> <span class="o">=</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shnum</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sect_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_type</span> <span class="o">==</span> <span class="n">SHT_NOTE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sysfs_bin_attr_init</span><span class="p">(</span><span class="n">nattr</span><span class="p">);</span>
			<span class="n">nattr</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">sect_attrs</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">loaded</span><span class="p">].</span><span class="n">name</span><span class="p">;</span>
			<span class="n">nattr</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">S_IRUGO</span><span class="p">;</span>
			<span class="n">nattr</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_size</span><span class="p">;</span>
			<span class="n">nattr</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_addr</span><span class="p">;</span>
			<span class="n">nattr</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">=</span> <span class="n">module_notes_read</span><span class="p">;</span>
			<span class="o">++</span><span class="n">nattr</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">++</span><span class="n">loaded</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">notes_attrs</span><span class="o">-&gt;</span><span class="n">dir</span> <span class="o">=</span> <span class="n">kobject_create_and_add</span><span class="p">(</span><span class="s">&quot;notes&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">mkobj</span><span class="p">.</span><span class="n">kobj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">notes_attrs</span><span class="o">-&gt;</span><span class="n">dir</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">notes</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sysfs_create_bin_file</span><span class="p">(</span><span class="n">notes_attrs</span><span class="o">-&gt;</span><span class="n">dir</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">notes_attrs</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">notes_attrs</span> <span class="o">=</span> <span class="n">notes_attrs</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>

  <span class="nl">out:</span>
	<span class="n">free_notes_attrs</span><span class="p">(</span><span class="n">notes_attrs</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">remove_notes_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">notes_attrs</span><span class="p">)</span>
		<span class="n">free_notes_attrs</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">notes_attrs</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">notes_attrs</span><span class="o">-&gt;</span><span class="n">notes</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">add_sect_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">load_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">remove_sect_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">add_notes_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">load_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">remove_notes_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_KALLSYMS */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_usage_links</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_MODULE_UNLOAD</span>
	<span class="k">struct</span> <span class="n">module_use</span> <span class="o">*</span><span class="n">use</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nowarn</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">use</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">target_list</span><span class="p">,</span> <span class="n">target_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nowarn</span> <span class="o">=</span> <span class="n">sysfs_create_link</span><span class="p">(</span><span class="n">use</span><span class="o">-&gt;</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">holders_dir</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">mkobj</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_mutex</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">del_usage_links</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_MODULE_UNLOAD</span>
	<span class="k">struct</span> <span class="n">module_use</span> <span class="o">*</span><span class="n">use</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">use</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">target_list</span><span class="p">,</span> <span class="n">target_list</span><span class="p">)</span>
		<span class="n">sysfs_remove_link</span><span class="p">(</span><span class="n">use</span><span class="o">-&gt;</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">holders_dir</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_mutex</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">module_add_modinfo_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">module_attribute</span> <span class="o">*</span><span class="n">temp_attr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">modinfo_attrs</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">((</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">module_attribute</span><span class="p">)</span> <span class="o">*</span>
					<span class="p">(</span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">modinfo_attrs</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)),</span>
					<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">modinfo_attrs</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">temp_attr</span> <span class="o">=</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">modinfo_attrs</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">attr</span> <span class="o">=</span> <span class="n">modinfo_attrs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">error</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">test</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">test</span> <span class="o">&amp;&amp;</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">test</span><span class="p">(</span><span class="n">mod</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">temp_attr</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">temp_attr</span><span class="p">));</span>
			<span class="n">sysfs_attr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">temp_attr</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">sysfs_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">mkobj</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span><span class="o">&amp;</span><span class="n">temp_attr</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">);</span>
			<span class="o">++</span><span class="n">temp_attr</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">module_remove_modinfo_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">attr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">modinfo_attrs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* pick a field to test for end of list */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">name</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">sysfs_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">mkobj</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span><span class="o">&amp;</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">)</span>
			<span class="n">attr</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">modinfo_attrs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mod_sysfs_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">module_sysfs_initialized</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: module sysfs not initialized</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kobj</span> <span class="o">=</span> <span class="n">kset_find_obj</span><span class="p">(</span><span class="n">module_kset</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kobj</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: module is already loaded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">kobject_put</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">mkobj</span><span class="p">.</span><span class="n">mod</span> <span class="o">=</span> <span class="n">mod</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">mkobj</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">mkobj</span><span class="p">.</span><span class="n">kobj</span><span class="p">));</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">mkobj</span><span class="p">.</span><span class="n">kobj</span><span class="p">.</span><span class="n">kset</span> <span class="o">=</span> <span class="n">module_kset</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">kobject_init_and_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">mkobj</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">module_ktype</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				   <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">kobject_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">mkobj</span><span class="p">.</span><span class="n">kobj</span><span class="p">);</span>

	<span class="cm">/* delay uevent until full sysfs population */</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mod_sysfs_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span>
			   <span class="k">const</span> <span class="k">struct</span> <span class="n">load_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kparam</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_params</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">mod_sysfs_init</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">holders_dir</span> <span class="o">=</span> <span class="n">kobject_create_and_add</span><span class="p">(</span><span class="s">&quot;holders&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">mkobj</span><span class="p">.</span><span class="n">kobj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">holders_dir</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unreg</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">module_param_sysfs_setup</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">kparam</span><span class="p">,</span> <span class="n">num_params</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unreg_holders</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">module_add_modinfo_attrs</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unreg_param</span><span class="p">;</span>

	<span class="n">add_usage_links</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
	<span class="n">add_sect_attrs</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
	<span class="n">add_notes_attrs</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>

	<span class="n">kobject_uevent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">mkobj</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span> <span class="n">KOBJ_ADD</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_unreg_param:</span>
	<span class="n">module_param_sysfs_remove</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
<span class="nl">out_unreg_holders:</span>
	<span class="n">kobject_put</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">holders_dir</span><span class="p">);</span>
<span class="nl">out_unreg:</span>
	<span class="n">kobject_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">mkobj</span><span class="p">.</span><span class="n">kobj</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mod_sysfs_fini</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">remove_notes_attrs</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
	<span class="n">remove_sect_attrs</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
	<span class="n">kobject_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">mkobj</span><span class="p">.</span><span class="n">kobj</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* !CONFIG_SYSFS */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mod_sysfs_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span>
			   <span class="k">const</span> <span class="k">struct</span> <span class="n">load_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kparam</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_params</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mod_sysfs_fini</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">module_remove_modinfo_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">del_usage_links</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_SYSFS */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mod_sysfs_teardown</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">del_usage_links</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
	<span class="n">module_remove_modinfo_attrs</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
	<span class="n">module_param_sysfs_remove</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
	<span class="n">kobject_put</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">mkobj</span><span class="p">.</span><span class="n">drivers_dir</span><span class="p">);</span>
	<span class="n">kobject_put</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">holders_dir</span><span class="p">);</span>
	<span class="n">mod_sysfs_fini</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * unlink the module with the whole machine is stopped with interrupts off</span>
<span class="cm"> * - this defends against kallsyms not taking locks</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__unlink_module</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">_mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span> <span class="o">=</span> <span class="n">_mod</span><span class="p">;</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">module_bug_cleanup</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_DEBUG_SET_MODULE_RONX</span>
<span class="cm">/*</span>
<span class="cm"> * LKM RO/NX protection: protect module&#39;s text/ro-data</span>
<span class="cm"> * from modification and any data from execution.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">set_page_attributes</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">end</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_pages</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">begin_pfn</span> <span class="o">=</span> <span class="n">PFN_DOWN</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">start</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_pfn</span> <span class="o">=</span> <span class="n">PFN_DOWN</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">end</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">end_pfn</span> <span class="o">&gt;</span> <span class="n">begin_pfn</span><span class="p">)</span>
		<span class="n">set</span><span class="p">(</span><span class="n">begin_pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span> <span class="n">end_pfn</span> <span class="o">-</span> <span class="n">begin_pfn</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_section_ro_nx</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">text_size</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ro_size</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* begin and end PFNs of the current subsection */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">begin_pfn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_pfn</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set RO for module text and RO-data:</span>
<span class="cm">	 * - Always protect first page.</span>
<span class="cm">	 * - Do not protect last partial page.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ro_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">set_page_attributes</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">ro_size</span><span class="p">,</span> <span class="n">set_memory_ro</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set NX permissions for module data:</span>
<span class="cm">	 * - Do not protect first partial page.</span>
<span class="cm">	 * - Always protect last page.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">total_size</span> <span class="o">&gt;</span> <span class="n">text_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">begin_pfn</span> <span class="o">=</span> <span class="n">PFN_UP</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">base</span> <span class="o">+</span> <span class="n">text_size</span><span class="p">);</span>
		<span class="n">end_pfn</span> <span class="o">=</span> <span class="n">PFN_UP</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">base</span> <span class="o">+</span> <span class="n">total_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">end_pfn</span> <span class="o">&gt;</span> <span class="n">begin_pfn</span><span class="p">)</span>
			<span class="n">set_memory_nx</span><span class="p">(</span><span class="n">begin_pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span> <span class="n">end_pfn</span> <span class="o">-</span> <span class="n">begin_pfn</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unset_module_core_ro_nx</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_page_attributes</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_core</span> <span class="o">+</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_text_size</span><span class="p">,</span>
		<span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_core</span> <span class="o">+</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_size</span><span class="p">,</span>
		<span class="n">set_memory_x</span><span class="p">);</span>
	<span class="n">set_page_attributes</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_core</span><span class="p">,</span>
		<span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_core</span> <span class="o">+</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_ro_size</span><span class="p">,</span>
		<span class="n">set_memory_rw</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unset_module_init_ro_nx</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_page_attributes</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_init</span> <span class="o">+</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">init_text_size</span><span class="p">,</span>
		<span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_init</span> <span class="o">+</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">init_size</span><span class="p">,</span>
		<span class="n">set_memory_x</span><span class="p">);</span>
	<span class="n">set_page_attributes</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_init</span><span class="p">,</span>
		<span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_init</span> <span class="o">+</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">init_ro_size</span><span class="p">,</span>
		<span class="n">set_memory_rw</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Iterate through all modules and set each module&#39;s text as RW */</span>
<span class="kt">void</span> <span class="nf">set_all_modules_text_rw</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">modules</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_core</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_text_size</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">set_page_attributes</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_core</span><span class="p">,</span>
						<span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_core</span> <span class="o">+</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_text_size</span><span class="p">,</span>
						<span class="n">set_memory_rw</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_init</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">init_text_size</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">set_page_attributes</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_init</span><span class="p">,</span>
						<span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_init</span> <span class="o">+</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">init_text_size</span><span class="p">,</span>
						<span class="n">set_memory_rw</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Iterate through all modules and set each module&#39;s text as RO */</span>
<span class="kt">void</span> <span class="nf">set_all_modules_text_ro</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">modules</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_core</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_text_size</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">set_page_attributes</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_core</span><span class="p">,</span>
						<span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_core</span> <span class="o">+</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_text_size</span><span class="p">,</span>
						<span class="n">set_memory_ro</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_init</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">init_text_size</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">set_page_attributes</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_init</span><span class="p">,</span>
						<span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_init</span> <span class="o">+</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">init_text_size</span><span class="p">,</span>
						<span class="n">set_memory_ro</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_mutex</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_section_ro_nx</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">text_size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ro_size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total_size</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">unset_module_core_ro_nx</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">unset_module_init_ro_nx</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="n">__weak</span> <span class="nf">module_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">module_region</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">module_region</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__weak</span> <span class="nf">module_arch_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/* Free a module, remove from lists, etc. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_module</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_module_free</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>

	<span class="cm">/* Delete from various lists */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_mutex</span><span class="p">);</span>
	<span class="n">stop_machine</span><span class="p">(</span><span class="n">__unlink_module</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_mutex</span><span class="p">);</span>
	<span class="n">mod_sysfs_teardown</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>

	<span class="cm">/* Remove dynamic debug info */</span>
	<span class="n">ddebug_remove_module</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="cm">/* Arch-specific cleanup. */</span>
	<span class="n">module_arch_cleanup</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>

	<span class="cm">/* Module unload stuff */</span>
	<span class="n">module_unload_free</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>

	<span class="cm">/* Free any allocated parameters. */</span>
	<span class="n">destroy_params</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">kp</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_kp</span><span class="p">);</span>

	<span class="cm">/* This may be NULL, but that&#39;s OK */</span>
	<span class="n">unset_module_init_ro_nx</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
	<span class="n">module_free</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_init</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">);</span>
	<span class="n">percpu_modfree</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>

	<span class="cm">/* Free lock-classes: */</span>
	<span class="n">lockdep_free_key_range</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_core</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_size</span><span class="p">);</span>

	<span class="cm">/* Finally, free the core (containing the module structure) */</span>
	<span class="n">unset_module_core_ro_nx</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
	<span class="n">module_free</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_core</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_MPU</span>
	<span class="n">update_protections</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">__symbol_get</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">symbol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_symbol</span> <span class="o">*</span><span class="n">sym</span><span class="p">;</span>

	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">sym</span> <span class="o">=</span> <span class="n">find_symbol</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">owner</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sym</span> <span class="o">&amp;&amp;</span> <span class="n">strong_try_module_get</span><span class="p">(</span><span class="n">owner</span><span class="p">))</span>
		<span class="n">sym</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">preempt_enable</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">sym</span> <span class="o">?</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__symbol_get</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Ensure that an exported symbol [global namespace] does not already exist</span>
<span class="cm"> * in the kernel or in some other module&#39;s exported symbol table.</span>
<span class="cm"> *</span>
<span class="cm"> * You must hold the module_mutex.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">verify_export_symbols</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_symbol</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_symbol</span> <span class="o">*</span><span class="n">sym</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">{</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">syms</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_syms</span> <span class="p">},</span>
		<span class="p">{</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">gpl_syms</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_gpl_syms</span> <span class="p">},</span>
		<span class="p">{</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">gpl_future_syms</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_gpl_future_syms</span> <span class="p">},</span>
<span class="cp">#ifdef CONFIG_UNUSED_SYMBOLS</span>
		<span class="p">{</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">unused_syms</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_unused_syms</span> <span class="p">},</span>
		<span class="p">{</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">unused_gpl_syms</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_unused_gpl_syms</span> <span class="p">},</span>
<span class="cp">#endif</span>
	<span class="p">};</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">s</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sym</span><span class="p">;</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sym</span> <span class="o">+</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">num</span><span class="p">;</span> <span class="n">s</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">find_symbol</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">owner</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
				       <span class="s">&quot;%s: exports duplicate symbol %s&quot;</span>
				       <span class="s">&quot; (owned by %s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">module_name</span><span class="p">(</span><span class="n">owner</span><span class="p">));</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Change all symbols so that st_value encodes the pointer directly. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">simplify_symbols</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">load_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">symsec</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">sym</span><span class="p">];</span>
	<span class="n">Elf_Sym</span> <span class="o">*</span><span class="n">sym</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">symsec</span><span class="o">-&gt;</span><span class="n">sh_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">secbase</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_symbol</span> <span class="o">*</span><span class="n">ksym</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">symsec</span><span class="o">-&gt;</span><span class="n">sh_size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Elf_Sym</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">strtab</span> <span class="o">+</span> <span class="n">sym</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_name</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">sym</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_shndx</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SHN_COMMON</span>:
			<span class="cm">/* We compiled with -fno-common.  These are not</span>
<span class="cm">			   supposed to happen.  */</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Common symbol: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: please compile with -fno-common</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SHN_ABS</span>:
			<span class="cm">/* Don&#39;t need to do anything */</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Absolute symbol: 0x%08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">sym</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_value</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SHN_UNDEF</span>:
			<span class="n">ksym</span> <span class="o">=</span> <span class="n">resolve_symbol_wait</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
			<span class="cm">/* Ok if resolved.  */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ksym</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ksym</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">sym</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_value</span> <span class="o">=</span> <span class="n">ksym</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Ok if weak.  */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ksym</span> <span class="o">&amp;&amp;</span> <span class="n">ELF_ST_BIND</span><span class="p">(</span><span class="n">sym</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_info</span><span class="p">)</span> <span class="o">==</span> <span class="n">STB_WEAK</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: Unknown symbol %s (err %li)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">ksym</span><span class="p">));</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">ksym</span><span class="p">)</span> <span class="o">?:</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="cm">/* Divert to percpu allocation if a percpu var. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sym</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_shndx</span> <span class="o">==</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">pcpu</span><span class="p">)</span>
				<span class="n">secbase</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">mod_percpu</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">secbase</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">sym</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_shndx</span><span class="p">].</span><span class="n">sh_addr</span><span class="p">;</span>
			<span class="n">sym</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_value</span> <span class="o">+=</span> <span class="n">secbase</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__weak</span> <span class="nf">apply_relocate</span><span class="p">(</span><span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">sechdrs</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strtab</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">symindex</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">relsec</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">me</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;module %s: REL relocation unsupported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__weak</span> <span class="nf">apply_relocate_add</span><span class="p">(</span><span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">sechdrs</span><span class="p">,</span>
			      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strtab</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">symindex</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">relsec</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">me</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;module %s: RELA relocation unsupported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">apply_relocations</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">load_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Now do relocations. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shnum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">infosec</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_info</span><span class="p">;</span>

		<span class="cm">/* Not a valid relocation section? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">infosec</span> <span class="o">&gt;=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shnum</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Don&#39;t bother with non-allocated sections */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">infosec</span><span class="p">].</span><span class="n">sh_flags</span> <span class="o">&amp;</span> <span class="n">SHF_ALLOC</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_type</span> <span class="o">==</span> <span class="n">SHT_REL</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">apply_relocate</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">strtab</span><span class="p">,</span>
					     <span class="n">info</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">sym</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">mod</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_type</span> <span class="o">==</span> <span class="n">SHT_RELA</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">apply_relocate_add</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">strtab</span><span class="p">,</span>
						 <span class="n">info</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">sym</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">mod</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Additional bytes needed by arch in front of individual sections */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__weak</span> <span class="nf">arch_mod_section_prepend</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">section</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* default implementation just returns zero */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Update size with this section: return offset. */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">get_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">size</span><span class="p">,</span>
		       <span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">sechdr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">section</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="o">*</span><span class="n">size</span> <span class="o">+=</span> <span class="n">arch_mod_section_prepend</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">section</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="o">*</span><span class="n">size</span><span class="p">,</span> <span class="n">sechdr</span><span class="o">-&gt;</span><span class="n">sh_addralign</span> <span class="o">?:</span> <span class="mi">1</span><span class="p">);</span>
	<span class="o">*</span><span class="n">size</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">+</span> <span class="n">sechdr</span><span class="o">-&gt;</span><span class="n">sh_size</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Lay out the SHF_ALLOC sections in a way not dissimilar to how ld</span>
<span class="cm">   might -- code, read-only data, read-write data, small data.  Tally</span>
<span class="cm">   sizes, and place the offsets into sh_entsize fields: high bit means it</span>
<span class="cm">   belongs in init. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">layout_sections</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="k">struct</span> <span class="n">load_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">masks</span><span class="p">[][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="cm">/* NOTE: all executable code must be the first section</span>
<span class="cm">		 * in this array; otherwise modify the text_size</span>
<span class="cm">		 * finder in the two loops below */</span>
		<span class="p">{</span> <span class="n">SHF_EXECINSTR</span> <span class="o">|</span> <span class="n">SHF_ALLOC</span><span class="p">,</span> <span class="n">ARCH_SHF_SMALL</span> <span class="p">},</span>
		<span class="p">{</span> <span class="n">SHF_ALLOC</span><span class="p">,</span> <span class="n">SHF_WRITE</span> <span class="o">|</span> <span class="n">ARCH_SHF_SMALL</span> <span class="p">},</span>
		<span class="p">{</span> <span class="n">SHF_WRITE</span> <span class="o">|</span> <span class="n">SHF_ALLOC</span><span class="p">,</span> <span class="n">ARCH_SHF_SMALL</span> <span class="p">},</span>
		<span class="p">{</span> <span class="n">ARCH_SHF_SMALL</span> <span class="o">|</span> <span class="n">SHF_ALLOC</span><span class="p">,</span> <span class="mi">0</span> <span class="p">}</span>
	<span class="p">};</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shnum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_entsize</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Core section allocation order:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">masks</span><span class="p">);</span> <span class="o">++</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shnum</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sname</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">secstrings</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sh_name</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sh_flags</span> <span class="o">&amp;</span> <span class="n">masks</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="n">masks</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
			    <span class="o">||</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sh_flags</span> <span class="o">&amp;</span> <span class="n">masks</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
			    <span class="o">||</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sh_entsize</span> <span class="o">!=</span> <span class="o">~</span><span class="mi">0UL</span>
			    <span class="o">||</span> <span class="n">strstarts</span><span class="p">(</span><span class="n">sname</span><span class="p">,</span> <span class="s">&quot;.init&quot;</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">sh_entsize</span> <span class="o">=</span> <span class="n">get_offset</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_size</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sname</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>: <span class="cm">/* executable */</span>
			<span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_size</span> <span class="o">=</span> <span class="n">debug_align</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_size</span><span class="p">);</span>
			<span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_text_size</span> <span class="o">=</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_size</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">1</span>: <span class="cm">/* RO: text and ro-data */</span>
			<span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_size</span> <span class="o">=</span> <span class="n">debug_align</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_size</span><span class="p">);</span>
			<span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_ro_size</span> <span class="o">=</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_size</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">3</span>: <span class="cm">/* whole core */</span>
			<span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_size</span> <span class="o">=</span> <span class="n">debug_align</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_size</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Init section allocation order:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">masks</span><span class="p">);</span> <span class="o">++</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shnum</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sname</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">secstrings</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sh_name</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sh_flags</span> <span class="o">&amp;</span> <span class="n">masks</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="n">masks</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
			    <span class="o">||</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sh_flags</span> <span class="o">&amp;</span> <span class="n">masks</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
			    <span class="o">||</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sh_entsize</span> <span class="o">!=</span> <span class="o">~</span><span class="mi">0UL</span>
			    <span class="o">||</span> <span class="o">!</span><span class="n">strstarts</span><span class="p">(</span><span class="n">sname</span><span class="p">,</span> <span class="s">&quot;.init&quot;</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">sh_entsize</span> <span class="o">=</span> <span class="p">(</span><span class="n">get_offset</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">init_size</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
					 <span class="o">|</span> <span class="n">INIT_OFFSET_MASK</span><span class="p">);</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sname</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>: <span class="cm">/* executable */</span>
			<span class="n">mod</span><span class="o">-&gt;</span><span class="n">init_size</span> <span class="o">=</span> <span class="n">debug_align</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">init_size</span><span class="p">);</span>
			<span class="n">mod</span><span class="o">-&gt;</span><span class="n">init_text_size</span> <span class="o">=</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">init_size</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">1</span>: <span class="cm">/* RO: text and ro-data */</span>
			<span class="n">mod</span><span class="o">-&gt;</span><span class="n">init_size</span> <span class="o">=</span> <span class="n">debug_align</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">init_size</span><span class="p">);</span>
			<span class="n">mod</span><span class="o">-&gt;</span><span class="n">init_ro_size</span> <span class="o">=</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">init_size</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">3</span>: <span class="cm">/* whole init */</span>
			<span class="n">mod</span><span class="o">-&gt;</span><span class="n">init_size</span> <span class="o">=</span> <span class="n">debug_align</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">init_size</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_license</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">license</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">license</span><span class="p">)</span>
		<span class="n">license</span> <span class="o">=</span> <span class="s">&quot;unspecified&quot;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">license_is_gpl_compatible</span><span class="p">(</span><span class="n">license</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_taint</span><span class="p">(</span><span class="n">TAINT_PROPRIETARY_MODULE</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: module license &#39;%s&#39; taints &quot;</span>
				<span class="s">&quot;kernel.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">license</span><span class="p">);</span>
		<span class="n">add_taint_module</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">TAINT_PROPRIETARY_MODULE</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Parse tag=value strings from .modinfo section */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">next_string</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">secsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Skip non-zero chars */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">string</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">string</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">secsize</span><span class="p">)</span><span class="o">--</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Skip any zero padding. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">string</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">string</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">secsize</span><span class="p">)</span><span class="o">--</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">get_modinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">load_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">taglen</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">tag</span><span class="p">);</span>
	<span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">infosec</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">info</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="n">infosec</span><span class="o">-&gt;</span><span class="n">sh_size</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">infosec</span><span class="o">-&gt;</span><span class="n">sh_addr</span><span class="p">;</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">next_string</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">taglen</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="p">[</span><span class="n">taglen</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;=&#39;</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">p</span> <span class="o">+</span> <span class="n">taglen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">setup_modinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="k">struct</span> <span class="n">load_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">attr</span> <span class="o">=</span> <span class="n">modinfo_attrs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">setup</span><span class="p">)</span>
			<span class="n">attr</span><span class="o">-&gt;</span><span class="n">setup</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">get_modinfo</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">name</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_modinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">attr</span> <span class="o">=</span> <span class="n">modinfo_attrs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">)</span>
			<span class="n">attr</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_KALLSYMS</span>

<span class="cm">/* lookup symbol in given range of kernel_symbols */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_symbol</span> <span class="o">*</span><span class="nf">lookup_symbol</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_symbol</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_symbol</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bsearch</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kernel_symbol</span><span class="p">),</span> <span class="n">cmp_name</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_exported</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">,</span>
		       <span class="k">const</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_symbol</span> <span class="o">*</span><span class="n">ks</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mod</span><span class="p">)</span>
		<span class="n">ks</span> <span class="o">=</span> <span class="n">lookup_symbol</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">__start___ksymtab</span><span class="p">,</span> <span class="n">__stop___ksymtab</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ks</span> <span class="o">=</span> <span class="n">lookup_symbol</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">syms</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">syms</span> <span class="o">+</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_syms</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ks</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">==</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* As per nm */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="nf">elf_type</span><span class="p">(</span><span class="k">const</span> <span class="n">Elf_Sym</span> <span class="o">*</span><span class="n">sym</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">load_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">sechdrs</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ELF_ST_BIND</span><span class="p">(</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_info</span><span class="p">)</span> <span class="o">==</span> <span class="n">STB_WEAK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ELF_ST_TYPE</span><span class="p">(</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_info</span><span class="p">)</span> <span class="o">==</span> <span class="n">STT_OBJECT</span><span class="p">)</span>
			<span class="k">return</span> <span class="sc">&#39;v&#39;</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="sc">&#39;w&#39;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_shndx</span> <span class="o">==</span> <span class="n">SHN_UNDEF</span><span class="p">)</span>
		<span class="k">return</span> <span class="sc">&#39;U&#39;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_shndx</span> <span class="o">==</span> <span class="n">SHN_ABS</span><span class="p">)</span>
		<span class="k">return</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_shndx</span> <span class="o">&gt;=</span> <span class="n">SHN_LORESERVE</span><span class="p">)</span>
		<span class="k">return</span> <span class="sc">&#39;?&#39;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_shndx</span><span class="p">].</span><span class="n">sh_flags</span> <span class="o">&amp;</span> <span class="n">SHF_EXECINSTR</span><span class="p">)</span>
		<span class="k">return</span> <span class="sc">&#39;t&#39;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_shndx</span><span class="p">].</span><span class="n">sh_flags</span> <span class="o">&amp;</span> <span class="n">SHF_ALLOC</span>
	    <span class="o">&amp;&amp;</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_shndx</span><span class="p">].</span><span class="n">sh_type</span> <span class="o">!=</span> <span class="n">SHT_NOBITS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_shndx</span><span class="p">].</span><span class="n">sh_flags</span> <span class="o">&amp;</span> <span class="n">SHF_WRITE</span><span class="p">))</span>
			<span class="k">return</span> <span class="sc">&#39;r&#39;</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_shndx</span><span class="p">].</span><span class="n">sh_flags</span> <span class="o">&amp;</span> <span class="n">ARCH_SHF_SMALL</span><span class="p">)</span>
			<span class="k">return</span> <span class="sc">&#39;g&#39;</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="sc">&#39;d&#39;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_shndx</span><span class="p">].</span><span class="n">sh_type</span> <span class="o">==</span> <span class="n">SHT_NOBITS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_shndx</span><span class="p">].</span><span class="n">sh_flags</span> <span class="o">&amp;</span> <span class="n">ARCH_SHF_SMALL</span><span class="p">)</span>
			<span class="k">return</span> <span class="sc">&#39;s&#39;</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="sc">&#39;b&#39;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strstarts</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">secstrings</span> <span class="o">+</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_shndx</span><span class="p">].</span><span class="n">sh_name</span><span class="p">,</span>
		      <span class="s">&quot;.debug&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="sc">&#39;n&#39;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="sc">&#39;?&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">is_core_symbol</span><span class="p">(</span><span class="k">const</span> <span class="n">Elf_Sym</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="k">const</span> <span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">sechdrs</span><span class="p">,</span>
                           <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">shnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">sec</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">st_shndx</span> <span class="o">==</span> <span class="n">SHN_UNDEF</span>
	    <span class="o">||</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">st_shndx</span> <span class="o">&gt;=</span> <span class="n">shnum</span>
	    <span class="o">||</span> <span class="o">!</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">st_name</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">sec</span> <span class="o">=</span> <span class="n">sechdrs</span> <span class="o">+</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">st_shndx</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sec</span><span class="o">-&gt;</span><span class="n">sh_flags</span> <span class="o">&amp;</span> <span class="n">SHF_ALLOC</span><span class="p">)</span>
<span class="cp">#ifndef CONFIG_KALLSYMS_ALL</span>
	    <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">sec</span><span class="o">-&gt;</span><span class="n">sh_flags</span> <span class="o">&amp;</span> <span class="n">SHF_EXECINSTR</span><span class="p">)</span>
<span class="cp">#endif</span>
	    <span class="o">||</span> <span class="p">(</span><span class="n">sec</span><span class="o">-&gt;</span><span class="n">sh_entsize</span> <span class="o">&amp;</span> <span class="n">INIT_OFFSET_MASK</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We only allocate and copy the strings needed by the parts of symtab</span>
<span class="cm"> * we keep.  This is simple, but has the effect of making multiple</span>
<span class="cm"> * copies of duplicates.  We could be more sophisticated, see</span>
<span class="cm"> * linux-kernel thread starting with</span>
<span class="cm"> * &lt;73defb5e4bca04a6431392cc341112b1@localhost&gt;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">layout_symtab</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="k">struct</span> <span class="n">load_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">symsect</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">sym</span><span class="p">;</span>
	<span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">strsect</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">str</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">Elf_Sym</span> <span class="o">*</span><span class="n">src</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">nsrc</span><span class="p">,</span> <span class="n">ndst</span><span class="p">,</span> <span class="n">strtab_size</span><span class="p">;</span>

	<span class="cm">/* Put symbol section at end of init part of module. */</span>
	<span class="n">symsect</span><span class="o">-&gt;</span><span class="n">sh_flags</span> <span class="o">|=</span> <span class="n">SHF_ALLOC</span><span class="p">;</span>
	<span class="n">symsect</span><span class="o">-&gt;</span><span class="n">sh_entsize</span> <span class="o">=</span> <span class="n">get_offset</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">init_size</span><span class="p">,</span> <span class="n">symsect</span><span class="p">,</span>
					 <span class="n">info</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">sym</span><span class="p">)</span> <span class="o">|</span> <span class="n">INIT_OFFSET_MASK</span><span class="p">;</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">secstrings</span> <span class="o">+</span> <span class="n">symsect</span><span class="o">-&gt;</span><span class="n">sh_name</span><span class="p">);</span>

	<span class="n">src</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">hdr</span> <span class="o">+</span> <span class="n">symsect</span><span class="o">-&gt;</span><span class="n">sh_offset</span><span class="p">;</span>
	<span class="n">nsrc</span> <span class="o">=</span> <span class="n">symsect</span><span class="o">-&gt;</span><span class="n">sh_size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">src</span><span class="p">);</span>

	<span class="cm">/* Compute total space required for the core symbols&#39; strtab. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">ndst</span> <span class="o">=</span> <span class="n">i</span> <span class="o">=</span> <span class="n">strtab_size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nsrc</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="o">++</span><span class="n">src</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_core_symbol</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shnum</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">strtab_size</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">strtab</span><span class="p">[</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">st_name</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">ndst</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="cm">/* Append room for core symbols at end of core part. */</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">symoffs</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_size</span><span class="p">,</span> <span class="n">symsect</span><span class="o">-&gt;</span><span class="n">sh_addralign</span> <span class="o">?:</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">stroffs</span> <span class="o">=</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_size</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">symoffs</span> <span class="o">+</span> <span class="n">ndst</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Elf_Sym</span><span class="p">);</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_size</span> <span class="o">+=</span> <span class="n">strtab_size</span><span class="p">;</span>

	<span class="cm">/* Put string table section at end of init part of module. */</span>
	<span class="n">strsect</span><span class="o">-&gt;</span><span class="n">sh_flags</span> <span class="o">|=</span> <span class="n">SHF_ALLOC</span><span class="p">;</span>
	<span class="n">strsect</span><span class="o">-&gt;</span><span class="n">sh_entsize</span> <span class="o">=</span> <span class="n">get_offset</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">init_size</span><span class="p">,</span> <span class="n">strsect</span><span class="p">,</span>
					 <span class="n">info</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">str</span><span class="p">)</span> <span class="o">|</span> <span class="n">INIT_OFFSET_MASK</span><span class="p">;</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">secstrings</span> <span class="o">+</span> <span class="n">strsect</span><span class="o">-&gt;</span><span class="n">sh_name</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_kallsyms</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">load_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ndst</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">Elf_Sym</span> <span class="o">*</span><span class="n">src</span><span class="p">;</span>
	<span class="n">Elf_Sym</span> <span class="o">*</span><span class="n">dst</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">symsec</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">sym</span><span class="p">];</span>

	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">symtab</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">symsec</span><span class="o">-&gt;</span><span class="n">sh_addr</span><span class="p">;</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_symtab</span> <span class="o">=</span> <span class="n">symsec</span><span class="o">-&gt;</span><span class="n">sh_size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Elf_Sym</span><span class="p">);</span>
	<span class="cm">/* Make sure we get permanent strtab: don&#39;t use info-&gt;strtab. */</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">strtab</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">str</span><span class="p">].</span><span class="n">sh_addr</span><span class="p">;</span>

	<span class="cm">/* Set types up while we still have access to sections. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_symtab</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">mod</span><span class="o">-&gt;</span><span class="n">symtab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_info</span> <span class="o">=</span> <span class="n">elf_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">symtab</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">info</span><span class="p">);</span>

	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_symtab</span> <span class="o">=</span> <span class="n">dst</span> <span class="o">=</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_core</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">symoffs</span><span class="p">;</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_strtab</span> <span class="o">=</span> <span class="n">s</span> <span class="o">=</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_core</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">stroffs</span><span class="p">;</span>
	<span class="n">src</span> <span class="o">=</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">symtab</span><span class="p">;</span>
	<span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="o">*</span><span class="n">src</span><span class="p">;</span>
	<span class="o">*</span><span class="n">s</span><span class="o">++</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">ndst</span> <span class="o">=</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_symtab</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="o">++</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_core_symbol</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shnum</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">dst</span><span class="p">[</span><span class="n">ndst</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">src</span><span class="p">;</span>
		<span class="n">dst</span><span class="p">[</span><span class="n">ndst</span><span class="o">++</span><span class="p">].</span><span class="n">st_name</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_strtab</span><span class="p">;</span>
		<span class="n">s</span> <span class="o">+=</span> <span class="n">strlcpy</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">strtab</span><span class="p">[</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">st_name</span><span class="p">],</span> <span class="n">KSYM_NAME_LEN</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_num_syms</span> <span class="o">=</span> <span class="n">ndst</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">layout_symtab</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="k">struct</span> <span class="n">load_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_kallsyms</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">load_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_KALLSYMS */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dynamic_debug_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">_ddebug</span> <span class="o">*</span><span class="n">debug</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_DYNAMIC_DEBUG</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ddebug_add_module</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">debug</span><span class="o">-&gt;</span><span class="n">modname</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;dynamic debug error adding module: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">debug</span><span class="o">-&gt;</span><span class="n">modname</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dynamic_debug_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">_ddebug</span> <span class="o">*</span><span class="n">debug</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">)</span>
		<span class="n">ddebug_remove_module</span><span class="p">(</span><span class="n">debug</span><span class="o">-&gt;</span><span class="n">modname</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span> <span class="n">__weak</span> <span class="nf">module_alloc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="nb">NULL</span> <span class="o">:</span> <span class="n">vmalloc_exec</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">module_alloc_update_bounds</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="n">module_alloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_mutex</span><span class="p">);</span>
		<span class="cm">/* Update module bounds. */</span>
		<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="n">module_addr_min</span><span class="p">)</span>
			<span class="n">module_addr_min</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ret</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ret</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">module_addr_max</span><span class="p">)</span>
			<span class="n">module_addr_max</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ret</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_mutex</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_DEBUG_KMEMLEAK</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">kmemleak_load_module</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">load_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* only scan the sections containing data */</span>
	<span class="n">kmemleak_scan_area</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shnum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">secstrings</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_name</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_flags</span> <span class="o">&amp;</span> <span class="n">SHF_ALLOC</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strstarts</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;.data&quot;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">strstarts</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;.bss&quot;</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">kmemleak_scan_area</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_addr</span><span class="p">,</span>
				   <span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">kmemleak_load_module</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">load_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* Sets info-&gt;hdr and info-&gt;len. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">copy_and_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">load_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">umod</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uargs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">Elf_Ehdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hdr</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>

	<span class="cm">/* Suck in entire file: we&#39;ll want most of it. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">hdr</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">len</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span> <span class="n">umod</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">free_hdr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Sanity checks against insmoding binaries or wrong arch,</span>
<span class="cm">	   weird elf version */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">,</span> <span class="n">ELFMAG</span><span class="p">,</span> <span class="n">SELFMAG</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
	    <span class="o">||</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_type</span> <span class="o">!=</span> <span class="n">ET_REL</span>
	    <span class="o">||</span> <span class="o">!</span><span class="n">elf_check_arch</span><span class="p">(</span><span class="n">hdr</span><span class="p">)</span>
	    <span class="o">||</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shentsize</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Elf_Shdr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">free_hdr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shoff</span> <span class="o">&gt;=</span> <span class="n">len</span> <span class="o">||</span>
	    <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shnum</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Elf_Shdr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">len</span> <span class="o">-</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shoff</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">free_hdr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">hdr</span> <span class="o">=</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">free_hdr:</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">hdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_copy</span><span class="p">(</span><span class="k">struct</span> <span class="n">load_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rewrite_section_headers</span><span class="p">(</span><span class="k">struct</span> <span class="n">load_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* This should always be true, but let&#39;s be sure. */</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">sh_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shnum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">shdr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">sh_type</span> <span class="o">!=</span> <span class="n">SHT_NOBITS</span>
		    <span class="o">&amp;&amp;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">shdr</span><span class="o">-&gt;</span><span class="n">sh_offset</span> <span class="o">+</span> <span class="n">shdr</span><span class="o">-&gt;</span><span class="n">sh_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Module len %lu truncated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">info</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Mark all sections sh_addr with their address in the</span>
<span class="cm">		   temporary image. */</span>
		<span class="n">shdr</span><span class="o">-&gt;</span><span class="n">sh_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">hdr</span> <span class="o">+</span> <span class="n">shdr</span><span class="o">-&gt;</span><span class="n">sh_offset</span><span class="p">;</span>

<span class="cp">#ifndef CONFIG_MODULE_UNLOAD</span>
		<span class="cm">/* Don&#39;t load .exit sections */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strstarts</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">secstrings</span><span class="o">+</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">sh_name</span><span class="p">,</span> <span class="s">&quot;.exit&quot;</span><span class="p">))</span>
			<span class="n">shdr</span><span class="o">-&gt;</span><span class="n">sh_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">SHF_ALLOC</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="cm">/* Track but don&#39;t keep modinfo and version sections. */</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">vers</span> <span class="o">=</span> <span class="n">find_sec</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;__versions&quot;</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">find_sec</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;.modinfo&quot;</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">info</span><span class="p">].</span><span class="n">sh_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">SHF_ALLOC</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">vers</span><span class="p">].</span><span class="n">sh_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">SHF_ALLOC</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set up our basic convenience variables (pointers to section headers,</span>
<span class="cm"> * search for module section index etc), and do some basic section</span>
<span class="cm"> * verification.</span>
<span class="cm"> *</span>
<span class="cm"> * Return the temporary module pointer (we&#39;ll replace it with the final</span>
<span class="cm"> * one when we move the module sections around).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="nf">setup_load_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">load_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">;</span>

	<span class="cm">/* Set up the convenience variables */</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">hdr</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shoff</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">secstrings</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">hdr</span>
		<span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shstrndx</span><span class="p">].</span><span class="n">sh_offset</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">rewrite_section_headers</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>

	<span class="cm">/* Find internal symbols and strings. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shnum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_type</span> <span class="o">==</span> <span class="n">SHT_SYMTAB</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">sym</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">str</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_link</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">strtab</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">hdr</span>
				<span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">str</span><span class="p">].</span><span class="n">sh_offset</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">mod</span> <span class="o">=</span> <span class="n">find_sec</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;.gnu.linkonce.this_module&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">mod</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;No module found in object</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOEXEC</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* This is temporary: point mod into copy of data. */</span>
	<span class="n">mod</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">mod</span><span class="p">].</span><span class="n">sh_addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">sym</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: module has no symbols (stripped?)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOEXEC</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">pcpu</span> <span class="o">=</span> <span class="n">find_pcpusec</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

	<span class="cm">/* Check module struct version now, before we try to use module. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_modstruct_version</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">vers</span><span class="p">,</span> <span class="n">mod</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOEXEC</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mod</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_modinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="k">struct</span> <span class="n">load_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">modmagic</span> <span class="o">=</span> <span class="n">get_modinfo</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;vermagic&quot;</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* This is allowed: modprobe --force will invalidate it. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">modmagic</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">try_to_force_load</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="s">&quot;bad vermagic&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">same_magic</span><span class="p">(</span><span class="n">modmagic</span><span class="p">,</span> <span class="n">vermagic</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">vers</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: version magic &#39;%s&#39; should be &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">modmagic</span><span class="p">,</span> <span class="n">vermagic</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">get_modinfo</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;intree&quot;</span><span class="p">))</span>
		<span class="n">add_taint_module</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">TAINT_OOT_MODULE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_modinfo</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;staging&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">add_taint_module</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">TAINT_CRAP</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: module is from the staging directory,&quot;</span>
		       <span class="s">&quot; the quality is unknown, you have been warned.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Set up license info based on the info section */</span>
	<span class="n">set_license</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">get_modinfo</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;license&quot;</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">find_module_sections</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="k">struct</span> <span class="n">load_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">kp</span> <span class="o">=</span> <span class="n">section_objs</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;__param&quot;</span><span class="p">,</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">kp</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_kp</span><span class="p">);</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">syms</span> <span class="o">=</span> <span class="n">section_objs</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;__ksymtab&quot;</span><span class="p">,</span>
				 <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">syms</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_syms</span><span class="p">);</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">crcs</span> <span class="o">=</span> <span class="n">section_addr</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;__kcrctab&quot;</span><span class="p">);</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">gpl_syms</span> <span class="o">=</span> <span class="n">section_objs</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;__ksymtab_gpl&quot;</span><span class="p">,</span>
				     <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">gpl_syms</span><span class="p">),</span>
				     <span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_gpl_syms</span><span class="p">);</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">gpl_crcs</span> <span class="o">=</span> <span class="n">section_addr</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;__kcrctab_gpl&quot;</span><span class="p">);</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">gpl_future_syms</span> <span class="o">=</span> <span class="n">section_objs</span><span class="p">(</span><span class="n">info</span><span class="p">,</span>
					    <span class="s">&quot;__ksymtab_gpl_future&quot;</span><span class="p">,</span>
					    <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">gpl_future_syms</span><span class="p">),</span>
					    <span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_gpl_future_syms</span><span class="p">);</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">gpl_future_crcs</span> <span class="o">=</span> <span class="n">section_addr</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;__kcrctab_gpl_future&quot;</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_UNUSED_SYMBOLS</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">unused_syms</span> <span class="o">=</span> <span class="n">section_objs</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;__ksymtab_unused&quot;</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">unused_syms</span><span class="p">),</span>
					<span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_unused_syms</span><span class="p">);</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">unused_crcs</span> <span class="o">=</span> <span class="n">section_addr</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;__kcrctab_unused&quot;</span><span class="p">);</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">unused_gpl_syms</span> <span class="o">=</span> <span class="n">section_objs</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;__ksymtab_unused_gpl&quot;</span><span class="p">,</span>
					    <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">unused_gpl_syms</span><span class="p">),</span>
					    <span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_unused_gpl_syms</span><span class="p">);</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">unused_gpl_crcs</span> <span class="o">=</span> <span class="n">section_addr</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;__kcrctab_unused_gpl&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_CONSTRUCTORS</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">ctors</span> <span class="o">=</span> <span class="n">section_objs</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;.ctors&quot;</span><span class="p">,</span>
				  <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">ctors</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_ctors</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_TRACEPOINTS</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">tracepoints_ptrs</span> <span class="o">=</span> <span class="n">section_objs</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;__tracepoints_ptrs&quot;</span><span class="p">,</span>
					     <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">tracepoints_ptrs</span><span class="p">),</span>
					     <span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_tracepoints</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef HAVE_JUMP_LABEL</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">jump_entries</span> <span class="o">=</span> <span class="n">section_objs</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;__jump_table&quot;</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">jump_entries</span><span class="p">),</span>
					<span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_jump_entries</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_EVENT_TRACING</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">trace_events</span> <span class="o">=</span> <span class="n">section_objs</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;_ftrace_events&quot;</span><span class="p">,</span>
					 <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">trace_events</span><span class="p">),</span>
					 <span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_trace_events</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * This section contains pointers to allocated objects in the trace</span>
<span class="cm">	 * code and not scanning it leads to false positives.</span>
<span class="cm">	 */</span>
	<span class="n">kmemleak_scan_area</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">trace_events</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">trace_events</span><span class="p">)</span> <span class="o">*</span>
			   <span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_trace_events</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_TRACING</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">trace_bprintk_fmt_start</span> <span class="o">=</span> <span class="n">section_objs</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;__trace_printk_fmt&quot;</span><span class="p">,</span>
					 <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">trace_bprintk_fmt_start</span><span class="p">),</span>
					 <span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_trace_bprintk_fmt</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * This section contains pointers to allocated objects in the trace</span>
<span class="cm">	 * code and not scanning it leads to false positives.</span>
<span class="cm">	 */</span>
	<span class="n">kmemleak_scan_area</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">trace_bprintk_fmt_start</span><span class="p">,</span>
			   <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">trace_bprintk_fmt_start</span><span class="p">)</span> <span class="o">*</span>
			   <span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_trace_bprintk_fmt</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_FTRACE_MCOUNT_RECORD</span>
	<span class="cm">/* sechdrs[0].sh_size is always zero */</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">ftrace_callsites</span> <span class="o">=</span> <span class="n">section_objs</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;__mcount_loc&quot;</span><span class="p">,</span>
					     <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">ftrace_callsites</span><span class="p">),</span>
					     <span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_ftrace_callsites</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">extable</span> <span class="o">=</span> <span class="n">section_objs</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;__ex_table&quot;</span><span class="p">,</span>
				    <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">extable</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_exentries</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">section_addr</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;__obsparm&quot;</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: Ignoring obsolete parameters</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">debug</span> <span class="o">=</span> <span class="n">section_objs</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;__verbose&quot;</span><span class="p">,</span>
				   <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">debug</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">num_debug</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">move_module</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="k">struct</span> <span class="n">load_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

	<span class="cm">/* Do the allocs. */</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="n">module_alloc_update_bounds</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_size</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * The pointer to this block is stored in the module structure</span>
<span class="cm">	 * which is inside the block. Just mark it as not being a</span>
<span class="cm">	 * leak.</span>
<span class="cm">	 */</span>
	<span class="n">kmemleak_not_leak</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_size</span><span class="p">);</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_core</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>

	<span class="n">ptr</span> <span class="o">=</span> <span class="n">module_alloc_update_bounds</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">init_size</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * The pointer to this block is stored in the module structure</span>
<span class="cm">	 * which is inside the block. This block doesn&#39;t need to be</span>
<span class="cm">	 * scanned as it contains data and code that will be freed</span>
<span class="cm">	 * after the module is initialized.</span>
<span class="cm">	 */</span>
	<span class="n">kmemleak_ignore</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptr</span> <span class="o">&amp;&amp;</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">init_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">module_free</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_core</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">init_size</span><span class="p">);</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_init</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>

	<span class="cm">/* Transfer each section which specifies SHF_ALLOC */</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;final section addresses:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shnum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">dest</span><span class="p">;</span>
		<span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">shdr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">sh_flags</span> <span class="o">&amp;</span> <span class="n">SHF_ALLOC</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">sh_entsize</span> <span class="o">&amp;</span> <span class="n">INIT_OFFSET_MASK</span><span class="p">)</span>
			<span class="n">dest</span> <span class="o">=</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_init</span>
				<span class="o">+</span> <span class="p">(</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">sh_entsize</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">INIT_OFFSET_MASK</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">dest</span> <span class="o">=</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_core</span> <span class="o">+</span> <span class="n">shdr</span><span class="o">-&gt;</span><span class="n">sh_entsize</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">sh_type</span> <span class="o">!=</span> <span class="n">SHT_NOBITS</span><span class="p">)</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">sh_addr</span><span class="p">,</span> <span class="n">shdr</span><span class="o">-&gt;</span><span class="n">sh_size</span><span class="p">);</span>
		<span class="cm">/* Update sh_addr to point to copy in image. */</span>
		<span class="n">shdr</span><span class="o">-&gt;</span><span class="n">sh_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">dest</span><span class="p">;</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">0x%lx %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">sh_addr</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">secstrings</span> <span class="o">+</span> <span class="n">shdr</span><span class="o">-&gt;</span><span class="n">sh_name</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_module_license_and_versions</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * ndiswrapper is under GPL by itself, but loads proprietary modules.</span>
<span class="cm">	 * Don&#39;t use add_taint_module(), as it would prevent ndiswrapper from</span>
<span class="cm">	 * using GPL-only symbols it needs.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;ndiswrapper&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">add_taint</span><span class="p">(</span><span class="n">TAINT_PROPRIETARY_MODULE</span><span class="p">);</span>

	<span class="cm">/* driverloader was caught wrongly pretending to be under GPL */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;driverloader&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">add_taint_module</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">TAINT_PROPRIETARY_MODULE</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_MODVERSIONS</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_syms</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">crcs</span><span class="p">)</span>
	    <span class="o">||</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_gpl_syms</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">gpl_crcs</span><span class="p">)</span>
	    <span class="o">||</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_gpl_future_syms</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">gpl_future_crcs</span><span class="p">)</span>
<span class="cp">#ifdef CONFIG_UNUSED_SYMBOLS</span>
	    <span class="o">||</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_unused_syms</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">unused_crcs</span><span class="p">)</span>
	    <span class="o">||</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_unused_gpl_syms</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">unused_gpl_crcs</span><span class="p">)</span>
<span class="cp">#endif</span>
		<span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">try_to_force_load</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span>
					 <span class="s">&quot;no versions for exported symbols&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">flush_module_icache</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mm_segment_t</span> <span class="n">old_fs</span><span class="p">;</span>

	<span class="cm">/* flush the icache in correct context */</span>
	<span class="n">old_fs</span> <span class="o">=</span> <span class="n">get_fs</span><span class="p">();</span>
	<span class="n">set_fs</span><span class="p">(</span><span class="n">KERNEL_DS</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Flush the instruction cache, since we&#39;ve played with text.</span>
<span class="cm">	 * Do it before processing of module parameters, so the module</span>
<span class="cm">	 * can provide parameter accessor functions of its own.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_init</span><span class="p">)</span>
		<span class="n">flush_icache_range</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_init</span><span class="p">,</span>
				   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_init</span>
				   <span class="o">+</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">init_size</span><span class="p">);</span>
	<span class="n">flush_icache_range</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_core</span><span class="p">,</span>
			   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_core</span> <span class="o">+</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_size</span><span class="p">);</span>

	<span class="n">set_fs</span><span class="p">(</span><span class="n">old_fs</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__weak</span> <span class="nf">module_frob_arch_sections</span><span class="p">(</span><span class="n">Elf_Ehdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">,</span>
				     <span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">sechdrs</span><span class="p">,</span>
				     <span class="kt">char</span> <span class="o">*</span><span class="n">secstrings</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="nf">layout_and_allocate</span><span class="p">(</span><span class="k">struct</span> <span class="n">load_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Module within temporary copy. */</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">;</span>
	<span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">pcpusec</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">mod</span> <span class="o">=</span> <span class="n">setup_load_info</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">mod</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">mod</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">check_modinfo</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>

	<span class="cm">/* Allow arches to frob section contents and sizes.  */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">module_frob_arch_sections</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">,</span>
					<span class="n">info</span><span class="o">-&gt;</span><span class="n">secstrings</span><span class="p">,</span> <span class="n">mod</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">pcpusec</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">pcpu</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcpusec</span><span class="o">-&gt;</span><span class="n">sh_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We have a special allocation for this section. */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">percpu_modalloc</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span>
				      <span class="n">pcpusec</span><span class="o">-&gt;</span><span class="n">sh_size</span><span class="p">,</span> <span class="n">pcpusec</span><span class="o">-&gt;</span><span class="n">sh_addralign</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">pcpusec</span><span class="o">-&gt;</span><span class="n">sh_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">SHF_ALLOC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Determine total sizes, and put offsets in sh_entsize.  For now</span>
<span class="cm">	   this is done generically; there doesn&#39;t appear to be any</span>
<span class="cm">	   special cases for the architectures. */</span>
	<span class="n">layout_sections</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
	<span class="n">layout_symtab</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>

	<span class="cm">/* Allocate and move to the final place */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">move_module</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_percpu</span><span class="p">;</span>

	<span class="cm">/* Module has been copied to its final place now: return it. */</span>
	<span class="n">mod</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">mod</span><span class="p">].</span><span class="n">sh_addr</span><span class="p">;</span>
	<span class="n">kmemleak_load_module</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">mod</span><span class="p">;</span>

<span class="nl">free_percpu:</span>
	<span class="n">percpu_modfree</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* mod is no longer valid after this! */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">module_deallocate</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="k">struct</span> <span class="n">load_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">percpu_modfree</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
	<span class="n">module_free</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_init</span><span class="p">);</span>
	<span class="n">module_free</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_core</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__weak</span> <span class="nf">module_finalize</span><span class="p">(</span><span class="k">const</span> <span class="n">Elf_Ehdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">,</span>
			   <span class="k">const</span> <span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">sechdrs</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">me</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">post_relocation</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">load_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Sort exception table now relocations are done. */</span>
	<span class="n">sort_extable</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">extable</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">extable</span> <span class="o">+</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_exentries</span><span class="p">);</span>

	<span class="cm">/* Copy relocated percpu area over. */</span>
	<span class="n">percpu_modcopy</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">pcpu</span><span class="p">].</span><span class="n">sh_addr</span><span class="p">,</span>
		       <span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">pcpu</span><span class="p">].</span><span class="n">sh_size</span><span class="p">);</span>

	<span class="cm">/* Setup kallsyms-specific fields. */</span>
	<span class="n">add_kallsyms</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>

	<span class="cm">/* Arch-specific module finalizing. */</span>
	<span class="k">return</span> <span class="n">module_finalize</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">,</span> <span class="n">mod</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Allocate and load the module: note that size of section 0 is always</span>
<span class="cm">   zero, and we rely on this for optional sections. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="nf">load_module</span><span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">umod</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span>
				  <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uargs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">load_info</span> <span class="n">info</span> <span class="o">=</span> <span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">};</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;load_module: umod=%p, len=%lu, uargs=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">umod</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">uargs</span><span class="p">);</span>

	<span class="cm">/* Copy in the blobs from userspace, check they are vaguely sane. */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">copy_and_check</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">umod</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">uargs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>

	<span class="cm">/* Figure out module layout, and allocate all the memory. */</span>
	<span class="n">mod</span> <span class="o">=</span> <span class="n">layout_and_allocate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">mod</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">free_copy</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Now module is in final location, initialize linked lists, etc. */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">module_unload_init</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_module</span><span class="p">;</span>

	<span class="cm">/* Now we&#39;ve got everything in the final locations, we can</span>
<span class="cm">	 * find optional sections. */</span>
	<span class="n">find_module_sections</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">check_module_license_and_versions</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_unload</span><span class="p">;</span>

	<span class="cm">/* Set up MODINFO_ATTR fields */</span>
	<span class="n">setup_modinfo</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>

	<span class="cm">/* Fix up syms, so that st_value is a pointer to location. */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">simplify_symbols</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_modinfo</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">apply_relocations</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_modinfo</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">post_relocation</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_modinfo</span><span class="p">;</span>

	<span class="n">flush_module_icache</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>

	<span class="cm">/* Now copy in args */</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">args</span> <span class="o">=</span> <span class="n">strndup_user</span><span class="p">(</span><span class="n">uargs</span><span class="p">,</span> <span class="o">~</span><span class="mi">0UL</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">free_arch_cleanup</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Mark state as coming so strong_try_module_get() ignores us. */</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">MODULE_STATE_COMING</span><span class="p">;</span>

	<span class="cm">/* Now sew it into the lists so we can get lockdep and oops</span>
<span class="cm">	 * info during argument parsing.  No one should access us, since</span>
<span class="cm">	 * strong_try_module_get() will fail.</span>
<span class="cm">	 * lockdep/oops can run asynchronous, so use the RCU list insertion</span>
<span class="cm">	 * function to insert in a way safe to concurrent readers.</span>
<span class="cm">	 * The mutex protects against concurrent writers.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">find_module</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* This has to be done once we&#39;re sure module name is unique. */</span>
	<span class="n">dynamic_debug_setup</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">debug</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">num_debug</span><span class="p">);</span>

	<span class="cm">/* Find duplicate symbols */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">verify_export_symbols</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">ddebug</span><span class="p">;</span>

	<span class="n">module_bug_finalize</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">hdr</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">sechdrs</span><span class="p">,</span> <span class="n">mod</span><span class="p">);</span>
	<span class="n">list_add_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">modules</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_mutex</span><span class="p">);</span>

	<span class="cm">/* Module is ready to execute: parsing args may do that. */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">parse_args</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">kp</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_kp</span><span class="p">,</span>
			 <span class="o">-</span><span class="mi">32768</span><span class="p">,</span> <span class="mi">32767</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ddebug_dyndbg_module_param_cb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlink</span><span class="p">;</span>

	<span class="cm">/* Link in to syfs. */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">mod_sysfs_setup</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">kp</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_kp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlink</span><span class="p">;</span>

	<span class="cm">/* Get rid of temporary copy. */</span>
	<span class="n">free_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>

	<span class="cm">/* Done! */</span>
	<span class="n">trace_module_load</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">mod</span><span class="p">;</span>

 <span class="nl">unlink:</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_mutex</span><span class="p">);</span>
	<span class="cm">/* Unlink carefully: kallsyms could be walking list. */</span>
	<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">module_bug_cleanup</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>

 <span class="nl">ddebug:</span>
	<span class="n">dynamic_debug_remove</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">debug</span><span class="p">);</span>
 <span class="nl">unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_mutex</span><span class="p">);</span>
	<span class="n">synchronize_sched</span><span class="p">();</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">);</span>
 <span class="nl">free_arch_cleanup:</span>
	<span class="n">module_arch_cleanup</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
 <span class="nl">free_modinfo:</span>
	<span class="n">free_modinfo</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
 <span class="nl">free_unload:</span>
	<span class="n">module_unload_free</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
 <span class="nl">free_module:</span>
	<span class="n">module_deallocate</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
 <span class="nl">free_copy:</span>
	<span class="n">free_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Call module constructors. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_mod_ctors</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_CONSTRUCTORS</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_ctors</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">mod</span><span class="o">-&gt;</span><span class="n">ctors</span><span class="p">[</span><span class="n">i</span><span class="p">]();</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/* This is where the real work happens */</span>
<span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">init_module</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">umod</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">uargs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Must have permission */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_MODULE</span><span class="p">)</span> <span class="o">||</span> <span class="n">modules_disabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="cm">/* Do all the hard work */</span>
	<span class="n">mod</span> <span class="o">=</span> <span class="n">load_module</span><span class="p">(</span><span class="n">umod</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">uargs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">mod</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>

	<span class="n">blocking_notifier_call_chain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_notify_list</span><span class="p">,</span>
			<span class="n">MODULE_STATE_COMING</span><span class="p">,</span> <span class="n">mod</span><span class="p">);</span>

	<span class="cm">/* Set RO and NX regions for core */</span>
	<span class="n">set_section_ro_nx</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_core</span><span class="p">,</span>
				<span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_text_size</span><span class="p">,</span>
				<span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_ro_size</span><span class="p">,</span>
				<span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_size</span><span class="p">);</span>

	<span class="cm">/* Set RO and NX regions for init */</span>
	<span class="n">set_section_ro_nx</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_init</span><span class="p">,</span>
				<span class="n">mod</span><span class="o">-&gt;</span><span class="n">init_text_size</span><span class="p">,</span>
				<span class="n">mod</span><span class="o">-&gt;</span><span class="n">init_ro_size</span><span class="p">,</span>
				<span class="n">mod</span><span class="o">-&gt;</span><span class="n">init_size</span><span class="p">);</span>

	<span class="n">do_mod_ctors</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
	<span class="cm">/* Start the module */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">init</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">do_one_initcall</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Init routine failed: abort.  Try to protect us from</span>
<span class="cm">                   buggy refcounters. */</span>
		<span class="n">mod</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">MODULE_STATE_GOING</span><span class="p">;</span>
		<span class="n">synchronize_sched</span><span class="p">();</span>
		<span class="n">module_put</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
		<span class="n">blocking_notifier_call_chain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_notify_list</span><span class="p">,</span>
					     <span class="n">MODULE_STATE_GOING</span><span class="p">,</span> <span class="n">mod</span><span class="p">);</span>
		<span class="n">free_module</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_wq</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
<span class="s">&quot;%s: &#39;%s&#39;-&gt;init suspiciously returned %d, it should follow 0/-E convention</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="s">&quot;%s: loading module anyway...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/* Now it&#39;s a first class citizen!  Wake up anyone waiting for it. */</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">MODULE_STATE_LIVE</span><span class="p">;</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_wq</span><span class="p">);</span>
	<span class="n">blocking_notifier_call_chain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_notify_list</span><span class="p">,</span>
				     <span class="n">MODULE_STATE_LIVE</span><span class="p">,</span> <span class="n">mod</span><span class="p">);</span>

	<span class="cm">/* We need to finish all async code before the module init sequence is done */</span>
	<span class="n">async_synchronize_full</span><span class="p">();</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_mutex</span><span class="p">);</span>
	<span class="cm">/* Drop initial reference. */</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
	<span class="n">trim_init_extable</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_KALLSYMS</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_symtab</span> <span class="o">=</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_num_syms</span><span class="p">;</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">symtab</span> <span class="o">=</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_symtab</span><span class="p">;</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">strtab</span> <span class="o">=</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_strtab</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">unset_module_init_ro_nx</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
	<span class="n">module_free</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_init</span><span class="p">);</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_init</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">init_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">init_ro_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">init_text_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">within</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="n">start</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_KALLSYMS</span>
<span class="cm">/*</span>
<span class="cm"> * This ignores the intensely annoying &quot;mapping symbols&quot; found</span>
<span class="cm"> * in ARM ELF files: $a, $t and $d.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">is_arm_mapping_symbol</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;$&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">strchr</span><span class="p">(</span><span class="s">&quot;atd&quot;</span><span class="p">,</span> <span class="n">str</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
	       <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span> <span class="o">||</span> <span class="n">str</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">get_ksymbol</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">size</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">best</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nextval</span><span class="p">;</span>

	<span class="cm">/* At worse, next value is at end of module */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">within_module_init</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">mod</span><span class="p">))</span>
		<span class="n">nextval</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_init</span><span class="o">+</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">init_text_size</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">nextval</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_core</span><span class="o">+</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_text_size</span><span class="p">;</span>

	<span class="cm">/* Scan for closest preceding symbol, and next symbol. (ELF</span>
<span class="cm">	   starts real symbols at 1). */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_symtab</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">symtab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_shndx</span> <span class="o">==</span> <span class="n">SHN_UNDEF</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* We ignore unnamed symbols: they&#39;re uninformative</span>
<span class="cm">		 * and inserted at a whim. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">symtab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_value</span> <span class="o">&lt;=</span> <span class="n">addr</span>
		    <span class="o">&amp;&amp;</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">symtab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_value</span> <span class="o">&gt;</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">symtab</span><span class="p">[</span><span class="n">best</span><span class="p">].</span><span class="n">st_value</span>
		    <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">strtab</span> <span class="o">+</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">symtab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_name</span><span class="p">)</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span>
		    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_arm_mapping_symbol</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">strtab</span> <span class="o">+</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">symtab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_name</span><span class="p">))</span>
			<span class="n">best</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">symtab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_value</span> <span class="o">&gt;</span> <span class="n">addr</span>
		    <span class="o">&amp;&amp;</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">symtab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_value</span> <span class="o">&lt;</span> <span class="n">nextval</span>
		    <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">strtab</span> <span class="o">+</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">symtab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_name</span><span class="p">)</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span>
		    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_arm_mapping_symbol</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">strtab</span> <span class="o">+</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">symtab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_name</span><span class="p">))</span>
			<span class="n">nextval</span> <span class="o">=</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">symtab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_value</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">best</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span>
		<span class="o">*</span><span class="n">size</span> <span class="o">=</span> <span class="n">nextval</span> <span class="o">-</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">symtab</span><span class="p">[</span><span class="n">best</span><span class="p">].</span><span class="n">st_value</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span><span class="p">)</span>
		<span class="o">*</span><span class="n">offset</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">-</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">symtab</span><span class="p">[</span><span class="n">best</span><span class="p">].</span><span class="n">st_value</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">strtab</span> <span class="o">+</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">symtab</span><span class="p">[</span><span class="n">best</span><span class="p">].</span><span class="n">st_name</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* For kallsyms to ask for address resolution.  NULL means not found.  Careful</span>
<span class="cm"> * not to lock to avoid deadlock on oopses, simply disable preemption. */</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">module_address_lookup</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">size</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">offset</span><span class="p">,</span>
			    <span class="kt">char</span> <span class="o">**</span><span class="n">modname</span><span class="p">,</span>
			    <span class="kt">char</span> <span class="o">*</span><span class="n">namebuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">modules</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">within_module_init</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">mod</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">within_module_core</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">mod</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">modname</span><span class="p">)</span>
				<span class="o">*</span><span class="n">modname</span> <span class="o">=</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">get_ksymbol</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Make a copy in here where it&#39;s safe */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">strncpy</span><span class="p">(</span><span class="n">namebuf</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">KSYM_NAME_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">namebuf</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">lookup_module_symbol_name</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">symname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">;</span>

	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">modules</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">within_module_init</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">mod</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">within_module_core</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">mod</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sym</span><span class="p">;</span>

			<span class="n">sym</span> <span class="o">=</span> <span class="n">get_ksymbol</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sym</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">strlcpy</span><span class="p">(</span><span class="n">symname</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">KSYM_NAME_LEN</span><span class="p">);</span>
			<span class="n">preempt_enable</span><span class="p">();</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">lookup_module_symbol_attrs</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">size</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">offset</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">modname</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">;</span>

	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">modules</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">within_module_init</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">mod</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">within_module_core</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">mod</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sym</span><span class="p">;</span>

			<span class="n">sym</span> <span class="o">=</span> <span class="n">get_ksymbol</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sym</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">modname</span><span class="p">)</span>
				<span class="n">strlcpy</span><span class="p">(</span><span class="n">modname</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">MODULE_NAME_LEN</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">name</span><span class="p">)</span>
				<span class="n">strlcpy</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">KSYM_NAME_LEN</span><span class="p">);</span>
			<span class="n">preempt_enable</span><span class="p">();</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">module_get_kallsym</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">symnum</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">module_name</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">exported</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">;</span>

	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">modules</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">symnum</span> <span class="o">&lt;</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_symtab</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">symtab</span><span class="p">[</span><span class="n">symnum</span><span class="p">].</span><span class="n">st_value</span><span class="p">;</span>
			<span class="o">*</span><span class="n">type</span> <span class="o">=</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">symtab</span><span class="p">[</span><span class="n">symnum</span><span class="p">].</span><span class="n">st_info</span><span class="p">;</span>
			<span class="n">strlcpy</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">strtab</span> <span class="o">+</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">symtab</span><span class="p">[</span><span class="n">symnum</span><span class="p">].</span><span class="n">st_name</span><span class="p">,</span>
				<span class="n">KSYM_NAME_LEN</span><span class="p">);</span>
			<span class="n">strlcpy</span><span class="p">(</span><span class="n">module_name</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">MODULE_NAME_LEN</span><span class="p">);</span>
			<span class="o">*</span><span class="n">exported</span> <span class="o">=</span> <span class="n">is_exported</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="n">mod</span><span class="p">);</span>
			<span class="n">preempt_enable</span><span class="p">();</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">symnum</span> <span class="o">-=</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_symtab</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mod_find_symname</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_symtab</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">strtab</span><span class="o">+</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">symtab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">mod</span><span class="o">-&gt;</span><span class="n">symtab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_info</span> <span class="o">!=</span> <span class="sc">&#39;U&#39;</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">symtab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_value</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Look for this name: can be of form module:name. */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">module_kallsyms_lookup_name</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">colon</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t lock: we&#39;re in enough trouble already. */</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">colon</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="sc">&#39;:&#39;</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">colon</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mod</span> <span class="o">=</span> <span class="n">find_module</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">mod_find_symname</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">colon</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
		<span class="o">*</span><span class="n">colon</span> <span class="o">=</span> <span class="sc">&#39;:&#39;</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">modules</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">mod_find_symname</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">module_kallsyms_on_each_symbol</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">),</span>
				   <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">modules</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_symtab</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">strtab</span> <span class="o">+</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">symtab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_name</span><span class="p">,</span>
				 <span class="n">mod</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">symtab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_value</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_KALLSYMS */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">module_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">taints</span> <span class="o">||</span>
	    <span class="n">mod</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">MODULE_STATE_GOING</span> <span class="o">||</span>
	    <span class="n">mod</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">MODULE_STATE_COMING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">bx</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;(&#39;</span><span class="p">;</span>
		<span class="n">bx</span> <span class="o">+=</span> <span class="n">module_flags_taint</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">bx</span><span class="p">);</span>
		<span class="cm">/* Show a - for module-is-being-unloaded */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">MODULE_STATE_GOING</span><span class="p">)</span>
			<span class="n">buf</span><span class="p">[</span><span class="n">bx</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;-&#39;</span><span class="p">;</span>
		<span class="cm">/* Show a + for module-is-being-loaded */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">MODULE_STATE_COMING</span><span class="p">)</span>
			<span class="n">buf</span><span class="p">[</span><span class="n">bx</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;+&#39;</span><span class="p">;</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">bx</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;)&#39;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">bx</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="cm">/* Called by the /proc file system to return a list of modules. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="n">m_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">seq_list_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">modules</span><span class="p">,</span> <span class="o">*</span><span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="n">m_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq_list_next</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">modules</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">m_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">m_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">module</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%s %u&quot;</span><span class="p">,</span>
		   <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">init_size</span> <span class="o">+</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_size</span><span class="p">);</span>
	<span class="n">print_unload_info</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">mod</span><span class="p">);</span>

	<span class="cm">/* Informative for users. */</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; %s&quot;</span><span class="p">,</span>
		   <span class="n">mod</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">MODULE_STATE_GOING</span> <span class="o">?</span> <span class="s">&quot;Unloading&quot;</span><span class="o">:</span>
		   <span class="n">mod</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">MODULE_STATE_COMING</span> <span class="o">?</span> <span class="s">&quot;Loading&quot;</span><span class="o">:</span>
		   <span class="s">&quot;Live&quot;</span><span class="p">);</span>
	<span class="cm">/* Used by oprofile and other similar tools. */</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; 0x%pK&quot;</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_core</span><span class="p">);</span>

	<span class="cm">/* Taints info */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">taints</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; %s&quot;</span><span class="p">,</span> <span class="n">module_flags</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">buf</span><span class="p">));</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Format: modulename size refcount deps address</span>

<span class="cm">   Where refcount is a number or -, and deps is a comma-separated list</span>
<span class="cm">   of depends or -.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">modules_op</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span>	<span class="o">=</span> <span class="n">m_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>	<span class="o">=</span> <span class="n">m_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>	<span class="o">=</span> <span class="n">m_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>	<span class="o">=</span> <span class="n">m_show</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">modules_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">modules_op</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_modules_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">modules_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">seq_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">proc_modules_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">proc_create</span><span class="p">(</span><span class="s">&quot;modules&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proc_modules_operations</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">proc_modules_init</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* Given an address, look for it in the module exception tables. */</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">exception_table_entry</span> <span class="o">*</span><span class="nf">search_module_extables</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">exception_table_entry</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">;</span>

	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">modules</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_exentries</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">e</span> <span class="o">=</span> <span class="n">search_extable</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">extable</span><span class="p">,</span>
				   <span class="n">mod</span><span class="o">-&gt;</span><span class="n">extable</span> <span class="o">+</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_exentries</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
				   <span class="n">addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">preempt_enable</span><span class="p">();</span>

	<span class="cm">/* Now, if we found one, we are running inside it now, hence</span>
<span class="cm">	   we cannot unload the module, hence no refcnt needed. */</span>
	<span class="k">return</span> <span class="n">e</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * is_module_address - is this address inside a module?</span>
<span class="cm"> * @addr: the address to check.</span>
<span class="cm"> *</span>
<span class="cm"> * See is_module_text_address() if you simply want to see if the address</span>
<span class="cm"> * is code (not data).</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">is_module_address</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__module_address</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">preempt_enable</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * __module_address - get the module which contains an address.</span>
<span class="cm"> * @addr: the address.</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called with preempt disabled or module mutex held so that</span>
<span class="cm"> * module doesn&#39;t get freed during this.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="nf">__module_address</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="n">module_addr_min</span> <span class="o">||</span> <span class="n">addr</span> <span class="o">&gt;</span> <span class="n">module_addr_max</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">modules</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">within_module_core</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">mod</span><span class="p">)</span>
		    <span class="o">||</span> <span class="n">within_module_init</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">mod</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">mod</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__module_address</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * is_module_text_address - is this address inside module code?</span>
<span class="cm"> * @addr: the address to check.</span>
<span class="cm"> *</span>
<span class="cm"> * See is_module_address() if you simply want to see if the address is</span>
<span class="cm"> * anywhere in a module.  See kernel_text_address() for testing if an</span>
<span class="cm"> * address corresponds to kernel or module code.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">is_module_text_address</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__module_text_address</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">preempt_enable</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * __module_text_address - get the module whose code contains an address.</span>
<span class="cm"> * @addr: the address.</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called with preempt disabled or module mutex held so that</span>
<span class="cm"> * module doesn&#39;t get freed during this.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="nf">__module_text_address</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span> <span class="o">=</span> <span class="n">__module_address</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mod</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Make sure it&#39;s within the text section. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">within</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_init</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">init_text_size</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">within</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_core</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_text_size</span><span class="p">))</span>
			<span class="n">mod</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">mod</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__module_text_address</span><span class="p">);</span>

<span class="cm">/* Don&#39;t grab lock, we&#39;re oopsing. */</span>
<span class="kt">void</span> <span class="nf">print_modules</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEFAULT</span> <span class="s">&quot;Modules linked in:&quot;</span><span class="p">);</span>
	<span class="cm">/* Most callers should already have preempt disabled, but make sure */</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">modules</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot; %s%s&quot;</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">module_flags</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">buf</span><span class="p">));</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last_unloaded_module</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot; [last unloaded: %s]&quot;</span><span class="p">,</span> <span class="n">last_unloaded_module</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_MODVERSIONS</span>
<span class="cm">/* Generate the signature for all relevant module structures here.</span>
<span class="cm"> * If these change, we don&#39;t want to try to parse the module. */</span>
<span class="kt">void</span> <span class="nf">module_layout</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">modversion_info</span> <span class="o">*</span><span class="n">ver</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">kernel_symbol</span> <span class="o">*</span><span class="n">ks</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">tracepoint</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">module_layout</span><span class="p">);</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
