<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › rcupdate.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>rcupdate.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Read-Copy Update mechanism for mutual exclusion</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright IBM Corporation, 2001</span>
<span class="cm"> *</span>
<span class="cm"> * Authors: Dipankar Sarma &lt;dipankar@in.ibm.com&gt;</span>
<span class="cm"> *	    Manfred Spraul &lt;manfred@colorfullife.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Based on the original work by Paul McKenney &lt;paulmck@us.ibm.com&gt;</span>
<span class="cm"> * and inputs from Rusty Russell, Andrea Arcangeli and Andi Kleen.</span>
<span class="cm"> * Papers:</span>
<span class="cm"> * http://www.rdrop.com/users/paulmck/paper/rclockpdcsproof.pdf</span>
<span class="cm"> * http://lse.sourceforge.net/locking/rclock_OLS.2001.05.01c.sc.pdf (OLS2001)</span>
<span class="cm"> *</span>
<span class="cm"> * For detailed explanation of Read-Copy Update mechanism see -</span>
<span class="cm"> *		http://lse.sourceforge.net/locking/rcupdate.html</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/hardirq.h&gt;</span>

<span class="cp">#define CREATE_TRACE_POINTS</span>
<span class="cp">#include &lt;trace/events/rcu.h&gt;</span>

<span class="cp">#include &quot;rcu.h&quot;</span>

<span class="cp">#ifdef CONFIG_PREEMPT_RCU</span>

<span class="cm">/*</span>
<span class="cm"> * Check for a task exiting while in a preemptible-RCU read-side</span>
<span class="cm"> * critical section, clean up if so.  No need to issue warnings,</span>
<span class="cm"> * as debug_check_no_locks_held() already does this if lockdep</span>
<span class="cm"> * is enabled.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">exit_rcu</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">rcu_node_entry</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">rcu_read_lock_nesting</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">barrier</span><span class="p">();</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">rcu_read_unlock_special</span> <span class="o">=</span> <span class="n">RCU_READ_UNLOCK_BLOCKED</span><span class="p">;</span>
	<span class="n">__rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* #ifdef CONFIG_PREEMPT_RCU */</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">exit_rcu</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* #else #ifdef CONFIG_PREEMPT_RCU */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_DEBUG_LOCK_ALLOC</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="n">rcu_lock_key</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">lockdep_map</span> <span class="n">rcu_lock_map</span> <span class="o">=</span>
	<span class="n">STATIC_LOCKDEP_MAP_INIT</span><span class="p">(</span><span class="s">&quot;rcu_read_lock&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rcu_lock_key</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rcu_lock_map</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="n">rcu_bh_lock_key</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">lockdep_map</span> <span class="n">rcu_bh_lock_map</span> <span class="o">=</span>
	<span class="n">STATIC_LOCKDEP_MAP_INIT</span><span class="p">(</span><span class="s">&quot;rcu_read_lock_bh&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rcu_bh_lock_key</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rcu_bh_lock_map</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="n">rcu_sched_lock_key</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">lockdep_map</span> <span class="n">rcu_sched_lock_map</span> <span class="o">=</span>
	<span class="n">STATIC_LOCKDEP_MAP_INIT</span><span class="p">(</span><span class="s">&quot;rcu_read_lock_sched&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rcu_sched_lock_key</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rcu_sched_lock_map</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_DEBUG_LOCK_ALLOC</span>

<span class="kt">int</span> <span class="nf">debug_lockdep_rcu_enabled</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rcu_scheduler_active</span> <span class="o">&amp;&amp;</span> <span class="n">debug_locks</span> <span class="o">&amp;&amp;</span>
	       <span class="n">current</span><span class="o">-&gt;</span><span class="n">lockdep_recursion</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">debug_lockdep_rcu_enabled</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rcu_read_lock_bh_held() - might we be in RCU-bh read-side critical section?</span>
<span class="cm"> *</span>
<span class="cm"> * Check for bottom half being disabled, which covers both the</span>
<span class="cm"> * CONFIG_PROVE_RCU and not cases.  Note that if someone uses</span>
<span class="cm"> * rcu_read_lock_bh(), but then later enables BH, lockdep (if enabled)</span>
<span class="cm"> * will show the situation.  This is useful for debug checks in functions</span>
<span class="cm"> * that require that they be called within an RCU read-side critical</span>
<span class="cm"> * section.</span>
<span class="cm"> *</span>
<span class="cm"> * Check debug_lockdep_rcu_enabled() to prevent false positives during boot.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that rcu_read_lock() is disallowed if the CPU is either idle or</span>
<span class="cm"> * offline from an RCU perspective, so check for those as well.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">rcu_read_lock_bh_held</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug_lockdep_rcu_enabled</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rcu_is_cpu_idle</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rcu_lockdep_current_cpu_online</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">in_softirq</span><span class="p">()</span> <span class="o">||</span> <span class="n">irqs_disabled</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rcu_read_lock_bh_held</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* #ifdef CONFIG_DEBUG_LOCK_ALLOC */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">rcu_synchronize</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">completion</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Awaken the corresponding synchronize_rcu() instance now that a</span>
<span class="cm"> * grace period has elapsed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wakeme_after_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span>  <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rcu_synchronize</span> <span class="o">*</span><span class="n">rcu</span><span class="p">;</span>

	<span class="n">rcu</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rcu_synchronize</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu</span><span class="o">-&gt;</span><span class="n">completion</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">wait_rcu_gp</span><span class="p">(</span><span class="n">call_rcu_func_t</span> <span class="n">crf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rcu_synchronize</span> <span class="n">rcu</span><span class="p">;</span>

	<span class="n">init_rcu_head_on_stack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu</span><span class="p">.</span><span class="n">head</span><span class="p">);</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu</span><span class="p">.</span><span class="n">completion</span><span class="p">);</span>
	<span class="cm">/* Will wake me after RCU finished. */</span>
	<span class="n">crf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu</span><span class="p">.</span><span class="n">head</span><span class="p">,</span> <span class="n">wakeme_after_rcu</span><span class="p">);</span>
	<span class="cm">/* Wait for it. */</span>
	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu</span><span class="p">.</span><span class="n">completion</span><span class="p">);</span>
	<span class="n">destroy_rcu_head_on_stack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu</span><span class="p">.</span><span class="n">head</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">wait_rcu_gp</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PROVE_RCU</span>
<span class="cm">/*</span>
<span class="cm"> * wrapper function to avoid #include problems.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">rcu_my_thread_group_empty</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">thread_group_empty</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rcu_my_thread_group_empty</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* #ifdef CONFIG_PROVE_RCU */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">debug_init_rcu_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debug_object_init</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rcuhead_debug_descr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">debug_rcu_head_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debug_object_free</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rcuhead_debug_descr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * fixup_init is called when:</span>
<span class="cm"> * - an active object is initialized</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rcuhead_fixup_init</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">enum</span> <span class="n">debug_obj_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ODEBUG_STATE_ACTIVE</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Ensure that queued callbacks are all executed.</span>
<span class="cm">		 * If we detect that we are nested in a RCU read-side critical</span>
<span class="cm">		 * section, we should simply fail, otherwise we would deadlock.</span>
<span class="cm">		 * In !PREEMPT configurations, there is no way to tell if we are</span>
<span class="cm">		 * in a RCU read-side critical section or not, so we never</span>
<span class="cm">		 * attempt any fixup and just print a warning.</span>
<span class="cm">		 */</span>
<span class="cp">#ifndef CONFIG_PREEMPT</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rcu_preempt_depth</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">preempt_count</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
		    <span class="n">irqs_disabled</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rcu_barrier</span><span class="p">();</span>
		<span class="n">rcu_barrier_sched</span><span class="p">();</span>
		<span class="n">rcu_barrier_bh</span><span class="p">();</span>
		<span class="n">debug_object_init</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rcuhead_debug_descr</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * fixup_activate is called when:</span>
<span class="cm"> * - an active object is activated</span>
<span class="cm"> * - an unknown object is activated (might be a statically initialized object)</span>
<span class="cm"> * Activation is performed internally by call_rcu().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rcuhead_fixup_activate</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">enum</span> <span class="n">debug_obj_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">case</span> <span class="n">ODEBUG_STATE_NOTAVAILABLE</span>:
		<span class="cm">/*</span>
<span class="cm">		 * This is not really a fixup. We just make sure that it is</span>
<span class="cm">		 * tracked in the object tracker.</span>
<span class="cm">		 */</span>
		<span class="n">debug_object_init</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rcuhead_debug_descr</span><span class="p">);</span>
		<span class="n">debug_object_activate</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rcuhead_debug_descr</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ODEBUG_STATE_ACTIVE</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Ensure that queued callbacks are all executed.</span>
<span class="cm">		 * If we detect that we are nested in a RCU read-side critical</span>
<span class="cm">		 * section, we should simply fail, otherwise we would deadlock.</span>
<span class="cm">		 * In !PREEMPT configurations, there is no way to tell if we are</span>
<span class="cm">		 * in a RCU read-side critical section or not, so we never</span>
<span class="cm">		 * attempt any fixup and just print a warning.</span>
<span class="cm">		 */</span>
<span class="cp">#ifndef CONFIG_PREEMPT</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rcu_preempt_depth</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">preempt_count</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
		    <span class="n">irqs_disabled</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rcu_barrier</span><span class="p">();</span>
		<span class="n">rcu_barrier_sched</span><span class="p">();</span>
		<span class="n">rcu_barrier_bh</span><span class="p">();</span>
		<span class="n">debug_object_activate</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rcuhead_debug_descr</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * fixup_free is called when:</span>
<span class="cm"> * - an active object is freed</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rcuhead_fixup_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">enum</span> <span class="n">debug_obj_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ODEBUG_STATE_ACTIVE</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Ensure that queued callbacks are all executed.</span>
<span class="cm">		 * If we detect that we are nested in a RCU read-side critical</span>
<span class="cm">		 * section, we should simply fail, otherwise we would deadlock.</span>
<span class="cm">		 * In !PREEMPT configurations, there is no way to tell if we are</span>
<span class="cm">		 * in a RCU read-side critical section or not, so we never</span>
<span class="cm">		 * attempt any fixup and just print a warning.</span>
<span class="cm">		 */</span>
<span class="cp">#ifndef CONFIG_PREEMPT</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rcu_preempt_depth</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">preempt_count</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
		    <span class="n">irqs_disabled</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rcu_barrier</span><span class="p">();</span>
		<span class="n">rcu_barrier_sched</span><span class="p">();</span>
		<span class="n">rcu_barrier_bh</span><span class="p">();</span>
		<span class="n">debug_object_free</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rcuhead_debug_descr</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * init_rcu_head_on_stack() - initialize on-stack rcu_head for debugobjects</span>
<span class="cm"> * @head: pointer to rcu_head structure to be initialized</span>
<span class="cm"> *</span>
<span class="cm"> * This function informs debugobjects of a new rcu_head structure that</span>
<span class="cm"> * has been allocated as an auto variable on the stack.  This function</span>
<span class="cm"> * is not required for rcu_head structures that are statically defined or</span>
<span class="cm"> * that are dynamically allocated on the heap.  This function has no</span>
<span class="cm"> * effect for !CONFIG_DEBUG_OBJECTS_RCU_HEAD kernel builds.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">init_rcu_head_on_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debug_object_init_on_stack</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rcuhead_debug_descr</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">init_rcu_head_on_stack</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * destroy_rcu_head_on_stack() - destroy on-stack rcu_head for debugobjects</span>
<span class="cm"> * @head: pointer to rcu_head structure to be initialized</span>
<span class="cm"> *</span>
<span class="cm"> * This function informs debugobjects that an on-stack rcu_head structure</span>
<span class="cm"> * is about to go out of scope.  As with init_rcu_head_on_stack(), this</span>
<span class="cm"> * function is not required for rcu_head structures that are statically</span>
<span class="cm"> * defined or that are dynamically allocated on the heap.  Also as with</span>
<span class="cm"> * init_rcu_head_on_stack(), this function has no effect for</span>
<span class="cm"> * !CONFIG_DEBUG_OBJECTS_RCU_HEAD kernel builds.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">destroy_rcu_head_on_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debug_object_free</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rcuhead_debug_descr</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">destroy_rcu_head_on_stack</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">debug_obj_descr</span> <span class="n">rcuhead_debug_descr</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;rcu_head&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fixup_init</span> <span class="o">=</span> <span class="n">rcuhead_fixup_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fixup_activate</span> <span class="o">=</span> <span class="n">rcuhead_fixup_activate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fixup_free</span> <span class="o">=</span> <span class="n">rcuhead_fixup_free</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rcuhead_debug_descr</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* #ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD */</span><span class="cp"></span>

<span class="cp">#if defined(CONFIG_TREE_RCU) || defined(CONFIG_TREE_PREEMPT_RCU) || defined(CONFIG_RCU_TRACE)</span>
<span class="kt">void</span> <span class="nf">do_trace_rcu_torture_read</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">rcutorturename</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">rhp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_rcu_torture_read</span><span class="p">(</span><span class="n">rcutorturename</span><span class="p">,</span> <span class="n">rhp</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">do_trace_rcu_torture_read</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp">#define do_trace_rcu_torture_read(rcutorturename, rhp) do { } while (0)</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
