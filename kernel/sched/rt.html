<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › sched › rt.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>rt.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Real-Time Scheduling Class (mapped to the SCHED_FIFO and SCHED_RR</span>
<span class="cm"> * policies)</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;sched.h&quot;</span>

<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">do_sched_rt_period_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_bandwidth</span> <span class="o">*</span><span class="n">rt_b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">overrun</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">rt_bandwidth</span> <span class="n">def_rt_bandwidth</span><span class="p">;</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">hrtimer_restart</span> <span class="nf">sched_rt_period_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rt_bandwidth</span> <span class="o">*</span><span class="n">rt_b</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rt_bandwidth</span><span class="p">,</span> <span class="n">rt_period_timer</span><span class="p">);</span>
	<span class="n">ktime_t</span> <span class="n">now</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">overrun</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">now</span> <span class="o">=</span> <span class="n">hrtimer_cb_get_time</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
		<span class="n">overrun</span> <span class="o">=</span> <span class="n">hrtimer_forward</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">now</span><span class="p">,</span> <span class="n">rt_b</span><span class="o">-&gt;</span><span class="n">rt_period</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">overrun</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">idle</span> <span class="o">=</span> <span class="n">do_sched_rt_period_timer</span><span class="p">(</span><span class="n">rt_b</span><span class="p">,</span> <span class="n">overrun</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">idle</span> <span class="o">?</span> <span class="n">HRTIMER_NORESTART</span> <span class="o">:</span> <span class="n">HRTIMER_RESTART</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">init_rt_bandwidth</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_bandwidth</span> <span class="o">*</span><span class="n">rt_b</span><span class="p">,</span> <span class="n">u64</span> <span class="n">period</span><span class="p">,</span> <span class="n">u64</span> <span class="n">runtime</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rt_b</span><span class="o">-&gt;</span><span class="n">rt_period</span> <span class="o">=</span> <span class="n">ns_to_ktime</span><span class="p">(</span><span class="n">period</span><span class="p">);</span>
	<span class="n">rt_b</span><span class="o">-&gt;</span><span class="n">rt_runtime</span> <span class="o">=</span> <span class="n">runtime</span><span class="p">;</span>

	<span class="n">raw_spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_b</span><span class="o">-&gt;</span><span class="n">rt_runtime_lock</span><span class="p">);</span>

	<span class="n">hrtimer_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_b</span><span class="o">-&gt;</span><span class="n">rt_period_timer</span><span class="p">,</span>
			<span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="n">HRTIMER_MODE_REL</span><span class="p">);</span>
	<span class="n">rt_b</span><span class="o">-&gt;</span><span class="n">rt_period_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">sched_rt_period_timer</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">start_rt_bandwidth</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_bandwidth</span> <span class="o">*</span><span class="n">rt_b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rt_bandwidth_enabled</span><span class="p">()</span> <span class="o">||</span> <span class="n">rt_b</span><span class="o">-&gt;</span><span class="n">rt_runtime</span> <span class="o">==</span> <span class="n">RUNTIME_INF</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hrtimer_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_b</span><span class="o">-&gt;</span><span class="n">rt_period_timer</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_b</span><span class="o">-&gt;</span><span class="n">rt_runtime_lock</span><span class="p">);</span>
	<span class="n">start_bandwidth_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_b</span><span class="o">-&gt;</span><span class="n">rt_period_timer</span><span class="p">,</span> <span class="n">rt_b</span><span class="o">-&gt;</span><span class="n">rt_period</span><span class="p">);</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_b</span><span class="o">-&gt;</span><span class="n">rt_runtime_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">init_rt_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rt_prio_array</span> <span class="o">*</span><span class="n">array</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">array</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_RT_PRIO</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="n">array</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">__clear_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">array</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* delimiter for bitsearch: */</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">MAX_RT_PRIO</span><span class="p">,</span> <span class="n">array</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">);</span>

<span class="cp">#if defined CONFIG_SMP</span>
	<span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">highest_prio</span><span class="p">.</span><span class="n">curr</span> <span class="o">=</span> <span class="n">MAX_RT_PRIO</span><span class="p">;</span>
	<span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">highest_prio</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">MAX_RT_PRIO</span><span class="p">;</span>
	<span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_nr_migratory</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">overloaded</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">plist_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">pushable_tasks</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_throttled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_runtime</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">raw_spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_runtime_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_RT_GROUP_SCHED</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">destroy_rt_bandwidth</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_bandwidth</span> <span class="o">*</span><span class="n">rt_b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hrtimer_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_b</span><span class="o">-&gt;</span><span class="n">rt_period_timer</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define rt_entity_is_task(rt_se) (!(rt_se)-&gt;my_q)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">rt_task_of</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SCHED_DEBUG</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">rt_entity_is_task</span><span class="p">(</span><span class="n">rt_se</span><span class="p">));</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">rt_se</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span><span class="p">,</span> <span class="n">rt</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="nf">rq_of_rt_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="nf">rt_rq_of_se</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rt_se</span><span class="o">-&gt;</span><span class="n">rt_rq</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">free_rt_sched_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">rt_se</span><span class="p">)</span>
		<span class="n">destroy_rt_bandwidth</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">rt_bandwidth</span><span class="p">);</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">rt_rq</span><span class="p">)</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">rt_rq</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">rt_se</span><span class="p">)</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">rt_se</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">rt_rq</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">rt_se</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">init_tg_rt_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">highest_prio</span><span class="p">.</span><span class="n">curr</span> <span class="o">=</span> <span class="n">MAX_RT_PRIO</span><span class="p">;</span>
	<span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_nr_boosted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rq</span> <span class="o">=</span> <span class="n">rq</span><span class="p">;</span>
	<span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">tg</span> <span class="o">=</span> <span class="n">tg</span><span class="p">;</span>

	<span class="n">tg</span><span class="o">-&gt;</span><span class="n">rt_rq</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">rt_rq</span><span class="p">;</span>
	<span class="n">tg</span><span class="o">-&gt;</span><span class="n">rt_se</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">rt_se</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rt_se</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">rt_se</span><span class="o">-&gt;</span><span class="n">rt_rq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">rt_se</span><span class="o">-&gt;</span><span class="n">rt_rq</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">my_q</span><span class="p">;</span>

	<span class="n">rt_se</span><span class="o">-&gt;</span><span class="n">my_q</span> <span class="o">=</span> <span class="n">rt_rq</span><span class="p">;</span>
	<span class="n">rt_se</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_se</span><span class="o">-&gt;</span><span class="n">run_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">alloc_rt_sched_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">tg</span><span class="o">-&gt;</span><span class="n">rt_rq</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">)</span> <span class="o">*</span> <span class="n">nr_cpu_ids</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">rt_rq</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">tg</span><span class="o">-&gt;</span><span class="n">rt_se</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">rt_se</span><span class="p">)</span> <span class="o">*</span> <span class="n">nr_cpu_ids</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">rt_se</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">init_rt_bandwidth</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">rt_bandwidth</span><span class="p">,</span>
			<span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">def_rt_bandwidth</span><span class="p">.</span><span class="n">rt_period</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rt_rq</span> <span class="o">=</span> <span class="n">kzalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_rq</span><span class="p">),</span>
				     <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rt_rq</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">rt_se</span> <span class="o">=</span> <span class="n">kzalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_rt_entity</span><span class="p">),</span>
				     <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rt_se</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_free_rq</span><span class="p">;</span>

		<span class="n">init_rt_rq</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">,</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
		<span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_runtime</span> <span class="o">=</span> <span class="n">tg</span><span class="o">-&gt;</span><span class="n">rt_bandwidth</span><span class="p">.</span><span class="n">rt_runtime</span><span class="p">;</span>
		<span class="n">init_tg_rt_entry</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="n">rt_rq</span><span class="p">,</span> <span class="n">rt_se</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">rt_se</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">err_free_rq:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">);</span>
<span class="nl">err:</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_RT_GROUP_SCHED */</span><span class="cp"></span>

<span class="cp">#define rt_entity_is_task(rt_se) (1)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">rt_task_of</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">rt_se</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span><span class="p">,</span> <span class="n">rt</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="nf">rq_of_rt_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rq</span><span class="p">,</span> <span class="n">rt</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="nf">rt_rq_of_se</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">rt_task_of</span><span class="p">(</span><span class="n">rt_se</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">free_rt_sched_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="kt">int</span> <span class="nf">alloc_rt_sched_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_RT_GROUP_SCHED */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_SMP</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">rt_overloaded</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">rto_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rt_set_overload</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">online</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">rto_mask</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Make sure the mask is visible before we set</span>
<span class="cm">	 * the overload count. That is checked to determine</span>
<span class="cm">	 * if we should look at the mask. It would be a shame</span>
<span class="cm">	 * if we looked at the mask, but the mask was not</span>
<span class="cm">	 * updated yet.</span>
<span class="cm">	 */</span>
	<span class="n">wmb</span><span class="p">();</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">rto_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rt_clear_overload</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">online</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* the order here really doesn&#39;t matter */</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">rto_count</span><span class="p">);</span>
	<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">rto_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_rt_migration</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_nr_migratory</span> <span class="o">&amp;&amp;</span> <span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_nr_total</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">overloaded</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rt_set_overload</span><span class="p">(</span><span class="n">rq_of_rt_rq</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">));</span>
			<span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">overloaded</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">overloaded</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rt_clear_overload</span><span class="p">(</span><span class="n">rq_of_rt_rq</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">));</span>
		<span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">overloaded</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">inc_rt_migration</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rt_entity_is_task</span><span class="p">(</span><span class="n">rt_se</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">rt_task_of</span><span class="p">(</span><span class="n">rt_se</span><span class="p">);</span>
	<span class="n">rt_rq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rq_of_rt_rq</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">;</span>

	<span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_nr_total</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">nr_cpus_allowed</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_nr_migratory</span><span class="o">++</span><span class="p">;</span>

	<span class="n">update_rt_migration</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dec_rt_migration</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rt_entity_is_task</span><span class="p">(</span><span class="n">rt_se</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">rt_task_of</span><span class="p">(</span><span class="n">rt_se</span><span class="p">);</span>
	<span class="n">rt_rq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rq_of_rt_rq</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">;</span>

	<span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_nr_total</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">nr_cpus_allowed</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_nr_migratory</span><span class="o">--</span><span class="p">;</span>

	<span class="n">update_rt_migration</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">has_pushable_tasks</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">plist_head_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">pushable_tasks</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enqueue_pushable_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">plist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pushable_tasks</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">pushable_tasks</span><span class="p">);</span>
	<span class="n">plist_node_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pushable_tasks</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">);</span>
	<span class="n">plist_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pushable_tasks</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">pushable_tasks</span><span class="p">);</span>

	<span class="cm">/* Update the highest prio pushable task */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">&lt;</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">highest_prio</span><span class="p">.</span><span class="n">next</span><span class="p">)</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">highest_prio</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dequeue_pushable_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">plist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pushable_tasks</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">pushable_tasks</span><span class="p">);</span>

	<span class="cm">/* Update the new highest prio pushable task */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">has_pushable_tasks</span><span class="p">(</span><span class="n">rq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">plist_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">pushable_tasks</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">task_struct</span><span class="p">,</span> <span class="n">pushable_tasks</span><span class="p">);</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">highest_prio</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">highest_prio</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">MAX_RT_PRIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">enqueue_pushable_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dequeue_pushable_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">inc_rt_migration</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">dec_rt_migration</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">on_rt_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_se</span><span class="o">-&gt;</span><span class="n">run_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_RT_GROUP_SCHED</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">sched_rt_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">tg</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">RUNTIME_INF</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_runtime</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">sched_rt_period</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">rt_bandwidth</span><span class="p">.</span><span class="n">rt_period</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">rt_rq_iter_t</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="nf">next_task_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">tg</span> <span class="o">=</span> <span class="n">list_entry_rcu</span><span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
			<span class="n">typeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span><span class="p">),</span> <span class="n">list</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">list</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">task_groups</span> <span class="o">&amp;&amp;</span> <span class="n">task_group_is_autogroup</span><span class="p">(</span><span class="n">tg</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">list</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">task_groups</span><span class="p">)</span>
		<span class="n">tg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">tg</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define for_each_rt_rq(rt_rq, iter, rq)					\</span>
<span class="cp">	for (iter = container_of(&amp;task_groups, typeof(*iter), list);	\</span>
<span class="cp">		(iter = next_task_group(iter)) &amp;&amp;			\</span>
<span class="cp">		(rt_rq = iter-&gt;rt_rq[cpu_of(rq)]);)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">list_add_leaf_rt_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_add_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">leaf_rt_rq_list</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">rq_of_rt_rq</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">leaf_rt_rq_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">list_del_leaf_rt_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">leaf_rt_rq_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define for_each_leaf_rt_rq(rt_rq, rq) \</span>
<span class="cp">	list_for_each_entry_rcu(rt_rq, &amp;rq-&gt;leaf_rt_rq_list, leaf_rt_rq_list)</span>

<span class="cp">#define for_each_sched_rt_entity(rt_se) \</span>
<span class="cp">	for (; rt_se; rt_se = rt_se-&gt;parent)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="nf">group_rt_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rt_se</span><span class="o">-&gt;</span><span class="n">my_q</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">enqueue_rt_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span><span class="p">,</span> <span class="n">bool</span> <span class="n">head</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dequeue_rt_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sched_rt_rq_enqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">rq_of_rt_rq</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">cpu_of</span><span class="p">(</span><span class="n">rq_of_rt_rq</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">));</span>

	<span class="n">rt_se</span> <span class="o">=</span> <span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">rt_se</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_nr_running</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rt_se</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">on_rt_rq</span><span class="p">(</span><span class="n">rt_se</span><span class="p">))</span>
			<span class="n">enqueue_rt_entity</span><span class="p">(</span><span class="n">rt_se</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">highest_prio</span><span class="p">.</span><span class="n">curr</span> <span class="o">&lt;</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">)</span>
			<span class="n">resched_task</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sched_rt_rq_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">cpu_of</span><span class="p">(</span><span class="n">rq_of_rt_rq</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">));</span>

	<span class="n">rt_se</span> <span class="o">=</span> <span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">rt_se</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rt_se</span> <span class="o">&amp;&amp;</span> <span class="n">on_rt_rq</span><span class="p">(</span><span class="n">rt_se</span><span class="p">))</span>
		<span class="n">dequeue_rt_entity</span><span class="p">(</span><span class="n">rt_se</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">rt_rq_throttled</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_throttled</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_nr_boosted</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rt_se_boosted</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span> <span class="o">=</span> <span class="n">group_rt_rq</span><span class="p">(</span><span class="n">rt_se</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rt_rq</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">!!</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_nr_boosted</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">rt_task_of</span><span class="p">(</span><span class="n">rt_se</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">!=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">normal_prio</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="nf">sched_rt_period_mask</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">())</span><span class="o">-&gt;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">span</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="nf">sched_rt_period_mask</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cpu_online_mask</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="nf">sched_rt_period_rt_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_bandwidth</span> <span class="o">*</span><span class="n">rt_b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">rt_b</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_group</span><span class="p">,</span> <span class="n">rt_bandwidth</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rt_rq</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">rt_bandwidth</span> <span class="o">*</span><span class="nf">sched_rt_bandwidth</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">rt_bandwidth</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* !CONFIG_RT_GROUP_SCHED */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">sched_rt_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_runtime</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">sched_rt_period</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">def_rt_bandwidth</span><span class="p">.</span><span class="n">rt_period</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq_iter_t</span><span class="p">;</span>

<span class="cp">#define for_each_rt_rq(rt_rq, iter, rq) \</span>
<span class="cp">	for ((void) iter, rt_rq = &amp;rq-&gt;rt; rt_rq; rt_rq = NULL)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">list_add_leaf_rt_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">list_del_leaf_rt_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#define for_each_leaf_rt_rq(rt_rq, rq) \</span>
<span class="cp">	for (rt_rq = &amp;rq-&gt;rt; rt_rq; rt_rq = NULL)</span>

<span class="cp">#define for_each_sched_rt_entity(rt_se) \</span>
<span class="cp">	for (; rt_se; rt_se = NULL)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="nf">group_rt_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sched_rt_rq_enqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_nr_running</span><span class="p">)</span>
		<span class="n">resched_task</span><span class="p">(</span><span class="n">rq_of_rt_rq</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sched_rt_rq_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">rt_rq_throttled</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_throttled</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="nf">sched_rt_period_mask</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cpu_online_mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="nf">sched_rt_period_rt_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_bandwidth</span> <span class="o">*</span><span class="n">rt_b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">rt_bandwidth</span> <span class="o">*</span><span class="nf">sched_rt_bandwidth</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">def_rt_bandwidth</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_RT_GROUP_SCHED */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cm">/*</span>
<span class="cm"> * We ran out of runtime, see if we can borrow some from our neighbours.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_balance_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rt_bandwidth</span> <span class="o">*</span><span class="n">rt_b</span> <span class="o">=</span> <span class="n">sched_rt_bandwidth</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">root_domain</span> <span class="o">*</span><span class="n">rd</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">())</span><span class="o">-&gt;</span><span class="n">rd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">more</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rt_period</span><span class="p">;</span>

	<span class="n">weight</span> <span class="o">=</span> <span class="n">cpumask_weight</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">span</span><span class="p">);</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_b</span><span class="o">-&gt;</span><span class="n">rt_runtime_lock</span><span class="p">);</span>
	<span class="n">rt_period</span> <span class="o">=</span> <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">rt_b</span><span class="o">-&gt;</span><span class="n">rt_period</span><span class="p">);</span>
	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">rd</span><span class="o">-&gt;</span><span class="n">span</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">sched_rt_period_rt_rq</span><span class="p">(</span><span class="n">rt_b</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">s64</span> <span class="n">diff</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">==</span> <span class="n">rt_rq</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">rt_runtime_lock</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Either all rqs have inf runtime and there&#39;s nothing to steal</span>
<span class="cm">		 * or __disable_runtime() below sets a specific rq to inf to</span>
<span class="cm">		 * indicate its been disabled and disalow stealing.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">rt_runtime</span> <span class="o">==</span> <span class="n">RUNTIME_INF</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * From runqueues with spare time, take 1/n part of their</span>
<span class="cm">		 * spare time, but no more than our period.</span>
<span class="cm">		 */</span>
		<span class="n">diff</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">rt_runtime</span> <span class="o">-</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">rt_time</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">diff</span> <span class="o">=</span> <span class="n">div_u64</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">diff</span><span class="p">,</span> <span class="n">weight</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_runtime</span> <span class="o">+</span> <span class="n">diff</span> <span class="o">&gt;</span> <span class="n">rt_period</span><span class="p">)</span>
				<span class="n">diff</span> <span class="o">=</span> <span class="n">rt_period</span> <span class="o">-</span> <span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_runtime</span><span class="p">;</span>
			<span class="n">iter</span><span class="o">-&gt;</span><span class="n">rt_runtime</span> <span class="o">-=</span> <span class="n">diff</span><span class="p">;</span>
			<span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_runtime</span> <span class="o">+=</span> <span class="n">diff</span><span class="p">;</span>
			<span class="n">more</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_runtime</span> <span class="o">==</span> <span class="n">rt_period</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">rt_runtime_lock</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
<span class="nl">next:</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">rt_runtime_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_b</span><span class="o">-&gt;</span><span class="n">rt_runtime_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">more</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Ensure this RQ takes back all the runtime it lend to its neighbours.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__disable_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">root_domain</span> <span class="o">*</span><span class="n">rd</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rd</span><span class="p">;</span>
	<span class="n">rt_rq_iter_t</span> <span class="n">iter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">scheduler_running</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">for_each_rt_rq</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">,</span> <span class="n">iter</span><span class="p">,</span> <span class="n">rq</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rt_bandwidth</span> <span class="o">*</span><span class="n">rt_b</span> <span class="o">=</span> <span class="n">sched_rt_bandwidth</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">);</span>
		<span class="n">s64</span> <span class="n">want</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_b</span><span class="o">-&gt;</span><span class="n">rt_runtime_lock</span><span class="p">);</span>
		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_runtime_lock</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Either we&#39;re all inf and nobody needs to borrow, or we&#39;re</span>
<span class="cm">		 * already disabled and thus have nothing to do, or we have</span>
<span class="cm">		 * exactly the right amount of runtime to take out.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_runtime</span> <span class="o">==</span> <span class="n">RUNTIME_INF</span> <span class="o">||</span>
				<span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_runtime</span> <span class="o">==</span> <span class="n">rt_b</span><span class="o">-&gt;</span><span class="n">rt_runtime</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">balanced</span><span class="p">;</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_runtime_lock</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Calculate the difference between what we started out with</span>
<span class="cm">		 * and what we current have, that&#39;s the amount of runtime</span>
<span class="cm">		 * we lend and now have to reclaim.</span>
<span class="cm">		 */</span>
		<span class="n">want</span> <span class="o">=</span> <span class="n">rt_b</span><span class="o">-&gt;</span><span class="n">rt_runtime</span> <span class="o">-</span> <span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_runtime</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Greedy reclaim, take back as much as we can.</span>
<span class="cm">		 */</span>
		<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">rd</span><span class="o">-&gt;</span><span class="n">span</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">sched_rt_period_rt_rq</span><span class="p">(</span><span class="n">rt_b</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">s64</span> <span class="n">diff</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Can&#39;t reclaim from ourselves or disabled runqueues.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">==</span> <span class="n">rt_rq</span> <span class="o">||</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">rt_runtime</span> <span class="o">==</span> <span class="n">RUNTIME_INF</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">rt_runtime_lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">want</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">diff</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">s64</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">rt_runtime</span><span class="p">,</span> <span class="n">want</span><span class="p">);</span>
				<span class="n">iter</span><span class="o">-&gt;</span><span class="n">rt_runtime</span> <span class="o">-=</span> <span class="n">diff</span><span class="p">;</span>
				<span class="n">want</span> <span class="o">-=</span> <span class="n">diff</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">iter</span><span class="o">-&gt;</span><span class="n">rt_runtime</span> <span class="o">-=</span> <span class="n">want</span><span class="p">;</span>
				<span class="n">want</span> <span class="o">-=</span> <span class="n">want</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">rt_runtime_lock</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">want</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_runtime_lock</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * We cannot be left wanting - that would mean some runtime</span>
<span class="cm">		 * leaked out of the system.</span>
<span class="cm">		 */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">want</span><span class="p">);</span>
<span class="nl">balanced:</span>
		<span class="cm">/*</span>
<span class="cm">		 * Disable all the borrow logic by pretending we have inf</span>
<span class="cm">		 * runtime - in which case borrowing doesn&#39;t make sense.</span>
<span class="cm">		 */</span>
		<span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_runtime</span> <span class="o">=</span> <span class="n">RUNTIME_INF</span><span class="p">;</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_runtime_lock</span><span class="p">);</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_b</span><span class="o">-&gt;</span><span class="n">rt_runtime_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">disable_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__disable_runtime</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__enable_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rt_rq_iter_t</span> <span class="n">iter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">scheduler_running</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reset each runqueue&#39;s bandwidth settings</span>
<span class="cm">	 */</span>
	<span class="n">for_each_rt_rq</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">,</span> <span class="n">iter</span><span class="p">,</span> <span class="n">rq</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rt_bandwidth</span> <span class="o">*</span><span class="n">rt_b</span> <span class="o">=</span> <span class="n">sched_rt_bandwidth</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">);</span>

		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_b</span><span class="o">-&gt;</span><span class="n">rt_runtime_lock</span><span class="p">);</span>
		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_runtime_lock</span><span class="p">);</span>
		<span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_runtime</span> <span class="o">=</span> <span class="n">rt_b</span><span class="o">-&gt;</span><span class="n">rt_runtime</span><span class="p">;</span>
		<span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_throttled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_runtime_lock</span><span class="p">);</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_b</span><span class="o">-&gt;</span><span class="n">rt_runtime_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enable_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__enable_runtime</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">update_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nfb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="kt">long</span><span class="p">)</span><span class="n">hcpu</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_DOWN_PREPARE</span>:
	<span class="k">case</span> <span class="n">CPU_DOWN_PREPARE_FROZEN</span>:
		<span class="n">disable_runtime</span><span class="p">(</span><span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CPU_DOWN_FAILED</span>:
	<span class="k">case</span> <span class="n">CPU_DOWN_FAILED_FROZEN</span>:
	<span class="k">case</span> <span class="n">CPU_ONLINE</span>:
	<span class="k">case</span> <span class="n">CPU_ONLINE_FROZEN</span>:
		<span class="n">enable_runtime</span><span class="p">(</span><span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">balance_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">more</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sched_feat</span><span class="p">(</span><span class="n">RT_RUNTIME_SHARE</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">more</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_time</span> <span class="o">&gt;</span> <span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_runtime</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_runtime_lock</span><span class="p">);</span>
		<span class="n">more</span> <span class="o">=</span> <span class="n">do_balance_runtime</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">);</span>
		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_runtime_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">more</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* !CONFIG_SMP */</span><span class="cp"></span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">balance_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_sched_rt_period_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_bandwidth</span> <span class="o">*</span><span class="n">rt_b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">overrun</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">idle</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">throttled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">span</span><span class="p">;</span>

	<span class="n">span</span> <span class="o">=</span> <span class="n">sched_rt_period_mask</span><span class="p">();</span>
	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">span</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">enqueue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span> <span class="o">=</span> <span class="n">sched_rt_period_rt_rq</span><span class="p">(</span><span class="n">rt_b</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">rq_of_rt_rq</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">);</span>

		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_time</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u64</span> <span class="n">runtime</span><span class="p">;</span>

			<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_runtime_lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_throttled</span><span class="p">)</span>
				<span class="n">balance_runtime</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">);</span>
			<span class="n">runtime</span> <span class="o">=</span> <span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_runtime</span><span class="p">;</span>
			<span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_time</span> <span class="o">-=</span> <span class="n">min</span><span class="p">(</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_time</span><span class="p">,</span> <span class="n">overrun</span><span class="o">*</span><span class="n">runtime</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_throttled</span> <span class="o">&amp;&amp;</span> <span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_time</span> <span class="o">&lt;</span> <span class="n">runtime</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_throttled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">enqueue</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

				<span class="cm">/*</span>
<span class="cm">				 * Force a clock update if the CPU was idle,</span>
<span class="cm">				 * lest wakeup -&gt; unthrottle time accumulate.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_nr_running</span> <span class="o">&amp;&amp;</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span> <span class="o">==</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">idle</span><span class="p">)</span>
					<span class="n">rq</span><span class="o">-&gt;</span><span class="n">skip_clock_update</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_time</span> <span class="o">||</span> <span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_nr_running</span><span class="p">)</span>
				<span class="n">idle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_runtime_lock</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_nr_running</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">idle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rt_rq_throttled</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">))</span>
				<span class="n">enqueue</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_throttled</span><span class="p">)</span>
			<span class="n">throttled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">enqueue</span><span class="p">)</span>
			<span class="n">sched_rt_rq_enqueue</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">);</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">throttled</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">rt_bandwidth_enabled</span><span class="p">()</span> <span class="o">||</span> <span class="n">rt_b</span><span class="o">-&gt;</span><span class="n">rt_runtime</span> <span class="o">==</span> <span class="n">RUNTIME_INF</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">idle</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">rt_se_prio</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_RT_GROUP_SCHED</span>
	<span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span> <span class="o">=</span> <span class="n">group_rt_rq</span><span class="p">(</span><span class="n">rt_se</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rt_rq</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">highest_prio</span><span class="p">.</span><span class="n">curr</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="n">rt_task_of</span><span class="p">(</span><span class="n">rt_se</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sched_rt_runtime_exceeded</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">runtime</span> <span class="o">=</span> <span class="n">sched_rt_runtime</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_throttled</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rt_rq_throttled</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">runtime</span> <span class="o">&gt;=</span> <span class="n">sched_rt_period</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">balance_runtime</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">);</span>
	<span class="n">runtime</span> <span class="o">=</span> <span class="n">sched_rt_runtime</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">runtime</span> <span class="o">==</span> <span class="n">RUNTIME_INF</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_time</span> <span class="o">&gt;</span> <span class="n">runtime</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rt_bandwidth</span> <span class="o">*</span><span class="n">rt_b</span> <span class="o">=</span> <span class="n">sched_rt_bandwidth</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Don&#39;t actually throttle groups that have no runtime assigned</span>
<span class="cm">		 * but accrue some time due to boosting.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">rt_b</span><span class="o">-&gt;</span><span class="n">rt_runtime</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">static</span> <span class="n">bool</span> <span class="n">once</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

			<span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_throttled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">once</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">once</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="n">printk_sched</span><span class="p">(</span><span class="s">&quot;sched: RT throttling activated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * In case we did anyway, make it go away,</span>
<span class="cm">			 * replenishment is a joke, since it will replenish us</span>
<span class="cm">			 * with exactly 0 ns.</span>
<span class="cm">			 */</span>
			<span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rt_rq_throttled</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sched_rt_rq_dequeue</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Update the current task&#39;s runtime statistics. Skip current tasks that</span>
<span class="cm"> * are not in our scheduling class.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_curr_rt</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span> <span class="o">=</span> <span class="n">rt_rq_of_se</span><span class="p">(</span><span class="n">rt_se</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">delta_exec</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">rt_sched_class</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">delta_exec</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">clock_task</span> <span class="o">-</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">exec_start</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">s64</span><span class="p">)</span><span class="n">delta_exec</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">delta_exec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">schedstat_set</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">statistics</span><span class="p">.</span><span class="n">exec_max</span><span class="p">,</span>
		      <span class="n">max</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">statistics</span><span class="p">.</span><span class="n">exec_max</span><span class="p">,</span> <span class="n">delta_exec</span><span class="p">));</span>

	<span class="n">curr</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">sum_exec_runtime</span> <span class="o">+=</span> <span class="n">delta_exec</span><span class="p">;</span>
	<span class="n">account_group_exec_runtime</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">delta_exec</span><span class="p">);</span>

	<span class="n">curr</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">exec_start</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">clock_task</span><span class="p">;</span>
	<span class="n">cpuacct_charge</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">delta_exec</span><span class="p">);</span>

	<span class="n">sched_rt_avg_update</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">delta_exec</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rt_bandwidth_enabled</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">for_each_sched_rt_entity</span><span class="p">(</span><span class="n">rt_se</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rt_rq</span> <span class="o">=</span> <span class="n">rt_rq_of_se</span><span class="p">(</span><span class="n">rt_se</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sched_rt_runtime</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">)</span> <span class="o">!=</span> <span class="n">RUNTIME_INF</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_runtime_lock</span><span class="p">);</span>
			<span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_time</span> <span class="o">+=</span> <span class="n">delta_exec</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sched_rt_runtime_exceeded</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">))</span>
				<span class="n">resched_task</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>
			<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_runtime_lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#if defined CONFIG_SMP</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">inc_rt_prio_smp</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prev_prio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">rq_of_rt_rq</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">online</span> <span class="o">&amp;&amp;</span> <span class="n">prio</span> <span class="o">&lt;</span> <span class="n">prev_prio</span><span class="p">)</span>
		<span class="n">cpupri_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">cpupri</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">prio</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">dec_rt_prio_smp</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prev_prio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">rq_of_rt_rq</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">online</span> <span class="o">&amp;&amp;</span> <span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">highest_prio</span><span class="p">.</span><span class="n">curr</span> <span class="o">!=</span> <span class="n">prev_prio</span><span class="p">)</span>
		<span class="n">cpupri_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">cpupri</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">highest_prio</span><span class="p">.</span><span class="n">curr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">inc_rt_prio_smp</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prev_prio</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">dec_rt_prio_smp</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prev_prio</span><span class="p">)</span> <span class="p">{}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="cp">#if defined CONFIG_SMP || defined CONFIG_RT_GROUP_SCHED</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">inc_rt_prio</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">prev_prio</span> <span class="o">=</span> <span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">highest_prio</span><span class="p">.</span><span class="n">curr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prio</span> <span class="o">&lt;</span> <span class="n">prev_prio</span><span class="p">)</span>
		<span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">highest_prio</span><span class="p">.</span><span class="n">curr</span> <span class="o">=</span> <span class="n">prio</span><span class="p">;</span>

	<span class="n">inc_rt_prio_smp</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">,</span> <span class="n">prio</span><span class="p">,</span> <span class="n">prev_prio</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">dec_rt_prio</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">prev_prio</span> <span class="o">=</span> <span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">highest_prio</span><span class="p">.</span><span class="n">curr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_nr_running</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">prio</span> <span class="o">&lt;</span> <span class="n">prev_prio</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * This may have been our highest task, and therefore</span>
<span class="cm">		 * we may have some recomputation to do</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prio</span> <span class="o">==</span> <span class="n">prev_prio</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">rt_prio_array</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">;</span>

			<span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">highest_prio</span><span class="p">.</span><span class="n">curr</span> <span class="o">=</span>
				<span class="n">sched_find_first_bit</span><span class="p">(</span><span class="n">array</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="p">}</span> <span class="k">else</span>
		<span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">highest_prio</span><span class="p">.</span><span class="n">curr</span> <span class="o">=</span> <span class="n">MAX_RT_PRIO</span><span class="p">;</span>

	<span class="n">dec_rt_prio_smp</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">,</span> <span class="n">prio</span><span class="p">,</span> <span class="n">prev_prio</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">inc_rt_prio</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prio</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dec_rt_prio</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prio</span><span class="p">)</span> <span class="p">{}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP || CONFIG_RT_GROUP_SCHED */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_RT_GROUP_SCHED</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">inc_rt_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rt_se_boosted</span><span class="p">(</span><span class="n">rt_se</span><span class="p">))</span>
		<span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_nr_boosted</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">tg</span><span class="p">)</span>
		<span class="n">start_rt_bandwidth</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">rt_bandwidth</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">dec_rt_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rt_se_boosted</span><span class="p">(</span><span class="n">rt_se</span><span class="p">))</span>
		<span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_nr_boosted</span><span class="o">--</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_nr_running</span> <span class="o">&amp;&amp;</span> <span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_nr_boosted</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_RT_GROUP_SCHED */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">inc_rt_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">start_rt_bandwidth</span><span class="p">(</span><span class="o">&amp;</span><span class="n">def_rt_bandwidth</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">dec_rt_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">)</span> <span class="p">{}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_RT_GROUP_SCHED */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">inc_rt_tasks</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">prio</span> <span class="o">=</span> <span class="n">rt_se_prio</span><span class="p">(</span><span class="n">rt_se</span><span class="p">);</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">rt_prio</span><span class="p">(</span><span class="n">prio</span><span class="p">));</span>
	<span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_nr_running</span><span class="o">++</span><span class="p">;</span>

	<span class="n">inc_rt_prio</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">,</span> <span class="n">prio</span><span class="p">);</span>
	<span class="n">inc_rt_migration</span><span class="p">(</span><span class="n">rt_se</span><span class="p">,</span> <span class="n">rt_rq</span><span class="p">);</span>
	<span class="n">inc_rt_group</span><span class="p">(</span><span class="n">rt_se</span><span class="p">,</span> <span class="n">rt_rq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">dec_rt_tasks</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">rt_prio</span><span class="p">(</span><span class="n">rt_se_prio</span><span class="p">(</span><span class="n">rt_se</span><span class="p">)));</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_nr_running</span><span class="p">);</span>
	<span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_nr_running</span><span class="o">--</span><span class="p">;</span>

	<span class="n">dec_rt_prio</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">,</span> <span class="n">rt_se_prio</span><span class="p">(</span><span class="n">rt_se</span><span class="p">));</span>
	<span class="n">dec_rt_migration</span><span class="p">(</span><span class="n">rt_se</span><span class="p">,</span> <span class="n">rt_rq</span><span class="p">);</span>
	<span class="n">dec_rt_group</span><span class="p">(</span><span class="n">rt_se</span><span class="p">,</span> <span class="n">rt_rq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__enqueue_rt_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span><span class="p">,</span> <span class="n">bool</span> <span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span> <span class="o">=</span> <span class="n">rt_rq_of_se</span><span class="p">(</span><span class="n">rt_se</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">rt_prio_array</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">group_rq</span> <span class="o">=</span> <span class="n">group_rt_rq</span><span class="p">(</span><span class="n">rt_se</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="n">array</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">+</span> <span class="n">rt_se_prio</span><span class="p">(</span><span class="n">rt_se</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t enqueue the group if its throttled, or when empty.</span>
<span class="cm">	 * The latter is a consequence of the former when a child group</span>
<span class="cm">	 * get throttled and the current group doesn&#39;t have any other</span>
<span class="cm">	 * active members.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">group_rq</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rt_rq_throttled</span><span class="p">(</span><span class="n">group_rq</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">group_rq</span><span class="o">-&gt;</span><span class="n">rt_nr_running</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_nr_running</span><span class="p">)</span>
		<span class="n">list_add_leaf_rt_rq</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="p">)</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_se</span><span class="o">-&gt;</span><span class="n">run_list</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_se</span><span class="o">-&gt;</span><span class="n">run_list</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">rt_se_prio</span><span class="p">(</span><span class="n">rt_se</span><span class="p">),</span> <span class="n">array</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">);</span>

	<span class="n">inc_rt_tasks</span><span class="p">(</span><span class="n">rt_se</span><span class="p">,</span> <span class="n">rt_rq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__dequeue_rt_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span> <span class="o">=</span> <span class="n">rt_rq_of_se</span><span class="p">(</span><span class="n">rt_se</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">rt_prio_array</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">;</span>

	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_se</span><span class="o">-&gt;</span><span class="n">run_list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="n">array</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">+</span> <span class="n">rt_se_prio</span><span class="p">(</span><span class="n">rt_se</span><span class="p">)))</span>
		<span class="n">__clear_bit</span><span class="p">(</span><span class="n">rt_se_prio</span><span class="p">(</span><span class="n">rt_se</span><span class="p">),</span> <span class="n">array</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">);</span>

	<span class="n">dec_rt_tasks</span><span class="p">(</span><span class="n">rt_se</span><span class="p">,</span> <span class="n">rt_rq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_nr_running</span><span class="p">)</span>
		<span class="n">list_del_leaf_rt_rq</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Because the prio of an upper entry depends on the lower</span>
<span class="cm"> * entries, we must remove entries top - down.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dequeue_rt_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">back</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">for_each_sched_rt_entity</span><span class="p">(</span><span class="n">rt_se</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rt_se</span><span class="o">-&gt;</span><span class="n">back</span> <span class="o">=</span> <span class="n">back</span><span class="p">;</span>
		<span class="n">back</span> <span class="o">=</span> <span class="n">rt_se</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">rt_se</span> <span class="o">=</span> <span class="n">back</span><span class="p">;</span> <span class="n">rt_se</span><span class="p">;</span> <span class="n">rt_se</span> <span class="o">=</span> <span class="n">rt_se</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">on_rt_rq</span><span class="p">(</span><span class="n">rt_se</span><span class="p">))</span>
			<span class="n">__dequeue_rt_entity</span><span class="p">(</span><span class="n">rt_se</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enqueue_rt_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span><span class="p">,</span> <span class="n">bool</span> <span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dequeue_rt_stack</span><span class="p">(</span><span class="n">rt_se</span><span class="p">);</span>
	<span class="n">for_each_sched_rt_entity</span><span class="p">(</span><span class="n">rt_se</span><span class="p">)</span>
		<span class="n">__enqueue_rt_entity</span><span class="p">(</span><span class="n">rt_se</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dequeue_rt_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dequeue_rt_stack</span><span class="p">(</span><span class="n">rt_se</span><span class="p">);</span>

	<span class="n">for_each_sched_rt_entity</span><span class="p">(</span><span class="n">rt_se</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span> <span class="o">=</span> <span class="n">group_rt_rq</span><span class="p">(</span><span class="n">rt_se</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rt_rq</span> <span class="o">&amp;&amp;</span> <span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_nr_running</span><span class="p">)</span>
			<span class="n">__enqueue_rt_entity</span><span class="p">(</span><span class="n">rt_se</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Adding/removing a task to/from a priority array:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">enqueue_task_rt</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ENQUEUE_WAKEUP</span><span class="p">)</span>
		<span class="n">rt_se</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">enqueue_rt_entity</span><span class="p">(</span><span class="n">rt_se</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ENQUEUE_HEAD</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task_current</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">nr_cpus_allowed</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">enqueue_pushable_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

	<span class="n">inc_nr_running</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dequeue_task_rt</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">;</span>

	<span class="n">update_curr_rt</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="n">dequeue_rt_entity</span><span class="p">(</span><span class="n">rt_se</span><span class="p">);</span>

	<span class="n">dequeue_pushable_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

	<span class="n">dec_nr_running</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Put task to the head or the end of the run list without the overhead of</span>
<span class="cm"> * dequeue followed by enqueue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">requeue_rt_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span><span class="p">,</span> <span class="kt">int</span> <span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">on_rt_rq</span><span class="p">(</span><span class="n">rt_se</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rt_prio_array</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="n">array</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">+</span> <span class="n">rt_se_prio</span><span class="p">(</span><span class="n">rt_se</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="p">)</span>
			<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_se</span><span class="o">-&gt;</span><span class="n">run_list</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_se</span><span class="o">-&gt;</span><span class="n">run_list</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">requeue_task_rt</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">;</span>

	<span class="n">for_each_sched_rt_entity</span><span class="p">(</span><span class="n">rt_se</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rt_rq</span> <span class="o">=</span> <span class="n">rt_rq_of_se</span><span class="p">(</span><span class="n">rt_se</span><span class="p">);</span>
		<span class="n">requeue_rt_entity</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">,</span> <span class="n">rt_se</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">yield_task_rt</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">requeue_task_rt</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">find_lowest_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">select_task_rq_rt</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sd_flag</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">nr_cpus_allowed</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* For anything but wake ups, just return the task_cpu */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sd_flag</span> <span class="o">!=</span> <span class="n">SD_BALANCE_WAKE</span> <span class="o">&amp;&amp;</span> <span class="n">sd_flag</span> <span class="o">!=</span> <span class="n">SD_BALANCE_FORK</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">curr</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">);</span> <span class="cm">/* unlocked access */</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the current task on @p&#39;s runqueue is an RT task, then</span>
<span class="cm">	 * try to see if we can wake this RT task up on another</span>
<span class="cm">	 * runqueue. Otherwise simply start this RT task</span>
<span class="cm">	 * on its current runqueue.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We want to avoid overloading runqueues. If the woken</span>
<span class="cm">	 * task is a higher priority, then it will stay on this CPU</span>
<span class="cm">	 * and the lower prio task should be moved to another CPU.</span>
<span class="cm">	 * Even though this will probably make the lower prio task</span>
<span class="cm">	 * lose its cache, we do not want to bounce a higher task</span>
<span class="cm">	 * around just because it gave up its CPU, perhaps for a</span>
<span class="cm">	 * lock?</span>
<span class="cm">	 *</span>
<span class="cm">	 * For equal prio tasks, we just let the scheduler sort it out.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Otherwise, just let it ride on the affined RQ and the</span>
<span class="cm">	 * post-schedule router will push the preempted task away</span>
<span class="cm">	 *</span>
<span class="cm">	 * This test is optimistic, if we get it wrong the load-balancer</span>
<span class="cm">	 * will have to sort it out.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">curr</span> <span class="o">&amp;&amp;</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">rt_task</span><span class="p">(</span><span class="n">curr</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">nr_cpus_allowed</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">||</span>
	     <span class="n">curr</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">&lt;=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">nr_cpus_allowed</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">target</span> <span class="o">=</span> <span class="n">find_lowest_rq</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">cpu</span> <span class="o">=</span> <span class="n">target</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">cpu</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_preempt_equal_prio</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">nr_cpus_allowed</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">nr_cpus_allowed</span> <span class="o">!=</span> <span class="mi">1</span>
	    <span class="o">&amp;&amp;</span> <span class="n">cpupri_find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">cpupri</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpupri_find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">cpupri</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * There appears to be other cpus that can accept</span>
<span class="cm">	 * current and none to run &#39;p&#39;, so lets reschedule</span>
<span class="cm">	 * to try and push current away:</span>
<span class="cm">	 */</span>
	<span class="n">requeue_task_rt</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">resched_task</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Preempt the current task with a newly woken task if needed:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_preempt_curr_rt</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">&lt;</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">resched_task</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="cm">/*</span>
<span class="cm">	 * If:</span>
<span class="cm">	 *</span>
<span class="cm">	 * - the newly woken task is of equal priority to the current task</span>
<span class="cm">	 * - the newly woken task is non-migratable while current is migratable</span>
<span class="cm">	 * - current will be preempted on the next reschedule</span>
<span class="cm">	 *</span>
<span class="cm">	 * we should check to see if current can readily move to a different</span>
<span class="cm">	 * cpu.  If so, we will reschedule to allow the push logic to try</span>
<span class="cm">	 * to move current somewhere else, making room for our non-migratable</span>
<span class="cm">	 * task.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">==</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">test_tsk_need_resched</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">))</span>
		<span class="n">check_preempt_equal_prio</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="nf">pick_next_rt_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span>
						   <span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rt_prio_array</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">queue</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>

	<span class="n">idx</span> <span class="o">=</span> <span class="n">sched_find_first_bit</span><span class="p">(</span><span class="n">array</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">MAX_RT_PRIO</span><span class="p">);</span>

	<span class="n">queue</span> <span class="o">=</span> <span class="n">array</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">+</span> <span class="n">idx</span><span class="p">;</span>
	<span class="n">next</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_rt_entity</span><span class="p">,</span> <span class="n">run_list</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">_pick_next_task_rt</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">;</span>

	<span class="n">rt_rq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_nr_running</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rt_rq_throttled</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">rt_se</span> <span class="o">=</span> <span class="n">pick_next_rt_entity</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">rt_rq</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">rt_se</span><span class="p">);</span>
		<span class="n">rt_rq</span> <span class="o">=</span> <span class="n">group_rt_rq</span><span class="p">(</span><span class="n">rt_se</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">rt_rq</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">rt_task_of</span><span class="p">(</span><span class="n">rt_se</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">exec_start</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">clock_task</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">pick_next_task_rt</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">_pick_next_task_rt</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>

	<span class="cm">/* The running task is never eligible for pushing */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
		<span class="n">dequeue_pushable_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="cm">/*</span>
<span class="cm">	 * We detect this state here so that we can avoid taking the RQ</span>
<span class="cm">	 * lock again later if there is no need to push</span>
<span class="cm">	 */</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">post_schedule</span> <span class="o">=</span> <span class="n">has_pushable_tasks</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">put_prev_task_rt</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">update_curr_rt</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The previous task needs to be made eligible for pushing</span>
<span class="cm">	 * if it is still active</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">on_rt_rq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">nr_cpus_allowed</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">enqueue_pushable_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SMP</span>

<span class="cm">/* Only try algorithms three times */</span>
<span class="cp">#define RT_MAX_TRIES 3</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pick_rt_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task_running</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">cpu</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">tsk_cpus_allowed</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">nr_cpus_allowed</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return the second highest RT task, NULL otherwise */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">pick_next_highest_task_rt</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rt_prio_array</span> <span class="o">*</span><span class="n">array</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>

	<span class="n">for_each_leaf_rt_rq</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">,</span> <span class="n">rq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">array</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">;</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">sched_find_first_bit</span><span class="p">(</span><span class="n">array</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">);</span>
<span class="nl">next_idx:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">MAX_RT_PRIO</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">&amp;&amp;</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">&lt;=</span> <span class="n">idx</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">rt_se</span><span class="p">,</span> <span class="n">array</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">+</span> <span class="n">idx</span><span class="p">,</span> <span class="n">run_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rt_entity_is_task</span><span class="p">(</span><span class="n">rt_se</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">p</span> <span class="o">=</span> <span class="n">rt_task_of</span><span class="p">(</span><span class="n">rt_se</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pick_rt_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">cpu</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">idx</span> <span class="o">=</span> <span class="n">find_next_bit</span><span class="p">(</span><span class="n">array</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">,</span> <span class="n">MAX_RT_PRIO</span><span class="p">,</span> <span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">next_idx</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">cpumask_var_t</span><span class="p">,</span> <span class="n">local_cpu_mask</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_lowest_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">lowest_mask</span> <span class="o">=</span> <span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">local_cpu_mask</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">this_cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">cpu</span>      <span class="o">=</span> <span class="n">task_cpu</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="cm">/* Make sure the mask is initialized first */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">lowest_mask</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">nr_cpus_allowed</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* No other targets possible */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpupri_find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task_rq</span><span class="p">(</span><span class="n">task</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">cpupri</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">lowest_mask</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* No targets found */</span>

	<span class="cm">/*</span>
<span class="cm">	 * At this point we have built a mask of cpus representing the</span>
<span class="cm">	 * lowest priority tasks in the system.  Now we want to elect</span>
<span class="cm">	 * the best one based on our affinity and topology.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We prioritize the last cpu that the task executed on since</span>
<span class="cm">	 * it is most likely cache-hot in that location.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">lowest_mask</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Otherwise, we consult the sched_domains span maps to figure</span>
<span class="cm">	 * out which cpu is logically closest to our hot cache data.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">,</span> <span class="n">lowest_mask</span><span class="p">))</span>
		<span class="n">this_cpu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* Skip this_cpu opt if not among lowest */</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">for_each_domain</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">sd</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SD_WAKE_AFFINE</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">best_cpu</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * &quot;this_cpu&quot; is cheaper to preempt than a</span>
<span class="cm">			 * remote processor.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">this_cpu</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span>
			    <span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">,</span> <span class="n">sched_domain_span</span><span class="p">(</span><span class="n">sd</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">rcu_read_unlock</span><span class="p">();</span>
				<span class="k">return</span> <span class="n">this_cpu</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">best_cpu</span> <span class="o">=</span> <span class="n">cpumask_first_and</span><span class="p">(</span><span class="n">lowest_mask</span><span class="p">,</span>
						     <span class="n">sched_domain_span</span><span class="p">(</span><span class="n">sd</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">best_cpu</span> <span class="o">&lt;</span> <span class="n">nr_cpu_ids</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rcu_read_unlock</span><span class="p">();</span>
				<span class="k">return</span> <span class="n">best_cpu</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * And finally, if there were no matches within the domains</span>
<span class="cm">	 * just give the caller *something* to work with from the compatible</span>
<span class="cm">	 * locations.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">this_cpu</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">this_cpu</span><span class="p">;</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="n">cpumask_any</span><span class="p">(</span><span class="n">lowest_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">&lt;</span> <span class="n">nr_cpu_ids</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Will lock the rq it finds */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="nf">find_lock_lowest_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">lowest_rq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tries</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">tries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tries</span> <span class="o">&lt;</span> <span class="n">RT_MAX_TRIES</span><span class="p">;</span> <span class="n">tries</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpu</span> <span class="o">=</span> <span class="n">find_lowest_rq</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">cpu</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">lowest_rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

		<span class="cm">/* if the prio of this runqueue changed, try again */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">double_lock_balance</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">lowest_rq</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We had to unlock the run queue. In</span>
<span class="cm">			 * the mean time, task could have</span>
<span class="cm">			 * migrated already or had its affinity changed.</span>
<span class="cm">			 * Also make sure that it wasn&#39;t scheduled on its rq.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">task_rq</span><span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="o">!=</span> <span class="n">rq</span> <span class="o">||</span>
				     <span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">lowest_rq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span>
						       <span class="n">tsk_cpus_allowed</span><span class="p">(</span><span class="n">task</span><span class="p">))</span> <span class="o">||</span>
				     <span class="n">task_running</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span> <span class="o">||</span>
				     <span class="o">!</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">))</span> <span class="p">{</span>

				<span class="n">double_unlock_balance</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">lowest_rq</span><span class="p">);</span>
				<span class="n">lowest_rq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* If this rq is still suitable use it. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lowest_rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">highest_prio</span><span class="p">.</span><span class="n">curr</span> <span class="o">&gt;</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* try again */</span>
		<span class="n">double_unlock_balance</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">lowest_rq</span><span class="p">);</span>
		<span class="n">lowest_rq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">lowest_rq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">pick_next_pushable_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">has_pushable_tasks</span><span class="p">(</span><span class="n">rq</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">plist_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">pushable_tasks</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">task_struct</span><span class="p">,</span> <span class="n">pushable_tasks</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">task_current</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">nr_cpus_allowed</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">rt_task</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If the current CPU has more than one RT task, see if the non</span>
<span class="cm"> * running task can migrate over to a CPU that is running a task</span>
<span class="cm"> * of lesser priority.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">push_rt_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">next_task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">lowest_rq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">overloaded</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">next_task</span> <span class="o">=</span> <span class="n">pick_next_pushable_task</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next_task</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef __ARCH_WANT_INTERRUPTS_ON_CTXSW</span>
       <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">task_running</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">next_task</span><span class="p">)))</span>
               <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="nl">retry:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">next_task</span> <span class="o">==</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * It&#39;s possible that the next_task slipped in of</span>
<span class="cm">	 * higher priority than current. If that&#39;s the case</span>
<span class="cm">	 * just reschedule current.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">next_task</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">&lt;</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">resched_task</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We might release rq lock */</span>
	<span class="n">get_task_struct</span><span class="p">(</span><span class="n">next_task</span><span class="p">);</span>

	<span class="cm">/* find_lock_lowest_rq locks the rq if found */</span>
	<span class="n">lowest_rq</span> <span class="o">=</span> <span class="n">find_lock_lowest_rq</span><span class="p">(</span><span class="n">next_task</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lowest_rq</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * find_lock_lowest_rq releases rq-&gt;lock</span>
<span class="cm">		 * so it is possible that next_task has migrated.</span>
<span class="cm">		 *</span>
<span class="cm">		 * We need to make sure that the task is still on the same</span>
<span class="cm">		 * run-queue and is also still the next task eligible for</span>
<span class="cm">		 * pushing.</span>
<span class="cm">		 */</span>
		<span class="n">task</span> <span class="o">=</span> <span class="n">pick_next_pushable_task</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">task_cpu</span><span class="p">(</span><span class="n">next_task</span><span class="p">)</span> <span class="o">==</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">&amp;&amp;</span> <span class="n">task</span> <span class="o">==</span> <span class="n">next_task</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The task hasn&#39;t migrated, and is still the next</span>
<span class="cm">			 * eligible task, but we failed to find a run-queue</span>
<span class="cm">			 * to push it to.  Do not retry in this case, since</span>
<span class="cm">			 * other cpus will pull from us when ready.</span>
<span class="cm">			 */</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span>
			<span class="cm">/* No more tasks, just exit */</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Something has shifted, try again.</span>
<span class="cm">		 */</span>
		<span class="n">put_task_struct</span><span class="p">(</span><span class="n">next_task</span><span class="p">);</span>
		<span class="n">next_task</span> <span class="o">=</span> <span class="n">task</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">deactivate_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">next_task</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">set_task_cpu</span><span class="p">(</span><span class="n">next_task</span><span class="p">,</span> <span class="n">lowest_rq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">activate_task</span><span class="p">(</span><span class="n">lowest_rq</span><span class="p">,</span> <span class="n">next_task</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">resched_task</span><span class="p">(</span><span class="n">lowest_rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">);</span>

	<span class="n">double_unlock_balance</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">lowest_rq</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">next_task</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">push_rt_tasks</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* push_rt_task will return true if it moved an RT */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">push_rt_task</span><span class="p">(</span><span class="n">rq</span><span class="p">))</span>
		<span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pull_rt_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">this_cpu</span> <span class="o">=</span> <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">src_rq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">rt_overloaded</span><span class="p">(</span><span class="n">this_rq</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">rto_mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">this_cpu</span> <span class="o">==</span> <span class="n">cpu</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">src_rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Don&#39;t bother taking the src_rq-&gt;lock if the next highest</span>
<span class="cm">		 * task is known to be lower-priority than our current task.</span>
<span class="cm">		 * This may look racy, but if this value is about to go</span>
<span class="cm">		 * logically higher, the src_rq will push this task away.</span>
<span class="cm">		 * And if its going logically lower, we do not care</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">src_rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">highest_prio</span><span class="p">.</span><span class="n">next</span> <span class="o">&gt;=</span>
		    <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">highest_prio</span><span class="p">.</span><span class="n">curr</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We can potentially drop this_rq&#39;s lock in</span>
<span class="cm">		 * double_lock_balance, and another CPU could</span>
<span class="cm">		 * alter this_rq</span>
<span class="cm">		 */</span>
		<span class="n">double_lock_balance</span><span class="p">(</span><span class="n">this_rq</span><span class="p">,</span> <span class="n">src_rq</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Are there still pullable RT tasks?</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">src_rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">rt_nr_running</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">skip</span><span class="p">;</span>

		<span class="n">p</span> <span class="o">=</span> <span class="n">pick_next_highest_task_rt</span><span class="p">(</span><span class="n">src_rq</span><span class="p">,</span> <span class="n">this_cpu</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Do we have an RT task that preempts</span>
<span class="cm">		 * the to-be-scheduled task?</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">&lt;</span> <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">highest_prio</span><span class="p">.</span><span class="n">curr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">src_rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">);</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * There&#39;s a chance that p is higher in priority</span>
<span class="cm">			 * than what&#39;s currently running on its cpu.</span>
<span class="cm">			 * This is just that p is wakeing up and hasn&#39;t</span>
<span class="cm">			 * had a chance to schedule. We only pull</span>
<span class="cm">			 * p if it is lower in priority than the</span>
<span class="cm">			 * current task on the run queue</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">&lt;</span> <span class="n">src_rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">skip</span><span class="p">;</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="n">deactivate_task</span><span class="p">(</span><span class="n">src_rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">set_task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">this_cpu</span><span class="p">);</span>
			<span class="n">activate_task</span><span class="p">(</span><span class="n">this_rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * We continue with the search, just in</span>
<span class="cm">			 * case there&#39;s an even higher prio task</span>
<span class="cm">			 * in another runqueue. (low likelihood</span>
<span class="cm">			 * but possible)</span>
<span class="cm">			 */</span>
		<span class="p">}</span>
<span class="nl">skip:</span>
		<span class="n">double_unlock_balance</span><span class="p">(</span><span class="n">this_rq</span><span class="p">,</span> <span class="n">src_rq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pre_schedule_rt</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Try to pull RT tasks here if we lower this rq&#39;s prio */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">highest_prio</span><span class="p">.</span><span class="n">curr</span> <span class="o">&gt;</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">)</span>
		<span class="n">pull_rt_task</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">post_schedule_rt</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">push_rt_tasks</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If we are not running and we are not going to reschedule soon, we should</span>
<span class="cm"> * try to push tasks away now</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">task_woken_rt</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task_running</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">test_tsk_need_resched</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">has_pushable_tasks</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">p</span><span class="o">-&gt;</span><span class="n">nr_cpus_allowed</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
	    <span class="n">rt_task</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">nr_cpus_allowed</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">||</span>
	     <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">&lt;=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">))</span>
		<span class="n">push_rt_tasks</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_cpus_allowed_rt</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">new_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">weight</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">rt_task</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">weight</span> <span class="o">=</span> <span class="n">cpumask_weight</span><span class="p">(</span><span class="n">new_mask</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Only update if the process changes its state from whether it</span>
<span class="cm">	 * can migrate or not.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">nr_cpus_allowed</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">weight</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">rq</span> <span class="o">=</span> <span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The process used to be able to migrate OR it can now migrate</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">weight</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task_current</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
			<span class="n">dequeue_pushable_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">rt_nr_migratory</span><span class="p">);</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">rt_nr_migratory</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task_current</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
			<span class="n">enqueue_pushable_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">rt_nr_migratory</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">update_rt_migration</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Assumes rq-&gt;lock is held */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rq_online_rt</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">overloaded</span><span class="p">)</span>
		<span class="n">rt_set_overload</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>

	<span class="n">__enable_runtime</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>

	<span class="n">cpupri_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">cpupri</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">highest_prio</span><span class="p">.</span><span class="n">curr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Assumes rq-&gt;lock is held */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rq_offline_rt</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">overloaded</span><span class="p">)</span>
		<span class="n">rt_clear_overload</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>

	<span class="n">__disable_runtime</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>

	<span class="n">cpupri_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">cpupri</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">CPUPRI_INVALID</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When switch from the rt queue, we bring ourselves to a position</span>
<span class="cm"> * that we might want to pull RT tasks from other runqueues.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">switched_from_rt</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * If there are other RT tasks then we will reschedule</span>
<span class="cm">	 * and the scheduling of the other RT tasks will handle</span>
<span class="cm">	 * the balancing. But if we are the last RT task</span>
<span class="cm">	 * we may need to handle the pulling of RT tasks</span>
<span class="cm">	 * now.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">on_rq</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">rt_nr_running</span><span class="p">)</span>
		<span class="n">pull_rt_task</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">init_sched_rt_class</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">zalloc_cpumask_var_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">local_cpu_mask</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span>
					<span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * When switching a task to RT, we may overload the runqueue</span>
<span class="cm"> * with RT tasks. In this case we try to push them off to</span>
<span class="cm"> * other runqueues.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">switched_to_rt</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">check_resched</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we are already running, then there&#39;s nothing</span>
<span class="cm">	 * that needs to be done. But if we are not running</span>
<span class="cm">	 * we may need to preempt the current running task.</span>
<span class="cm">	 * If that current running task is also an RT task</span>
<span class="cm">	 * then see if we can move to another run queue.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">on_rq</span> <span class="o">&amp;&amp;</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span> <span class="o">!=</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">overloaded</span> <span class="o">&amp;&amp;</span> <span class="n">push_rt_task</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="cm">/* Don&#39;t resched if we changed runqueues */</span>
		    <span class="n">rq</span> <span class="o">!=</span> <span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
			<span class="n">check_resched</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>
		<span class="k">if</span> <span class="p">(</span><span class="n">check_resched</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">&lt;</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">)</span>
			<span class="n">resched_task</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Priority of the task has changed. This may cause</span>
<span class="cm"> * us to initiate a push or pull.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">prio_changed_rt</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oldprio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span> <span class="o">==</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
		<span class="cm">/*</span>
<span class="cm">		 * If our priority decreases while running, we</span>
<span class="cm">		 * may need to pull tasks to this runqueue.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">oldprio</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">)</span>
			<span class="n">pull_rt_task</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If there&#39;s a higher priority task waiting to run</span>
<span class="cm">		 * then reschedule. Note, the above pull_rt_task</span>
<span class="cm">		 * can release the rq lock and p could migrate.</span>
<span class="cm">		 * Only reschedule if p is still on the same runqueue.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">&gt;</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">highest_prio</span><span class="p">.</span><span class="n">curr</span> <span class="o">&amp;&amp;</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span> <span class="o">==</span> <span class="n">p</span><span class="p">)</span>
			<span class="n">resched_task</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="cp">#else</span>
		<span class="cm">/* For UP simply resched on drop of prio */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">oldprio</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">)</span>
			<span class="n">resched_task</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This task is not running, but if it is</span>
<span class="cm">		 * greater than the current running task</span>
<span class="cm">		 * then reschedule.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">&lt;</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">)</span>
			<span class="n">resched_task</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">watchdog</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">soft</span><span class="p">,</span> <span class="n">hard</span><span class="p">;</span>

	<span class="cm">/* max may change after cur was read, this will be fixed next tick */</span>
	<span class="n">soft</span> <span class="o">=</span> <span class="n">task_rlimit</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">RLIMIT_RTTIME</span><span class="p">);</span>
	<span class="n">hard</span> <span class="o">=</span> <span class="n">task_rlimit_max</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">RLIMIT_RTTIME</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">soft</span> <span class="o">!=</span> <span class="n">RLIM_INFINITY</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next</span><span class="p">;</span>

		<span class="n">p</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">timeout</span><span class="o">++</span><span class="p">;</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">soft</span><span class="p">,</span> <span class="n">hard</span><span class="p">),</span> <span class="n">USEC_PER_SEC</span><span class="o">/</span><span class="n">HZ</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">timeout</span> <span class="o">&gt;</span> <span class="n">next</span><span class="p">)</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">cputime_expires</span><span class="p">.</span><span class="n">sched_exp</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">sum_exec_runtime</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">task_tick_rt</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">queued</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">;</span>

	<span class="n">update_curr_rt</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>

	<span class="n">watchdog</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * RR tasks need a special form of timeslice management.</span>
<span class="cm">	 * FIFO tasks have no timeslices.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">!=</span> <span class="n">SCHED_RR</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">time_slice</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">time_slice</span> <span class="o">=</span> <span class="n">RR_TIMESLICE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Requeue to the end of queue if we (and all of our ancestors) are the</span>
<span class="cm">	 * only element on the queue</span>
<span class="cm">	 */</span>
	<span class="n">for_each_sched_rt_entity</span><span class="p">(</span><span class="n">rt_se</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rt_se</span><span class="o">-&gt;</span><span class="n">run_list</span><span class="p">.</span><span class="n">prev</span> <span class="o">!=</span> <span class="n">rt_se</span><span class="o">-&gt;</span><span class="n">run_list</span><span class="p">.</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">requeue_task_rt</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">set_tsk_need_resched</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_curr_task_rt</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">;</span>

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">exec_start</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">clock_task</span><span class="p">;</span>

	<span class="cm">/* The running task is never eligible for pushing */</span>
	<span class="n">dequeue_pushable_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">get_rr_interval_rt</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Time slice is 0 for SCHED_FIFO tasks</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">==</span> <span class="n">SCHED_RR</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">RR_TIMESLICE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">sched_class</span> <span class="n">rt_sched_class</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">next</span>			<span class="o">=</span> <span class="o">&amp;</span><span class="n">fair_sched_class</span><span class="p">,</span>
	<span class="p">.</span><span class="n">enqueue_task</span>		<span class="o">=</span> <span class="n">enqueue_task_rt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dequeue_task</span>		<span class="o">=</span> <span class="n">dequeue_task_rt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">yield_task</span>		<span class="o">=</span> <span class="n">yield_task_rt</span><span class="p">,</span>

	<span class="p">.</span><span class="n">check_preempt_curr</span>	<span class="o">=</span> <span class="n">check_preempt_curr_rt</span><span class="p">,</span>

	<span class="p">.</span><span class="n">pick_next_task</span>		<span class="o">=</span> <span class="n">pick_next_task_rt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">put_prev_task</span>		<span class="o">=</span> <span class="n">put_prev_task_rt</span><span class="p">,</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="p">.</span><span class="n">select_task_rq</span>		<span class="o">=</span> <span class="n">select_task_rq_rt</span><span class="p">,</span>

	<span class="p">.</span><span class="n">set_cpus_allowed</span>       <span class="o">=</span> <span class="n">set_cpus_allowed_rt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rq_online</span>              <span class="o">=</span> <span class="n">rq_online_rt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rq_offline</span>             <span class="o">=</span> <span class="n">rq_offline_rt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pre_schedule</span>		<span class="o">=</span> <span class="n">pre_schedule_rt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">post_schedule</span>		<span class="o">=</span> <span class="n">post_schedule_rt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">task_woken</span>		<span class="o">=</span> <span class="n">task_woken_rt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">switched_from</span>		<span class="o">=</span> <span class="n">switched_from_rt</span><span class="p">,</span>
<span class="cp">#endif</span>

	<span class="p">.</span><span class="n">set_curr_task</span>          <span class="o">=</span> <span class="n">set_curr_task_rt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">task_tick</span>		<span class="o">=</span> <span class="n">task_tick_rt</span><span class="p">,</span>

	<span class="p">.</span><span class="n">get_rr_interval</span>	<span class="o">=</span> <span class="n">get_rr_interval_rt</span><span class="p">,</span>

	<span class="p">.</span><span class="n">prio_changed</span>		<span class="o">=</span> <span class="n">prio_changed_rt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">switched_to</span>		<span class="o">=</span> <span class="n">switched_to_rt</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_SCHED_DEBUG</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">print_rt_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">print_rt_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rt_rq_iter_t</span> <span class="n">iter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">for_each_rt_rq</span><span class="p">(</span><span class="n">rt_rq</span><span class="p">,</span> <span class="n">iter</span><span class="p">,</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
		<span class="n">print_rt_rq</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">rt_rq</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SCHED_DEBUG */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
