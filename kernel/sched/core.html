<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › sched › core.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>core.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  kernel/sched/core.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Kernel scheduler and related syscalls</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1991-2002  Linus Torvalds</span>
<span class="cm"> *</span>
<span class="cm"> *  1996-12-23  Modified by Dave Grothe to fix bugs in semaphores and</span>
<span class="cm"> *		make semaphores SMP safe</span>
<span class="cm"> *  1998-11-19	Implemented schedule_timeout() and related stuff</span>
<span class="cm"> *		by Andrea Arcangeli</span>
<span class="cm"> *  2002-01-04	New ultra-scalable O(1) scheduler by Ingo Molnar:</span>
<span class="cm"> *		hybrid priority-list and round-robin design with</span>
<span class="cm"> *		an array-switch method of distributing timeslices</span>
<span class="cm"> *		and per-CPU runqueues.  Cleanups and useful suggestions</span>
<span class="cm"> *		by Davide Libenzi, preemptible kernel bits by Robert Love.</span>
<span class="cm"> *  2003-09-03	Interactivity tuning by Con Kolivas.</span>
<span class="cm"> *  2004-04-02	Scheduler domains code by Nick Piggin</span>
<span class="cm"> *  2007-04-15  Work begun on replacing all interactivity tuning with a</span>
<span class="cm"> *              fair scheduling design by Con Kolivas.</span>
<span class="cm"> *  2007-05-05  Load balancing (smp-nice) and other improvements</span>
<span class="cm"> *              by Peter Williams</span>
<span class="cm"> *  2007-05-06  Interactivity improvements to CFS by Mike Galbraith</span>
<span class="cm"> *  2007-07-01  Group scheduling enhancements by Srivatsa Vaddagiri</span>
<span class="cm"> *  2007-11-29  RT balancing improvements by Steven Rostedt, Gregory Haskins,</span>
<span class="cm"> *              Thomas Gleixner, Mike Kravetz</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/nmi.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;asm/mmu_context.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/kernel_stat.h&gt;</span>
<span class="cp">#include &lt;linux/debug_locks.h&gt;</span>
<span class="cp">#include &lt;linux/perf_event.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/profile.h&gt;</span>
<span class="cp">#include &lt;linux/freezer.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/pid_namespace.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/threads.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/cpuset.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/sysctl.h&gt;</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/times.h&gt;</span>
<span class="cp">#include &lt;linux/tsacct_kern.h&gt;</span>
<span class="cp">#include &lt;linux/kprobes.h&gt;</span>
<span class="cp">#include &lt;linux/delayacct.h&gt;</span>
<span class="cp">#include &lt;linux/unistd.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/hrtimer.h&gt;</span>
<span class="cp">#include &lt;linux/tick.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/ftrace.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/init_task.h&gt;</span>
<span class="cp">#include &lt;linux/binfmts.h&gt;</span>

<span class="cp">#include &lt;asm/switch_to.h&gt;</span>
<span class="cp">#include &lt;asm/tlb.h&gt;</span>
<span class="cp">#include &lt;asm/irq_regs.h&gt;</span>
<span class="cp">#include &lt;asm/mutex.h&gt;</span>
<span class="cp">#ifdef CONFIG_PARAVIRT</span>
<span class="cp">#include &lt;asm/paravirt.h&gt;</span>
<span class="cp">#endif</span>

<span class="cp">#include &quot;sched.h&quot;</span>
<span class="cp">#include &quot;../workqueue_sched.h&quot;</span>
<span class="cp">#include &quot;../smpboot.h&quot;</span>

<span class="cp">#define CREATE_TRACE_POINTS</span>
<span class="cp">#include &lt;trace/events/sched.h&gt;</span>

<span class="kt">void</span> <span class="nf">start_bandwidth_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">period_timer</span><span class="p">,</span> <span class="n">ktime_t</span> <span class="n">period</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delta</span><span class="p">;</span>
	<span class="n">ktime_t</span> <span class="n">soft</span><span class="p">,</span> <span class="n">hard</span><span class="p">,</span> <span class="n">now</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hrtimer_active</span><span class="p">(</span><span class="n">period_timer</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">now</span> <span class="o">=</span> <span class="n">hrtimer_cb_get_time</span><span class="p">(</span><span class="n">period_timer</span><span class="p">);</span>
		<span class="n">hrtimer_forward</span><span class="p">(</span><span class="n">period_timer</span><span class="p">,</span> <span class="n">now</span><span class="p">,</span> <span class="n">period</span><span class="p">);</span>

		<span class="n">soft</span> <span class="o">=</span> <span class="n">hrtimer_get_softexpires</span><span class="p">(</span><span class="n">period_timer</span><span class="p">);</span>
		<span class="n">hard</span> <span class="o">=</span> <span class="n">hrtimer_get_expires</span><span class="p">(</span><span class="n">period_timer</span><span class="p">);</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">ktime_sub</span><span class="p">(</span><span class="n">hard</span><span class="p">,</span> <span class="n">soft</span><span class="p">));</span>
		<span class="n">__hrtimer_start_range_ns</span><span class="p">(</span><span class="n">period_timer</span><span class="p">,</span> <span class="n">soft</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span>
					 <span class="n">HRTIMER_MODE_ABS_PINNED</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">sched_domains_mutex</span><span class="p">);</span>
<span class="n">DEFINE_PER_CPU_SHARED_ALIGNED</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span><span class="p">,</span> <span class="n">runqueues</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">update_rq_clock_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="n">s64</span> <span class="n">delta</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">update_rq_clock</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s64</span> <span class="n">delta</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">skip_clock_update</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">delta</span> <span class="o">=</span> <span class="n">sched_clock_cpu</span><span class="p">(</span><span class="n">cpu_of</span><span class="p">(</span><span class="n">rq</span><span class="p">))</span> <span class="o">-</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">;</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">clock</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
	<span class="n">update_rq_clock_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Debugging: various feature bits</span>
<span class="cm"> */</span>

<span class="cp">#define SCHED_FEAT(name, enabled)	\</span>
<span class="cp">	(1UL &lt;&lt; __SCHED_FEAT_##name) * enabled |</span>

<span class="n">const_debug</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_sched_features</span> <span class="o">=</span>
<span class="cp">#include &quot;features.h&quot;</span>
	<span class="mi">0</span><span class="p">;</span>

<span class="cp">#undef SCHED_FEAT</span>

<span class="cp">#ifdef CONFIG_SCHED_DEBUG</span>
<span class="cp">#define SCHED_FEAT(name, enabled)	\</span>
<span class="cp">	#name ,</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">sched_feat_names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="cp">#include &quot;features.h&quot;</span>
<span class="p">};</span>

<span class="cp">#undef SCHED_FEAT</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sched_feat_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">__SCHED_FEAT_NR</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sysctl_sched_features</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">)))</span>
			<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;NO_&quot;</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%s &quot;</span><span class="p">,</span> <span class="n">sched_feat_names</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef HAVE_JUMP_LABEL</span>

<span class="cp">#define jump_label_key__true  STATIC_KEY_INIT_TRUE</span>
<span class="cp">#define jump_label_key__false STATIC_KEY_INIT_FALSE</span>

<span class="cp">#define SCHED_FEAT(name, enabled)	\</span>
<span class="cp">	jump_label_key__##enabled ,</span>

<span class="k">struct</span> <span class="n">static_key</span> <span class="n">sched_feat_keys</span><span class="p">[</span><span class="n">__SCHED_FEAT_NR</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
<span class="cp">#include &quot;features.h&quot;</span>
<span class="p">};</span>

<span class="cp">#undef SCHED_FEAT</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sched_feat_disable</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">static_key_enabled</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sched_feat_keys</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
		<span class="n">static_key_slow_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sched_feat_keys</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sched_feat_enable</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">static_key_enabled</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sched_feat_keys</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
		<span class="n">static_key_slow_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sched_feat_keys</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sched_feat_disable</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="p">};</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sched_feat_enable</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="p">};</span>
<span class="cp">#endif </span><span class="cm">/* HAVE_JUMP_LABEL */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">sched_feat_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">cmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">neg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">63</span><span class="p">)</span>
		<span class="n">cnt</span> <span class="o">=</span> <span class="mi">63</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">buf</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cmp</span> <span class="o">=</span> <span class="n">strstrip</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">cmp</span><span class="p">,</span> <span class="s">&quot;NO_&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">neg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">cmp</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">__SCHED_FEAT_NR</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">cmp</span><span class="p">,</span> <span class="n">sched_feat_names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">neg</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sysctl_sched_features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">);</span>
				<span class="n">sched_feat_disable</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">sysctl_sched_features</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">);</span>
				<span class="n">sched_feat_enable</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">__SCHED_FEAT_NR</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="o">*</span><span class="n">ppos</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sched_feat_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">sched_feat_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">sched_feat_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">sched_feat_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">sched_feat_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">sched_init_debug</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debugfs_create_file</span><span class="p">(</span><span class="s">&quot;sched_features&quot;</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">sched_feat_fops</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">late_initcall</span><span class="p">(</span><span class="n">sched_init_debug</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SCHED_DEBUG */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Number of tasks to iterate in a single balance run.</span>
<span class="cm"> * Limited because this is done with IRQs disabled.</span>
<span class="cm"> */</span>
<span class="n">const_debug</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_sched_nr_migrate</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * period over which we average the RT time consumption, measured</span>
<span class="cm"> * in ms.</span>
<span class="cm"> *</span>
<span class="cm"> * default: 1s</span>
<span class="cm"> */</span>
<span class="n">const_debug</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_sched_time_avg</span> <span class="o">=</span> <span class="n">MSEC_PER_SEC</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * period over which we measure -rt task cpu usage in us.</span>
<span class="cm"> * default: 1s</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_sched_rt_period</span> <span class="o">=</span> <span class="mi">1000000</span><span class="p">;</span>

<span class="n">__read_mostly</span> <span class="kt">int</span> <span class="n">scheduler_running</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * part of the period that we allow rt tasks to run in us.</span>
<span class="cm"> * default: 0.95s</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">sysctl_sched_rt_runtime</span> <span class="o">=</span> <span class="mi">950000</span><span class="p">;</span>



<span class="cm">/*</span>
<span class="cm"> * __task_rq_lock - lock the rq @p resides on.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="nf">__task_rq_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
	<span class="n">__acquires</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>

	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">rq</span> <span class="o">=</span> <span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">rq</span> <span class="o">==</span> <span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">rq</span><span class="p">;</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * task_rq_lock - lock p-&gt;pi_lock and lock the rq @p resides on.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="nf">task_rq_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
	<span class="n">__acquires</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">)</span>
	<span class="n">__acquires</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="o">*</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">rq</span> <span class="o">=</span> <span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">rq</span> <span class="o">==</span> <span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">rq</span><span class="p">;</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="o">*</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__task_rq_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">task_rq_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="o">*</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this_rq_lock - lock this runqueue and disable interrupts.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="nf">this_rq_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
	<span class="n">__acquires</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>

	<span class="n">local_irq_disable</span><span class="p">();</span>
	<span class="n">rq</span> <span class="o">=</span> <span class="n">this_rq</span><span class="p">();</span>
	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rq</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SCHED_HRTICK</span>
<span class="cm">/*</span>
<span class="cm"> * Use HR-timers to deliver accurate preemption points.</span>
<span class="cm"> *</span>
<span class="cm"> * Its all a bit involved since we cannot program an hrt while holding the</span>
<span class="cm"> * rq-&gt;lock. So what we do is store a state in in rq-&gt;hrtick_* and ask for a</span>
<span class="cm"> * reschedule event.</span>
<span class="cm"> *</span>
<span class="cm"> * When we get rescheduled we reprogram the hrtick_timer outside of the</span>
<span class="cm"> * rq-&gt;lock.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hrtick_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hrtimer_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">hrtick_timer</span><span class="p">))</span>
		<span class="n">hrtimer_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">hrtick_timer</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * High-resolution timer tick.</span>
<span class="cm"> * Runs from hardirq context with interrupts disabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">hrtimer_restart</span> <span class="nf">hrtick</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rq</span><span class="p">,</span> <span class="n">hrtick_timer</span><span class="p">);</span>

	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">cpu_of</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">!=</span> <span class="n">smp_processor_id</span><span class="p">());</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">task_tick</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">HRTIMER_NORESTART</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cm">/*</span>
<span class="cm"> * called from hardirq (IPI) context</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__hrtick_start</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">hrtimer_restart</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">hrtick_timer</span><span class="p">);</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">hrtick_csd_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called to set the hrtick timer state.</span>
<span class="cm"> *</span>
<span class="cm"> * called with rq-&gt;lock held and irqs disabled</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">hrtick_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="n">u64</span> <span class="n">delay</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">hrtick_timer</span><span class="p">;</span>
	<span class="n">ktime_t</span> <span class="n">time</span> <span class="o">=</span> <span class="n">ktime_add_ns</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">get_time</span><span class="p">(),</span> <span class="n">delay</span><span class="p">);</span>

	<span class="n">hrtimer_set_expires</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">time</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span> <span class="o">==</span> <span class="n">this_rq</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">hrtimer_restart</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">hrtick_csd_pending</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__smp_call_function_single</span><span class="p">(</span><span class="n">cpu_of</span><span class="p">(</span><span class="n">rq</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">hrtick_csd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">hrtick_csd_pending</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">hotplug_hrtick</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nfb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="kt">long</span><span class="p">)</span><span class="n">hcpu</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_UP_CANCELED</span>:
	<span class="k">case</span> <span class="n">CPU_UP_CANCELED_FROZEN</span>:
	<span class="k">case</span> <span class="n">CPU_DOWN_PREPARE</span>:
	<span class="k">case</span> <span class="n">CPU_DOWN_PREPARE_FROZEN</span>:
	<span class="k">case</span> <span class="n">CPU_DEAD</span>:
	<span class="k">case</span> <span class="n">CPU_DEAD_FROZEN</span>:
		<span class="n">hrtick_clear</span><span class="p">(</span><span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">void</span> <span class="nf">init_hrtick</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hotcpu_notifier</span><span class="p">(</span><span class="n">hotplug_hrtick</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cm">/*</span>
<span class="cm"> * Called to set the hrtick timer state.</span>
<span class="cm"> *</span>
<span class="cm"> * called with rq-&gt;lock held and irqs disabled</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">hrtick_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="n">u64</span> <span class="n">delay</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__hrtimer_start_range_ns</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">hrtick_timer</span><span class="p">,</span> <span class="n">ns_to_ktime</span><span class="p">(</span><span class="n">delay</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">HRTIMER_MODE_REL_PINNED</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">init_hrtick</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_rq_hrtick</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">hrtick_csd_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">hrtick_csd</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">hrtick_csd</span><span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">__hrtick_start</span><span class="p">;</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">hrtick_csd</span><span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">rq</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">hrtimer_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">hrtick_timer</span><span class="p">,</span> <span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="n">HRTIMER_MODE_REL</span><span class="p">);</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">hrtick_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">hrtick</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else	</span><span class="cm">/* CONFIG_SCHED_HRTICK */</span><span class="cp"></span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hrtick_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">init_rq_hrtick</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">init_hrtick</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_SCHED_HRTICK */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * resched_task - mark a task &#39;to be rescheduled now&#39;.</span>
<span class="cm"> *</span>
<span class="cm"> * On UP this means the setting of the need_resched flag, on SMP it</span>
<span class="cm"> * might also involve a cross-CPU call to trigger the scheduler on</span>
<span class="cm"> * the target CPU.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_SMP</span>

<span class="cp">#ifndef tsk_is_polling</span>
<span class="cp">#define tsk_is_polling(t) test_tsk_thread_flag(t, TIF_POLLING_NRFLAG)</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="nf">resched_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">assert_raw_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_tsk_need_resched</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">set_tsk_need_resched</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">smp_processor_id</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* NEED_RESCHED must be visible before we test polling */</span>
	<span class="n">smp_mb</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tsk_is_polling</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
		<span class="n">smp_send_reschedule</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">resched_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">raw_spin_trylock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">resched_task</span><span class="p">(</span><span class="n">cpu_curr</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NO_HZ</span>
<span class="cm">/*</span>
<span class="cm"> * In the semi idle case, use the nearest busy cpu for migrating timers</span>
<span class="cm"> * from an idle cpu.  This is good for power-savings.</span>
<span class="cm"> *</span>
<span class="cm"> * We don&#39;t do similar optimization for completely idle system, as</span>
<span class="cm"> * selecting an idle cpu will add more delays to the timers than intended</span>
<span class="cm"> * (as that cpu&#39;s timer base may not be uptodate wrt jiffies etc).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">get_nohz_timer_target</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">for_each_domain</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">sd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">sched_domain_span</span><span class="p">(</span><span class="n">sd</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">idle_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">cpu</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">unlock:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">cpu</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * When add_timer_on() enqueues a timer into the timer wheel of an</span>
<span class="cm"> * idle CPU then this timer might expire before the next timer event</span>
<span class="cm"> * which is scheduled to wake up that CPU. In case of a completely</span>
<span class="cm"> * idle system the next event might even be infinite time into the</span>
<span class="cm"> * future. wake_up_idle_cpu() ensures that the CPU is woken up and</span>
<span class="cm"> * leaves the inner idle loop so the newly added timer is taken into</span>
<span class="cm"> * account when the CPU goes back to idle and evaluates the timer</span>
<span class="cm"> * wheel for the next timer event.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">wake_up_idle_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">smp_processor_id</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is safe, as this function is called with the timer</span>
<span class="cm">	 * wheel base lock of (cpu) held. When the CPU is on the way</span>
<span class="cm">	 * to idle and has not yet set rq-&gt;curr to idle then it will</span>
<span class="cm">	 * be serialized on the timer wheel base lock and take the new</span>
<span class="cm">	 * timer into account automatically.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span> <span class="o">!=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">idle</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We can set TIF_RESCHED on the idle task of the other CPU</span>
<span class="cm">	 * lockless. The worst case is that the other CPU runs the</span>
<span class="cm">	 * idle task through an additional NOOP schedule()</span>
<span class="cm">	 */</span>
	<span class="n">set_tsk_need_resched</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">idle</span><span class="p">);</span>

	<span class="cm">/* NEED_RESCHED must be visible before we test polling */</span>
	<span class="n">smp_mb</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tsk_is_polling</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">idle</span><span class="p">))</span>
		<span class="n">smp_send_reschedule</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">got_nohz_idle_kick</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">idle_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">NOHZ_BALANCE_KICK</span><span class="p">,</span> <span class="n">nohz_flags</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_NO_HZ */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">got_nohz_idle_kick</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_NO_HZ */</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">sched_avg_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s64</span> <span class="n">period</span> <span class="o">=</span> <span class="n">sched_avg_period</span><span class="p">();</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">s64</span><span class="p">)(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">clock</span> <span class="o">-</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">age_stamp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">period</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Inline assembly required to prevent the compiler</span>
<span class="cm">		 * optimising this loop into a divmod call.</span>
<span class="cm">		 * See __iter_div_u64_rem() for another example of this.</span>
<span class="cm">		 */</span>
		<span class="n">asm</span><span class="p">(</span><span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;+rm&quot;</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">age_stamp</span><span class="p">));</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">age_stamp</span> <span class="o">+=</span> <span class="n">period</span><span class="p">;</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt_avg</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* !CONFIG_SMP */</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">resched_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">assert_raw_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">set_tsk_need_resched</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="cp">#if defined(CONFIG_RT_GROUP_SCHED) || (defined(CONFIG_FAIR_GROUP_SCHED) &amp;&amp; \</span>
<span class="cp">			(defined(CONFIG_SMP) || defined(CONFIG_CFS_BANDWIDTH)))</span>
<span class="cm">/*</span>
<span class="cm"> * Iterate task_group tree rooted at *from, calling @down when first entering a</span>
<span class="cm"> * node and @up when leaving it for the final time.</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must hold rcu_lock or sufficient equivalent.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">walk_tg_tree_from</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span>
			     <span class="n">tg_visitor</span> <span class="n">down</span><span class="p">,</span> <span class="n">tg_visitor</span> <span class="n">up</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">parent</span> <span class="o">=</span> <span class="n">from</span><span class="p">;</span>

<span class="nl">down:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">down</span><span class="p">)(</span><span class="n">parent</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">,</span> <span class="n">siblings</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="n">child</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">down</span><span class="p">;</span>

<span class="nl">up:</span>
		<span class="k">continue</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">up</span><span class="p">)(</span><span class="n">parent</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">||</span> <span class="n">parent</span> <span class="o">==</span> <span class="n">from</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">child</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
	<span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">up</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">tg_nop</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_load_weight</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">prio</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">static_prio</span> <span class="o">-</span> <span class="n">MAX_RT_PRIO</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">load_weight</span> <span class="o">*</span><span class="n">load</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">load</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * SCHED_IDLE tasks get minimal weight:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">==</span> <span class="n">SCHED_IDLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">load</span><span class="o">-&gt;</span><span class="n">weight</span> <span class="o">=</span> <span class="n">scale_load</span><span class="p">(</span><span class="n">WEIGHT_IDLEPRIO</span><span class="p">);</span>
		<span class="n">load</span><span class="o">-&gt;</span><span class="n">inv_weight</span> <span class="o">=</span> <span class="n">WMULT_IDLEPRIO</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">load</span><span class="o">-&gt;</span><span class="n">weight</span> <span class="o">=</span> <span class="n">scale_load</span><span class="p">(</span><span class="n">prio_to_weight</span><span class="p">[</span><span class="n">prio</span><span class="p">]);</span>
	<span class="n">load</span><span class="o">-&gt;</span><span class="n">inv_weight</span> <span class="o">=</span> <span class="n">prio_to_wmult</span><span class="p">[</span><span class="n">prio</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enqueue_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="n">sched_info_queued</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">enqueue_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dequeue_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="n">sched_info_dequeued</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">dequeue_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">activate_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task_contributes_to_load</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_uninterruptible</span><span class="o">--</span><span class="p">;</span>

	<span class="n">enqueue_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">deactivate_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task_contributes_to_load</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_uninterruptible</span><span class="o">++</span><span class="p">;</span>

	<span class="n">dequeue_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_IRQ_TIME_ACCOUNTING</span>

<span class="cm">/*</span>
<span class="cm"> * There are no locks covering percpu hardirq/softirq time.</span>
<span class="cm"> * They are only modified in account_system_vtime, on corresponding CPU</span>
<span class="cm"> * with interrupts disabled. So, writes are safe.</span>
<span class="cm"> * They are read and saved off onto struct rq in update_rq_clock().</span>
<span class="cm"> * This may result in other CPU reading this CPU&#39;s irq time and can</span>
<span class="cm"> * race with irq/account_system_vtime on this CPU. We would either get old</span>
<span class="cm"> * or new value with a side effect of accounting a slice of irq time to wrong</span>
<span class="cm"> * task when irq is in progress while we read rq-&gt;clock. That is a worthy</span>
<span class="cm"> * compromise in place of having locks on each irq in account_system_time.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="n">cpu_hardirq_time</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="n">cpu_softirq_time</span><span class="p">);</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="n">irq_start_time</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sched_clock_irqtime</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">enable_sched_clock_irqtime</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sched_clock_irqtime</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">disable_sched_clock_irqtime</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sched_clock_irqtime</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifndef CONFIG_64BIT</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">seqcount_t</span><span class="p">,</span> <span class="n">irq_time_seq</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">irq_time_write_begin</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__this_cpu_inc</span><span class="p">(</span><span class="n">irq_time_seq</span><span class="p">.</span><span class="n">sequence</span><span class="p">);</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">irq_time_write_end</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">__this_cpu_inc</span><span class="p">(</span><span class="n">irq_time_seq</span><span class="p">.</span><span class="n">sequence</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">irq_time_read</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">irq_time</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">seq</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">seq</span> <span class="o">=</span> <span class="n">read_seqcount_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">irq_time_seq</span><span class="p">,</span> <span class="n">cpu</span><span class="p">));</span>
		<span class="n">irq_time</span> <span class="o">=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_softirq_time</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">+</span>
			   <span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_hardirq_time</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">read_seqcount_retry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">irq_time_seq</span><span class="p">,</span> <span class="n">cpu</span><span class="p">),</span> <span class="n">seq</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">irq_time</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_64BIT */</span><span class="cp"></span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">irq_time_write_begin</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">irq_time_write_end</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">irq_time_read</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_softirq_time</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">+</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_hardirq_time</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_64BIT */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Called before incrementing preempt_count on {soft,}irq_enter</span>
<span class="cm"> * and before decrementing preempt_count on {soft,}irq_exit.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">account_system_vtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">delta</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sched_clock_irqtime</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="n">delta</span> <span class="o">=</span> <span class="n">sched_clock_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">-</span> <span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">irq_start_time</span><span class="p">);</span>
	<span class="n">__this_cpu_add</span><span class="p">(</span><span class="n">irq_start_time</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>

	<span class="n">irq_time_write_begin</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * We do not account for softirq time from ksoftirqd here.</span>
<span class="cm">	 * We want to continue accounting softirq time to ksoftirqd thread</span>
<span class="cm">	 * in that case, so as not to confuse scheduler with a special task</span>
<span class="cm">	 * that do not consume any time, but still wants to run.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hardirq_count</span><span class="p">())</span>
		<span class="n">__this_cpu_add</span><span class="p">(</span><span class="n">cpu_hardirq_time</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">in_serving_softirq</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">curr</span> <span class="o">!=</span> <span class="n">this_cpu_ksoftirqd</span><span class="p">())</span>
		<span class="n">__this_cpu_add</span><span class="p">(</span><span class="n">cpu_softirq_time</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>

	<span class="n">irq_time_write_end</span><span class="p">();</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">account_system_vtime</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_IRQ_TIME_ACCOUNTING */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_PARAVIRT</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">steal_ticks</span><span class="p">(</span><span class="n">u64</span> <span class="n">steal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">steal</span> <span class="o">&gt;</span> <span class="n">NSEC_PER_SEC</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">div_u64</span><span class="p">(</span><span class="n">steal</span><span class="p">,</span> <span class="n">TICK_NSEC</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">__iter_div_u64_rem</span><span class="p">(</span><span class="n">steal</span><span class="p">,</span> <span class="n">TICK_NSEC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">steal</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_rq_clock_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="n">s64</span> <span class="n">delta</span><span class="p">)</span>
<span class="p">{</span>
<span class="cm">/*</span>
<span class="cm"> * In theory, the compile should just see 0 here, and optimize out the call</span>
<span class="cm"> * to sched_rt_avg_update. But I don&#39;t trust it...</span>
<span class="cm"> */</span>
<span class="cp">#if defined(CONFIG_IRQ_TIME_ACCOUNTING) || defined(CONFIG_PARAVIRT_TIME_ACCOUNTING)</span>
	<span class="n">s64</span> <span class="n">steal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">irq_delta</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_IRQ_TIME_ACCOUNTING</span>
	<span class="n">irq_delta</span> <span class="o">=</span> <span class="n">irq_time_read</span><span class="p">(</span><span class="n">cpu_of</span><span class="p">(</span><span class="n">rq</span><span class="p">))</span> <span class="o">-</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">prev_irq_time</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since irq_time is only updated on {soft,}irq_exit, we might run into</span>
<span class="cm">	 * this case when a previous update_rq_clock() happened inside a</span>
<span class="cm">	 * {soft,}irq region.</span>
<span class="cm">	 *</span>
<span class="cm">	 * When this happens, we stop -&gt;clock_task and only update the</span>
<span class="cm">	 * prev_irq_time stamp to account for the part that fit, so that a next</span>
<span class="cm">	 * update will consume the rest. This ensures -&gt;clock_task is</span>
<span class="cm">	 * monotonic.</span>
<span class="cm">	 *</span>
<span class="cm">	 * It does however cause some slight miss-attribution of {soft,}irq</span>
<span class="cm">	 * time, a more accurate solution would be to update the irq_time using</span>
<span class="cm">	 * the current rq-&gt;clock timestamp, except that would require using</span>
<span class="cm">	 * atomic ops.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq_delta</span> <span class="o">&gt;</span> <span class="n">delta</span><span class="p">)</span>
		<span class="n">irq_delta</span> <span class="o">=</span> <span class="n">delta</span><span class="p">;</span>

	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">prev_irq_time</span> <span class="o">+=</span> <span class="n">irq_delta</span><span class="p">;</span>
	<span class="n">delta</span> <span class="o">-=</span> <span class="n">irq_delta</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_PARAVIRT_TIME_ACCOUNTING</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">static_key_false</span><span class="p">((</span><span class="o">&amp;</span><span class="n">paravirt_steal_rq_enabled</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">st</span><span class="p">;</span>

		<span class="n">steal</span> <span class="o">=</span> <span class="n">paravirt_steal_clock</span><span class="p">(</span><span class="n">cpu_of</span><span class="p">(</span><span class="n">rq</span><span class="p">));</span>
		<span class="n">steal</span> <span class="o">-=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">prev_steal_time_rq</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">steal</span> <span class="o">&gt;</span> <span class="n">delta</span><span class="p">))</span>
			<span class="n">steal</span> <span class="o">=</span> <span class="n">delta</span><span class="p">;</span>

		<span class="n">st</span> <span class="o">=</span> <span class="n">steal_ticks</span><span class="p">(</span><span class="n">steal</span><span class="p">);</span>
		<span class="n">steal</span> <span class="o">=</span> <span class="n">st</span> <span class="o">*</span> <span class="n">TICK_NSEC</span><span class="p">;</span>

		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">prev_steal_time_rq</span> <span class="o">+=</span> <span class="n">steal</span><span class="p">;</span>

		<span class="n">delta</span> <span class="o">-=</span> <span class="n">steal</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">clock_task</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>

<span class="cp">#if defined(CONFIG_IRQ_TIME_ACCOUNTING) || defined(CONFIG_PARAVIRT_TIME_ACCOUNTING)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">irq_delta</span> <span class="o">+</span> <span class="n">steal</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">sched_feat</span><span class="p">(</span><span class="n">NONTASK_POWER</span><span class="p">))</span>
		<span class="n">sched_rt_avg_update</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">irq_delta</span> <span class="o">+</span> <span class="n">steal</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_IRQ_TIME_ACCOUNTING</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irqtime_account_hi_update</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">cpustat</span> <span class="o">=</span> <span class="n">kcpustat_this_cpu</span><span class="o">-&gt;</span><span class="n">cpustat</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">latest_ns</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">latest_ns</span> <span class="o">=</span> <span class="n">this_cpu_read</span><span class="p">(</span><span class="n">cpu_hardirq_time</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nsecs_to_cputime64</span><span class="p">(</span><span class="n">latest_ns</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">cpustat</span><span class="p">[</span><span class="n">CPUTIME_IRQ</span><span class="p">])</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">irqtime_account_si_update</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">cpustat</span> <span class="o">=</span> <span class="n">kcpustat_this_cpu</span><span class="o">-&gt;</span><span class="n">cpustat</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">latest_ns</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">latest_ns</span> <span class="o">=</span> <span class="n">this_cpu_read</span><span class="p">(</span><span class="n">cpu_softirq_time</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nsecs_to_cputime64</span><span class="p">(</span><span class="n">latest_ns</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">cpustat</span><span class="p">[</span><span class="n">CPUTIME_SOFTIRQ</span><span class="p">])</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_IRQ_TIME_ACCOUNTING */</span><span class="cp"></span>

<span class="cp">#define sched_clock_irqtime	(0)</span>

<span class="cp">#endif</span>

<span class="kt">void</span> <span class="nf">sched_set_stop_task</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_param</span> <span class="n">param</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">sched_priority</span> <span class="o">=</span> <span class="n">MAX_RT_PRIO</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">};</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">old_stop</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Make it appear like a SCHED_FIFO task, its something</span>
<span class="cm">		 * userspace knows about and won&#39;t get confused about.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Also, it will make PI more or less work without too</span>
<span class="cm">		 * much confusion -- but then, stop work should not</span>
<span class="cm">		 * rely on PI working anyway.</span>
<span class="cm">		 */</span>
		<span class="n">sched_setscheduler_nocheck</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="n">SCHED_FIFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">);</span>

		<span class="n">stop</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">stop_sched_class</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">stop</span> <span class="o">=</span> <span class="n">stop</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">old_stop</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Reset it back to a normal scheduling class so that</span>
<span class="cm">		 * it can die in pieces.</span>
<span class="cm">		 */</span>
		<span class="n">old_stop</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rt_sched_class</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * __normal_prio - return the priority that is based on the static prio</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__normal_prio</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">static_prio</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Calculate the expected normal priority: i.e. priority</span>
<span class="cm"> * without taking RT-inheritance into account. Might be</span>
<span class="cm"> * boosted by interactivity modifiers. Changes upon fork,</span>
<span class="cm"> * setprio syscalls, and whenever the interactivity</span>
<span class="cm"> * estimator recalculates.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">normal_prio</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">prio</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task_has_rt_policy</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
		<span class="n">prio</span> <span class="o">=</span> <span class="n">MAX_RT_PRIO</span><span class="o">-</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rt_priority</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">prio</span> <span class="o">=</span> <span class="n">__normal_prio</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">prio</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Calculate the current priority, i.e. the priority</span>
<span class="cm"> * taken into account by the scheduler. This value might</span>
<span class="cm"> * be boosted by RT tasks, or might be boosted by</span>
<span class="cm"> * interactivity modifiers. Will be RT if the task got</span>
<span class="cm"> * RT-boosted. If not then it returns p-&gt;normal_prio.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">effective_prio</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">normal_prio</span> <span class="o">=</span> <span class="n">normal_prio</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we are RT tasks or we were boosted to RT priority,</span>
<span class="cm">	 * keep the priority unchanged. Otherwise, update priority</span>
<span class="cm">	 * to the normal priority:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rt_prio</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">normal_prio</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * task_curr - is this task currently executing on a CPU?</span>
<span class="cm"> * @p: the task in question.</span>
<span class="cm"> */</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">task_curr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cpu_curr</span><span class="p">(</span><span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">==</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">check_class_changed</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
				       <span class="k">const</span> <span class="k">struct</span> <span class="n">sched_class</span> <span class="o">*</span><span class="n">prev_class</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">oldprio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prev_class</span> <span class="o">!=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prev_class</span><span class="o">-&gt;</span><span class="n">switched_from</span><span class="p">)</span>
			<span class="n">prev_class</span><span class="o">-&gt;</span><span class="n">switched_from</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">switched_to</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">oldprio</span> <span class="o">!=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">)</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">prio_changed</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">oldprio</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">check_preempt_curr</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sched_class</span> <span class="o">*</span><span class="n">class</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">==</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">check_preempt_curr</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">for_each_class</span><span class="p">(</span><span class="n">class</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">class</span> <span class="o">==</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">class</span> <span class="o">==</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">resched_task</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * A queue event has occurred, and we&#39;re going to schedule.  In</span>
<span class="cm">	 * this case, we can save a useless back to back clock update.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">on_rq</span> <span class="o">&amp;&amp;</span> <span class="n">test_tsk_need_resched</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">))</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">skip_clock_update</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="kt">void</span> <span class="nf">set_task_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">new_cpu</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SCHED_DEBUG</span>
	<span class="cm">/*</span>
<span class="cm">	 * We should never call set_task_cpu() on a blocked task,</span>
<span class="cm">	 * ttwu() will sort out the placement.</span>
<span class="cm">	 */</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">TASK_RUNNING</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">TASK_WAKING</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="p">(</span><span class="n">task_thread_info</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">preempt_count</span> <span class="o">&amp;</span> <span class="n">PREEMPT_ACTIVE</span><span class="p">));</span>

<span class="cp">#ifdef CONFIG_LOCKDEP</span>
	<span class="cm">/*</span>
<span class="cm">	 * The caller should hold either p-&gt;pi_lock or rq-&gt;lock, when changing</span>
<span class="cm">	 * a task&#39;s CPU. -&gt;pi_lock for waking tasks, rq-&gt;lock for runnable tasks.</span>
<span class="cm">	 *</span>
<span class="cm">	 * sched_move_task() holds both and thus holding either pins the cgroup,</span>
<span class="cm">	 * see set_task_rq().</span>
<span class="cm">	 *</span>
<span class="cm">	 * Furthermore, all task_rq users should acquire both locks, see</span>
<span class="cm">	 * task_rq_lock().</span>
<span class="cm">	 */</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">debug_locks</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">lockdep_is_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">)</span> <span class="o">||</span>
				      <span class="n">lockdep_is_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)));</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

	<span class="n">trace_sched_migrate_task</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">new_cpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">!=</span> <span class="n">new_cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">nr_migrations</span><span class="o">++</span><span class="p">;</span>
		<span class="n">perf_sw_event</span><span class="p">(</span><span class="n">PERF_COUNT_SW_CPU_MIGRATIONS</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">__set_task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">new_cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">migration_arg</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dest_cpu</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">migration_cpu_stop</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * wait_task_inactive - wait for a thread to unschedule.</span>
<span class="cm"> *</span>
<span class="cm"> * If @match_state is nonzero, it&#39;s the @p-&gt;state value just checked and</span>
<span class="cm"> * not expected to change.  If it changes, i.e. @p might have woken up,</span>
<span class="cm"> * then return zero.  When we succeed in waiting for @p to be off its CPU,</span>
<span class="cm"> * we return a positive number (its total switch count).  If a second call</span>
<span class="cm"> * a short while later returns the same number, the caller can be sure that</span>
<span class="cm"> * @p has remained unscheduled the whole time.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must ensure that the task *will* unschedule sometime soon,</span>
<span class="cm"> * else this function might spin for a *long* time. This function can&#39;t</span>
<span class="cm"> * be called with interrupts off, or it may introduce deadlock with</span>
<span class="cm"> * smp_call_function() if an IPI is sent by the same process we are</span>
<span class="cm"> * waiting to become inactive.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">wait_task_inactive</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">long</span> <span class="n">match_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">running</span><span class="p">,</span> <span class="n">on_rq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ncsw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We do the initial early heuristics without holding</span>
<span class="cm">		 * any task-queue locks at all. We&#39;ll only try to get</span>
<span class="cm">		 * the runqueue lock when things look like they will</span>
<span class="cm">		 * work out!</span>
<span class="cm">		 */</span>
		<span class="n">rq</span> <span class="o">=</span> <span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If the task is actively running on another CPU</span>
<span class="cm">		 * still, just relax and busy-wait without holding</span>
<span class="cm">		 * any locks.</span>
<span class="cm">		 *</span>
<span class="cm">		 * NOTE! Since we don&#39;t hold any locks, it&#39;s not</span>
<span class="cm">		 * even sure that &quot;rq&quot; stays as the right runqueue!</span>
<span class="cm">		 * But we don&#39;t care, since &quot;task_running()&quot; will</span>
<span class="cm">		 * return false if the runqueue has changed and p</span>
<span class="cm">		 * is actually now running somewhere else!</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">task_running</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">match_state</span> <span class="o">&amp;&amp;</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">match_state</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">cpu_relax</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Ok, time to look more closely! We need the rq</span>
<span class="cm">		 * lock now, to be *sure*. If we&#39;re wrong, we&#39;ll</span>
<span class="cm">		 * just go back and repeat.</span>
<span class="cm">		 */</span>
		<span class="n">rq</span> <span class="o">=</span> <span class="n">task_rq_lock</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">trace_sched_wait_task</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">running</span> <span class="o">=</span> <span class="n">task_running</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="n">on_rq</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">;</span>
		<span class="n">ncsw</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">match_state</span> <span class="o">||</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">match_state</span><span class="p">)</span>
			<span class="n">ncsw</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">nvcsw</span> <span class="o">|</span> <span class="n">LONG_MIN</span><span class="p">;</span> <span class="cm">/* sets MSB */</span>
		<span class="n">task_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If it changed from the expected state, bail out now.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ncsw</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Was it really running after all now that we</span>
<span class="cm">		 * checked with the proper locks actually held?</span>
<span class="cm">		 *</span>
<span class="cm">		 * Oops. Go back and try again..</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">running</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cpu_relax</span><span class="p">();</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * It&#39;s not enough that it&#39;s not actively running,</span>
<span class="cm">		 * it must be off the runqueue _entirely_, and not</span>
<span class="cm">		 * preempted!</span>
<span class="cm">		 *</span>
<span class="cm">		 * So if it was still runnable (but just not actively</span>
<span class="cm">		 * running right now), it&#39;s preempted, and we should</span>
<span class="cm">		 * yield - it could be a while.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">on_rq</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ktime_t</span> <span class="n">to</span> <span class="o">=</span> <span class="n">ktime_set</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">NSEC_PER_SEC</span><span class="o">/</span><span class="n">HZ</span><span class="p">);</span>

			<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
			<span class="n">schedule_hrtimeout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">to</span><span class="p">,</span> <span class="n">HRTIMER_MODE_REL</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Ahh, all good. It wasn&#39;t running, and it wasn&#39;t</span>
<span class="cm">		 * runnable, which means that it will never become</span>
<span class="cm">		 * running in the future either. We&#39;re all done!</span>
<span class="cm">		 */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ncsw</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/***</span>
<span class="cm"> * kick_process - kick a running thread to enter/exit the kernel</span>
<span class="cm"> * @p: the to-be-kicked thread</span>
<span class="cm"> *</span>
<span class="cm"> * Cause a process which is running on another CPU to enter</span>
<span class="cm"> * kernel-mode, without any delay. (to get signals handled.)</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: this function doesn&#39;t have to take the runqueue lock,</span>
<span class="cm"> * because all it wants to ensure is that the remote task enters</span>
<span class="cm"> * the kernel. If the IPI races and the task has been migrated</span>
<span class="cm"> * to another CPU then no harm is done and the purpose has been</span>
<span class="cm"> * achieved as well.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">kick_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">cpu</span> <span class="o">=</span> <span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">smp_processor_id</span><span class="p">())</span> <span class="o">&amp;&amp;</span> <span class="n">task_curr</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
		<span class="n">smp_send_reschedule</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kick_process</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cm">/*</span>
<span class="cm"> * -&gt;cpus_allowed is protected by both rq-&gt;lock and p-&gt;pi_lock</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">select_fallback_rq</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">nodemask</span> <span class="o">=</span> <span class="n">cpumask_of_node</span><span class="p">(</span><span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
	<span class="k">enum</span> <span class="p">{</span> <span class="n">cpuset</span><span class="p">,</span> <span class="n">possible</span><span class="p">,</span> <span class="n">fail</span> <span class="p">}</span> <span class="n">state</span> <span class="o">=</span> <span class="n">cpuset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dest_cpu</span><span class="p">;</span>

	<span class="cm">/* Look for allowed, online CPU in same node. */</span>
	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">dest_cpu</span><span class="p">,</span> <span class="n">nodemask</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">dest_cpu</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_active</span><span class="p">(</span><span class="n">dest_cpu</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">dest_cpu</span><span class="p">,</span> <span class="n">tsk_cpus_allowed</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">dest_cpu</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="cm">/* Any allowed, online CPU? */</span>
		<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">dest_cpu</span><span class="p">,</span> <span class="n">tsk_cpus_allowed</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">dest_cpu</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_active</span><span class="p">(</span><span class="n">dest_cpu</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">cpuset</span>:
			<span class="cm">/* No more Mr. Nice Guy. */</span>
			<span class="n">cpuset_cpus_allowed_fallback</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
			<span class="n">state</span> <span class="o">=</span> <span class="n">possible</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">possible</span>:
			<span class="n">do_set_cpus_allowed</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cpu_possible_mask</span><span class="p">);</span>
			<span class="n">state</span> <span class="o">=</span> <span class="n">fail</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">fail</span>:
			<span class="n">BUG</span><span class="p">();</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">!=</span> <span class="n">cpuset</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Don&#39;t tell them about moving exiting tasks or</span>
<span class="cm">		 * kernel threads (both mm NULL), since they never</span>
<span class="cm">		 * leave kernel.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">&amp;&amp;</span> <span class="n">printk_ratelimit</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">printk_sched</span><span class="p">(</span><span class="s">&quot;process %d (%s) no longer affine to cpu%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">task_pid_nr</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">dest_cpu</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The caller (fork, wakeup) owns p-&gt;pi_lock, -&gt;cpus_allowed is stable.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">int</span> <span class="nf">select_task_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sd_flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wake_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">select_task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">sd_flags</span><span class="p">,</span> <span class="n">wake_flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * In order not to call set_task_cpu() on a blocking task we need</span>
<span class="cm">	 * to rely on ttwu() to place the task on a valid -&gt;cpus_allowed</span>
<span class="cm">	 * cpu.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Since this is common to all placement strategies, this lives here.</span>
<span class="cm">	 *</span>
<span class="cm">	 * [ this allows -&gt;select_task() to simply return task_cpu(p) and</span>
<span class="cm">	 *   not worry about this generic constraint ]</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">tsk_cpus_allowed</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">||</span>
		     <span class="o">!</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">)))</span>
		<span class="n">cpu</span> <span class="o">=</span> <span class="n">select_fallback_rq</span><span class="p">(</span><span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">p</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">cpu</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_avg</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">avg</span><span class="p">,</span> <span class="n">u64</span> <span class="n">sample</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s64</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">sample</span> <span class="o">-</span> <span class="o">*</span><span class="n">avg</span><span class="p">;</span>
	<span class="o">*</span><span class="n">avg</span> <span class="o">+=</span> <span class="n">diff</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ttwu_stat</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wake_flags</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SCHEDSTATS</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">this_rq</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="kt">int</span> <span class="n">this_cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">this_cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">ttwu_local</span><span class="p">);</span>
		<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">se</span><span class="p">.</span><span class="n">statistics</span><span class="p">.</span><span class="n">nr_wakeups_local</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>

		<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">se</span><span class="p">.</span><span class="n">statistics</span><span class="p">.</span><span class="n">nr_wakeups_remote</span><span class="p">);</span>
		<span class="n">rcu_read_lock</span><span class="p">();</span>
		<span class="n">for_each_domain</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">,</span> <span class="n">sd</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">sched_domain_span</span><span class="p">(</span><span class="n">sd</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">ttwu_wake_remote</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wake_flags</span> <span class="o">&amp;</span> <span class="n">WF_MIGRATED</span><span class="p">)</span>
		<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">se</span><span class="p">.</span><span class="n">statistics</span><span class="p">.</span><span class="n">nr_wakeups_migrate</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

	<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">ttwu_count</span><span class="p">);</span>
	<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">se</span><span class="p">.</span><span class="n">statistics</span><span class="p">.</span><span class="n">nr_wakeups</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wake_flags</span> <span class="o">&amp;</span> <span class="n">WF_SYNC</span><span class="p">)</span>
		<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">se</span><span class="p">.</span><span class="n">statistics</span><span class="p">.</span><span class="n">nr_wakeups_sync</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_SCHEDSTATS */</span><span class="cp"></span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ttwu_activate</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">en_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">activate_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">en_flags</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">on_rq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* if a worker is waking up, notify workqueue */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_WQ_WORKER</span><span class="p">)</span>
		<span class="n">wq_worker_waking_up</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cpu_of</span><span class="p">(</span><span class="n">rq</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Mark the task runnable and perform wakeup-preemption.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ttwu_do_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wake_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_sched_wakeup</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">check_preempt_curr</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">wake_flags</span><span class="p">);</span>

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_RUNNING</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">task_woken</span><span class="p">)</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">task_woken</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">idle_stamp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">clock</span> <span class="o">-</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">idle_stamp</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">sysctl_sched_migration_cost</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span>
			<span class="n">rq</span><span class="o">-&gt;</span><span class="n">avg_idle</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">update_avg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">avg_idle</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">idle_stamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ttwu_do_activate</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wake_flags</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_contributes_to_load</span><span class="p">)</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_uninterruptible</span><span class="o">--</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">ttwu_activate</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">ENQUEUE_WAKEUP</span> <span class="o">|</span> <span class="n">ENQUEUE_WAKING</span><span class="p">);</span>
	<span class="n">ttwu_do_wakeup</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">wake_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called in case the task @p isn&#39;t fully descheduled from its runqueue,</span>
<span class="cm"> * in this case we must do a remote wakeup. Its a &#39;light&#39; wakeup though,</span>
<span class="cm"> * since all we need to do is flip p-&gt;state to TASK_RUNNING, since</span>
<span class="cm"> * the task is still -&gt;on_rq.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ttwu_remote</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wake_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rq</span> <span class="o">=</span> <span class="n">__task_rq_lock</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ttwu_do_wakeup</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">wake_flags</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">__task_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sched_ttwu_pending</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">this_rq</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">llist_node</span> <span class="o">*</span><span class="n">llist</span> <span class="o">=</span> <span class="n">llist_del_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">wake_list</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">llist</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">llist_entry</span><span class="p">(</span><span class="n">llist</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span><span class="p">,</span> <span class="n">wake_entry</span><span class="p">);</span>
		<span class="n">llist</span> <span class="o">=</span> <span class="n">llist_next</span><span class="p">(</span><span class="n">llist</span><span class="p">);</span>
		<span class="n">ttwu_do_activate</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">scheduler_ipi</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">llist_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_rq</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">wake_list</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">got_nohz_idle_kick</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Not all reschedule IPI handlers call irq_enter/irq_exit, since</span>
<span class="cm">	 * traditionally all their work was done from the interrupt return</span>
<span class="cm">	 * path. Now that we actually do some work, we need to make sure</span>
<span class="cm">	 * we do call them.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Some archs already do call them, luckily irq_enter/exit nest</span>
<span class="cm">	 * properly.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Arguably we should visit all archs and update all handlers,</span>
<span class="cm">	 * however a fair share of IPIs are still resched only so this would</span>
<span class="cm">	 * somewhat pessimize the simple resched case.</span>
<span class="cm">	 */</span>
	<span class="n">irq_enter</span><span class="p">();</span>
	<span class="n">sched_ttwu_pending</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if someone kicked us for doing the nohz idle load balance.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">got_nohz_idle_kick</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">need_resched</span><span class="p">()))</span> <span class="p">{</span>
		<span class="n">this_rq</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">idle_balance</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">raise_softirq_irqoff</span><span class="p">(</span><span class="n">SCHED_SOFTIRQ</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">irq_exit</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ttwu_queue_remote</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">llist_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">wake_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">wake_list</span><span class="p">))</span>
		<span class="n">smp_send_reschedule</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef __ARCH_WANT_INTERRUPTS_ON_CTXSW</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ttwu_activate_remote</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wake_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rq</span> <span class="o">=</span> <span class="n">__task_rq_lock</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">on_cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ttwu_activate</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">ENQUEUE_WAKEUP</span><span class="p">);</span>
		<span class="n">ttwu_do_wakeup</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">wake_flags</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">__task_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* __ARCH_WANT_INTERRUPTS_ON_CTXSW */</span><span class="cp"></span>

<span class="n">bool</span> <span class="nf">cpus_share_cache</span><span class="p">(</span><span class="kt">int</span> <span class="n">this_cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">that_cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">sd_llc_id</span><span class="p">,</span> <span class="n">this_cpu</span><span class="p">)</span> <span class="o">==</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">sd_llc_id</span><span class="p">,</span> <span class="n">that_cpu</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ttwu_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

<span class="cp">#if defined(CONFIG_SMP)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sched_feat</span><span class="p">(</span><span class="n">TTWU_QUEUE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cpus_share_cache</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">(),</span> <span class="n">cpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sched_clock_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span> <span class="cm">/* sync clocks x-cpu */</span>
		<span class="n">ttwu_queue_remote</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ttwu_do_activate</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * try_to_wake_up - wake up a thread</span>
<span class="cm"> * @p: the thread to be awakened</span>
<span class="cm"> * @state: the mask of task states that can be woken</span>
<span class="cm"> * @wake_flags: wake modifier flags (WF_*)</span>
<span class="cm"> *</span>
<span class="cm"> * Put it on the run-queue if it&#39;s not already there. The &quot;current&quot;</span>
<span class="cm"> * thread is always on the run-queue (except when the actual</span>
<span class="cm"> * re-schedule is in progress), and as such you&#39;re allowed to do</span>
<span class="cm"> * the simpler &quot;current-&gt;state = TASK_RUNNING&quot; to mark yourself</span>
<span class="cm"> * runnable without the overhead of this.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns %true if @p was woken up, %false if it was already running</span>
<span class="cm"> * or @state didn&#39;t match @p&#39;s state.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">try_to_wake_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wake_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">success</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">state</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">success</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* we&#39;re going to change -&gt;state */</span>
	<span class="n">cpu</span> <span class="o">=</span> <span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">on_rq</span> <span class="o">&amp;&amp;</span> <span class="n">ttwu_remote</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">wake_flags</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">stat</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the owning (remote) cpu is still in the middle of schedule() with</span>
<span class="cm">	 * this task as prev, wait until its done referencing the task.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">on_cpu</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef __ARCH_WANT_INTERRUPTS_ON_CTXSW</span>
		<span class="cm">/*</span>
<span class="cm">		 * In case the architecture enables interrupts in</span>
<span class="cm">		 * context_switch(), we cannot busy wait, since that</span>
<span class="cm">		 * would lead to deadlocks when an interrupt hits and</span>
<span class="cm">		 * tries to wake up @prev. So bail and do a complete</span>
<span class="cm">		 * remote wakeup.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ttwu_activate_remote</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">wake_flags</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">stat</span><span class="p">;</span>
<span class="cp">#else</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Pairs with the smp_wmb() in finish_lock_switch().</span>
<span class="cm">	 */</span>
	<span class="n">smp_rmb</span><span class="p">();</span>

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_contributes_to_load</span> <span class="o">=</span> <span class="o">!!</span><span class="n">task_contributes_to_load</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_WAKING</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">task_waking</span><span class="p">)</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">task_waking</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="n">select_task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">SD_BALANCE_WAKE</span><span class="p">,</span> <span class="n">wake_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">!=</span> <span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wake_flags</span> <span class="o">|=</span> <span class="n">WF_MIGRATED</span><span class="p">;</span>
		<span class="n">set_task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

	<span class="n">ttwu_queue</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="nl">stat:</span>
	<span class="n">ttwu_stat</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">wake_flags</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">success</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * try_to_wake_up_local - try to wake up a local task with rq lock held</span>
<span class="cm"> * @p: the thread to be awakened</span>
<span class="cm"> *</span>
<span class="cm"> * Put @p on the run-queue if it&#39;s not already there. The caller must</span>
<span class="cm"> * ensure that this_rq() is locked, @p is bound to this_rq() and not</span>
<span class="cm"> * the current task.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">try_to_wake_up_local</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">rq</span> <span class="o">!=</span> <span class="n">this_rq</span><span class="p">());</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">current</span><span class="p">);</span>
	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">raw_spin_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>
		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">TASK_NORMAL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">)</span>
		<span class="n">ttwu_activate</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">ENQUEUE_WAKEUP</span><span class="p">);</span>

	<span class="n">ttwu_do_wakeup</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ttwu_stat</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * wake_up_process - Wake up a specific process</span>
<span class="cm"> * @p: The process to be woken up.</span>
<span class="cm"> *</span>
<span class="cm"> * Attempt to wake up the nominated process and move it to the set of runnable</span>
<span class="cm"> * processes.  Returns 1 if the process was woken up, 0 if it was already</span>
<span class="cm"> * running.</span>
<span class="cm"> *</span>
<span class="cm"> * It may be assumed that this function implies a write memory barrier before</span>
<span class="cm"> * changing the task state if and only if any tasks are woken up.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">wake_up_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">try_to_wake_up</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">TASK_ALL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">wake_up_process</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">wake_up_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">try_to_wake_up</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Perform scheduler related setup for a newly forked process p.</span>
<span class="cm"> * p is forked by current.</span>
<span class="cm"> *</span>
<span class="cm"> * __sched_fork() is basic setup used by init_idle() too:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__sched_fork</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">on_rq</span>			<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">on_rq</span>			<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">exec_start</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">sum_exec_runtime</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">prev_sum_exec_runtime</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">nr_migrations</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">vruntime</span>			<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">group_node</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SCHEDSTATS</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">statistics</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">statistics</span><span class="p">));</span>
<span class="cp">#endif</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">run_list</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PREEMPT_NOTIFIERS</span>
	<span class="n">INIT_HLIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">preempt_notifiers</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * fork()/clone()-time setup:</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sched_fork</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">get_cpu</span><span class="p">();</span>

	<span class="n">__sched_fork</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * We mark the process as running here. This guarantees that</span>
<span class="cm">	 * nobody will actually run it, and a signal or other external</span>
<span class="cm">	 * event cannot wake it up and insert it on the runqueue either.</span>
<span class="cm">	 */</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_RUNNING</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure we do not leak PI boosting priority to the child.</span>
<span class="cm">	 */</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">normal_prio</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Revert to default priority/policy on fork if requested.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_reset_on_fork</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">task_has_rt_policy</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">=</span> <span class="n">SCHED_NORMAL</span><span class="p">;</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">static_prio</span> <span class="o">=</span> <span class="n">NICE_TO_PRIO</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">rt_priority</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">PRIO_TO_NICE</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">static_prio</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">static_prio</span> <span class="o">=</span> <span class="n">NICE_TO_PRIO</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

		<span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">normal_prio</span> <span class="o">=</span> <span class="n">__normal_prio</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">set_load_weight</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * We don&#39;t need the reset flag anymore after the fork. It has</span>
<span class="cm">		 * fulfilled its duty:</span>
<span class="cm">		 */</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_reset_on_fork</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rt_prio</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">))</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fair_sched_class</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">task_fork</span><span class="p">)</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">task_fork</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The child is not yet in the pid-hash so no cgroup attach races,</span>
<span class="cm">	 * and the cgroup is pinned to this child due to cgroup_fork()</span>
<span class="cm">	 * is ran before sched_fork().</span>
<span class="cm">	 *</span>
<span class="cm">	 * Silence PROVE_RCU.</span>
<span class="cm">	 */</span>
	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">set_task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

<span class="cp">#if defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">sched_info_on</span><span class="p">()))</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_info</span><span class="p">));</span>
<span class="cp">#endif</span>
<span class="cp">#if defined(CONFIG_SMP)</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">on_cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_PREEMPT_COUNT</span>
	<span class="cm">/* Want to start with kernel preemption disabled. */</span>
	<span class="n">task_thread_info</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">preempt_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">plist_node_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pushable_tasks</span><span class="p">,</span> <span class="n">MAX_PRIO</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">put_cpu</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * wake_up_new_task - wake up a newly created task for the first time.</span>
<span class="cm"> *</span>
<span class="cm"> * This function will do some initial scheduler statistics housekeeping</span>
<span class="cm"> * that must be done for every newly created context, then puts the task</span>
<span class="cm"> * on the runqueue and wakes it.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">wake_up_new_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="cm">/*</span>
<span class="cm">	 * Fork balancing, do it here and not earlier because:</span>
<span class="cm">	 *  - cpus_allowed can change in the fork path</span>
<span class="cm">	 *  - any previously selected cpu might disappear through hotplug</span>
<span class="cm">	 */</span>
	<span class="n">set_task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">select_task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">SD_BALANCE_FORK</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
<span class="cp">#endif</span>

	<span class="n">rq</span> <span class="o">=</span> <span class="n">__task_rq_lock</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">activate_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">on_rq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">trace_sched_wakeup_new</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">check_preempt_curr</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">WF_FORK</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">task_woken</span><span class="p">)</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">task_woken</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">task_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PREEMPT_NOTIFIERS</span>

<span class="cm">/**</span>
<span class="cm"> * preempt_notifier_register - tell me when current is being preempted &amp; rescheduled</span>
<span class="cm"> * @notifier: notifier struct to register</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">preempt_notifier_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">preempt_notifier</span> <span class="o">*</span><span class="n">notifier</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">notifier</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">preempt_notifiers</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">preempt_notifier_register</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * preempt_notifier_unregister - no longer interested in preemption notifications</span>
<span class="cm"> * @notifier: notifier struct to unregister</span>
<span class="cm"> *</span>
<span class="cm"> * This is safe to call from within a preemption notifier.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">preempt_notifier_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">preempt_notifier</span> <span class="o">*</span><span class="n">notifier</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">notifier</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">preempt_notifier_unregister</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fire_sched_in_preempt_notifiers</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">preempt_notifier</span> <span class="o">*</span><span class="n">notifier</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">notifier</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">preempt_notifiers</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span>
		<span class="n">notifier</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sched_in</span><span class="p">(</span><span class="n">notifier</span><span class="p">,</span> <span class="n">raw_smp_processor_id</span><span class="p">());</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">fire_sched_out_preempt_notifiers</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">preempt_notifier</span> <span class="o">*</span><span class="n">notifier</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">notifier</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">preempt_notifiers</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span>
		<span class="n">notifier</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sched_out</span><span class="p">(</span><span class="n">notifier</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* !CONFIG_PREEMPT_NOTIFIERS */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fire_sched_in_preempt_notifiers</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">fire_sched_out_preempt_notifiers</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_PREEMPT_NOTIFIERS */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * prepare_task_switch - prepare to switch tasks</span>
<span class="cm"> * @rq: the runqueue preparing to switch</span>
<span class="cm"> * @prev: the current task that is being switched out</span>
<span class="cm"> * @next: the task we are going to switch to.</span>
<span class="cm"> *</span>
<span class="cm"> * This is called with the rq lock held and interrupts off. It must</span>
<span class="cm"> * be paired with a subsequent finish_task_switch after the context</span>
<span class="cm"> * switch.</span>
<span class="cm"> *</span>
<span class="cm"> * prepare_task_switch sets up locking and calls architecture specific</span>
<span class="cm"> * hooks.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">prepare_task_switch</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sched_info_switch</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
	<span class="n">perf_event_task_sched_out</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
	<span class="n">fire_sched_out_preempt_notifiers</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
	<span class="n">prepare_lock_switch</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
	<span class="n">prepare_arch_switch</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
	<span class="n">trace_sched_switch</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * finish_task_switch - clean up after a task-switch</span>
<span class="cm"> * @rq: runqueue associated with task-switch</span>
<span class="cm"> * @prev: the thread we just switched away from.</span>
<span class="cm"> *</span>
<span class="cm"> * finish_task_switch must be called after the context switch, paired</span>
<span class="cm"> * with a prepare_task_switch call before the context switch.</span>
<span class="cm"> * finish_task_switch will reconcile locking set up by prepare_task_switch,</span>
<span class="cm"> * and do any other architecture-specific cleanup actions.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that we may have delayed dropping an mm in context_switch(). If</span>
<span class="cm"> * so, we finish that here outside of the runqueue lock. (Doing it</span>
<span class="cm"> * with the lock held can cause deadlocks; see schedule() for</span>
<span class="cm"> * details.)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">finish_task_switch</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">prev_mm</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">prev_state</span><span class="p">;</span>

	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">prev_mm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * A task struct has one reference for the use as &quot;current&quot;.</span>
<span class="cm">	 * If a task dies, then it sets TASK_DEAD in tsk-&gt;state and calls</span>
<span class="cm">	 * schedule one last time. The schedule call will never return, and</span>
<span class="cm">	 * the scheduled task must drop that reference.</span>
<span class="cm">	 * The test for TASK_DEAD must occur while the runqueue locks are</span>
<span class="cm">	 * still held, otherwise prev could be scheduled on another cpu, die</span>
<span class="cm">	 * there before we look at prev-&gt;state, and then the reference would</span>
<span class="cm">	 * be dropped twice.</span>
<span class="cm">	 *		Manfred Spraul &lt;manfred@colorfullife.com&gt;</span>
<span class="cm">	 */</span>
	<span class="n">prev_state</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
	<span class="n">finish_arch_switch</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
<span class="cp">#ifdef __ARCH_WANT_INTERRUPTS_ON_CTXSW</span>
	<span class="n">local_irq_disable</span><span class="p">();</span>
<span class="cp">#endif </span><span class="cm">/* __ARCH_WANT_INTERRUPTS_ON_CTXSW */</span><span class="cp"></span>
	<span class="n">perf_event_task_sched_in</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
<span class="cp">#ifdef __ARCH_WANT_INTERRUPTS_ON_CTXSW</span>
	<span class="n">local_irq_enable</span><span class="p">();</span>
<span class="cp">#endif </span><span class="cm">/* __ARCH_WANT_INTERRUPTS_ON_CTXSW */</span><span class="cp"></span>
	<span class="n">finish_lock_switch</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>
	<span class="n">finish_arch_post_lock_switch</span><span class="p">();</span>

	<span class="n">fire_sched_in_preempt_notifiers</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="p">)</span>
		<span class="n">mmdrop</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">prev_state</span> <span class="o">==</span> <span class="n">TASK_DEAD</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Remove function-return probe instances associated with this</span>
<span class="cm">		 * task and put them back on the free list.</span>
<span class="cm">		 */</span>
		<span class="n">kprobe_flush_task</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
		<span class="n">put_task_struct</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SMP</span>

<span class="cm">/* assumes rq-&gt;lock is held */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pre_schedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">pre_schedule</span><span class="p">)</span>
		<span class="n">prev</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">pre_schedule</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* rq-&gt;lock is NOT held, but preemption is disabled */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">post_schedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">post_schedule</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

		<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">post_schedule</span><span class="p">)</span>
			<span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">post_schedule</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">post_schedule</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pre_schedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">post_schedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * schedule_tail - first thing a freshly forked thread must call.</span>
<span class="cm"> * @prev: the thread we just switched away from.</span>
<span class="cm"> */</span>
<span class="n">asmlinkage</span> <span class="kt">void</span> <span class="nf">schedule_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">this_rq</span><span class="p">();</span>

	<span class="n">finish_task_switch</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * FIXME: do we need to worry about rq being invalidated by the</span>
<span class="cm">	 * task_switch?</span>
<span class="cm">	 */</span>
	<span class="n">post_schedule</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>

<span class="cp">#ifdef __ARCH_WANT_UNLOCKED_CTXSW</span>
	<span class="cm">/* In this case, finish_task_switch does not reenable preemption */</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">set_child_tid</span><span class="p">)</span>
		<span class="n">put_user</span><span class="p">(</span><span class="n">task_pid_vnr</span><span class="p">(</span><span class="n">current</span><span class="p">),</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">set_child_tid</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * context_switch - switch to the new MM and the new</span>
<span class="cm"> * thread&#39;s register state.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">context_switch</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span>
	       <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="o">*</span><span class="n">oldmm</span><span class="p">;</span>

	<span class="n">prepare_task_switch</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>

	<span class="n">mm</span> <span class="o">=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="n">oldmm</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * For paravirt, this is coupled with an exit in switch_to to</span>
<span class="cm">	 * combine the page table reload and the switch backend into</span>
<span class="cm">	 * one hypercall.</span>
<span class="cm">	 */</span>
	<span class="n">arch_start_context_switch</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">next</span><span class="o">-&gt;</span><span class="n">active_mm</span> <span class="o">=</span> <span class="n">oldmm</span><span class="p">;</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldmm</span><span class="o">-&gt;</span><span class="n">mm_count</span><span class="p">);</span>
		<span class="n">enter_lazy_tlb</span><span class="p">(</span><span class="n">oldmm</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">switch_mm</span><span class="p">(</span><span class="n">oldmm</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">prev_mm</span> <span class="o">=</span> <span class="n">oldmm</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Since the runqueue lock will be released by the next</span>
<span class="cm">	 * task (which is an invalid locking op but in the case</span>
<span class="cm">	 * of the scheduler it&#39;s an obvious special-case), so we</span>
<span class="cm">	 * do an early lockdep release here:</span>
<span class="cm">	 */</span>
<span class="cp">#ifndef __ARCH_WANT_UNLOCKED_CTXSW</span>
	<span class="n">spin_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">.</span><span class="n">dep_map</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_THIS_IP_</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* Here we just switch the register state and the stack. */</span>
	<span class="n">rcu_switch_from</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
	<span class="n">switch_to</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>

	<span class="n">barrier</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * this_rq must be evaluated again because prev may have moved</span>
<span class="cm">	 * CPUs since it called schedule(), thus the &#39;rq&#39; on its stack</span>
<span class="cm">	 * frame will be invalid.</span>
<span class="cm">	 */</span>
	<span class="n">finish_task_switch</span><span class="p">(</span><span class="n">this_rq</span><span class="p">(),</span> <span class="n">prev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * nr_running, nr_uninterruptible and nr_context_switches:</span>
<span class="cm"> *</span>
<span class="cm"> * externally visible scheduler statistics: current number of runnable</span>
<span class="cm"> * threads, current number of uninterruptible-sleeping threads, total</span>
<span class="cm"> * number of context switches performed since bootup.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">nr_running</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">,</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_running</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">nr_uninterruptible</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">,</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_uninterruptible</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since we read the counters lockless, it might be slightly</span>
<span class="cm">	 * inaccurate. Do not allow it to go below zero though:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="kt">long</span><span class="p">)</span><span class="n">sum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">nr_context_switches</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_switches</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">nr_iowait</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">,</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_rq</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_iowait</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">nr_iowait_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">nr_iowait</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">this_cpu_load</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">this_rq</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">cpu_load</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>


<span class="cm">/* Variables and functions for calc_load */</span>
<span class="k">static</span> <span class="n">atomic_long_t</span> <span class="n">calc_load_tasks</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">calc_load_update</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">avenrun</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">avenrun</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">calc_load_fold_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">nr_active</span><span class="p">,</span> <span class="n">delta</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">nr_active</span> <span class="o">=</span> <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">nr_running</span><span class="p">;</span>
	<span class="n">nr_active</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">nr_uninterruptible</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr_active</span> <span class="o">!=</span> <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">calc_load_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="n">nr_active</span> <span class="o">-</span> <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">calc_load_active</span><span class="p">;</span>
		<span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">calc_load_active</span> <span class="o">=</span> <span class="n">nr_active</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">delta</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">calc_load</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">load</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">exp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">active</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">load</span> <span class="o">*=</span> <span class="n">exp</span><span class="p">;</span>
	<span class="n">load</span> <span class="o">+=</span> <span class="n">active</span> <span class="o">*</span> <span class="p">(</span><span class="n">FIXED_1</span> <span class="o">-</span> <span class="n">exp</span><span class="p">);</span>
	<span class="n">load</span> <span class="o">+=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">FSHIFT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">load</span> <span class="o">&gt;&gt;</span> <span class="n">FSHIFT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NO_HZ</span>
<span class="cm">/*</span>
<span class="cm"> * For NO_HZ we delay the active fold to the next LOAD_FREQ update.</span>
<span class="cm"> *</span>
<span class="cm"> * When making the ILB scale, we should try to pull this in as well.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">atomic_long_t</span> <span class="n">calc_load_tasks_idle</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">calc_load_account_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">delta</span><span class="p">;</span>

	<span class="n">delta</span> <span class="o">=</span> <span class="n">calc_load_fold_active</span><span class="p">(</span><span class="n">this_rq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delta</span><span class="p">)</span>
		<span class="n">atomic_long_add</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">calc_load_tasks_idle</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">calc_load_fold_idle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">delta</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Its got a race, we don&#39;t care...</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">calc_load_tasks_idle</span><span class="p">))</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="n">atomic_long_xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">calc_load_tasks_idle</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">delta</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fixed_power_int - compute: x^n, in O(log n) time</span>
<span class="cm"> *</span>
<span class="cm"> * @x:         base of the power</span>
<span class="cm"> * @frac_bits: fractional bits of @x</span>
<span class="cm"> * @n:         power to raise @x to.</span>
<span class="cm"> *</span>
<span class="cm"> * By exploiting the relation between the definition of the natural power</span>
<span class="cm"> * function: x^n := x*x*...*x (x multiplied by itself for n times), and</span>
<span class="cm"> * the binary encoding of numbers used by computers: n := \Sum n_i * 2^i,</span>
<span class="cm"> * (where: n_i \elem {0, 1}, the binary vector representing n),</span>
<span class="cm"> * we find: x^n := x^(\Sum n_i * 2^i) := \Prod x^(n_i * 2^i), which is</span>
<span class="cm"> * of course trivially computable in O(log_2 n), the length of our binary</span>
<span class="cm"> * vector.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">fixed_power_int</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">x</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">frac_bits</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">frac_bits</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">result</span> <span class="o">*=</span> <span class="n">x</span><span class="p">;</span>
			<span class="n">result</span> <span class="o">+=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">frac_bits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">result</span> <span class="o">&gt;&gt;=</span> <span class="n">frac_bits</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">n</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">x</span> <span class="o">*=</span> <span class="n">x</span><span class="p">;</span>
		<span class="n">x</span> <span class="o">+=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">frac_bits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">frac_bits</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * a1 = a0 * e + a * (1 - e)</span>
<span class="cm"> *</span>
<span class="cm"> * a2 = a1 * e + a * (1 - e)</span>
<span class="cm"> *    = (a0 * e + a * (1 - e)) * e + a * (1 - e)</span>
<span class="cm"> *    = a0 * e^2 + a * (1 - e) * (1 + e)</span>
<span class="cm"> *</span>
<span class="cm"> * a3 = a2 * e + a * (1 - e)</span>
<span class="cm"> *    = (a0 * e^2 + a * (1 - e) * (1 + e)) * e + a * (1 - e)</span>
<span class="cm"> *    = a0 * e^3 + a * (1 - e) * (1 + e + e^2)</span>
<span class="cm"> *</span>
<span class="cm"> *  ...</span>
<span class="cm"> *</span>
<span class="cm"> * an = a0 * e^n + a * (1 - e) * (1 + e + ... + e^n-1) [1]</span>
<span class="cm"> *    = a0 * e^n + a * (1 - e) * (1 - e^n)/(1 - e)</span>
<span class="cm"> *    = a0 * e^n + a * (1 - e^n)</span>
<span class="cm"> *</span>
<span class="cm"> * [1] application of the geometric series:</span>
<span class="cm"> *</span>
<span class="cm"> *              n         1 - x^(n+1)</span>
<span class="cm"> *     S_n := \Sum x^i = -------------</span>
<span class="cm"> *             i=0          1 - x</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">calc_load_n</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">load</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">exp</span><span class="p">,</span>
	    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">active</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">return</span> <span class="n">calc_load</span><span class="p">(</span><span class="n">load</span><span class="p">,</span> <span class="n">fixed_power_int</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">FSHIFT</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">active</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * NO_HZ can leave us missing all per-cpu ticks calling</span>
<span class="cm"> * calc_load_account_active(), but since an idle CPU folds its delta into</span>
<span class="cm"> * calc_load_tasks_idle per calc_load_account_idle(), all we need to do is fold</span>
<span class="cm"> * in the pending idle delta if our idle period crossed a load cycle boundary.</span>
<span class="cm"> *</span>
<span class="cm"> * Once we&#39;ve updated the global active value, we need to apply the exponential</span>
<span class="cm"> * weights adjusted to the number of cycles missed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">calc_global_nohz</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">delta</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we crossed a calc_load_update boundary, make sure to fold</span>
<span class="cm">	 * any pending idle changes, the respective CPUs might have</span>
<span class="cm">	 * missed the tick driven calc_load_account_active() update</span>
<span class="cm">	 * due to NO_HZ.</span>
<span class="cm">	 */</span>
	<span class="n">delta</span> <span class="o">=</span> <span class="n">calc_load_fold_idle</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delta</span><span class="p">)</span>
		<span class="n">atomic_long_add</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">calc_load_tasks</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * It could be the one fold was all it took, we done!</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">calc_load_update</span> <span class="o">+</span> <span class="mi">10</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Catch-up, fold however many we are behind still</span>
<span class="cm">	 */</span>
	<span class="n">delta</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">-</span> <span class="n">calc_load_update</span> <span class="o">-</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">n</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">delta</span> <span class="o">/</span> <span class="n">LOAD_FREQ</span><span class="p">);</span>

	<span class="n">active</span> <span class="o">=</span> <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">calc_load_tasks</span><span class="p">);</span>
	<span class="n">active</span> <span class="o">=</span> <span class="n">active</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">active</span> <span class="o">*</span> <span class="n">FIXED_1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">avenrun</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">calc_load_n</span><span class="p">(</span><span class="n">avenrun</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">EXP_1</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="n">avenrun</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">calc_load_n</span><span class="p">(</span><span class="n">avenrun</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">EXP_5</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="n">avenrun</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">calc_load_n</span><span class="p">(</span><span class="n">avenrun</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">EXP_15</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

	<span class="n">calc_load_update</span> <span class="o">+=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">LOAD_FREQ</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="kt">void</span> <span class="nf">calc_load_account_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">long</span> <span class="nf">calc_load_fold_idle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">calc_global_nohz</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * get_avenrun - get the load average array</span>
<span class="cm"> * @loads:	pointer to dest load array</span>
<span class="cm"> * @offset:	offset to add</span>
<span class="cm"> * @shift:	shift count to shift the result left</span>
<span class="cm"> *</span>
<span class="cm"> * These values are estimates at best, so no need for locking.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">get_avenrun</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">loads</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shift</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">loads</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">avenrun</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">;</span>
	<span class="n">loads</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">avenrun</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">;</span>
	<span class="n">loads</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">avenrun</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * calc_load - update the avenrun load estimates 10 ticks after the</span>
<span class="cm"> * CPUs have updated calc_load_tasks.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">calc_global_load</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ticks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">active</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">calc_load_update</span> <span class="o">+</span> <span class="mi">10</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">active</span> <span class="o">=</span> <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">calc_load_tasks</span><span class="p">);</span>
	<span class="n">active</span> <span class="o">=</span> <span class="n">active</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">active</span> <span class="o">*</span> <span class="n">FIXED_1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">avenrun</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">calc_load</span><span class="p">(</span><span class="n">avenrun</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">EXP_1</span><span class="p">,</span> <span class="n">active</span><span class="p">);</span>
	<span class="n">avenrun</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">calc_load</span><span class="p">(</span><span class="n">avenrun</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">EXP_5</span><span class="p">,</span> <span class="n">active</span><span class="p">);</span>
	<span class="n">avenrun</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">calc_load</span><span class="p">(</span><span class="n">avenrun</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">EXP_15</span><span class="p">,</span> <span class="n">active</span><span class="p">);</span>

	<span class="n">calc_load_update</span> <span class="o">+=</span> <span class="n">LOAD_FREQ</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Account one period with whatever state we found before</span>
<span class="cm">	 * folding in the nohz state and ageing the entire idle period.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This avoids loosing a sample when we go idle between </span>
<span class="cm">	 * calc_load_account_active() (10 ticks ago) and now and thus</span>
<span class="cm">	 * under-accounting.</span>
<span class="cm">	 */</span>
	<span class="n">calc_global_nohz</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called from update_cpu_load() to periodically update this CPU&#39;s</span>
<span class="cm"> * active count.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">calc_load_account_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">delta</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">calc_load_update</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">delta</span>  <span class="o">=</span> <span class="n">calc_load_fold_active</span><span class="p">(</span><span class="n">this_rq</span><span class="p">);</span>
	<span class="n">delta</span> <span class="o">+=</span> <span class="n">calc_load_fold_idle</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delta</span><span class="p">)</span>
		<span class="n">atomic_long_add</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">calc_load_tasks</span><span class="p">);</span>

	<span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">calc_load_update</span> <span class="o">+=</span> <span class="n">LOAD_FREQ</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The exact cpuload at various idx values, calculated at every tick would be</span>
<span class="cm"> * load = (2^idx - 1) / 2^idx * load + 1 / 2^idx * cur_load</span>
<span class="cm"> *</span>
<span class="cm"> * If a cpu misses updates for n-1 ticks (as it was idle) and update gets called</span>
<span class="cm"> * on nth tick when cpu may be busy, then we have:</span>
<span class="cm"> * load = ((2^idx - 1) / 2^idx)^(n-1) * load</span>
<span class="cm"> * load = (2^idx - 1) / 2^idx) * load + 1 / 2^idx * cur_load</span>
<span class="cm"> *</span>
<span class="cm"> * decay_load_missed() below does efficient calculation of</span>
<span class="cm"> * load = ((2^idx - 1) / 2^idx)^(n-1) * load</span>
<span class="cm"> * avoiding 0..n-1 loop doing load = ((2^idx - 1) / 2^idx) * load</span>
<span class="cm"> *</span>
<span class="cm"> * The calculation is approximated on a 128 point scale.</span>
<span class="cm"> * degrade_zero_ticks is the number of ticks after which load at any</span>
<span class="cm"> * particular idx is approximated to be zero.</span>
<span class="cm"> * degrade_factor is a precomputed table, a row for each load idx.</span>
<span class="cm"> * Each column corresponds to degradation factor for a power of two ticks,</span>
<span class="cm"> * based on 128 point scale.</span>
<span class="cm"> * Example:</span>
<span class="cm"> * row 2, col 3 (=12) says that the degradation at load idx 2 after</span>
<span class="cm"> * 8 ticks is 12/128 (which is an approximation of exact factor 3^8/4^8).</span>
<span class="cm"> *</span>
<span class="cm"> * With this power of 2 load factors, we can degrade the load n times</span>
<span class="cm"> * by looking at 1 bits in n and doing as many mult/shift instead of</span>
<span class="cm"> * n mult/shifts needed by the exact degradation.</span>
<span class="cm"> */</span>
<span class="cp">#define DEGRADE_SHIFT		7</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span>
		<span class="n">degrade_zero_ticks</span><span class="p">[</span><span class="n">CPU_LOAD_IDX_MAX</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span>
		<span class="n">degrade_factor</span><span class="p">[</span><span class="n">CPU_LOAD_IDX_MAX</span><span class="p">][</span><span class="n">DEGRADE_SHIFT</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
					<span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
					<span class="p">{</span><span class="mi">64</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
					<span class="p">{</span><span class="mi">96</span><span class="p">,</span> <span class="mi">72</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
					<span class="p">{</span><span class="mi">112</span><span class="p">,</span> <span class="mi">98</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="mi">43</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
					<span class="p">{</span><span class="mi">120</span><span class="p">,</span> <span class="mi">112</span><span class="p">,</span> <span class="mi">98</span><span class="p">,</span> <span class="mi">76</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span> <span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Update cpu_load for any missed ticks, due to tickless idle. The backlog</span>
<span class="cm"> * would be when CPU is idle and so we just decay the old load without</span>
<span class="cm"> * adding any new load.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">decay_load_missed</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">load</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">missed_updates</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">missed_updates</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">load</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">missed_updates</span> <span class="o">&gt;=</span> <span class="n">degrade_zero_ticks</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">load</span> <span class="o">&gt;&gt;</span> <span class="n">missed_updates</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">missed_updates</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">missed_updates</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">load</span> <span class="o">=</span> <span class="p">(</span><span class="n">load</span> <span class="o">*</span> <span class="n">degrade_factor</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="n">DEGRADE_SHIFT</span><span class="p">;</span>

		<span class="n">missed_updates</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">j</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">load</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Update rq-&gt;cpu_load[] statistics. This function is usually called every</span>
<span class="cm"> * scheduler tick (TICK_NSEC). With tickless idle this will not be called</span>
<span class="cm"> * every tick. We fix it up based on jiffies.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__update_cpu_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">this_load</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pending_updates</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">scale</span><span class="p">;</span>

	<span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">nr_load_updates</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Update our load: */</span>
	<span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">cpu_load</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_load</span><span class="p">;</span> <span class="cm">/* Fasttrack for idx 0 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CPU_LOAD_IDX_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">scale</span> <span class="o">+=</span> <span class="n">scale</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old_load</span><span class="p">,</span> <span class="n">new_load</span><span class="p">;</span>

		<span class="cm">/* scale is effectively 1 &lt;&lt; i now, and &gt;&gt; i divides by scale */</span>

		<span class="n">old_load</span> <span class="o">=</span> <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">cpu_load</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">old_load</span> <span class="o">=</span> <span class="n">decay_load_missed</span><span class="p">(</span><span class="n">old_load</span><span class="p">,</span> <span class="n">pending_updates</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">new_load</span> <span class="o">=</span> <span class="n">this_load</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Round up the averaging division if load is increasing. This</span>
<span class="cm">		 * prevents us from getting stuck on 9 if the load is 10, for</span>
<span class="cm">		 * example.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_load</span> <span class="o">&gt;</span> <span class="n">old_load</span><span class="p">)</span>
			<span class="n">new_load</span> <span class="o">+=</span> <span class="n">scale</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">cpu_load</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">old_load</span> <span class="o">*</span> <span class="p">(</span><span class="n">scale</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">new_load</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sched_avg_update</span><span class="p">(</span><span class="n">this_rq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NO_HZ</span>
<span class="cm">/*</span>
<span class="cm"> * There is no sane way to deal with nohz on smp when using jiffies because the</span>
<span class="cm"> * cpu doing the jiffies update might drift wrt the cpu doing the jiffy reading</span>
<span class="cm"> * causing off-by-one errors in observed deltas; {0,2} instead of {1,1}.</span>
<span class="cm"> *</span>
<span class="cm"> * Therefore we cannot use the delta approach from the regular tick since that</span>
<span class="cm"> * would seriously skew the load calculation. However we&#39;ll make do for those</span>
<span class="cm"> * updates happening while idle (nohz_idle_balance) or coming out of idle</span>
<span class="cm"> * (tick_nohz_idle_exit).</span>
<span class="cm"> *</span>
<span class="cm"> * This means we might still be one tick off for nohz periods.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Called from nohz_idle_balance() to update the load ratings before doing the</span>
<span class="cm"> * idle balance.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">update_idle_cpu_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">curr_jiffies</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">jiffies</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">load</span> <span class="o">=</span> <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pending_updates</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * bail if there&#39;s load or we&#39;re actually up-to-date.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">load</span> <span class="o">||</span> <span class="n">curr_jiffies</span> <span class="o">==</span> <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">last_load_update_tick</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pending_updates</span> <span class="o">=</span> <span class="n">curr_jiffies</span> <span class="o">-</span> <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">last_load_update_tick</span><span class="p">;</span>
	<span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">last_load_update_tick</span> <span class="o">=</span> <span class="n">curr_jiffies</span><span class="p">;</span>

	<span class="n">__update_cpu_load</span><span class="p">(</span><span class="n">this_rq</span><span class="p">,</span> <span class="n">load</span><span class="p">,</span> <span class="n">pending_updates</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called from tick_nohz_idle_exit() -- try and fix up the ticks we missed.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">update_cpu_load_nohz</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span> <span class="o">=</span> <span class="n">this_rq</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">curr_jiffies</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">jiffies</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pending_updates</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">curr_jiffies</span> <span class="o">==</span> <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">last_load_update_tick</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">pending_updates</span> <span class="o">=</span> <span class="n">curr_jiffies</span> <span class="o">-</span> <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">last_load_update_tick</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pending_updates</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">last_load_update_tick</span> <span class="o">=</span> <span class="n">curr_jiffies</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * We were idle, this means load 0, the current load might be</span>
<span class="cm">		 * !0 due to remote wakeups and the sort.</span>
<span class="cm">		 */</span>
		<span class="n">__update_cpu_load</span><span class="p">(</span><span class="n">this_rq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pending_updates</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_NO_HZ */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Called from scheduler_tick()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_cpu_load_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * See the mess around update_idle_cpu_load() / update_cpu_load_nohz().</span>
<span class="cm">	 */</span>
	<span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">last_load_update_tick</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">__update_cpu_load</span><span class="p">(</span><span class="n">this_rq</span><span class="p">,</span> <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">calc_load_account_active</span><span class="p">(</span><span class="n">this_rq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SMP</span>

<span class="cm">/*</span>
<span class="cm"> * sched_exec - execve() is a valuable balancing opportunity, because at</span>
<span class="cm"> * this point the task has the smallest effective memory and cache footprint.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sched_exec</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dest_cpu</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">dest_cpu</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">select_task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">SD_BALANCE_EXEC</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dest_cpu</span> <span class="o">==</span> <span class="n">smp_processor_id</span><span class="p">())</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">cpu_active</span><span class="p">(</span><span class="n">dest_cpu</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">migration_arg</span> <span class="n">arg</span> <span class="o">=</span> <span class="p">{</span> <span class="n">p</span><span class="p">,</span> <span class="n">dest_cpu</span> <span class="p">};</span>

		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">stop_one_cpu</span><span class="p">(</span><span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">migration_cpu_stop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">unlock:</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">kernel_stat</span><span class="p">,</span> <span class="n">kstat</span><span class="p">);</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">kernel_cpustat</span><span class="p">,</span> <span class="n">kernel_cpustat</span><span class="p">);</span>

<span class="n">EXPORT_PER_CPU_SYMBOL</span><span class="p">(</span><span class="n">kstat</span><span class="p">);</span>
<span class="n">EXPORT_PER_CPU_SYMBOL</span><span class="p">(</span><span class="n">kernel_cpustat</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Return any ns on the sched_clock that have not yet been accounted in</span>
<span class="cm"> * @p in case that task is currently running.</span>
<span class="cm"> *</span>
<span class="cm"> * Called with task_rq_lock() held on @rq.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="nf">do_task_delta_exec</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">ns</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task_current</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
		<span class="n">ns</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">clock_task</span> <span class="o">-</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">exec_start</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">s64</span><span class="p">)</span><span class="n">ns</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ns</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ns</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">task_delta_exec</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ns</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rq</span> <span class="o">=</span> <span class="n">task_rq_lock</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">ns</span> <span class="o">=</span> <span class="n">do_task_delta_exec</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
	<span class="n">task_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ns</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return accounted runtime for the task.</span>
<span class="cm"> * In case the task is currently running, return the runtime plus current&#39;s</span>
<span class="cm"> * pending runtime that have not been accounted yet.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">task_sched_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ns</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rq</span> <span class="o">=</span> <span class="n">task_rq_lock</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">ns</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">sum_exec_runtime</span> <span class="o">+</span> <span class="n">do_task_delta_exec</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
	<span class="n">task_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ns</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_CGROUP_CPUACCT</span>
<span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="n">cpuacct_subsys</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">cpuacct</span> <span class="n">root_cpuacct</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">task_group_account_field</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span>
					    <span class="n">u64</span> <span class="n">tmp</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_CGROUP_CPUACCT</span>
	<span class="k">struct</span> <span class="n">kernel_cpustat</span> <span class="o">*</span><span class="n">kcpustat</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpuacct</span> <span class="o">*</span><span class="n">ca</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 * Since all updates are sure to touch the root cgroup, we</span>
<span class="cm">	 * get ourselves ahead and touch it first. If the root cgroup</span>
<span class="cm">	 * is the only cgroup, then nothing else should be necessary.</span>
<span class="cm">	 *</span>
<span class="cm">	 */</span>
	<span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">kernel_cpustat</span><span class="p">).</span><span class="n">cpustat</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tmp</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_CGROUP_CPUACCT</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">cpuacct_subsys</span><span class="p">.</span><span class="n">active</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">ca</span> <span class="o">=</span> <span class="n">task_ca</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ca</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ca</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">root_cpuacct</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kcpustat</span> <span class="o">=</span> <span class="n">this_cpu_ptr</span><span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">cpustat</span><span class="p">);</span>
		<span class="n">kcpustat</span><span class="o">-&gt;</span><span class="n">cpustat</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="n">ca</span> <span class="o">=</span> <span class="n">parent_ca</span><span class="p">(</span><span class="n">ca</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="cp">#endif</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Account user cpu time to a process.</span>
<span class="cm"> * @p: the process that the cpu time gets accounted to</span>
<span class="cm"> * @cputime: the cpu time spent in user space since the last update</span>
<span class="cm"> * @cputime_scaled: cputime scaled by cpu frequency</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">account_user_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">cputime_t</span> <span class="n">cputime</span><span class="p">,</span>
		       <span class="n">cputime_t</span> <span class="n">cputime_scaled</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="cm">/* Add user time to process. */</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">utime</span> <span class="o">+=</span> <span class="n">cputime</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">utimescaled</span> <span class="o">+=</span> <span class="n">cputime_scaled</span><span class="p">;</span>
	<span class="n">account_group_user_time</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cputime</span><span class="p">);</span>

	<span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">TASK_NICE</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">CPUTIME_NICE</span> <span class="o">:</span> <span class="n">CPUTIME_USER</span><span class="p">;</span>

	<span class="cm">/* Add user time to cpustat. */</span>
	<span class="n">task_group_account_field</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">__force</span> <span class="n">u64</span><span class="p">)</span> <span class="n">cputime</span><span class="p">);</span>

	<span class="cm">/* Account for user time used */</span>
	<span class="n">acct_update_integrals</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Account guest cpu time to a process.</span>
<span class="cm"> * @p: the process that the cpu time gets accounted to</span>
<span class="cm"> * @cputime: the cpu time spent in virtual machine since the last update</span>
<span class="cm"> * @cputime_scaled: cputime scaled by cpu frequency</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">account_guest_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">cputime_t</span> <span class="n">cputime</span><span class="p">,</span>
			       <span class="n">cputime_t</span> <span class="n">cputime_scaled</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">cpustat</span> <span class="o">=</span> <span class="n">kcpustat_this_cpu</span><span class="o">-&gt;</span><span class="n">cpustat</span><span class="p">;</span>

	<span class="cm">/* Add guest time to process. */</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">utime</span> <span class="o">+=</span> <span class="n">cputime</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">utimescaled</span> <span class="o">+=</span> <span class="n">cputime_scaled</span><span class="p">;</span>
	<span class="n">account_group_user_time</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cputime</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">gtime</span> <span class="o">+=</span> <span class="n">cputime</span><span class="p">;</span>

	<span class="cm">/* Add guest time to cpustat. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TASK_NICE</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpustat</span><span class="p">[</span><span class="n">CPUTIME_NICE</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">u64</span><span class="p">)</span> <span class="n">cputime</span><span class="p">;</span>
		<span class="n">cpustat</span><span class="p">[</span><span class="n">CPUTIME_GUEST_NICE</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">u64</span><span class="p">)</span> <span class="n">cputime</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cpustat</span><span class="p">[</span><span class="n">CPUTIME_USER</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">u64</span><span class="p">)</span> <span class="n">cputime</span><span class="p">;</span>
		<span class="n">cpustat</span><span class="p">[</span><span class="n">CPUTIME_GUEST</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">u64</span><span class="p">)</span> <span class="n">cputime</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Account system cpu time to a process and desired cpustat field</span>
<span class="cm"> * @p: the process that the cpu time gets accounted to</span>
<span class="cm"> * @cputime: the cpu time spent in kernel space since the last update</span>
<span class="cm"> * @cputime_scaled: cputime scaled by cpu frequency</span>
<span class="cm"> * @target_cputime64: pointer to cpustat field that has to be updated</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">__account_system_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">cputime_t</span> <span class="n">cputime</span><span class="p">,</span>
			<span class="n">cputime_t</span> <span class="n">cputime_scaled</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Add system time to process. */</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">stime</span> <span class="o">+=</span> <span class="n">cputime</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">stimescaled</span> <span class="o">+=</span> <span class="n">cputime_scaled</span><span class="p">;</span>
	<span class="n">account_group_system_time</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cputime</span><span class="p">);</span>

	<span class="cm">/* Add system time to cpustat. */</span>
	<span class="n">task_group_account_field</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">__force</span> <span class="n">u64</span><span class="p">)</span> <span class="n">cputime</span><span class="p">);</span>

	<span class="cm">/* Account for system time used */</span>
	<span class="n">acct_update_integrals</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Account system cpu time to a process.</span>
<span class="cm"> * @p: the process that the cpu time gets accounted to</span>
<span class="cm"> * @hardirq_offset: the offset to subtract from hardirq_count()</span>
<span class="cm"> * @cputime: the cpu time spent in kernel space since the last update</span>
<span class="cm"> * @cputime_scaled: cputime scaled by cpu frequency</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">account_system_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hardirq_offset</span><span class="p">,</span>
			 <span class="n">cputime_t</span> <span class="n">cputime</span><span class="p">,</span> <span class="n">cputime_t</span> <span class="n">cputime_scaled</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_VCPU</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">irq_count</span><span class="p">()</span> <span class="o">-</span> <span class="n">hardirq_offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">account_guest_time</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cputime</span><span class="p">,</span> <span class="n">cputime_scaled</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hardirq_count</span><span class="p">()</span> <span class="o">-</span> <span class="n">hardirq_offset</span><span class="p">)</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">CPUTIME_IRQ</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">in_serving_softirq</span><span class="p">())</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">CPUTIME_SOFTIRQ</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">CPUTIME_SYSTEM</span><span class="p">;</span>

	<span class="n">__account_system_time</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cputime</span><span class="p">,</span> <span class="n">cputime_scaled</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Account for involuntary wait time.</span>
<span class="cm"> * @cputime: the cpu time spent in involuntary wait</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">account_steal_time</span><span class="p">(</span><span class="n">cputime_t</span> <span class="n">cputime</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">cpustat</span> <span class="o">=</span> <span class="n">kcpustat_this_cpu</span><span class="o">-&gt;</span><span class="n">cpustat</span><span class="p">;</span>

	<span class="n">cpustat</span><span class="p">[</span><span class="n">CPUTIME_STEAL</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">u64</span><span class="p">)</span> <span class="n">cputime</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Account for idle time.</span>
<span class="cm"> * @cputime: the cpu time spent in idle wait</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">account_idle_time</span><span class="p">(</span><span class="n">cputime_t</span> <span class="n">cputime</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">cpustat</span> <span class="o">=</span> <span class="n">kcpustat_this_cpu</span><span class="o">-&gt;</span><span class="n">cpustat</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">this_rq</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_iowait</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">cpustat</span><span class="p">[</span><span class="n">CPUTIME_IOWAIT</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">u64</span><span class="p">)</span> <span class="n">cputime</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">cpustat</span><span class="p">[</span><span class="n">CPUTIME_IDLE</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">u64</span><span class="p">)</span> <span class="n">cputime</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__always_inline</span> <span class="n">bool</span> <span class="nf">steal_account_process_tick</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_PARAVIRT</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">static_key_false</span><span class="p">(</span><span class="o">&amp;</span><span class="n">paravirt_steal_enabled</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">steal</span><span class="p">,</span> <span class="n">st</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">steal</span> <span class="o">=</span> <span class="n">paravirt_steal_clock</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">());</span>
		<span class="n">steal</span> <span class="o">-=</span> <span class="n">this_rq</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">prev_steal_time</span><span class="p">;</span>

		<span class="n">st</span> <span class="o">=</span> <span class="n">steal_ticks</span><span class="p">(</span><span class="n">steal</span><span class="p">);</span>
		<span class="n">this_rq</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">prev_steal_time</span> <span class="o">+=</span> <span class="n">st</span> <span class="o">*</span> <span class="n">TICK_NSEC</span><span class="p">;</span>

		<span class="n">account_steal_time</span><span class="p">(</span><span class="n">st</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">st</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifndef CONFIG_VIRT_CPU_ACCOUNTING</span>

<span class="cp">#ifdef CONFIG_IRQ_TIME_ACCOUNTING</span>
<span class="cm">/*</span>
<span class="cm"> * Account a tick to a process and cpustat</span>
<span class="cm"> * @p: the process that the cpu time gets accounted to</span>
<span class="cm"> * @user_tick: is the tick from userspace</span>
<span class="cm"> * @rq: the pointer to rq</span>
<span class="cm"> *</span>
<span class="cm"> * Tick demultiplexing follows the order</span>
<span class="cm"> * - pending hardirq update</span>
<span class="cm"> * - pending softirq update</span>
<span class="cm"> * - user_time</span>
<span class="cm"> * - idle_time</span>
<span class="cm"> * - system time</span>
<span class="cm"> *   - check for guest_time</span>
<span class="cm"> *   - else account as system_time</span>
<span class="cm"> *</span>
<span class="cm"> * Check for hardirq is done both for system and user time as there is</span>
<span class="cm"> * no timer going off while we are on hardirq and hence we may never get an</span>
<span class="cm"> * opportunity to update it solely in system time.</span>
<span class="cm"> * p-&gt;stime and friends are only updated on system time and not on irq</span>
<span class="cm"> * softirq as those do not count in task exec_runtime any more.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irqtime_account_process_tick</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">user_tick</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cputime_t</span> <span class="n">one_jiffy_scaled</span> <span class="o">=</span> <span class="n">cputime_to_scaled</span><span class="p">(</span><span class="n">cputime_one_jiffy</span><span class="p">);</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">cpustat</span> <span class="o">=</span> <span class="n">kcpustat_this_cpu</span><span class="o">-&gt;</span><span class="n">cpustat</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">steal_account_process_tick</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irqtime_account_hi_update</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">cpustat</span><span class="p">[</span><span class="n">CPUTIME_IRQ</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">u64</span><span class="p">)</span> <span class="n">cputime_one_jiffy</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">irqtime_account_si_update</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">cpustat</span><span class="p">[</span><span class="n">CPUTIME_SOFTIRQ</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">u64</span><span class="p">)</span> <span class="n">cputime_one_jiffy</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">this_cpu_ksoftirqd</span><span class="p">()</span> <span class="o">==</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * ksoftirqd time do not get accounted in cpu_softirq_time.</span>
<span class="cm">		 * So, we have to handle it separately here.</span>
<span class="cm">		 * Also, p-&gt;stime needs to be updated for ksoftirqd.</span>
<span class="cm">		 */</span>
		<span class="n">__account_system_time</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cputime_one_jiffy</span><span class="p">,</span> <span class="n">one_jiffy_scaled</span><span class="p">,</span>
					<span class="n">CPUTIME_SOFTIRQ</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">user_tick</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">account_user_time</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cputime_one_jiffy</span><span class="p">,</span> <span class="n">one_jiffy_scaled</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">idle</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">account_idle_time</span><span class="p">(</span><span class="n">cputime_one_jiffy</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_VCPU</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* System time or guest time */</span>
		<span class="n">account_guest_time</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cputime_one_jiffy</span><span class="p">,</span> <span class="n">one_jiffy_scaled</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">__account_system_time</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cputime_one_jiffy</span><span class="p">,</span> <span class="n">one_jiffy_scaled</span><span class="p">,</span>
					<span class="n">CPUTIME_SYSTEM</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">irqtime_account_idle_ticks</span><span class="p">(</span><span class="kt">int</span> <span class="n">ticks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">this_rq</span><span class="p">();</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ticks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">irqtime_account_process_tick</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_IRQ_TIME_ACCOUNTING */</span><span class="cp"></span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irqtime_account_idle_ticks</span><span class="p">(</span><span class="kt">int</span> <span class="n">ticks</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irqtime_account_process_tick</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">user_tick</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span> <span class="p">{}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_IRQ_TIME_ACCOUNTING */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Account a single tick of cpu time.</span>
<span class="cm"> * @p: the process that the cpu time gets accounted to</span>
<span class="cm"> * @user_tick: indicates if the tick is a user or a system tick</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">account_process_tick</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">user_tick</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cputime_t</span> <span class="n">one_jiffy_scaled</span> <span class="o">=</span> <span class="n">cputime_to_scaled</span><span class="p">(</span><span class="n">cputime_one_jiffy</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">this_rq</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sched_clock_irqtime</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">irqtime_account_process_tick</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">user_tick</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">steal_account_process_tick</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">user_tick</span><span class="p">)</span>
		<span class="n">account_user_time</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cputime_one_jiffy</span><span class="p">,</span> <span class="n">one_jiffy_scaled</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">p</span> <span class="o">!=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">idle</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">irq_count</span><span class="p">()</span> <span class="o">!=</span> <span class="n">HARDIRQ_OFFSET</span><span class="p">))</span>
		<span class="n">account_system_time</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">HARDIRQ_OFFSET</span><span class="p">,</span> <span class="n">cputime_one_jiffy</span><span class="p">,</span>
				    <span class="n">one_jiffy_scaled</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">account_idle_time</span><span class="p">(</span><span class="n">cputime_one_jiffy</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Account multiple ticks of steal time.</span>
<span class="cm"> * @p: the process from which the cpu time has been stolen</span>
<span class="cm"> * @ticks: number of stolen ticks</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">account_steal_ticks</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ticks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">account_steal_time</span><span class="p">(</span><span class="n">jiffies_to_cputime</span><span class="p">(</span><span class="n">ticks</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Account multiple ticks of idle time.</span>
<span class="cm"> * @ticks: number of stolen ticks</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">account_idle_ticks</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ticks</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sched_clock_irqtime</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">irqtime_account_idle_ticks</span><span class="p">(</span><span class="n">ticks</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">account_idle_time</span><span class="p">(</span><span class="n">jiffies_to_cputime</span><span class="p">(</span><span class="n">ticks</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Use precise platform statistics if available:</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_VIRT_CPU_ACCOUNTING</span>
<span class="kt">void</span> <span class="nf">task_times</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">cputime_t</span> <span class="o">*</span><span class="n">ut</span><span class="p">,</span> <span class="n">cputime_t</span> <span class="o">*</span><span class="n">st</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">ut</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">utime</span><span class="p">;</span>
	<span class="o">*</span><span class="n">st</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">stime</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">thread_group_times</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">cputime_t</span> <span class="o">*</span><span class="n">ut</span><span class="p">,</span> <span class="n">cputime_t</span> <span class="o">*</span><span class="n">st</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_cputime</span> <span class="n">cputime</span><span class="p">;</span>

	<span class="n">thread_group_cputime</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cputime</span><span class="p">);</span>

	<span class="o">*</span><span class="n">ut</span> <span class="o">=</span> <span class="n">cputime</span><span class="p">.</span><span class="n">utime</span><span class="p">;</span>
	<span class="o">*</span><span class="n">st</span> <span class="o">=</span> <span class="n">cputime</span><span class="p">.</span><span class="n">stime</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>

<span class="cp">#ifndef nsecs_to_cputime</span>
<span class="cp"># define nsecs_to_cputime(__nsecs)	nsecs_to_jiffies(__nsecs)</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="nf">task_times</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">cputime_t</span> <span class="o">*</span><span class="n">ut</span><span class="p">,</span> <span class="n">cputime_t</span> <span class="o">*</span><span class="n">st</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cputime_t</span> <span class="n">rtime</span><span class="p">,</span> <span class="n">utime</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">utime</span><span class="p">,</span> <span class="n">total</span> <span class="o">=</span> <span class="n">utime</span> <span class="o">+</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">stime</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Use CFS&#39;s precise accounting:</span>
<span class="cm">	 */</span>
	<span class="n">rtime</span> <span class="o">=</span> <span class="n">nsecs_to_cputime</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">sum_exec_runtime</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">total</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">u64</span><span class="p">)</span> <span class="n">rtime</span><span class="p">;</span>

		<span class="n">temp</span> <span class="o">*=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">u64</span><span class="p">)</span> <span class="n">utime</span><span class="p">;</span>
		<span class="n">do_div</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="p">(</span><span class="n">__force</span> <span class="n">u32</span><span class="p">)</span> <span class="n">total</span><span class="p">);</span>
		<span class="n">utime</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">cputime_t</span><span class="p">)</span> <span class="n">temp</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">utime</span> <span class="o">=</span> <span class="n">rtime</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Compare with previous values, to keep monotonicity:</span>
<span class="cm">	 */</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">prev_utime</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">prev_utime</span><span class="p">,</span> <span class="n">utime</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">prev_stime</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">prev_stime</span><span class="p">,</span> <span class="n">rtime</span> <span class="o">-</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prev_utime</span><span class="p">);</span>

	<span class="o">*</span><span class="n">ut</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prev_utime</span><span class="p">;</span>
	<span class="o">*</span><span class="n">st</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prev_stime</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Must be called with siglock held.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">thread_group_times</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">cputime_t</span> <span class="o">*</span><span class="n">ut</span><span class="p">,</span> <span class="n">cputime_t</span> <span class="o">*</span><span class="n">st</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">signal_struct</span> <span class="o">*</span><span class="n">sig</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_cputime</span> <span class="n">cputime</span><span class="p">;</span>
	<span class="n">cputime_t</span> <span class="n">rtime</span><span class="p">,</span> <span class="n">utime</span><span class="p">,</span> <span class="n">total</span><span class="p">;</span>

	<span class="n">thread_group_cputime</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cputime</span><span class="p">);</span>

	<span class="n">total</span> <span class="o">=</span> <span class="n">cputime</span><span class="p">.</span><span class="n">utime</span> <span class="o">+</span> <span class="n">cputime</span><span class="p">.</span><span class="n">stime</span><span class="p">;</span>
	<span class="n">rtime</span> <span class="o">=</span> <span class="n">nsecs_to_cputime</span><span class="p">(</span><span class="n">cputime</span><span class="p">.</span><span class="n">sum_exec_runtime</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">total</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">u64</span><span class="p">)</span> <span class="n">rtime</span><span class="p">;</span>

		<span class="n">temp</span> <span class="o">*=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">u64</span><span class="p">)</span> <span class="n">cputime</span><span class="p">.</span><span class="n">utime</span><span class="p">;</span>
		<span class="n">do_div</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="p">(</span><span class="n">__force</span> <span class="n">u32</span><span class="p">)</span> <span class="n">total</span><span class="p">);</span>
		<span class="n">utime</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">cputime_t</span><span class="p">)</span> <span class="n">temp</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">utime</span> <span class="o">=</span> <span class="n">rtime</span><span class="p">;</span>

	<span class="n">sig</span><span class="o">-&gt;</span><span class="n">prev_utime</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">prev_utime</span><span class="p">,</span> <span class="n">utime</span><span class="p">);</span>
	<span class="n">sig</span><span class="o">-&gt;</span><span class="n">prev_stime</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">prev_stime</span><span class="p">,</span> <span class="n">rtime</span> <span class="o">-</span> <span class="n">sig</span><span class="o">-&gt;</span><span class="n">prev_utime</span><span class="p">);</span>

	<span class="o">*</span><span class="n">ut</span> <span class="o">=</span> <span class="n">sig</span><span class="o">-&gt;</span><span class="n">prev_utime</span><span class="p">;</span>
	<span class="o">*</span><span class="n">st</span> <span class="o">=</span> <span class="n">sig</span><span class="o">-&gt;</span><span class="n">prev_stime</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * This function gets called by the timer code, with HZ frequency.</span>
<span class="cm"> * We call it with interrupts disabled.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">scheduler_tick</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">;</span>

	<span class="n">sched_clock_tick</span><span class="p">();</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="n">update_cpu_load_active</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="n">curr</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">task_tick</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">curr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">perf_event_task_tick</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">idle_balance</span> <span class="o">=</span> <span class="n">idle_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">trigger_load_balance</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="n">notrace</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">get_parent_ip</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in_lock_functions</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">CALLER_ADDR2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">in_lock_functions</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span>
			<span class="n">addr</span> <span class="o">=</span> <span class="n">CALLER_ADDR3</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if defined(CONFIG_PREEMPT) &amp;&amp; (defined(CONFIG_DEBUG_PREEMPT) || \</span>
<span class="cp">				defined(CONFIG_PREEMPT_TRACER))</span>

<span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">add_preempt_count</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_DEBUG_PREEMPT</span>
	<span class="cm">/*</span>
<span class="cm">	 * Underflow?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">((</span><span class="n">preempt_count</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">preempt_count</span><span class="p">()</span> <span class="o">+=</span> <span class="n">val</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_DEBUG_PREEMPT</span>
	<span class="cm">/*</span>
<span class="cm">	 * Spinlock count overflowing soon?</span>
<span class="cm">	 */</span>
	<span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">((</span><span class="n">preempt_count</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">PREEMPT_MASK</span><span class="p">)</span> <span class="o">&gt;=</span>
				<span class="n">PREEMPT_MASK</span> <span class="o">-</span> <span class="mi">10</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">preempt_count</span><span class="p">()</span> <span class="o">==</span> <span class="n">val</span><span class="p">)</span>
		<span class="n">trace_preempt_off</span><span class="p">(</span><span class="n">CALLER_ADDR0</span><span class="p">,</span> <span class="n">get_parent_ip</span><span class="p">(</span><span class="n">CALLER_ADDR1</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">add_preempt_count</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">sub_preempt_count</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_DEBUG_PREEMPT</span>
	<span class="cm">/*</span>
<span class="cm">	 * Underflow?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">(</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">preempt_count</span><span class="p">()))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Is the spinlock portion underflowing?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">((</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">PREEMPT_MASK</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="p">(</span><span class="n">preempt_count</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">PREEMPT_MASK</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">preempt_count</span><span class="p">()</span> <span class="o">==</span> <span class="n">val</span><span class="p">)</span>
		<span class="n">trace_preempt_on</span><span class="p">(</span><span class="n">CALLER_ADDR0</span><span class="p">,</span> <span class="n">get_parent_ip</span><span class="p">(</span><span class="n">CALLER_ADDR1</span><span class="p">));</span>
	<span class="n">preempt_count</span><span class="p">()</span> <span class="o">-=</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sub_preempt_count</span><span class="p">);</span>

<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Print scheduling while atomic bug:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">void</span> <span class="nf">__schedule_bug</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oops_in_progress</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;BUG: scheduling while atomic: %s/%d/0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">prev</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">preempt_count</span><span class="p">());</span>

	<span class="n">debug_show_held_locks</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
	<span class="n">print_modules</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irqs_disabled</span><span class="p">())</span>
		<span class="n">print_irqtrace_events</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
	<span class="n">dump_stack</span><span class="p">();</span>
	<span class="n">add_taint</span><span class="p">(</span><span class="n">TAINT_WARN</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Various schedule()-time debugging checks and statistics:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">schedule_debug</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Test if we are atomic. Since do_exit() needs to call into</span>
<span class="cm">	 * schedule() atomically, we ignore that path for now.</span>
<span class="cm">	 * Otherwise, whine if we are scheduling when we should not be.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">in_atomic_preempt_off</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">exit_state</span><span class="p">))</span>
		<span class="n">__schedule_bug</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
	<span class="n">rcu_sleep_check</span><span class="p">();</span>

	<span class="n">profile_hit</span><span class="p">(</span><span class="n">SCHED_PROFILING</span><span class="p">,</span> <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

	<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">this_rq</span><span class="p">(),</span> <span class="n">sched_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">put_prev_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">on_rq</span> <span class="o">||</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">skip_clock_update</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="n">prev</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">put_prev_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Pick up the highest-prio task:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span>
<span class="nf">pick_next_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sched_class</span> <span class="o">*</span><span class="n">class</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Optimization: we know that if all tasks are in</span>
<span class="cm">	 * the fair class we can call that function directly:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">==</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">.</span><span class="n">h_nr_running</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">fair_sched_class</span><span class="p">.</span><span class="n">pick_next_task</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">for_each_class</span><span class="p">(</span><span class="n">class</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">class</span><span class="o">-&gt;</span><span class="n">pick_next_task</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BUG</span><span class="p">();</span> <span class="cm">/* the idle class will always have a runnable task */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * __schedule() is the main scheduler function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__sched</span> <span class="nf">__schedule</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">switch_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

<span class="nl">need_resched:</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">rcu_note_context_switch</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">prev</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">;</span>

	<span class="n">schedule_debug</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sched_feat</span><span class="p">(</span><span class="n">HRTICK</span><span class="p">))</span>
		<span class="n">hrtick_clear</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>

	<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">switch_count</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">nivcsw</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">preempt_count</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">PREEMPT_ACTIVE</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">signal_pending_state</span><span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="n">prev</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">prev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_RUNNING</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">deactivate_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">DEQUEUE_SLEEP</span><span class="p">);</span>
			<span class="n">prev</span><span class="o">-&gt;</span><span class="n">on_rq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * If a worker went to sleep, notify and ask workqueue</span>
<span class="cm">			 * whether it wants to wake up a task to maintain</span>
<span class="cm">			 * concurrency.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_WQ_WORKER</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">to_wakeup</span><span class="p">;</span>

				<span class="n">to_wakeup</span> <span class="o">=</span> <span class="n">wq_worker_sleeping</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">to_wakeup</span><span class="p">)</span>
					<span class="n">try_to_wake_up_local</span><span class="p">(</span><span class="n">to_wakeup</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">switch_count</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">nvcsw</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pre_schedule</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_running</span><span class="p">))</span>
		<span class="n">idle_balance</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>

	<span class="n">put_prev_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>
	<span class="n">next</span> <span class="o">=</span> <span class="n">pick_next_task</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="n">clear_tsk_need_resched</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">skip_clock_update</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">prev</span> <span class="o">!=</span> <span class="n">next</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_switches</span><span class="o">++</span><span class="p">;</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
		<span class="o">++*</span><span class="n">switch_count</span><span class="p">;</span>

		<span class="n">context_switch</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span> <span class="cm">/* unlocks the rq */</span>
		<span class="cm">/*</span>
<span class="cm">		 * The context switch have flipped the stack from under us</span>
<span class="cm">		 * and restored the local variables which were saved when</span>
<span class="cm">		 * this task called schedule() in the past. prev == current</span>
<span class="cm">		 * is still correct, but it can be moved to another cpu/rq.</span>
<span class="cm">		 */</span>
		<span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
		<span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">post_schedule</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>

	<span class="n">sched_preempt_enable_no_resched</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">need_resched</span><span class="p">())</span>
		<span class="k">goto</span> <span class="n">need_resched</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sched_submit_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">||</span> <span class="n">tsk_is_pi_blocked</span><span class="p">(</span><span class="n">tsk</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we are going to sleep and we have plugged IO queued,</span>
<span class="cm">	 * make sure to submit it to avoid deadlocks.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blk_needs_flush_plug</span><span class="p">(</span><span class="n">tsk</span><span class="p">))</span>
		<span class="n">blk_schedule_flush_plug</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">__sched</span> <span class="nf">schedule</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

	<span class="n">sched_submit_work</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">__schedule</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">schedule</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * schedule_preempt_disabled - called with preemption disabled</span>
<span class="cm"> *</span>
<span class="cm"> * Returns with preemption disabled. Note: preempt_count must be 1</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__sched</span> <span class="nf">schedule_preempt_disabled</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sched_preempt_enable_no_resched</span><span class="p">();</span>
	<span class="n">schedule</span><span class="p">();</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_MUTEX_SPIN_ON_OWNER</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">owner_running</span><span class="p">(</span><span class="k">struct</span> <span class="n">mutex</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">owner</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">!=</span> <span class="n">owner</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ensure we emit the owner-&gt;on_cpu, dereference _after_ checking</span>
<span class="cm">	 * lock-&gt;owner still matches owner, if that fails, owner might</span>
<span class="cm">	 * point to free()d memory, if it still matches, the rcu_read_lock()</span>
<span class="cm">	 * ensures the memory stays valid.</span>
<span class="cm">	 */</span>
	<span class="n">barrier</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">owner</span><span class="o">-&gt;</span><span class="n">on_cpu</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Look out! &quot;owner&quot; is an entirely speculative pointer</span>
<span class="cm"> * access and not reliable.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">mutex_spin_on_owner</span><span class="p">(</span><span class="k">struct</span> <span class="n">mutex</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">owner</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sched_feat</span><span class="p">(</span><span class="n">OWNER_SPIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">owner_running</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">owner</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">need_resched</span><span class="p">())</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">arch_mutex_cpu_relax</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * We break out the loop above on need_resched() and when the</span>
<span class="cm">	 * owner changed, which is a sign for heavy contention. Return</span>
<span class="cm">	 * success only when lock-&gt;owner is NULL.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">lock</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PREEMPT</span>
<span class="cm">/*</span>
<span class="cm"> * this is the entry point to schedule() from in-kernel preemption</span>
<span class="cm"> * off of preempt_enable. Kernel preemptions off return from interrupt</span>
<span class="cm"> * occur there and call schedule directly.</span>
<span class="cm"> */</span>
<span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">__sched</span> <span class="n">notrace</span> <span class="nf">preempt_schedule</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">thread_info</span> <span class="o">*</span><span class="n">ti</span> <span class="o">=</span> <span class="n">current_thread_info</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there is a non-zero preempt_count or interrupts are disabled,</span>
<span class="cm">	 * we do not want to preempt the current task. Just return..</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">preempt_count</span> <span class="o">||</span> <span class="n">irqs_disabled</span><span class="p">()))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">add_preempt_count_notrace</span><span class="p">(</span><span class="n">PREEMPT_ACTIVE</span><span class="p">);</span>
		<span class="n">__schedule</span><span class="p">();</span>
		<span class="n">sub_preempt_count_notrace</span><span class="p">(</span><span class="n">PREEMPT_ACTIVE</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check again in case we missed a preemption opportunity</span>
<span class="cm">		 * between schedule and now.</span>
<span class="cm">		 */</span>
		<span class="n">barrier</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">need_resched</span><span class="p">());</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">preempt_schedule</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * this is the entry point to schedule() from kernel preemption</span>
<span class="cm"> * off of irq context.</span>
<span class="cm"> * Note, that this is called and return with irqs disabled. This will</span>
<span class="cm"> * protect us against recursive calling from irq.</span>
<span class="cm"> */</span>
<span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">__sched</span> <span class="nf">preempt_schedule_irq</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">thread_info</span> <span class="o">*</span><span class="n">ti</span> <span class="o">=</span> <span class="n">current_thread_info</span><span class="p">();</span>

	<span class="cm">/* Catch callers which need to be fixed */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">preempt_count</span> <span class="o">||</span> <span class="o">!</span><span class="n">irqs_disabled</span><span class="p">());</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">add_preempt_count</span><span class="p">(</span><span class="n">PREEMPT_ACTIVE</span><span class="p">);</span>
		<span class="n">local_irq_enable</span><span class="p">();</span>
		<span class="n">__schedule</span><span class="p">();</span>
		<span class="n">local_irq_disable</span><span class="p">();</span>
		<span class="n">sub_preempt_count</span><span class="p">(</span><span class="n">PREEMPT_ACTIVE</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check again in case we missed a preemption opportunity</span>
<span class="cm">		 * between schedule and now.</span>
<span class="cm">		 */</span>
		<span class="n">barrier</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">need_resched</span><span class="p">());</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_PREEMPT */</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">default_wake_function</span><span class="p">(</span><span class="n">wait_queue_t</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wake_flags</span><span class="p">,</span>
			  <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">try_to_wake_up</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">wake_flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">default_wake_function</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The core wakeup function. Non-exclusive wakeups (nr_exclusive == 0) just</span>
<span class="cm"> * wake everything up. If it&#39;s an exclusive wakeup (nr_exclusive == small +ve</span>
<span class="cm"> * number) then we wake all the non-exclusive tasks and one exclusive task.</span>
<span class="cm"> *</span>
<span class="cm"> * There are circumstances in which we can try to wake a task which has already</span>
<span class="cm"> * started to run but is not in state TASK_RUNNING. try_to_wake_up() returns</span>
<span class="cm"> * zero in this (rare) case, and we handle it by continuing to scan the queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__wake_up_common</span><span class="p">(</span><span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">nr_exclusive</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wake_flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wait_queue_t</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">task_list</span><span class="p">,</span> <span class="n">task_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">wake_flags</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_FLAG_EXCLUSIVE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!--</span><span class="n">nr_exclusive</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __wake_up - wake up threads blocked on a waitqueue.</span>
<span class="cm"> * @q: the waitqueue</span>
<span class="cm"> * @mode: which threads</span>
<span class="cm"> * @nr_exclusive: how many wake-one or wake-many threads to wake up</span>
<span class="cm"> * @key: is directly passed to the wakeup function</span>
<span class="cm"> *</span>
<span class="cm"> * It may be assumed that this function implies a write memory barrier before</span>
<span class="cm"> * changing the task state if and only if any tasks are woken up.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__wake_up</span><span class="p">(</span><span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">nr_exclusive</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__wake_up_common</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">nr_exclusive</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__wake_up</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Same as __wake_up but called with the spinlock in wait_queue_head_t held.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__wake_up_locked</span><span class="p">(</span><span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__wake_up_common</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__wake_up_locked</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">__wake_up_locked_key</span><span class="p">(</span><span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__wake_up_common</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__wake_up_locked_key</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __wake_up_sync_key - wake up threads blocked on a waitqueue.</span>
<span class="cm"> * @q: the waitqueue</span>
<span class="cm"> * @mode: which threads</span>
<span class="cm"> * @nr_exclusive: how many wake-one or wake-many threads to wake up</span>
<span class="cm"> * @key: opaque value to be passed to wakeup targets</span>
<span class="cm"> *</span>
<span class="cm"> * The sync wakeup differs that the waker knows that it will schedule</span>
<span class="cm"> * away soon, so while the target thread will be woken up, it will not</span>
<span class="cm"> * be migrated to another CPU - ie. the two threads are &#39;synchronized&#39;</span>
<span class="cm"> * with each other. This can prevent needless bouncing between CPUs.</span>
<span class="cm"> *</span>
<span class="cm"> * On UP it can prevent extra preemption.</span>
<span class="cm"> *</span>
<span class="cm"> * It may be assumed that this function implies a write memory barrier before</span>
<span class="cm"> * changing the task state if and only if any tasks are woken up.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__wake_up_sync_key</span><span class="p">(</span><span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">nr_exclusive</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wake_flags</span> <span class="o">=</span> <span class="n">WF_SYNC</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">nr_exclusive</span><span class="p">))</span>
		<span class="n">wake_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__wake_up_common</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">nr_exclusive</span><span class="p">,</span> <span class="n">wake_flags</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__wake_up_sync_key</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * __wake_up_sync - see __wake_up_sync_key()</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__wake_up_sync</span><span class="p">(</span><span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_exclusive</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__wake_up_sync_key</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">nr_exclusive</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__wake_up_sync</span><span class="p">);</span>	<span class="cm">/* For internal use only */</span>

<span class="cm">/**</span>
<span class="cm"> * complete: - signals a single thread waiting on this completion</span>
<span class="cm"> * @x:  holds the state of this particular completion</span>
<span class="cm"> *</span>
<span class="cm"> * This will wake up a single thread waiting on this completion. Threads will be</span>
<span class="cm"> * awakened in the same order in which they were queued.</span>
<span class="cm"> *</span>
<span class="cm"> * See also complete_all(), wait_for_completion() and related routines.</span>
<span class="cm"> *</span>
<span class="cm"> * It may be assumed that this function implies a write memory barrier before</span>
<span class="cm"> * changing the task state if and only if any tasks are woken up.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">x</span><span class="o">-&gt;</span><span class="n">done</span><span class="o">++</span><span class="p">;</span>
	<span class="n">__wake_up_common</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span> <span class="n">TASK_NORMAL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">complete</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * complete_all: - signals all threads waiting on this completion</span>
<span class="cm"> * @x:  holds the state of this particular completion</span>
<span class="cm"> *</span>
<span class="cm"> * This will wake up all threads waiting on this particular completion event.</span>
<span class="cm"> *</span>
<span class="cm"> * It may be assumed that this function implies a write memory barrier before</span>
<span class="cm"> * changing the task state if and only if any tasks are woken up.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">complete_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">x</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">+=</span> <span class="n">UINT_MAX</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
	<span class="n">__wake_up_common</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span> <span class="n">TASK_NORMAL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">complete_all</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">long</span> <span class="n">__sched</span>
<span class="nf">do_wait_for_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>

		<span class="n">__add_wait_queue_tail_exclusive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending_state</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">current</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">timeout</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">__set_current_state</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">timeout</span> <span class="o">=</span> <span class="n">schedule_timeout</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">&amp;&amp;</span> <span class="n">timeout</span><span class="p">);</span>
		<span class="n">__remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">x</span><span class="o">-&gt;</span><span class="n">done</span><span class="o">--</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">timeout</span> <span class="o">?:</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="n">__sched</span>
<span class="nf">wait_for_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">might_sleep</span><span class="p">();</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">do_wait_for_common</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">timeout</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * wait_for_completion: - waits for completion of a task</span>
<span class="cm"> * @x:  holds the state of this particular completion</span>
<span class="cm"> *</span>
<span class="cm"> * This waits to be signaled for completion of a specific task. It is NOT</span>
<span class="cm"> * interruptible and there is no timeout.</span>
<span class="cm"> *</span>
<span class="cm"> * See also similar routines (i.e. wait_for_completion_timeout()) with timeout</span>
<span class="cm"> * and interrupt capability. Also see complete().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__sched</span> <span class="nf">wait_for_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wait_for_common</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">MAX_SCHEDULE_TIMEOUT</span><span class="p">,</span> <span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">wait_for_completion</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * wait_for_completion_timeout: - waits for completion of a task (w/timeout)</span>
<span class="cm"> * @x:  holds the state of this particular completion</span>
<span class="cm"> * @timeout:  timeout value in jiffies</span>
<span class="cm"> *</span>
<span class="cm"> * This waits for either a completion of a specific task to be signaled or for a</span>
<span class="cm"> * specified timeout to expire. The timeout is in jiffies. It is not</span>
<span class="cm"> * interruptible.</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is 0 if timed out, and positive (at least 1, or number of</span>
<span class="cm"> * jiffies left till timeout) if completed.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__sched</span>
<span class="nf">wait_for_completion_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">wait_for_common</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">wait_for_completion_timeout</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * wait_for_completion_interruptible: - waits for completion of a task (w/intr)</span>
<span class="cm"> * @x:  holds the state of this particular completion</span>
<span class="cm"> *</span>
<span class="cm"> * This waits for completion of a specific task to be signaled. It is</span>
<span class="cm"> * interruptible.</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is -ERESTARTSYS if interrupted, 0 if completed.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__sched</span> <span class="nf">wait_for_completion_interruptible</span><span class="p">(</span><span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">t</span> <span class="o">=</span> <span class="n">wait_for_common</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">MAX_SCHEDULE_TIMEOUT</span><span class="p">,</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">t</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">wait_for_completion_interruptible</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * wait_for_completion_interruptible_timeout: - waits for completion (w/(to,intr))</span>
<span class="cm"> * @x:  holds the state of this particular completion</span>
<span class="cm"> * @timeout:  timeout value in jiffies</span>
<span class="cm"> *</span>
<span class="cm"> * This waits for either a completion of a specific task to be signaled or for a</span>
<span class="cm"> * specified timeout to expire. It is interruptible. The timeout is in jiffies.</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is -ERESTARTSYS if interrupted, 0 if timed out,</span>
<span class="cm"> * positive (at least 1, or number of jiffies left till timeout) if completed.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="n">__sched</span>
<span class="nf">wait_for_completion_interruptible_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">wait_for_common</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">wait_for_completion_interruptible_timeout</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * wait_for_completion_killable: - waits for completion of a task (killable)</span>
<span class="cm"> * @x:  holds the state of this particular completion</span>
<span class="cm"> *</span>
<span class="cm"> * This waits to be signaled for completion of a specific task. It can be</span>
<span class="cm"> * interrupted by a kill signal.</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is -ERESTARTSYS if interrupted, 0 if completed.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__sched</span> <span class="nf">wait_for_completion_killable</span><span class="p">(</span><span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">t</span> <span class="o">=</span> <span class="n">wait_for_common</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">MAX_SCHEDULE_TIMEOUT</span><span class="p">,</span> <span class="n">TASK_KILLABLE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">t</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">wait_for_completion_killable</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * wait_for_completion_killable_timeout: - waits for completion of a task (w/(to,killable))</span>
<span class="cm"> * @x:  holds the state of this particular completion</span>
<span class="cm"> * @timeout:  timeout value in jiffies</span>
<span class="cm"> *</span>
<span class="cm"> * This waits for either a completion of a specific task to be</span>
<span class="cm"> * signaled or for a specified timeout to expire. It can be</span>
<span class="cm"> * interrupted by a kill signal. The timeout is in jiffies.</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is -ERESTARTSYS if interrupted, 0 if timed out,</span>
<span class="cm"> * positive (at least 1, or number of jiffies left till timeout) if completed.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="n">__sched</span>
<span class="nf">wait_for_completion_killable_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">wait_for_common</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">TASK_KILLABLE</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">wait_for_completion_killable_timeout</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	try_wait_for_completion - try to decrement a completion without blocking</span>
<span class="cm"> *	@x:	completion structure</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns: 0 if a decrement cannot be done without blocking</span>
<span class="cm"> *		 1 if a decrement succeeded.</span>
<span class="cm"> *</span>
<span class="cm"> *	If a completion is being used as a counting completion,</span>
<span class="cm"> *	attempt to decrement the counter without blocking. This</span>
<span class="cm"> *	enables us to avoid waiting if the resource the completion</span>
<span class="cm"> *	is protecting is not available.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">try_wait_for_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">x</span><span class="o">-&gt;</span><span class="n">done</span><span class="o">--</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">try_wait_for_completion</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	completion_done - Test to see if a completion has any waiters</span>
<span class="cm"> *	@x:	completion structure</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns: 0 if there are waiters (wait_for_completion() in progress)</span>
<span class="cm"> *		 1 if there are no waiters.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">completion_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">completion_done</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">long</span> <span class="n">__sched</span>
<span class="nf">sleep_on_common</span><span class="p">(</span><span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">,</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">wait_queue_t</span> <span class="n">wait</span><span class="p">;</span>

	<span class="n">init_waitqueue_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>

	<span class="n">__set_current_state</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__add_wait_queue</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">schedule_timeout</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">__remove_wait_queue</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">timeout</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__sched</span> <span class="nf">interruptible_sleep_on</span><span class="p">(</span><span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sleep_on_common</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">,</span> <span class="n">MAX_SCHEDULE_TIMEOUT</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">interruptible_sleep_on</span><span class="p">);</span>

<span class="kt">long</span> <span class="n">__sched</span>
<span class="nf">interruptible_sleep_on_timeout</span><span class="p">(</span><span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sleep_on_common</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">interruptible_sleep_on_timeout</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__sched</span> <span class="nf">sleep_on</span><span class="p">(</span><span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sleep_on_common</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">,</span> <span class="n">MAX_SCHEDULE_TIMEOUT</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sleep_on</span><span class="p">);</span>

<span class="kt">long</span> <span class="n">__sched</span> <span class="nf">sleep_on_timeout</span><span class="p">(</span><span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sleep_on_common</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sleep_on_timeout</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_RT_MUTEXES</span>

<span class="cm">/*</span>
<span class="cm"> * rt_mutex_setprio - set the current priority of a task</span>
<span class="cm"> * @p: task</span>
<span class="cm"> * @prio: prio value (kernel-internal form)</span>
<span class="cm"> *</span>
<span class="cm"> * This function changes the &#39;effective&#39; priority of a task. It does</span>
<span class="cm"> * not touch -&gt;normal_prio like __setscheduler().</span>
<span class="cm"> *</span>
<span class="cm"> * Used by the rt_mutex code to implement priority inheritance logic.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">rt_mutex_setprio</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">oldprio</span><span class="p">,</span> <span class="n">on_rq</span><span class="p">,</span> <span class="n">running</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sched_class</span> <span class="o">*</span><span class="n">prev_class</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">prio</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">prio</span> <span class="o">&gt;</span> <span class="n">MAX_PRIO</span><span class="p">);</span>

	<span class="n">rq</span> <span class="o">=</span> <span class="n">__task_rq_lock</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Idle task boosting is a nono in general. There is one</span>
<span class="cm">	 * exception, when PREEMPT_RT and NOHZ is active:</span>
<span class="cm">	 *</span>
<span class="cm">	 * The idle task calls get_next_timer_interrupt() and holds</span>
<span class="cm">	 * the timer wheel base-&gt;lock on the CPU and another CPU wants</span>
<span class="cm">	 * to access the timer (probably to cancel it). We can safely</span>
<span class="cm">	 * ignore the boosting request, as the idle CPU runs this code</span>
<span class="cm">	 * with interrupts disabled and will complete the lock</span>
<span class="cm">	 * protected section without being interrupted. So there is no</span>
<span class="cm">	 * real need to boost.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">idle</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_blocked_on</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">trace_sched_pi_setprio</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">prio</span><span class="p">);</span>
	<span class="n">oldprio</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">;</span>
	<span class="n">prev_class</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="p">;</span>
	<span class="n">on_rq</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">;</span>
	<span class="n">running</span> <span class="o">=</span> <span class="n">task_current</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">on_rq</span><span class="p">)</span>
		<span class="n">dequeue_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">running</span><span class="p">)</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">put_prev_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rt_prio</span><span class="p">(</span><span class="n">prio</span><span class="p">))</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rt_sched_class</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fair_sched_class</span><span class="p">;</span>

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">=</span> <span class="n">prio</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">running</span><span class="p">)</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">set_curr_task</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">on_rq</span><span class="p">)</span>
		<span class="n">enqueue_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">oldprio</span> <span class="o">&lt;</span> <span class="n">prio</span> <span class="o">?</span> <span class="n">ENQUEUE_HEAD</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">check_class_changed</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">prev_class</span><span class="p">,</span> <span class="n">oldprio</span><span class="p">);</span>
<span class="nl">out_unlock:</span>
	<span class="n">__task_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>
<span class="kt">void</span> <span class="nf">set_user_nice</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">long</span> <span class="n">nice</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">old_prio</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">on_rq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">TASK_NICE</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="n">nice</span> <span class="o">||</span> <span class="n">nice</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">20</span> <span class="o">||</span> <span class="n">nice</span> <span class="o">&gt;</span> <span class="mi">19</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We have to be careful, if called from sys_setpriority(),</span>
<span class="cm">	 * the task might be in the middle of scheduling on another CPU.</span>
<span class="cm">	 */</span>
	<span class="n">rq</span> <span class="o">=</span> <span class="n">task_rq_lock</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * The RT priorities are set via sched_setscheduler(), but we still</span>
<span class="cm">	 * allow the &#39;normal&#39; nice value to be set - but as expected</span>
<span class="cm">	 * it wont have any effect on scheduling until the task is</span>
<span class="cm">	 * SCHED_FIFO/SCHED_RR:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task_has_rt_policy</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">static_prio</span> <span class="o">=</span> <span class="n">NICE_TO_PRIO</span><span class="p">(</span><span class="n">nice</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">on_rq</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">on_rq</span><span class="p">)</span>
		<span class="n">dequeue_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">static_prio</span> <span class="o">=</span> <span class="n">NICE_TO_PRIO</span><span class="p">(</span><span class="n">nice</span><span class="p">);</span>
	<span class="n">set_load_weight</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">old_prio</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">=</span> <span class="n">effective_prio</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">delta</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">-</span> <span class="n">old_prio</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">on_rq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">enqueue_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the task increased its priority or is running and</span>
<span class="cm">		 * lowered its priority, then reschedule its CPU:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">task_running</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">)))</span>
			<span class="n">resched_task</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out_unlock:</span>
	<span class="n">task_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">set_user_nice</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * can_nice - check if a task can reduce its nice value</span>
<span class="cm"> * @p: task</span>
<span class="cm"> * @nice: nice value</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">can_nice</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">nice</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* convert nice value [19,-20] to rlimit style value [1,40] */</span>
	<span class="kt">int</span> <span class="n">nice_rlim</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">-</span> <span class="n">nice</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">nice_rlim</span> <span class="o">&lt;=</span> <span class="n">task_rlimit</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">RLIMIT_NICE</span><span class="p">)</span> <span class="o">||</span>
		<span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_NICE</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#ifdef __ARCH_WANT_SYS_NICE</span>

<span class="cm">/*</span>
<span class="cm"> * sys_nice - change the priority of the current process.</span>
<span class="cm"> * @increment: priority increment</span>
<span class="cm"> *</span>
<span class="cm"> * sys_setpriority is a more generic, but much slower function that</span>
<span class="cm"> * does similar things.</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">nice</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">increment</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">nice</span><span class="p">,</span> <span class="n">retval</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setpriority might change our priority at the same moment.</span>
<span class="cm">	 * We don&#39;t have to worry. Conceptually one call occurs first</span>
<span class="cm">	 * and we have a single winner.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">increment</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">40</span><span class="p">)</span>
		<span class="n">increment</span> <span class="o">=</span> <span class="o">-</span><span class="mi">40</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">increment</span> <span class="o">&gt;</span> <span class="mi">40</span><span class="p">)</span>
		<span class="n">increment</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span>

	<span class="n">nice</span> <span class="o">=</span> <span class="n">TASK_NICE</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">+</span> <span class="n">increment</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nice</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">20</span><span class="p">)</span>
		<span class="n">nice</span> <span class="o">=</span> <span class="o">-</span><span class="mi">20</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nice</span> <span class="o">&gt;</span> <span class="mi">19</span><span class="p">)</span>
		<span class="n">nice</span> <span class="o">=</span> <span class="mi">19</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">increment</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">can_nice</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">nice</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">security_task_setnice</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">nice</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">set_user_nice</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">nice</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * task_prio - return the priority value of a given task.</span>
<span class="cm"> * @p: the task in question.</span>
<span class="cm"> *</span>
<span class="cm"> * This is the priority value as seen by users in /proc.</span>
<span class="cm"> * RT tasks are offset by -200. Normal tasks are centered</span>
<span class="cm"> * around 0, value goes from -16 to +15.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">task_prio</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">-</span> <span class="n">MAX_RT_PRIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * task_nice - return the nice value of a given task.</span>
<span class="cm"> * @p: the task in question.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">task_nice</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">TASK_NICE</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">task_nice</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * idle_cpu - is a given cpu idle currently?</span>
<span class="cm"> * @cpu: the processor in question.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">idle_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span> <span class="o">!=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">idle</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_running</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">llist_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">wake_list</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * idle_task - return the idle task for a given cpu.</span>
<span class="cm"> * @cpu: the processor in question.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">idle_task</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">idle</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * find_process_by_pid - find a process with a matching PID value.</span>
<span class="cm"> * @pid: the pid in question.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">find_process_by_pid</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pid</span> <span class="o">?</span> <span class="n">find_task_by_vpid</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span> <span class="o">:</span> <span class="n">current</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Actually do priority change: must hold rq lock. */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">__setscheduler</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">policy</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">=</span> <span class="n">policy</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">rt_priority</span> <span class="o">=</span> <span class="n">prio</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">normal_prio</span> <span class="o">=</span> <span class="n">normal_prio</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="cm">/* we are holding p-&gt;pi_lock already */</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">=</span> <span class="n">rt_mutex_getprio</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rt_prio</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">))</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rt_sched_class</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fair_sched_class</span><span class="p">;</span>
	<span class="n">set_load_weight</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * check the target process has a UID that matches the current process&#39;s</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">check_same_owner</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">(),</span> <span class="o">*</span><span class="n">pcred</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">match</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">pcred</span> <span class="o">=</span> <span class="n">__task_cred</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">match</span> <span class="o">=</span> <span class="p">(</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">,</span> <span class="n">pcred</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">)</span> <span class="o">||</span>
		 <span class="n">uid_eq</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">,</span> <span class="n">pcred</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">));</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">match</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__sched_setscheduler</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">policy</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">sched_param</span> <span class="o">*</span><span class="n">param</span><span class="p">,</span> <span class="n">bool</span> <span class="n">user</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">,</span> <span class="n">oldprio</span><span class="p">,</span> <span class="n">oldpolicy</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">on_rq</span><span class="p">,</span> <span class="n">running</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sched_class</span> <span class="o">*</span><span class="n">prev_class</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reset_on_fork</span><span class="p">;</span>

	<span class="cm">/* may grab non-irq protected spin_locks */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">in_interrupt</span><span class="p">());</span>
<span class="nl">recheck:</span>
	<span class="cm">/* double check policy once rq lock held */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">policy</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reset_on_fork</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_reset_on_fork</span><span class="p">;</span>
		<span class="n">policy</span> <span class="o">=</span> <span class="n">oldpolicy</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">policy</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">reset_on_fork</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">policy</span> <span class="o">&amp;</span> <span class="n">SCHED_RESET_ON_FORK</span><span class="p">);</span>
		<span class="n">policy</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SCHED_RESET_ON_FORK</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">policy</span> <span class="o">!=</span> <span class="n">SCHED_FIFO</span> <span class="o">&amp;&amp;</span> <span class="n">policy</span> <span class="o">!=</span> <span class="n">SCHED_RR</span> <span class="o">&amp;&amp;</span>
				<span class="n">policy</span> <span class="o">!=</span> <span class="n">SCHED_NORMAL</span> <span class="o">&amp;&amp;</span> <span class="n">policy</span> <span class="o">!=</span> <span class="n">SCHED_BATCH</span> <span class="o">&amp;&amp;</span>
				<span class="n">policy</span> <span class="o">!=</span> <span class="n">SCHED_IDLE</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Valid priorities for SCHED_FIFO and SCHED_RR are</span>
<span class="cm">	 * 1..MAX_USER_RT_PRIO-1, valid priority for SCHED_NORMAL,</span>
<span class="cm">	 * SCHED_BATCH and SCHED_IDLE is 0.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">param</span><span class="o">-&gt;</span><span class="n">sched_priority</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">&amp;&amp;</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">sched_priority</span> <span class="o">&gt;</span> <span class="n">MAX_USER_RT_PRIO</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">&amp;&amp;</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">sched_priority</span> <span class="o">&gt;</span> <span class="n">MAX_RT_PRIO</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rt_policy</span><span class="p">(</span><span class="n">policy</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">param</span><span class="o">-&gt;</span><span class="n">sched_priority</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allow unprivileged RT tasks to decrease priority:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">user</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_NICE</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rt_policy</span><span class="p">(</span><span class="n">policy</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rlim_rtprio</span> <span class="o">=</span>
					<span class="n">task_rlimit</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">RLIMIT_RTPRIO</span><span class="p">);</span>

			<span class="cm">/* can&#39;t set/change the rt policy */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">policy</span> <span class="o">!=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">rlim_rtprio</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

			<span class="cm">/* can&#39;t increase priority */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">param</span><span class="o">-&gt;</span><span class="n">sched_priority</span> <span class="o">&gt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rt_priority</span> <span class="o">&amp;&amp;</span>
			    <span class="n">param</span><span class="o">-&gt;</span><span class="n">sched_priority</span> <span class="o">&gt;</span> <span class="n">rlim_rtprio</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Treat SCHED_IDLE as nice 20. Only allow a switch to</span>
<span class="cm">		 * SCHED_NORMAL if the RLIMIT_NICE would normally permit it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">==</span> <span class="n">SCHED_IDLE</span> <span class="o">&amp;&amp;</span> <span class="n">policy</span> <span class="o">!=</span> <span class="n">SCHED_IDLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">can_nice</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">TASK_NICE</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* can&#39;t change other user&#39;s priorities */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_same_owner</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

		<span class="cm">/* Normal users shall not reset the sched_reset_on_fork flag */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_reset_on_fork</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">reset_on_fork</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">user</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">security_task_setscheduler</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * make sure no PI-waiters arrive (or leave) while we are</span>
<span class="cm">	 * changing the priority of the task:</span>
<span class="cm">	 *</span>
<span class="cm">	 * To be able to change p-&gt;policy safely, the appropriate</span>
<span class="cm">	 * runqueue lock must be held.</span>
<span class="cm">	 */</span>
	<span class="n">rq</span> <span class="o">=</span> <span class="n">task_rq_lock</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Changing the policy of the stop threads its a very bad idea</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">task_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If not changing anything there&#39;s no need to proceed further:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">policy</span> <span class="o">==</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">rt_policy</span><span class="p">(</span><span class="n">policy</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">param</span><span class="o">-&gt;</span><span class="n">sched_priority</span> <span class="o">==</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rt_priority</span><span class="p">)))</span> <span class="p">{</span>

		<span class="n">__task_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_RT_GROUP_SCHED</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">user</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Do not allow realtime tasks into groups that have no runtime</span>
<span class="cm">		 * assigned.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rt_bandwidth_enabled</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">rt_policy</span><span class="p">(</span><span class="n">policy</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="n">task_group</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rt_bandwidth</span><span class="p">.</span><span class="n">rt_runtime</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
				<span class="o">!</span><span class="n">task_group_is_autogroup</span><span class="p">(</span><span class="n">task_group</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">task_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* recheck policy now with rq lock held */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">oldpolicy</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">oldpolicy</span> <span class="o">!=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">policy</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">policy</span> <span class="o">=</span> <span class="n">oldpolicy</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">task_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">recheck</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">on_rq</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">;</span>
	<span class="n">running</span> <span class="o">=</span> <span class="n">task_current</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">on_rq</span><span class="p">)</span>
		<span class="n">dequeue_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">running</span><span class="p">)</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">put_prev_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_reset_on_fork</span> <span class="o">=</span> <span class="n">reset_on_fork</span><span class="p">;</span>

	<span class="n">oldprio</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">;</span>
	<span class="n">prev_class</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="p">;</span>
	<span class="n">__setscheduler</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">policy</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">sched_priority</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">running</span><span class="p">)</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">set_curr_task</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">on_rq</span><span class="p">)</span>
		<span class="n">enqueue_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">check_class_changed</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">prev_class</span><span class="p">,</span> <span class="n">oldprio</span><span class="p">);</span>
	<span class="n">task_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">rt_mutex_adjust_pi</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sched_setscheduler - change the scheduling policy and/or RT priority of a thread.</span>
<span class="cm"> * @p: the task in question.</span>
<span class="cm"> * @policy: new policy.</span>
<span class="cm"> * @param: structure containing the new RT priority.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE that the task may be already dead.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sched_setscheduler</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">policy</span><span class="p">,</span>
		       <span class="k">const</span> <span class="k">struct</span> <span class="n">sched_param</span> <span class="o">*</span><span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__sched_setscheduler</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">policy</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sched_setscheduler</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * sched_setscheduler_nocheck - change the scheduling policy and/or RT priority of a thread from kernelspace.</span>
<span class="cm"> * @p: the task in question.</span>
<span class="cm"> * @policy: new policy.</span>
<span class="cm"> * @param: structure containing the new RT priority.</span>
<span class="cm"> *</span>
<span class="cm"> * Just like sched_setscheduler, only don&#39;t bother checking if the</span>
<span class="cm"> * current context has permission.  For example, this is needed in</span>
<span class="cm"> * stop_machine(): we create temporary high priority worker threads,</span>
<span class="cm"> * but our caller might not have that capability.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sched_setscheduler_nocheck</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">policy</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">sched_param</span> <span class="o">*</span><span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__sched_setscheduler</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">policy</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">do_sched_setscheduler</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">policy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_param</span> <span class="n">__user</span> <span class="o">*</span><span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_param</span> <span class="n">lparam</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">param</span> <span class="o">||</span> <span class="n">pid</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lparam</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_param</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">find_process_by_pid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sched_setscheduler</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">policy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lparam</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sys_sched_setscheduler - set/change the scheduler policy and RT priority</span>
<span class="cm"> * @pid: the pid in question.</span>
<span class="cm"> * @policy: new policy.</span>
<span class="cm"> * @param: structure containing the new RT priority.</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">sched_setscheduler</span><span class="p">,</span> <span class="n">pid_t</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">policy</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">sched_param</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* negative values for policy are not valid */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">policy</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">do_sched_setscheduler</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">policy</span><span class="p">,</span> <span class="n">param</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sys_sched_setparam - set/change the RT priority of a thread</span>
<span class="cm"> * @pid: the pid in question.</span>
<span class="cm"> * @param: structure containing the new RT priority.</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">sched_setparam</span><span class="p">,</span> <span class="n">pid_t</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_param</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">do_sched_setscheduler</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">param</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sys_sched_getscheduler - get the policy (scheduling class) of a thread</span>
<span class="cm"> * @pid: the pid in question.</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">sched_getscheduler</span><span class="p">,</span> <span class="n">pid_t</span><span class="p">,</span> <span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">find_process_by_pid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">security_task_getscheduler</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">policy</span>
				<span class="o">|</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_reset_on_fork</span> <span class="o">?</span> <span class="n">SCHED_RESET_ON_FORK</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sys_sched_getparam - get the RT priority of a thread</span>
<span class="cm"> * @pid: the pid in question.</span>
<span class="cm"> * @param: structure containing the RT priority.</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">sched_getparam</span><span class="p">,</span> <span class="n">pid_t</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_param</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_param</span> <span class="n">lp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">param</span> <span class="o">||</span> <span class="n">pid</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">find_process_by_pid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">security_task_getscheduler</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">lp</span><span class="p">.</span><span class="n">sched_priority</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rt_priority</span><span class="p">;</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * This one might sleep, we cannot do it with a spinlock held ...</span>
<span class="cm">	 */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">param</span><span class="p">))</span> <span class="o">?</span> <span class="o">-</span><span class="n">EFAULT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

<span class="nl">out_unlock:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">long</span> <span class="n">sched_setaffinity</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">in_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpumask_var_t</span> <span class="n">cpus_allowed</span><span class="p">,</span> <span class="n">new_mask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">get_online_cpus</span><span class="p">();</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">find_process_by_pid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="n">put_online_cpus</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Prevent p going away */</span>
	<span class="n">get_task_struct</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpus_allowed</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_put_task</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_mask</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free_cpus_allowed</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_same_owner</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ns_capable</span><span class="p">(</span><span class="n">task_user_ns</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">CAP_SYS_NICE</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">security_task_setscheduler</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">cpuset_cpus_allowed</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cpus_allowed</span><span class="p">);</span>
	<span class="n">cpumask_and</span><span class="p">(</span><span class="n">new_mask</span><span class="p">,</span> <span class="n">in_mask</span><span class="p">,</span> <span class="n">cpus_allowed</span><span class="p">);</span>
<span class="nl">again:</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">set_cpus_allowed_ptr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">new_mask</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpuset_cpus_allowed</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cpus_allowed</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_subset</span><span class="p">(</span><span class="n">new_mask</span><span class="p">,</span> <span class="n">cpus_allowed</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We must have raced with a concurrent cpuset</span>
<span class="cm">			 * update. Just reset the cpus_allowed to the</span>
<span class="cm">			 * cpuset&#39;s cpus_allowed</span>
<span class="cm">			 */</span>
			<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">new_mask</span><span class="p">,</span> <span class="n">cpus_allowed</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out_unlock:</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">new_mask</span><span class="p">);</span>
<span class="nl">out_free_cpus_allowed:</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">cpus_allowed</span><span class="p">);</span>
<span class="nl">out_put_task:</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">put_online_cpus</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">get_user_cpu_mask</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_mask_ptr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">new_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">cpumask_size</span><span class="p">())</span>
		<span class="n">cpumask_clear</span><span class="p">(</span><span class="n">new_mask</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">cpumask_size</span><span class="p">())</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">cpumask_size</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="n">new_mask</span><span class="p">,</span> <span class="n">user_mask_ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="n">EFAULT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sys_sched_setaffinity - set the cpu affinity of a process</span>
<span class="cm"> * @pid: pid of the process</span>
<span class="cm"> * @len: length in bytes of the bitmask pointed to by user_mask_ptr</span>
<span class="cm"> * @user_mask_ptr: user-space pointer to the new cpu mask</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">sched_setaffinity</span><span class="p">,</span> <span class="n">pid_t</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">user_mask_ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpumask_var_t</span> <span class="n">new_mask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_mask</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">get_user_cpu_mask</span><span class="p">(</span><span class="n">user_mask_ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">new_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sched_setaffinity</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">new_mask</span><span class="p">);</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">new_mask</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">long</span> <span class="n">sched_getaffinity</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">get_online_cpus</span><span class="p">();</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">find_process_by_pid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">security_task_getscheduler</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">cpumask_and</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">,</span> <span class="n">cpu_online_mask</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

<span class="nl">out_unlock:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="n">put_online_cpus</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sys_sched_getaffinity - get the cpu affinity of a process</span>
<span class="cm"> * @pid: pid of the process</span>
<span class="cm"> * @len: length in bytes of the bitmask pointed to by user_mask_ptr</span>
<span class="cm"> * @user_mask_ptr: user-space pointer to hold the current cpu mask</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">sched_getaffinity</span><span class="p">,</span> <span class="n">pid_t</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">user_mask_ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">cpumask_var_t</span> <span class="n">mask</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">len</span> <span class="o">*</span> <span class="n">BITS_PER_BYTE</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">nr_cpu_ids</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&amp;</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mask</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">sched_getaffinity</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">retlen</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">cpumask_size</span><span class="p">());</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">user_mask_ptr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">retlen</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">retlen</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sys_sched_yield - yield the current processor to other threads.</span>
<span class="cm"> *</span>
<span class="cm"> * This function yields the current CPU to other tasks. If there are no</span>
<span class="cm"> * other threads running on this CPU then this function will return.</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE0</span><span class="p">(</span><span class="n">sched_yield</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">this_rq_lock</span><span class="p">();</span>

	<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">yld_count</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">yield_task</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since we are going to call schedule() anyway, there&#39;s</span>
<span class="cm">	 * no need to preempt or enable interrupts:</span>
<span class="cm">	 */</span>
	<span class="n">__release</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">spin_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">.</span><span class="n">dep_map</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_THIS_IP_</span><span class="p">);</span>
	<span class="n">do_raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">sched_preempt_enable_no_resched</span><span class="p">();</span>

	<span class="n">schedule</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">should_resched</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">need_resched</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">preempt_count</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">PREEMPT_ACTIVE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cond_resched</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">add_preempt_count</span><span class="p">(</span><span class="n">PREEMPT_ACTIVE</span><span class="p">);</span>
	<span class="n">__schedule</span><span class="p">();</span>
	<span class="n">sub_preempt_count</span><span class="p">(</span><span class="n">PREEMPT_ACTIVE</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__sched</span> <span class="n">_cond_resched</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">should_resched</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">__cond_resched</span><span class="p">();</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">_cond_resched</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * __cond_resched_lock() - if a reschedule is pending, drop the given lock,</span>
<span class="cm"> * call schedule, and on return reacquire the lock.</span>
<span class="cm"> *</span>
<span class="cm"> * This works OK both with and without CONFIG_PREEMPT. We do strange low-level</span>
<span class="cm"> * operations here to prevent schedule() from being called twice (once via</span>
<span class="cm"> * spin_unlock(), once by hand).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__cond_resched_lock</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">resched</span> <span class="o">=</span> <span class="n">should_resched</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spin_needbreak</span><span class="p">(</span><span class="n">lock</span><span class="p">)</span> <span class="o">||</span> <span class="n">resched</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">resched</span><span class="p">)</span>
			<span class="n">__cond_resched</span><span class="p">();</span>
		<span class="k">else</span>
			<span class="n">cpu_relax</span><span class="p">();</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__cond_resched_lock</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">__sched</span> <span class="nf">__cond_resched_softirq</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">in_softirq</span><span class="p">());</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">should_resched</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">local_bh_enable</span><span class="p">();</span>
		<span class="n">__cond_resched</span><span class="p">();</span>
		<span class="n">local_bh_disable</span><span class="p">();</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__cond_resched_softirq</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * yield - yield the current processor to other threads.</span>
<span class="cm"> *</span>
<span class="cm"> * Do not ever use this function, there&#39;s a 99% chance you&#39;re doing it wrong.</span>
<span class="cm"> *</span>
<span class="cm"> * The scheduler is at all times free to pick the calling task as the most</span>
<span class="cm"> * eligible task to run, if removing the yield() call from your code breaks</span>
<span class="cm"> * it, its already broken.</span>
<span class="cm"> *</span>
<span class="cm"> * Typical broken usage is:</span>
<span class="cm"> *</span>
<span class="cm"> * while (!event)</span>
<span class="cm"> * 	yield();</span>
<span class="cm"> *</span>
<span class="cm"> * where one assumes that yield() will let &#39;the other&#39; process run that will</span>
<span class="cm"> * make event true. If the current task is a SCHED_FIFO task that will never</span>
<span class="cm"> * happen. Never use yield() as a progress guarantee!!</span>
<span class="cm"> *</span>
<span class="cm"> * If you want to use yield() to wait for something, use wait_event().</span>
<span class="cm"> * If you want to use yield() to be &#39;nice&#39; for others, use cond_resched().</span>
<span class="cm"> * If you still want to use yield(), do not!</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__sched</span> <span class="nf">yield</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
	<span class="n">sys_sched_yield</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">yield</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * yield_to - yield the current processor to another thread in</span>
<span class="cm"> * your thread group, or accelerate that thread toward the</span>
<span class="cm"> * processor it&#39;s on.</span>
<span class="cm"> * @p: target task</span>
<span class="cm"> * @preempt: whether task preemption is allowed or not</span>
<span class="cm"> *</span>
<span class="cm"> * It&#39;s the caller&#39;s job to ensure that the target task struct</span>
<span class="cm"> * can&#39;t go away on us before we can do any checks.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns true if we indeed boosted the target task.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="n">__sched</span> <span class="nf">yield_to</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">bool</span> <span class="n">preempt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="o">*</span><span class="n">p_rq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">yielded</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">rq</span> <span class="o">=</span> <span class="n">this_rq</span><span class="p">();</span>

<span class="nl">again:</span>
	<span class="n">p_rq</span> <span class="o">=</span> <span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">double_rq_lock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p_rq</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">!=</span> <span class="n">p_rq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">double_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p_rq</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">yield_to_task</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">!=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task_running</span><span class="p">(</span><span class="n">p_rq</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">||</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">yielded</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">yield_to_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">preempt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">yielded</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">yld_count</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Make p&#39;s CPU reschedule; pick_next_entity takes care of</span>
<span class="cm">		 * fairness.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">preempt</span> <span class="o">&amp;&amp;</span> <span class="n">rq</span> <span class="o">!=</span> <span class="n">p_rq</span><span class="p">)</span>
			<span class="n">resched_task</span><span class="p">(</span><span class="n">p_rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We might have set it in task_yield_fair(), but are</span>
<span class="cm">		 * not going to schedule(), so don&#39;t want to skip</span>
<span class="cm">		 * the next update.</span>
<span class="cm">		 */</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">skip_clock_update</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">double_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p_rq</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">yielded</span><span class="p">)</span>
		<span class="n">schedule</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">yielded</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">yield_to</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * This task is about to go to sleep on IO. Increment rq-&gt;nr_iowait so</span>
<span class="cm"> * that process accounting knows that this is a task in IO wait state.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__sched</span> <span class="nf">io_schedule</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">raw_rq</span><span class="p">();</span>

	<span class="n">delayacct_blkio_start</span><span class="p">();</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_iowait</span><span class="p">);</span>
	<span class="n">blk_flush_plug</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">in_iowait</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">schedule</span><span class="p">();</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">in_iowait</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_iowait</span><span class="p">);</span>
	<span class="n">delayacct_blkio_end</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">io_schedule</span><span class="p">);</span>

<span class="kt">long</span> <span class="n">__sched</span> <span class="nf">io_schedule_timeout</span><span class="p">(</span><span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">raw_rq</span><span class="p">();</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">delayacct_blkio_start</span><span class="p">();</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_iowait</span><span class="p">);</span>
	<span class="n">blk_flush_plug</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">in_iowait</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">schedule_timeout</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">in_iowait</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_iowait</span><span class="p">);</span>
	<span class="n">delayacct_blkio_end</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sys_sched_get_priority_max - return maximum RT priority.</span>
<span class="cm"> * @policy: scheduling class.</span>
<span class="cm"> *</span>
<span class="cm"> * this syscall returns the maximum rt_priority that can be used</span>
<span class="cm"> * by a given scheduling class.</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">sched_get_priority_max</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">policy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">policy</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCHED_FIFO</span>:
	<span class="k">case</span> <span class="n">SCHED_RR</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">MAX_USER_RT_PRIO</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCHED_NORMAL</span>:
	<span class="k">case</span> <span class="n">SCHED_BATCH</span>:
	<span class="k">case</span> <span class="n">SCHED_IDLE</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sys_sched_get_priority_min - return minimum RT priority.</span>
<span class="cm"> * @policy: scheduling class.</span>
<span class="cm"> *</span>
<span class="cm"> * this syscall returns the minimum rt_priority that can be used</span>
<span class="cm"> * by a given scheduling class.</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">sched_get_priority_min</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">policy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">policy</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCHED_FIFO</span>:
	<span class="k">case</span> <span class="n">SCHED_RR</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCHED_NORMAL</span>:
	<span class="k">case</span> <span class="n">SCHED_BATCH</span>:
	<span class="k">case</span> <span class="n">SCHED_IDLE</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sys_sched_rr_get_interval - return the default timeslice of a process.</span>
<span class="cm"> * @pid: pid of the process.</span>
<span class="cm"> * @interval: userspace pointer to the timeslice value.</span>
<span class="cm"> *</span>
<span class="cm"> * this syscall writes the default timeslice value of a given process</span>
<span class="cm"> * into the user-space timespec buffer. A value of &#39;0&#39; means infinity.</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">sched_rr_get_interval</span><span class="p">,</span> <span class="n">pid_t</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">timespec</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">interval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">time_slice</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">t</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">find_process_by_pid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">security_task_getscheduler</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">rq</span> <span class="o">=</span> <span class="n">task_rq_lock</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">time_slice</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">get_rr_interval</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">task_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="n">jiffies_to_timespec</span><span class="p">(</span><span class="n">time_slice</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="o">?</span> <span class="o">-</span><span class="n">EFAULT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

<span class="nl">out_unlock:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">stat_nam</span><span class="p">[]</span> <span class="o">=</span> <span class="n">TASK_STATE_TO_CHAR_STR</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">sched_show_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">state</span><span class="p">;</span>

	<span class="n">state</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">?</span> <span class="n">__ffs</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%-15.15s %c&quot;</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span>
		<span class="n">state</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">stat_nam</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">?</span> <span class="n">stat_nam</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">:</span> <span class="sc">&#39;?&#39;</span><span class="p">);</span>
<span class="cp">#if BITS_PER_LONG == 32</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">TASK_RUNNING</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot; running  &quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot; %08lx &quot;</span><span class="p">,</span> <span class="n">thread_saved_pc</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
<span class="cp">#else</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">TASK_RUNNING</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;  running task    &quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot; %016lx &quot;</span><span class="p">,</span> <span class="n">thread_saved_pc</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_DEBUG_STACK_USAGE</span>
	<span class="n">free</span> <span class="o">=</span> <span class="n">stack_not_used</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;%5lu %5d %6d 0x%08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">free</span><span class="p">,</span>
		<span class="n">task_pid_nr</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">rcu_dereference</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">real_parent</span><span class="p">)),</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">task_thread_info</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">show_stack</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">show_state_filter</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">state_filter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">g</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

<span class="cp">#if BITS_PER_LONG == 32</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
		<span class="s">&quot;  task                PC stack   pid father</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
		<span class="s">&quot;  task                        PC stack   pid father</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">do_each_thread</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * reset the NMI-timeout, listing all files on a slow</span>
<span class="cm">		 * console might take a lot of time:</span>
<span class="cm">		 */</span>
		<span class="n">touch_nmi_watchdog</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state_filter</span> <span class="o">||</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">state_filter</span><span class="p">))</span>
			<span class="n">sched_show_task</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span> <span class="n">while_each_thread</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

	<span class="n">touch_all_softlockup_watchdogs</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_SCHED_DEBUG</span>
	<span class="n">sysrq_sched_debug_show</span><span class="p">();</span>
<span class="cp">#endif</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * Only show locks if all tasks are dumped:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state_filter</span><span class="p">)</span>
		<span class="n">debug_show_all_locks</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">init_idle_bootup_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">idle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">idle</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">idle_sched_class</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * init_idle - set up an idle thread for a given CPU</span>
<span class="cm"> * @idle: task in question</span>
<span class="cm"> * @cpu: cpu the idle task belongs to</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: this function does not set the idle thread&#39;s NEED_RESCHED</span>
<span class="cm"> * flag, to make booting more robust.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">init_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">idle</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">__sched_fork</span><span class="p">(</span><span class="n">idle</span><span class="p">);</span>
	<span class="n">idle</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_RUNNING</span><span class="p">;</span>
	<span class="n">idle</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">exec_start</span> <span class="o">=</span> <span class="n">sched_clock</span><span class="p">();</span>

	<span class="n">do_set_cpus_allowed</span><span class="p">(</span><span class="n">idle</span><span class="p">,</span> <span class="n">cpumask_of</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * We&#39;re having a chicken and egg problem, even though we are</span>
<span class="cm">	 * holding rq-&gt;lock, the cpu isn&#39;t yet set to this cpu so the</span>
<span class="cm">	 * lockdep check in task_group() will fail.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Similar case to sched_fork(). / Alternatively we could</span>
<span class="cm">	 * use task_rq_lock() here and obtain the other rq-&gt;lock.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Silence PROVE_RCU</span>
<span class="cm">	 */</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">__set_task_cpu</span><span class="p">(</span><span class="n">idle</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">=</span> <span class="n">idle</span><span class="p">;</span>
<span class="cp">#if defined(CONFIG_SMP)</span>
	<span class="n">idle</span><span class="o">-&gt;</span><span class="n">on_cpu</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Set the preempt count _outside_ the spinlocks! */</span>
	<span class="n">task_thread_info</span><span class="p">(</span><span class="n">idle</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">preempt_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The idle tasks have their own, simple scheduling class:</span>
<span class="cm">	 */</span>
	<span class="n">idle</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">idle_sched_class</span><span class="p">;</span>
	<span class="n">ftrace_graph_init_idle_task</span><span class="p">(</span><span class="n">idle</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="cp">#if defined(CONFIG_SMP)</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">idle</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="s">&quot;%s/%d&quot;</span><span class="p">,</span> <span class="n">INIT_TASK_COMM</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="kt">void</span> <span class="nf">do_set_cpus_allowed</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">new_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">set_cpus_allowed</span><span class="p">)</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">set_cpus_allowed</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">new_mask</span><span class="p">);</span>

	<span class="n">cpumask_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">,</span> <span class="n">new_mask</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">nr_cpus_allowed</span> <span class="o">=</span> <span class="n">cpumask_weight</span><span class="p">(</span><span class="n">new_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is how migration works:</span>
<span class="cm"> *</span>
<span class="cm"> * 1) we invoke migration_cpu_stop() on the target CPU using</span>
<span class="cm"> *    stop_one_cpu().</span>
<span class="cm"> * 2) stopper starts to run (implicitly forcing the migrated thread</span>
<span class="cm"> *    off the CPU)</span>
<span class="cm"> * 3) it checks whether the migrated task is still in the wrong runqueue.</span>
<span class="cm"> * 4) if it&#39;s in the wrong runqueue then the migration thread removes</span>
<span class="cm"> *    it and puts it into the right queue.</span>
<span class="cm"> * 5) stopper completes and stop_one_cpu() returns and the migration</span>
<span class="cm"> *    is done.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Change a given task&#39;s CPU affinity. Migrate the thread to a</span>
<span class="cm"> * proper CPU and schedule it away if the CPU it&#39;s executing on</span>
<span class="cm"> * is removed from the allowed bitmask.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: the caller must have a valid reference to the task, the</span>
<span class="cm"> * task must not exit() &amp; deallocate itself prematurely. The</span>
<span class="cm"> * call is not atomic; no spinlocks may be held.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">set_cpus_allowed_ptr</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">new_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dest_cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rq</span> <span class="o">=</span> <span class="n">task_rq_lock</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_equal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">,</span> <span class="n">new_mask</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_intersects</span><span class="p">(</span><span class="n">new_mask</span><span class="p">,</span> <span class="n">cpu_active_mask</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_THREAD_BOUND</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">current</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">do_set_cpus_allowed</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">new_mask</span><span class="p">);</span>

	<span class="cm">/* Can the task run on the task&#39;s current CPU? If so, we&#39;re done */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">new_mask</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">dest_cpu</span> <span class="o">=</span> <span class="n">cpumask_any_and</span><span class="p">(</span><span class="n">cpu_active_mask</span><span class="p">,</span> <span class="n">new_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">migration_arg</span> <span class="n">arg</span> <span class="o">=</span> <span class="p">{</span> <span class="n">p</span><span class="p">,</span> <span class="n">dest_cpu</span> <span class="p">};</span>
		<span class="cm">/* Need help from migration thread: drop lock and wait. */</span>
		<span class="n">task_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">stop_one_cpu</span><span class="p">(</span><span class="n">cpu_of</span><span class="p">(</span><span class="n">rq</span><span class="p">),</span> <span class="n">migration_cpu_stop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg</span><span class="p">);</span>
		<span class="n">tlb_migrate_finish</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">task_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">set_cpus_allowed_ptr</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Move (not current) task off this cpu, onto dest cpu. We&#39;re doing</span>
<span class="cm"> * this because either it can&#39;t run here any more (set_cpus_allowed()</span>
<span class="cm"> * away from this CPU, or CPU going down), or because we&#39;re</span>
<span class="cm"> * attempting to rebalance this task on exec (sched_exec).</span>
<span class="cm"> *</span>
<span class="cm"> * So we race with normal scheduler movements, but that&#39;s OK, as long</span>
<span class="cm"> * as the task is no longer on this CPU.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns non-zero if task was successfully migrated.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__migrate_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">src_cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dest_cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq_dest</span><span class="p">,</span> <span class="o">*</span><span class="n">rq_src</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">cpu_active</span><span class="p">(</span><span class="n">dest_cpu</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">rq_src</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">src_cpu</span><span class="p">);</span>
	<span class="n">rq_dest</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">dest_cpu</span><span class="p">);</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>
	<span class="n">double_rq_lock</span><span class="p">(</span><span class="n">rq_src</span><span class="p">,</span> <span class="n">rq_dest</span><span class="p">);</span>
	<span class="cm">/* Already moved. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">!=</span> <span class="n">src_cpu</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="cm">/* Affinity changed (again). */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">dest_cpu</span><span class="p">,</span> <span class="n">tsk_cpus_allowed</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we&#39;re not on a rq, the next wake-up will ensure we&#39;re</span>
<span class="cm">	 * placed properly.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dequeue_task</span><span class="p">(</span><span class="n">rq_src</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">set_task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">dest_cpu</span><span class="p">);</span>
		<span class="n">enqueue_task</span><span class="p">(</span><span class="n">rq_dest</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">check_preempt_curr</span><span class="p">(</span><span class="n">rq_dest</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">done:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="n">double_rq_unlock</span><span class="p">(</span><span class="n">rq_src</span><span class="p">,</span> <span class="n">rq_dest</span><span class="p">);</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * migration_cpu_stop - this will be executed by a highprio stopper thread</span>
<span class="cm"> * and performs thread migration by bumping thread off CPU then</span>
<span class="cm"> * &#39;pushing&#39; onto another runqueue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">migration_cpu_stop</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">migration_arg</span> <span class="o">*</span><span class="n">arg</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The original target cpu might have gone down and we might</span>
<span class="cm">	 * be on another cpu but it doesn&#39;t matter.</span>
<span class="cm">	 */</span>
	<span class="n">local_irq_disable</span><span class="p">();</span>
	<span class="n">__migrate_task</span><span class="p">(</span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">,</span> <span class="n">raw_smp_processor_id</span><span class="p">(),</span> <span class="n">arg</span><span class="o">-&gt;</span><span class="n">dest_cpu</span><span class="p">);</span>
	<span class="n">local_irq_enable</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>

<span class="cm">/*</span>
<span class="cm"> * Ensures that the idle task is using init_mm right before its cpu goes</span>
<span class="cm"> * offline.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">idle_task_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">()));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">init_mm</span><span class="p">)</span>
		<span class="n">switch_mm</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="n">mmdrop</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * While a dead CPU has no uninterruptible tasks queued at this point,</span>
<span class="cm"> * it might still have a nonzero -&gt;nr_uninterruptible counter, because</span>
<span class="cm"> * for performance reasons the counter is not stricly tracking tasks to</span>
<span class="cm"> * their home CPUs. So we just add the counter to another CPU&#39;s counter,</span>
<span class="cm"> * to keep the global sum constant after CPU-down:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">migrate_nr_uninterruptible</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq_src</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq_dest</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpumask_any</span><span class="p">(</span><span class="n">cpu_active_mask</span><span class="p">));</span>

	<span class="n">rq_dest</span><span class="o">-&gt;</span><span class="n">nr_uninterruptible</span> <span class="o">+=</span> <span class="n">rq_src</span><span class="o">-&gt;</span><span class="n">nr_uninterruptible</span><span class="p">;</span>
	<span class="n">rq_src</span><span class="o">-&gt;</span><span class="n">nr_uninterruptible</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * remove the tasks which were accounted by rq from calc_load_tasks.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">calc_global_load_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_long_sub</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">calc_load_active</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">calc_load_tasks</span><span class="p">);</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">calc_load_active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Migrate all tasks from the rq, sleeping tasks will be migrated by</span>
<span class="cm"> * try_to_wake_up()-&gt;select_task_rq().</span>
<span class="cm"> *</span>
<span class="cm"> * Called with rq-&gt;lock held even though we&#39;er in stop_machine() and</span>
<span class="cm"> * there&#39;s no concurrency possible, we hold the required locks anyway</span>
<span class="cm"> * because of lock validation efforts.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">migrate_tasks</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dead_cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">dead_cpu</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="o">*</span><span class="n">stop</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dest_cpu</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fudge the rq selection such that the below task selection loop</span>
<span class="cm">	 * doesn&#39;t get stuck on the currently eligible stop task.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We&#39;re currently inside stop_machine() and the rq is either stuck</span>
<span class="cm">	 * in the stop_machine_cpu_stop() loop, or we&#39;re executing this code,</span>
<span class="cm">	 * either way we should never end up calling schedule() until we&#39;re</span>
<span class="cm">	 * done here.</span>
<span class="cm">	 */</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">stop</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Ensure any throttled groups are reachable by pick_next_task */</span>
	<span class="n">unthrottle_offline_cfs_rqs</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * There&#39;s this thread running, bail when that&#39;s the only</span>
<span class="cm">		 * remaining thread.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">next</span> <span class="o">=</span> <span class="n">pick_next_task</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">next</span><span class="p">);</span>
		<span class="n">next</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">put_prev_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>

		<span class="cm">/* Find suitable destination for @next, with force if needed. */</span>
		<span class="n">dest_cpu</span> <span class="o">=</span> <span class="n">select_fallback_rq</span><span class="p">(</span><span class="n">dead_cpu</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">__migrate_task</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">dead_cpu</span><span class="p">,</span> <span class="n">dest_cpu</span><span class="p">);</span>

		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">stop</span> <span class="o">=</span> <span class="n">stop</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_HOTPLUG_CPU */</span><span class="cp"></span>

<span class="cp">#if defined(CONFIG_SCHED_DEBUG) &amp;&amp; defined(CONFIG_SYSCTL)</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ctl_table</span> <span class="n">sd_ctl_dir</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">procname</span>	<span class="o">=</span> <span class="s">&quot;sched_domain&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">mode</span>		<span class="o">=</span> <span class="mo">0555</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ctl_table</span> <span class="n">sd_ctl_root</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">procname</span>	<span class="o">=</span> <span class="s">&quot;kernel&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">mode</span>		<span class="o">=</span> <span class="mo">0555</span><span class="p">,</span>
		<span class="p">.</span><span class="n">child</span>		<span class="o">=</span> <span class="n">sd_ctl_dir</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="nf">sd_alloc_ctl_entry</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span>
		<span class="n">kcalloc</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctl_table</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">entry</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sd_free_ctl_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">**</span><span class="n">tablep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * In the intermediate directories, both the child directory and</span>
<span class="cm">	 * procname are dynamically allocated and could fail but the mode</span>
<span class="cm">	 * will always be set. In the lowest directory the names are</span>
<span class="cm">	 * static strings and all have proc handlers.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">entry</span> <span class="o">=</span> <span class="o">*</span><span class="n">tablep</span><span class="p">;</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">;</span> <span class="n">entry</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">)</span>
			<span class="n">sd_free_ctl_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">proc_handler</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">procname</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="o">*</span><span class="n">tablep</span><span class="p">);</span>
	<span class="o">*</span><span class="n">tablep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">set_table_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">procname</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxlen</span><span class="p">,</span>
		<span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span> <span class="n">proc_handler</span> <span class="o">*</span><span class="n">proc_handler</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">procname</span> <span class="o">=</span> <span class="n">procname</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">maxlen</span> <span class="o">=</span> <span class="n">maxlen</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">proc_handler</span> <span class="o">=</span> <span class="n">proc_handler</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span>
<span class="nf">sd_alloc_ctl_domain_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span> <span class="o">=</span> <span class="n">sd_alloc_ctl_entry</span><span class="p">(</span><span class="mi">13</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">table</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">set_table_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&quot;min_interval&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">min_interval</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">),</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">proc_doulongvec_minmax</span><span class="p">);</span>
	<span class="n">set_table_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&quot;max_interval&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">max_interval</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">),</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">proc_doulongvec_minmax</span><span class="p">);</span>
	<span class="n">set_table_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s">&quot;busy_idx&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">busy_idx</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">proc_dointvec_minmax</span><span class="p">);</span>
	<span class="n">set_table_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="s">&quot;idle_idx&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">idle_idx</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">proc_dointvec_minmax</span><span class="p">);</span>
	<span class="n">set_table_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="s">&quot;newidle_idx&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">newidle_idx</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">proc_dointvec_minmax</span><span class="p">);</span>
	<span class="n">set_table_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="s">&quot;wake_idx&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">wake_idx</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">proc_dointvec_minmax</span><span class="p">);</span>
	<span class="n">set_table_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="s">&quot;forkexec_idx&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">forkexec_idx</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">proc_dointvec_minmax</span><span class="p">);</span>
	<span class="n">set_table_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="s">&quot;busy_factor&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">busy_factor</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">proc_dointvec_minmax</span><span class="p">);</span>
	<span class="n">set_table_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="s">&quot;imbalance_pct&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">imbalance_pct</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">proc_dointvec_minmax</span><span class="p">);</span>
	<span class="n">set_table_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="p">[</span><span class="mi">9</span><span class="p">],</span> <span class="s">&quot;cache_nice_tries&quot;</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">cache_nice_tries</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">proc_dointvec_minmax</span><span class="p">);</span>
	<span class="n">set_table_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="s">&quot;flags&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">proc_dointvec_minmax</span><span class="p">);</span>
	<span class="n">set_table_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="p">[</span><span class="mi">11</span><span class="p">],</span> <span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		<span class="n">CORENAME_MAX_SIZE</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">proc_dostring</span><span class="p">);</span>
	<span class="cm">/* &amp;table[12] is terminator */</span>

	<span class="k">return</span> <span class="n">table</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="nf">sd_alloc_ctl_cpu_table</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">domain_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>

	<span class="n">for_each_domain</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">sd</span><span class="p">)</span>
		<span class="n">domain_num</span><span class="o">++</span><span class="p">;</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">table</span> <span class="o">=</span> <span class="n">sd_alloc_ctl_entry</span><span class="p">(</span><span class="n">domain_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">table</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">for_each_domain</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">sd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="s">&quot;domain%d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">procname</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="mo">0555</span><span class="p">;</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">child</span> <span class="o">=</span> <span class="n">sd_alloc_ctl_domain_table</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
		<span class="n">entry</span><span class="o">++</span><span class="p">;</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">table</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ctl_table_header</span> <span class="o">*</span><span class="n">sd_sysctl_header</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">register_sched_domain_sysctl</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">cpu_num</span> <span class="o">=</span> <span class="n">num_possible_cpus</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">sd_alloc_ctl_entry</span><span class="p">(</span><span class="n">cpu_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">sd_ctl_dir</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">child</span><span class="p">);</span>
	<span class="n">sd_ctl_dir</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">child</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="s">&quot;cpu%d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">procname</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="mo">0555</span><span class="p">;</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">child</span> <span class="o">=</span> <span class="n">sd_alloc_ctl_cpu_table</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="n">entry</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">sd_sysctl_header</span><span class="p">);</span>
	<span class="n">sd_sysctl_header</span> <span class="o">=</span> <span class="n">register_sysctl_table</span><span class="p">(</span><span class="n">sd_ctl_root</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* may be called multiple times per register */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">unregister_sched_domain_sysctl</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sd_sysctl_header</span><span class="p">)</span>
		<span class="n">unregister_sysctl_table</span><span class="p">(</span><span class="n">sd_sysctl_header</span><span class="p">);</span>
	<span class="n">sd_sysctl_header</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sd_ctl_dir</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">child</span><span class="p">)</span>
		<span class="n">sd_free_ctl_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd_ctl_dir</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">child</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">register_sched_domain_sysctl</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">unregister_sched_domain_sysctl</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_rq_online</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">online</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">sched_class</span> <span class="o">*</span><span class="n">class</span><span class="p">;</span>

		<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">online</span><span class="p">);</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">online</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">for_each_class</span><span class="p">(</span><span class="n">class</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">rq_online</span><span class="p">)</span>
				<span class="n">class</span><span class="o">-&gt;</span><span class="n">rq_online</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_rq_offline</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">online</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">sched_class</span> <span class="o">*</span><span class="n">class</span><span class="p">;</span>

		<span class="n">for_each_class</span><span class="p">(</span><span class="n">class</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">rq_offline</span><span class="p">)</span>
				<span class="n">class</span><span class="o">-&gt;</span><span class="n">rq_offline</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">online</span><span class="p">);</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">online</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * migration_call - callback that gets triggered when a CPU is added.</span>
<span class="cm"> * Here we can start up the necessary migration thread for the new CPU.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span>
<span class="nf">migration_call</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nfb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">hcpu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CPU_TASKS_FROZEN</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">case</span> <span class="n">CPU_UP_PREPARE</span>:
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">calc_load_update</span> <span class="o">=</span> <span class="n">calc_load_update</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CPU_ONLINE</span>:
		<span class="cm">/* Update our root-domain */</span>
		<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">span</span><span class="p">));</span>

			<span class="n">set_rq_online</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
	<span class="k">case</span> <span class="n">CPU_DYING</span>:
		<span class="n">sched_ttwu_pending</span><span class="p">();</span>
		<span class="cm">/* Update our root-domain */</span>
		<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">span</span><span class="p">));</span>
			<span class="n">set_rq_offline</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">migrate_tasks</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span> <span class="cm">/* the migration thread */</span>
		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">migrate_nr_uninterruptible</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
		<span class="n">calc_global_load_remove</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="n">update_max_interval</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Register at high priority so that task migration (migrate_all_tasks)</span>
<span class="cm"> * happens before everything else.  This has to be lower priority than</span>
<span class="cm"> * the notifier in the perf_event subsystem, though.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">__cpuinitdata</span> <span class="n">migration_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">migration_call</span><span class="p">,</span>
	<span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">CPU_PRI_MIGRATION</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">sched_cpu_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nfb</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CPU_TASKS_FROZEN</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_STARTING</span>:
	<span class="k">case</span> <span class="n">CPU_DOWN_FAILED</span>:
		<span class="n">set_cpu_active</span><span class="p">((</span><span class="kt">long</span><span class="p">)</span><span class="n">hcpu</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">sched_cpu_inactive</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nfb</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CPU_TASKS_FROZEN</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_DOWN_PREPARE</span>:
		<span class="n">set_cpu_active</span><span class="p">((</span><span class="kt">long</span><span class="p">)</span><span class="n">hcpu</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">migration_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">cpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">long</span><span class="p">)</span><span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* Initialize migration for the boot CPU */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">migration_call</span><span class="p">(</span><span class="o">&amp;</span><span class="n">migration_notifier</span><span class="p">,</span> <span class="n">CPU_UP_PREPARE</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">NOTIFY_BAD</span><span class="p">);</span>
	<span class="n">migration_call</span><span class="p">(</span><span class="o">&amp;</span><span class="n">migration_notifier</span><span class="p">,</span> <span class="n">CPU_ONLINE</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">register_cpu_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">migration_notifier</span><span class="p">);</span>

	<span class="cm">/* Register cpu active notifiers */</span>
	<span class="n">cpu_notifier</span><span class="p">(</span><span class="n">sched_cpu_active</span><span class="p">,</span> <span class="n">CPU_PRI_SCHED_ACTIVE</span><span class="p">);</span>
	<span class="n">cpu_notifier</span><span class="p">(</span><span class="n">sched_cpu_inactive</span><span class="p">,</span> <span class="n">CPU_PRI_SCHED_INACTIVE</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_initcall</span><span class="p">(</span><span class="n">migration_init</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_SMP</span>

<span class="k">static</span> <span class="n">cpumask_var_t</span> <span class="n">sched_domains_tmpmask</span><span class="p">;</span> <span class="cm">/* sched_domains_mutex */</span>

<span class="cp">#ifdef CONFIG_SCHED_DEBUG</span>

<span class="k">static</span> <span class="n">__read_mostly</span> <span class="kt">int</span> <span class="n">sched_debug_enabled</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">sched_debug_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sched_debug_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;sched_debug&quot;</span><span class="p">,</span> <span class="n">sched_debug_setup</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">sched_debug</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sched_debug_enabled</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sched_domain_debug_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">groupmask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">group</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>

	<span class="n">cpulist_scnprintf</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">str</span><span class="p">),</span> <span class="n">sched_domain_span</span><span class="p">(</span><span class="n">sd</span><span class="p">));</span>
	<span class="n">cpumask_clear</span><span class="p">(</span><span class="n">groupmask</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%*s domain %d: &quot;</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SD_LOAD_BALANCE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;does not load-balance</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;ERROR: !SD_LOAD_BALANCE domain&quot;</span>
					<span class="s">&quot; has parent&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;span %s level %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">sched_domain_span</span><span class="p">(</span><span class="n">sd</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;ERROR: domain-&gt;span does not contain &quot;</span>
				<span class="s">&quot;CPU%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">sched_group_cpus</span><span class="p">(</span><span class="n">group</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;ERROR: domain-&gt;groups does not contain&quot;</span>
				<span class="s">&quot; CPU%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%*s groups:&quot;</span><span class="p">,</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">group</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;ERROR: group is NULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Even though we initialize -&gt;power to something semi-sane,</span>
<span class="cm">		 * we leave power_orig unset. This allows us to detect if</span>
<span class="cm">		 * domain iteration is still funny without causing /0 traps.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">power_orig</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;ERROR: domain-&gt;cpu_power not &quot;</span>
					<span class="s">&quot;set</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_weight</span><span class="p">(</span><span class="n">sched_group_cpus</span><span class="p">(</span><span class="n">group</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;ERROR: empty group</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SD_OVERLAP</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">cpumask_intersects</span><span class="p">(</span><span class="n">groupmask</span><span class="p">,</span> <span class="n">sched_group_cpus</span><span class="p">(</span><span class="n">group</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;ERROR: repeated CPUs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">cpumask_or</span><span class="p">(</span><span class="n">groupmask</span><span class="p">,</span> <span class="n">groupmask</span><span class="p">,</span> <span class="n">sched_group_cpus</span><span class="p">(</span><span class="n">group</span><span class="p">));</span>

		<span class="n">cpulist_scnprintf</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">str</span><span class="p">),</span> <span class="n">sched_group_cpus</span><span class="p">(</span><span class="n">group</span><span class="p">));</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot; %s&quot;</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">power</span> <span class="o">!=</span> <span class="n">SCHED_POWER_SCALE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot; (cpu_power = %d)&quot;</span><span class="p">,</span>
				<span class="n">group</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">group</span> <span class="o">=</span> <span class="n">group</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">group</span> <span class="o">!=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_equal</span><span class="p">(</span><span class="n">sched_domain_span</span><span class="p">(</span><span class="n">sd</span><span class="p">),</span> <span class="n">groupmask</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;ERROR: groups don&#39;t span domain-&gt;span</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">cpumask_subset</span><span class="p">(</span><span class="n">groupmask</span><span class="p">,</span> <span class="n">sched_domain_span</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;ERROR: parent span is not a superset &quot;</span>
			<span class="s">&quot;of domain-&gt;span</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sched_domain_debug</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sched_debug_enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;CPU%d attaching NULL sched-domain.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;CPU%d attaching sched-domain:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sched_domain_debug_one</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">sched_domains_tmpmask</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">level</span><span class="o">++</span><span class="p">;</span>
		<span class="n">sd</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sd</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* !CONFIG_SCHED_DEBUG */</span><span class="cp"></span>
<span class="cp"># define sched_domain_debug(sd, cpu) do { } while (0)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">sched_debug</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SCHED_DEBUG */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sd_degenerate</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_weight</span><span class="p">(</span><span class="n">sched_domain_span</span><span class="p">(</span><span class="n">sd</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Following flags need at least 2 groups */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SD_LOAD_BALANCE</span> <span class="o">|</span>
			 <span class="n">SD_BALANCE_NEWIDLE</span> <span class="o">|</span>
			 <span class="n">SD_BALANCE_FORK</span> <span class="o">|</span>
			 <span class="n">SD_BALANCE_EXEC</span> <span class="o">|</span>
			 <span class="n">SD_SHARE_CPUPOWER</span> <span class="o">|</span>
			 <span class="n">SD_SHARE_PKG_RESOURCES</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">groups</span> <span class="o">!=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">groups</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Following flags don&#39;t use groups */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SD_WAKE_AFFINE</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sd_parent_degenerate</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cflags</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">pflags</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sd_degenerate</span><span class="p">(</span><span class="n">parent</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_equal</span><span class="p">(</span><span class="n">sched_domain_span</span><span class="p">(</span><span class="n">sd</span><span class="p">),</span> <span class="n">sched_domain_span</span><span class="p">(</span><span class="n">parent</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Flags needing groups don&#39;t count if only 1 group in parent */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">groups</span> <span class="o">==</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">groups</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pflags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">SD_LOAD_BALANCE</span> <span class="o">|</span>
				<span class="n">SD_BALANCE_NEWIDLE</span> <span class="o">|</span>
				<span class="n">SD_BALANCE_FORK</span> <span class="o">|</span>
				<span class="n">SD_BALANCE_EXEC</span> <span class="o">|</span>
				<span class="n">SD_SHARE_CPUPOWER</span> <span class="o">|</span>
				<span class="n">SD_SHARE_PKG_RESOURCES</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr_node_ids</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">pflags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SD_SERIALIZE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">~</span><span class="n">cflags</span> <span class="o">&amp;</span> <span class="n">pflags</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_rootdomain</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">rcu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">root_domain</span> <span class="o">*</span><span class="n">rd</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">rcu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">root_domain</span><span class="p">,</span> <span class="n">rcu</span><span class="p">);</span>

	<span class="n">cpupri_cleanup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">cpupri</span><span class="p">);</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">rto_mask</span><span class="p">);</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">online</span><span class="p">);</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">span</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">rd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rq_attach_root</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">root_domain</span> <span class="o">*</span><span class="n">rd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">root_domain</span> <span class="o">*</span><span class="n">old_rd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">old_rd</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rd</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">old_rd</span><span class="o">-&gt;</span><span class="n">online</span><span class="p">))</span>
			<span class="n">set_rq_offline</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>

		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">old_rd</span><span class="o">-&gt;</span><span class="n">span</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If we dont want to free the old_rt yet then</span>
<span class="cm">		 * set old_rd to NULL to skip the freeing later</span>
<span class="cm">		 * in this function:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_rd</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">))</span>
			<span class="n">old_rd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">rd</span> <span class="o">=</span> <span class="n">rd</span><span class="p">;</span>

	<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">rd</span><span class="o">-&gt;</span><span class="n">span</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_active_mask</span><span class="p">))</span>
		<span class="n">set_rq_online</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>

	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">old_rd</span><span class="p">)</span>
		<span class="n">call_rcu_sched</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_rd</span><span class="o">-&gt;</span><span class="n">rcu</span><span class="p">,</span> <span class="n">free_rootdomain</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_rootdomain</span><span class="p">(</span><span class="k">struct</span> <span class="n">root_domain</span> <span class="o">*</span><span class="n">rd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">rd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rd</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">span</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">online</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">free_span</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">rto_mask</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">free_online</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpupri_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">cpupri</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_rto_mask</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">free_rto_mask:</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">rto_mask</span><span class="p">);</span>
<span class="nl">free_online:</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">online</span><span class="p">);</span>
<span class="nl">free_span:</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">span</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * By default the system creates a single root-domain with all cpus as</span>
<span class="cm"> * members (mimicking the global state we have today).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">root_domain</span> <span class="n">def_root_domain</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_defrootdomain</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">init_rootdomain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">def_root_domain</span><span class="p">);</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">def_root_domain</span><span class="p">.</span><span class="n">refcount</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">root_domain</span> <span class="o">*</span><span class="nf">alloc_rootdomain</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">root_domain</span> <span class="o">*</span><span class="n">rd</span><span class="p">;</span>

	<span class="n">rd</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rd</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rd</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">init_rootdomain</span><span class="p">(</span><span class="n">rd</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">rd</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rd</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_sched_groups</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">free_sgp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">tmp</span><span class="p">,</span> <span class="o">*</span><span class="n">first</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sg</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">first</span> <span class="o">=</span> <span class="n">sg</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">free_sgp</span> <span class="o">&amp;&amp;</span> <span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">))</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="p">);</span>

		<span class="n">kfree</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
		<span class="n">sg</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">sg</span> <span class="o">!=</span> <span class="n">first</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_sched_domain</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">rcu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">rcu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_domain</span><span class="p">,</span> <span class="n">rcu</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If its an overlapping domain it has private groups, iterate and</span>
<span class="cm">	 * nuke them all.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SD_OVERLAP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_sched_groups</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">groups</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">groups</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">destroy_sched_domain</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">rcu</span><span class="p">,</span> <span class="n">free_sched_domain</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">destroy_sched_domains</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">sd</span><span class="p">;</span> <span class="n">sd</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">destroy_sched_domain</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Keep a special pointer to the highest sched_domain that has</span>
<span class="cm"> * SD_SHARE_PKG_RESOURCE set (Last Level Cache Domain) for this</span>
<span class="cm"> * allows us to avoid some pointer chasing select_idle_sibling().</span>
<span class="cm"> *</span>
<span class="cm"> * Also keep a unique ID per domain (we use the first cpu number in</span>
<span class="cm"> * the cpumask of the domain), this allows us to quickly tell if</span>
<span class="cm"> * two cpus are in the same cache domain, see cpus_share_cache().</span>
<span class="cm"> */</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="p">,</span> <span class="n">sd_llc</span><span class="p">);</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">sd_llc_id</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_top_cache_domain</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">sd</span> <span class="o">=</span> <span class="n">highest_flag_domain</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">SD_SHARE_PKG_RESOURCES</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="p">)</span>
		<span class="n">id</span> <span class="o">=</span> <span class="n">cpumask_first</span><span class="p">(</span><span class="n">sched_domain_span</span><span class="p">(</span><span class="n">sd</span><span class="p">));</span>

	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">sd_llc</span><span class="p">,</span> <span class="n">cpu</span><span class="p">),</span> <span class="n">sd</span><span class="p">);</span>
	<span class="n">per_cpu</span><span class="p">(</span><span class="n">sd_llc_id</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Attach the domain &#39;sd&#39; to &#39;cpu&#39; as its base domain. Callers must</span>
<span class="cm"> * hold the hotplug lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cpu_attach_domain</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">root_domain</span> <span class="o">*</span><span class="n">rd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/* Remove the sched domains which do not contribute to scheduling. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">sd</span><span class="p">;</span> <span class="n">tmp</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sd_parent_degenerate</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">parent</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
				<span class="n">parent</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">child</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
			<span class="n">destroy_sched_domain</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sd</span> <span class="o">&amp;&amp;</span> <span class="n">sd_degenerate</span><span class="p">(</span><span class="n">sd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">sd</span><span class="p">;</span>
		<span class="n">sd</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
		<span class="n">destroy_sched_domain</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="p">)</span>
			<span class="n">sd</span><span class="o">-&gt;</span><span class="n">child</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sched_domain_debug</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="n">rq_attach_root</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">rd</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">;</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">,</span> <span class="n">sd</span><span class="p">);</span>
	<span class="n">destroy_sched_domains</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="n">update_top_cache_domain</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* cpus with isolated domains */</span>
<span class="k">static</span> <span class="n">cpumask_var_t</span> <span class="n">cpu_isolated_map</span><span class="p">;</span>

<span class="cm">/* Setup the mask of cpus configured for isolated domains */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">isolated_cpu_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">alloc_bootmem_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_isolated_map</span><span class="p">);</span>
	<span class="n">cpulist_parse</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">cpu_isolated_map</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;isolcpus=&quot;</span><span class="p">,</span> <span class="n">isolated_cpu_setup</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="nf">cpu_cpu_mask</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cpumask_of_node</span><span class="p">(</span><span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">sd_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">**</span><span class="n">__percpu</span> <span class="n">sd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sched_group</span> <span class="o">**</span><span class="n">__percpu</span> <span class="n">sg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sched_group_power</span> <span class="o">**</span><span class="n">__percpu</span> <span class="n">sgp</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">s_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">**</span> <span class="n">__percpu</span> <span class="n">sd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">root_domain</span>	<span class="o">*</span><span class="n">rd</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">s_alloc</span> <span class="p">{</span>
	<span class="n">sa_rootdomain</span><span class="p">,</span>
	<span class="n">sa_sd</span><span class="p">,</span>
	<span class="n">sa_sd_storage</span><span class="p">,</span>
	<span class="n">sa_none</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sched_domain_topology_level</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">sched_domain_init_f</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sched_domain_topology_level</span> <span class="o">*</span><span class="n">tl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>
<span class="k">typedef</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">sched_domain_mask_f</span><span class="p">)(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>

<span class="cp">#define SDTL_OVERLAP	0x01</span>

<span class="k">struct</span> <span class="n">sched_domain_topology_level</span> <span class="p">{</span>
	<span class="n">sched_domain_init_f</span> <span class="n">init</span><span class="p">;</span>
	<span class="n">sched_domain_mask_f</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">int</span>		    <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span>		    <span class="n">numa_level</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sd_data</span>      <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Build an iteration mask that can exclude certain CPUs from the upwards</span>
<span class="cm"> * domain traversal.</span>
<span class="cm"> *</span>
<span class="cm"> * Asymmetric node setups can result in situations where the domain tree is of</span>
<span class="cm"> * unequal depth, make sure to skip domains that already cover the entire</span>
<span class="cm"> * range.</span>
<span class="cm"> *</span>
<span class="cm"> * In that case build_sched_domains() will have terminated the iteration early</span>
<span class="cm"> * and our sibling sd spans will be empty. Domains should always include the</span>
<span class="cm"> * cpu they&#39;re built on, so check that.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">build_group_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">sg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">span</span> <span class="o">=</span> <span class="n">sched_domain_span</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sd_data</span> <span class="o">*</span><span class="n">sdd</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sibling</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">span</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sibling</span> <span class="o">=</span> <span class="o">*</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">sched_domain_span</span><span class="p">(</span><span class="n">sibling</span><span class="p">)))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">sched_group_mask</span><span class="p">(</span><span class="n">sg</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the canonical balance cpu for this group, this is the first cpu</span>
<span class="cm"> * of this group that&#39;s also in the iteration mask.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">group_balance_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">sg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cpumask_first_and</span><span class="p">(</span><span class="n">sched_group_cpus</span><span class="p">(</span><span class="n">sg</span><span class="p">),</span> <span class="n">sched_group_mask</span><span class="p">(</span><span class="n">sg</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">build_overlap_sched_groups</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">first</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">groups</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">span</span> <span class="o">=</span> <span class="n">sched_domain_span</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">covered</span> <span class="o">=</span> <span class="n">sched_domains_tmpmask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sd_data</span> <span class="o">*</span><span class="n">sdd</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">cpumask_clear</span><span class="p">(</span><span class="n">covered</span><span class="p">);</span>

	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">span</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">sg_span</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">covered</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">child</span> <span class="o">=</span> <span class="o">*</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="cm">/* See the comment near build_group_mask(). */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">sched_domain_span</span><span class="p">(</span><span class="n">child</span><span class="p">)))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">sg</span> <span class="o">=</span> <span class="n">kzalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_group</span><span class="p">)</span> <span class="o">+</span> <span class="n">cpumask_size</span><span class="p">(),</span>
				<span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sg</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

		<span class="n">sg_span</span> <span class="o">=</span> <span class="n">sched_group_cpus</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">child</span> <span class="o">=</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">;</span>
			<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">sg_span</span><span class="p">,</span> <span class="n">sched_domain_span</span><span class="p">(</span><span class="n">child</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">sg_span</span><span class="p">);</span>

		<span class="n">cpumask_or</span><span class="p">(</span><span class="n">covered</span><span class="p">,</span> <span class="n">covered</span><span class="p">,</span> <span class="n">sg_span</span><span class="p">);</span>

		<span class="n">sg</span><span class="o">-&gt;</span><span class="n">sgp</span> <span class="o">=</span> <span class="o">*</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">build_group_mask</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">sg</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Initialize sgp-&gt;power such that even if we mess up the</span>
<span class="cm">		 * domains and no possible iteration will get us here, we won&#39;t</span>
<span class="cm">		 * die on a /0 trap.</span>
<span class="cm">		 */</span>
		<span class="n">sg</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">power</span> <span class="o">=</span> <span class="n">SCHED_POWER_SCALE</span> <span class="o">*</span> <span class="n">cpumask_weight</span><span class="p">(</span><span class="n">sg_span</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Make sure the first group of this domain contains the</span>
<span class="cm">		 * canonical balance cpu. Otherwise the sched_domain iteration</span>
<span class="cm">		 * breaks. See update_sg_lb_stats().</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">groups</span> <span class="o">&amp;&amp;</span> <span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">sg_span</span><span class="p">))</span> <span class="o">||</span>
		    <span class="n">group_balance_cpu</span><span class="p">(</span><span class="n">sg</span><span class="p">)</span> <span class="o">==</span> <span class="n">cpu</span><span class="p">)</span>
			<span class="n">groups</span> <span class="o">=</span> <span class="n">sg</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">first</span><span class="p">)</span>
			<span class="n">first</span> <span class="o">=</span> <span class="n">sg</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="p">)</span>
			<span class="n">last</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">sg</span><span class="p">;</span>
		<span class="n">last</span> <span class="o">=</span> <span class="n">sg</span><span class="p">;</span>
		<span class="n">last</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sd</span><span class="o">-&gt;</span><span class="n">groups</span> <span class="o">=</span> <span class="n">groups</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">free_sched_groups</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_group</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sd_data</span> <span class="o">*</span><span class="n">sdd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_group</span> <span class="o">**</span><span class="n">sg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="o">*</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">child</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">child</span><span class="p">)</span>
		<span class="n">cpu</span> <span class="o">=</span> <span class="n">cpumask_first</span><span class="p">(</span><span class="n">sched_domain_span</span><span class="p">(</span><span class="n">child</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sg</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">sg</span> <span class="o">=</span> <span class="o">*</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="p">(</span><span class="o">*</span><span class="n">sg</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sgp</span> <span class="o">=</span> <span class="o">*</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">sg</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="cm">/* for claim_allocations */</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">cpu</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * build_sched_groups will build a circular linked list of the groups</span>
<span class="cm"> * covered by the given span, and will set each group&#39;s -&gt;cpumask correctly,</span>
<span class="cm"> * and -&gt;cpu_power to 0.</span>
<span class="cm"> *</span>
<span class="cm"> * Assumes the sched_domain tree is fully constructed</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">build_sched_groups</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">first</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sd_data</span> <span class="o">*</span><span class="n">sdd</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">span</span> <span class="o">=</span> <span class="n">sched_domain_span</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">covered</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">get_group</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">sdd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">groups</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">cpumask_first</span><span class="p">(</span><span class="n">sched_domain_span</span><span class="p">(</span><span class="n">sd</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sched_domains_mutex</span><span class="p">);</span>
	<span class="n">covered</span> <span class="o">=</span> <span class="n">sched_domains_tmpmask</span><span class="p">;</span>

	<span class="n">cpumask_clear</span><span class="p">(</span><span class="n">covered</span><span class="p">);</span>

	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">span</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">group</span> <span class="o">=</span> <span class="n">get_group</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">sdd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sg</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">covered</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">cpumask_clear</span><span class="p">(</span><span class="n">sched_group_cpus</span><span class="p">(</span><span class="n">sg</span><span class="p">));</span>
		<span class="n">sg</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">power</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cpumask_setall</span><span class="p">(</span><span class="n">sched_group_mask</span><span class="p">(</span><span class="n">sg</span><span class="p">));</span>

		<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">span</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">get_group</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">sdd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="n">group</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">covered</span><span class="p">);</span>
			<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">sched_group_cpus</span><span class="p">(</span><span class="n">sg</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">first</span><span class="p">)</span>
			<span class="n">first</span> <span class="o">=</span> <span class="n">sg</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="p">)</span>
			<span class="n">last</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">sg</span><span class="p">;</span>
		<span class="n">last</span> <span class="o">=</span> <span class="n">sg</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">last</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize sched groups cpu_power.</span>
<span class="cm"> *</span>
<span class="cm"> * cpu_power indicates the capacity of sched group, which is used while</span>
<span class="cm"> * distributing the load between different sched groups in a sched domain.</span>
<span class="cm"> * Typically cpu_power for all the groups in a sched domain will be same unless</span>
<span class="cm"> * there are asymmetries in the topology. If there are asymmetries, group</span>
<span class="cm"> * having more cpu_power will pickup more load compared to the group having</span>
<span class="cm"> * less cpu_power.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_sched_groups_power</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">sg</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">sd</span> <span class="o">||</span> <span class="o">!</span><span class="n">sg</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">sg</span><span class="o">-&gt;</span><span class="n">group_weight</span> <span class="o">=</span> <span class="n">cpumask_weight</span><span class="p">(</span><span class="n">sched_group_cpus</span><span class="p">(</span><span class="n">sg</span><span class="p">));</span>
		<span class="n">sg</span> <span class="o">=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">sg</span> <span class="o">!=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">group_balance_cpu</span><span class="p">(</span><span class="n">sg</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">update_group_power</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">nr_busy_cpus</span><span class="p">,</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">group_weight</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__weak</span> <span class="nf">arch_sd_sibling_asym_packing</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
       <span class="k">return</span> <span class="mi">0</span><span class="o">*</span><span class="n">SD_ASYM_PACKING</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initializers for schedule domains</span>
<span class="cm"> * Non-inlined to reduce accumulated stack pressure in build_sched_domains()</span>
<span class="cm"> */</span>

<span class="cp">#ifdef CONFIG_SCHED_DEBUG</span>
<span class="cp"># define SD_INIT_NAME(sd, type)		sd-&gt;name = #type</span>
<span class="cp">#else</span>
<span class="cp"># define SD_INIT_NAME(sd, type)		do { } while (0)</span>
<span class="cp">#endif</span>

<span class="cp">#define SD_INIT_FUNC(type)						\</span>
<span class="cp">static noinline struct sched_domain *					\</span>
<span class="cp">sd_init_##type(struct sched_domain_topology_level *tl, int cpu) 	\</span>
<span class="cp">{									\</span>
<span class="cp">	struct sched_domain *sd = *per_cpu_ptr(tl-&gt;data.sd, cpu);	\</span>
<span class="cp">	*sd = SD_##type##_INIT;						\</span>
<span class="cp">	SD_INIT_NAME(sd, type);						\</span>
<span class="cp">	sd-&gt;private = &amp;tl-&gt;data;					\</span>
<span class="cp">	return sd;							\</span>
<span class="cp">}</span>

<span class="n">SD_INIT_FUNC</span><span class="p">(</span><span class="n">CPU</span><span class="p">)</span>
<span class="cp">#ifdef CONFIG_SCHED_SMT</span>
 <span class="n">SD_INIT_FUNC</span><span class="p">(</span><span class="n">SIBLING</span><span class="p">)</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_SCHED_MC</span>
 <span class="n">SD_INIT_FUNC</span><span class="p">(</span><span class="n">MC</span><span class="p">)</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_SCHED_BOOK</span>
 <span class="n">SD_INIT_FUNC</span><span class="p">(</span><span class="n">BOOK</span><span class="p">)</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">default_relax_domain_level</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">sched_domain_level_max</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">setup_relax_domain_level</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kstrtoint</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">default_relax_domain_level</span><span class="p">))</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Unable to set relax_domain_level</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;relax_domain_level=&quot;</span><span class="p">,</span> <span class="n">setup_relax_domain_level</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_domain_attribute</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">sched_domain_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">request</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">attr</span> <span class="o">||</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">relax_domain_level</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">default_relax_domain_level</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">request</span> <span class="o">=</span> <span class="n">default_relax_domain_level</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">request</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">relax_domain_level</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">request</span> <span class="o">&lt;</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* turn off idle balance on this domain */</span>
		<span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">SD_BALANCE_WAKE</span><span class="o">|</span><span class="n">SD_BALANCE_NEWIDLE</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* turn on idle balance on this domain */</span>
		<span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">SD_BALANCE_WAKE</span><span class="o">|</span><span class="n">SD_BALANCE_NEWIDLE</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__sdt_free</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpu_map</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__sdt_alloc</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpu_map</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__free_domain_allocs</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_data</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="k">enum</span> <span class="n">s_alloc</span> <span class="n">what</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpu_map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">what</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">sa_rootdomain</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">))</span>
			<span class="n">free_rootdomain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">rcu</span><span class="p">);</span> <span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">sa_sd</span>:
		<span class="n">free_percpu</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">);</span> <span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">sa_sd_storage</span>:
		<span class="n">__sdt_free</span><span class="p">(</span><span class="n">cpu_map</span><span class="p">);</span> <span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">sa_none</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">s_alloc</span> <span class="nf">__visit_domain_allocation_hell</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_data</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span>
						   <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpu_map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">d</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__sdt_alloc</span><span class="p">(</span><span class="n">cpu_map</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sa_sd_storage</span><span class="p">;</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">sd</span> <span class="o">=</span> <span class="n">alloc_percpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sa_sd_storage</span><span class="p">;</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">rd</span> <span class="o">=</span> <span class="n">alloc_rootdomain</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">rd</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sa_sd</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sa_rootdomain</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * NULL the sd_data elements we&#39;ve used to build the sched_domain and</span>
<span class="cm"> * sched_group structure so that the subsequent __free_domain_allocs()</span>
<span class="cm"> * will not free the data we&#39;re using.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">claim_allocations</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sd_data</span> <span class="o">*</span><span class="n">sdd</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">*</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">!=</span> <span class="n">sd</span><span class="p">);</span>
	<span class="o">*</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">,</span> <span class="n">cpu</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">))</span>
		<span class="o">*</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="p">,</span> <span class="n">cpu</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">))</span>
		<span class="o">*</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SCHED_SMT</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="nf">cpu_smt_mask</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">topology_thread_cpumask</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Topology list, bottom-up.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sched_domain_topology_level</span> <span class="n">default_topology</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_SCHED_SMT</span>
	<span class="p">{</span> <span class="n">sd_init_SIBLING</span><span class="p">,</span> <span class="n">cpu_smt_mask</span><span class="p">,</span> <span class="p">},</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_SCHED_MC</span>
	<span class="p">{</span> <span class="n">sd_init_MC</span><span class="p">,</span> <span class="n">cpu_coregroup_mask</span><span class="p">,</span> <span class="p">},</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_SCHED_BOOK</span>
	<span class="p">{</span> <span class="n">sd_init_BOOK</span><span class="p">,</span> <span class="n">cpu_book_mask</span><span class="p">,</span> <span class="p">},</span>
<span class="cp">#endif</span>
	<span class="p">{</span> <span class="n">sd_init_CPU</span><span class="p">,</span> <span class="n">cpu_cpu_mask</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sched_domain_topology_level</span> <span class="o">*</span><span class="n">sched_domain_topology</span> <span class="o">=</span> <span class="n">default_topology</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_NUMA</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">sched_domains_numa_levels</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="o">*</span><span class="n">sched_domains_numa_distance</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">***</span><span class="n">sched_domains_numa_masks</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sched_domains_curr_level</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sd_local_flags</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sched_domains_numa_distance</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">RECLAIM_DISTANCE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">SD_BALANCE_EXEC</span> <span class="o">|</span> <span class="n">SD_BALANCE_FORK</span> <span class="o">|</span> <span class="n">SD_WAKE_AFFINE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span>
<span class="nf">sd_numa_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain_topology_level</span> <span class="o">*</span><span class="n">tl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="o">*</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">tl</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">sd</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="n">tl</span><span class="o">-&gt;</span><span class="n">numa_level</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sd_weight</span> <span class="o">=</span> <span class="n">cpumask_weight</span><span class="p">(</span>
			<span class="n">sched_domains_numa_masks</span><span class="p">[</span><span class="n">level</span><span class="p">][</span><span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">)]);</span>

	<span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span><span class="p">){</span>
		<span class="p">.</span><span class="n">min_interval</span>		<span class="o">=</span> <span class="n">sd_weight</span><span class="p">,</span>
		<span class="p">.</span><span class="n">max_interval</span>		<span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">sd_weight</span><span class="p">,</span>
		<span class="p">.</span><span class="n">busy_factor</span>		<span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
		<span class="p">.</span><span class="n">imbalance_pct</span>		<span class="o">=</span> <span class="mi">125</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cache_nice_tries</span>	<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
		<span class="p">.</span><span class="n">busy_idx</span>		<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
		<span class="p">.</span><span class="n">idle_idx</span>		<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
		<span class="p">.</span><span class="n">newidle_idx</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">wake_idx</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">forkexec_idx</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>

		<span class="p">.</span><span class="n">flags</span>			<span class="o">=</span> <span class="mi">1</span><span class="o">*</span><span class="n">SD_LOAD_BALANCE</span>
					<span class="o">|</span> <span class="mi">1</span><span class="o">*</span><span class="n">SD_BALANCE_NEWIDLE</span>
					<span class="o">|</span> <span class="mi">0</span><span class="o">*</span><span class="n">SD_BALANCE_EXEC</span>
					<span class="o">|</span> <span class="mi">0</span><span class="o">*</span><span class="n">SD_BALANCE_FORK</span>
					<span class="o">|</span> <span class="mi">0</span><span class="o">*</span><span class="n">SD_BALANCE_WAKE</span>
					<span class="o">|</span> <span class="mi">0</span><span class="o">*</span><span class="n">SD_WAKE_AFFINE</span>
					<span class="o">|</span> <span class="mi">0</span><span class="o">*</span><span class="n">SD_PREFER_LOCAL</span>
					<span class="o">|</span> <span class="mi">0</span><span class="o">*</span><span class="n">SD_SHARE_CPUPOWER</span>
					<span class="o">|</span> <span class="mi">0</span><span class="o">*</span><span class="n">SD_SHARE_PKG_RESOURCES</span>
					<span class="o">|</span> <span class="mi">1</span><span class="o">*</span><span class="n">SD_SERIALIZE</span>
					<span class="o">|</span> <span class="mi">0</span><span class="o">*</span><span class="n">SD_PREFER_SIBLING</span>
					<span class="o">|</span> <span class="n">sd_local_flags</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
					<span class="p">,</span>
		<span class="p">.</span><span class="n">last_balance</span>		<span class="o">=</span> <span class="n">jiffies</span><span class="p">,</span>
		<span class="p">.</span><span class="n">balance_interval</span>	<span class="o">=</span> <span class="n">sd_weight</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="n">SD_INIT_NAME</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">NUMA</span><span class="p">);</span>
	<span class="n">sd</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tl</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ugly hack to pass state to sd_numa_mask()...</span>
<span class="cm">	 */</span>
	<span class="n">sched_domains_curr_level</span> <span class="o">=</span> <span class="n">tl</span><span class="o">-&gt;</span><span class="n">numa_level</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sd</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="nf">sd_numa_mask</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sched_domains_numa_masks</span><span class="p">[</span><span class="n">sched_domains_curr_level</span><span class="p">][</span><span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">)];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sched_numa_warn</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">done</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">done</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;ERROR: %s</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_node_ids</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;  &quot;</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nr_node_ids</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;%02d &quot;</span><span class="p">,</span> <span class="n">node_distance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">find_numa_distance</span><span class="p">(</span><span class="kt">int</span> <span class="n">distance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">distance</span> <span class="o">==</span> <span class="n">node_distance</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sched_domains_numa_levels</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sched_domains_numa_distance</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">distance</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sched_init_numa</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">next_distance</span><span class="p">,</span> <span class="n">curr_distance</span> <span class="o">=</span> <span class="n">node_distance</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sched_domain_topology_level</span> <span class="o">*</span><span class="n">tl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>

	<span class="n">sched_domains_numa_distance</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">nr_node_ids</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sched_domains_numa_distance</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * O(nr_nodes^2) deduplicating selection sort -- in order to find the</span>
<span class="cm">	 * unique distances in the node_distance() table.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Assumes node_distance(0,j) includes all distances in</span>
<span class="cm">	 * node_distance(i,j) in order to avoid cubic time.</span>
<span class="cm">	 */</span>
	<span class="n">next_distance</span> <span class="o">=</span> <span class="n">curr_distance</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_node_ids</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nr_node_ids</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">nr_node_ids</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">node_distance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">distance</span> <span class="o">&gt;</span> <span class="n">curr_distance</span> <span class="o">&amp;&amp;</span>
				    <span class="p">(</span><span class="n">distance</span> <span class="o">&lt;</span> <span class="n">next_distance</span> <span class="o">||</span>
				     <span class="n">next_distance</span> <span class="o">==</span> <span class="n">curr_distance</span><span class="p">))</span>
					<span class="n">next_distance</span> <span class="o">=</span> <span class="n">distance</span><span class="p">;</span>

				<span class="cm">/*</span>
<span class="cm">				 * While not a strong assumption it would be nice to know</span>
<span class="cm">				 * about cases where if node A is connected to B, B is not</span>
<span class="cm">				 * equally connected to A.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">sched_debug</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">node_distance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">!=</span> <span class="n">distance</span><span class="p">)</span>
					<span class="n">sched_numa_warn</span><span class="p">(</span><span class="s">&quot;Node-distance not symmetric&quot;</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">sched_debug</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">find_numa_distance</span><span class="p">(</span><span class="n">distance</span><span class="p">))</span>
					<span class="n">sched_numa_warn</span><span class="p">(</span><span class="s">&quot;Node-0 not representative&quot;</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">next_distance</span> <span class="o">!=</span> <span class="n">curr_distance</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sched_domains_numa_distance</span><span class="p">[</span><span class="n">level</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">next_distance</span><span class="p">;</span>
				<span class="n">sched_domains_numa_levels</span> <span class="o">=</span> <span class="n">level</span><span class="p">;</span>
				<span class="n">curr_distance</span> <span class="o">=</span> <span class="n">next_distance</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * In case of sched_debug() we verify the above assumption.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sched_debug</span><span class="p">())</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * &#39;level&#39; contains the number of unique distances, excluding the</span>
<span class="cm">	 * identity distance node_distance(i,i).</span>
<span class="cm">	 *</span>
<span class="cm">	 * The sched_domains_nume_distance[] array includes the actual distance</span>
<span class="cm">	 * numbers.</span>
<span class="cm">	 */</span>

	<span class="n">sched_domains_numa_masks</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="n">level</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sched_domains_numa_masks</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now for each level, construct a mask per node which contains all</span>
<span class="cm">	 * cpus of nodes that are that many hops away from us.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">level</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sched_domains_numa_masks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">kzalloc</span><span class="p">(</span><span class="n">nr_node_ids</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sched_domains_numa_masks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nr_node_ids</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">cpumask_size</span><span class="p">(),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mask</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>

			<span class="n">sched_domains_numa_masks</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">nr_node_ids</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">node_distance</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">sched_domains_numa_distance</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
					<span class="k">continue</span><span class="p">;</span>

				<span class="n">cpumask_or</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">cpumask_of_node</span><span class="p">(</span><span class="n">k</span><span class="p">));</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">tl</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">((</span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">default_topology</span><span class="p">)</span> <span class="o">+</span> <span class="n">level</span><span class="p">)</span> <span class="o">*</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain_topology_level</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tl</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Copy the default topology bits..</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">default_topology</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">init</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">tl</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">default_topology</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * .. and append &#39;j&#39; levels of NUMA goodness.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">level</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tl</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain_topology_level</span><span class="p">){</span>
			<span class="p">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">sd_numa_init</span><span class="p">,</span>
			<span class="p">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">sd_numa_mask</span><span class="p">,</span>
			<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">SDTL_OVERLAP</span><span class="p">,</span>
			<span class="p">.</span><span class="n">numa_level</span> <span class="o">=</span> <span class="n">j</span><span class="p">,</span>
		<span class="p">};</span>
	<span class="p">}</span>

	<span class="n">sched_domain_topology</span> <span class="o">=</span> <span class="n">tl</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sched_init_numa</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_NUMA */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__sdt_alloc</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpu_map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_domain_topology_level</span> <span class="o">*</span><span class="n">tl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">tl</span> <span class="o">=</span> <span class="n">sched_domain_topology</span><span class="p">;</span> <span class="n">tl</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">;</span> <span class="n">tl</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sd_data</span> <span class="o">*</span><span class="n">sdd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tl</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

		<span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sd</span> <span class="o">=</span> <span class="n">alloc_percpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sg</span> <span class="o">=</span> <span class="n">alloc_percpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sgp</span> <span class="o">=</span> <span class="n">alloc_percpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_group_power</span> <span class="o">*</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">cpu_map</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">sched_group_power</span> <span class="o">*</span><span class="n">sgp</span><span class="p">;</span>

		       	<span class="n">sd</span> <span class="o">=</span> <span class="n">kzalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span><span class="p">)</span> <span class="o">+</span> <span class="n">cpumask_size</span><span class="p">(),</span>
					<span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">j</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sd</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

			<span class="o">*</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">sd</span><span class="p">;</span>

			<span class="n">sg</span> <span class="o">=</span> <span class="n">kzalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_group</span><span class="p">)</span> <span class="o">+</span> <span class="n">cpumask_size</span><span class="p">(),</span>
					<span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">j</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sg</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

			<span class="n">sg</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">sg</span><span class="p">;</span>

			<span class="o">*</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">sg</span><span class="p">;</span>

			<span class="n">sgp</span> <span class="o">=</span> <span class="n">kzalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_group_power</span><span class="p">)</span> <span class="o">+</span> <span class="n">cpumask_size</span><span class="p">(),</span>
					<span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">j</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sgp</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

			<span class="o">*</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">sgp</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__sdt_free</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpu_map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_domain_topology_level</span> <span class="o">*</span><span class="n">tl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">tl</span> <span class="o">=</span> <span class="n">sched_domain_topology</span><span class="p">;</span> <span class="n">tl</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">;</span> <span class="n">tl</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sd_data</span> <span class="o">*</span><span class="n">sdd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tl</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

		<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">cpu_map</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sd</span> <span class="o">=</span> <span class="o">*</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">sd</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SD_OVERLAP</span><span class="p">))</span>
					<span class="n">free_sched_groups</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="o">*</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">,</span> <span class="n">j</span><span class="p">));</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">)</span>
				<span class="n">kfree</span><span class="p">(</span><span class="o">*</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">,</span> <span class="n">j</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="p">)</span>
				<span class="n">kfree</span><span class="p">(</span><span class="o">*</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="p">,</span> <span class="n">j</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">free_percpu</span><span class="p">(</span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">);</span>
		<span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">free_percpu</span><span class="p">(</span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">);</span>
		<span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">free_percpu</span><span class="p">(</span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="p">);</span>
		<span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sgp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="nf">build_sched_domain</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain_topology_level</span> <span class="o">*</span><span class="n">tl</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">s_data</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpu_map</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">sched_domain_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="n">tl</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="n">tl</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sd</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">child</span><span class="p">;</span>

	<span class="n">cpumask_and</span><span class="p">(</span><span class="n">sched_domain_span</span><span class="p">(</span><span class="n">sd</span><span class="p">),</span> <span class="n">cpu_map</span><span class="p">,</span> <span class="n">tl</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sd</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">=</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">sched_domain_level_max</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">sched_domain_level_max</span><span class="p">,</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">);</span>
		<span class="n">child</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">sd</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sd</span><span class="o">-&gt;</span><span class="n">child</span> <span class="o">=</span> <span class="n">child</span><span class="p">;</span>
	<span class="n">set_domain_attribute</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sd</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Build sched domains for a given set of cpus and attach the sched domains</span>
<span class="cm"> * to the individual cpus</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">build_sched_domains</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpu_map</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">sched_domain_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">s_alloc</span> <span class="n">alloc_state</span> <span class="o">=</span> <span class="n">sa_none</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">s_data</span> <span class="n">d</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">alloc_state</span> <span class="o">=</span> <span class="n">__visit_domain_allocation_hell</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">,</span> <span class="n">cpu_map</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alloc_state</span> <span class="o">!=</span> <span class="n">sa_rootdomain</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* Set up domains for cpus specified by the cpu_map. */</span>
	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">cpu_map</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sched_domain_topology_level</span> <span class="o">*</span><span class="n">tl</span><span class="p">;</span>

		<span class="n">sd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">tl</span> <span class="o">=</span> <span class="n">sched_domain_topology</span><span class="p">;</span> <span class="n">tl</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">;</span> <span class="n">tl</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sd</span> <span class="o">=</span> <span class="n">build_sched_domain</span><span class="p">(</span><span class="n">tl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">,</span> <span class="n">cpu_map</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tl</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SDTL_OVERLAP</span> <span class="o">||</span> <span class="n">sched_feat</span><span class="p">(</span><span class="n">FORCE_SD_OVERLAP</span><span class="p">))</span>
				<span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">SD_OVERLAP</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_equal</span><span class="p">(</span><span class="n">cpu_map</span><span class="p">,</span> <span class="n">sched_domain_span</span><span class="p">(</span><span class="n">sd</span><span class="p">)))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">)</span>
			<span class="n">sd</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">;</span>

		<span class="o">*</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">sd</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">sd</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Build the groups for the domains */</span>
	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">cpu_map</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">sd</span> <span class="o">=</span> <span class="o">*</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">sd</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span> <span class="n">sd</span><span class="p">;</span> <span class="n">sd</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sd</span><span class="o">-&gt;</span><span class="n">span_weight</span> <span class="o">=</span> <span class="n">cpumask_weight</span><span class="p">(</span><span class="n">sched_domain_span</span><span class="p">(</span><span class="n">sd</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SD_OVERLAP</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">build_overlap_sched_groups</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">build_sched_groups</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Calculate CPU power for physical packages and nodes */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">nr_cpumask_bits</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">cpu_map</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">sd</span> <span class="o">=</span> <span class="o">*</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">sd</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span> <span class="n">sd</span><span class="p">;</span> <span class="n">sd</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">claim_allocations</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">sd</span><span class="p">);</span>
			<span class="n">init_sched_groups_power</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">sd</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Attach the domains */</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">cpu_map</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sd</span> <span class="o">=</span> <span class="o">*</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">sd</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">cpu_attach_domain</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">d</span><span class="p">.</span><span class="n">rd</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">error:</span>
	<span class="n">__free_domain_allocs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">,</span> <span class="n">alloc_state</span><span class="p">,</span> <span class="n">cpu_map</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">cpumask_var_t</span> <span class="o">*</span><span class="n">doms_cur</span><span class="p">;</span>	<span class="cm">/* current sched domains */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ndoms_cur</span><span class="p">;</span>		<span class="cm">/* number of sched domains in &#39;doms_cur&#39; */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sched_domain_attr</span> <span class="o">*</span><span class="n">dattr_cur</span><span class="p">;</span>
				<span class="cm">/* attribues of custom domains in &#39;doms_cur&#39; */</span>

<span class="cm">/*</span>
<span class="cm"> * Special case: If a kmalloc of a doms_cur partition (array of</span>
<span class="cm"> * cpumask) fails, then fallback to a single sched domain,</span>
<span class="cm"> * as determined by the single cpumask fallback_doms.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">cpumask_var_t</span> <span class="n">fallback_doms</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * arch_update_cpu_topology lets virtualized architectures update the</span>
<span class="cm"> * cpu core maps. It is supposed to return 1 if the topology changed</span>
<span class="cm"> * or 0 if it stayed the same.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">weak</span><span class="p">))</span> <span class="n">arch_update_cpu_topology</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">cpumask_var_t</span> <span class="o">*</span><span class="nf">alloc_sched_domains</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ndoms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">cpumask_var_t</span> <span class="o">*</span><span class="n">doms</span><span class="p">;</span>

	<span class="n">doms</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">doms</span><span class="p">)</span> <span class="o">*</span> <span class="n">ndoms</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">doms</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ndoms</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">doms</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">free_sched_domains</span><span class="p">(</span><span class="n">doms</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">doms</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">free_sched_domains</span><span class="p">(</span><span class="n">cpumask_var_t</span> <span class="n">doms</span><span class="p">[],</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ndoms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ndoms</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">doms</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">doms</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set up scheduler domains and groups. Callers must hold the hotplug lock.</span>
<span class="cm"> * For now this just excludes isolated cpus, but could be used to</span>
<span class="cm"> * exclude other special cases in the future.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_sched_domains</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpu_map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">arch_update_cpu_topology</span><span class="p">();</span>
	<span class="n">ndoms_cur</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">doms_cur</span> <span class="o">=</span> <span class="n">alloc_sched_domains</span><span class="p">(</span><span class="n">ndoms_cur</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">doms_cur</span><span class="p">)</span>
		<span class="n">doms_cur</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fallback_doms</span><span class="p">;</span>
	<span class="n">cpumask_andnot</span><span class="p">(</span><span class="n">doms_cur</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cpu_map</span><span class="p">,</span> <span class="n">cpu_isolated_map</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">build_sched_domains</span><span class="p">(</span><span class="n">doms_cur</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">register_sched_domain_sysctl</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Detach sched domains from a group of cpus specified in cpu_map</span>
<span class="cm"> * These cpus will now be attached to the NULL domain</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">detach_destroy_domains</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpu_map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">cpu_map</span><span class="p">)</span>
		<span class="n">cpu_attach_domain</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">def_root_domain</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* handle null as &quot;default&quot; */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dattrs_equal</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain_attr</span> <span class="o">*</span><span class="n">cur</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx_cur</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">sched_domain_attr</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx_new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_domain_attr</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/* fast path */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cur</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">SD_ATTR_INIT</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">cur</span> <span class="o">?</span> <span class="p">(</span><span class="n">cur</span> <span class="o">+</span> <span class="n">idx_cur</span><span class="p">)</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span>
			<span class="n">new</span> <span class="o">?</span> <span class="p">(</span><span class="n">new</span> <span class="o">+</span> <span class="n">idx_new</span><span class="p">)</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain_attr</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Partition sched domains as specified by the &#39;ndoms_new&#39;</span>
<span class="cm"> * cpumasks in the array doms_new[] of cpumasks. This compares</span>
<span class="cm"> * doms_new[] to the current sched domain partitioning, doms_cur[].</span>
<span class="cm"> * It destroys each deleted domain and builds each new domain.</span>
<span class="cm"> *</span>
<span class="cm"> * &#39;doms_new&#39; is an array of cpumask_var_t&#39;s of length &#39;ndoms_new&#39;.</span>
<span class="cm"> * The masks don&#39;t intersect (don&#39;t overlap.) We should setup one</span>
<span class="cm"> * sched domain for each mask. CPUs not in any of the cpumasks will</span>
<span class="cm"> * not be load balanced. If the same cpumask appears both in the</span>
<span class="cm"> * current &#39;doms_cur&#39; domains and in the new &#39;doms_new&#39;, we can leave</span>
<span class="cm"> * it as it is.</span>
<span class="cm"> *</span>
<span class="cm"> * The passed in &#39;doms_new&#39; should be allocated using</span>
<span class="cm"> * alloc_sched_domains.  This routine takes ownership of it and will</span>
<span class="cm"> * free_sched_domains it when done with it. If the caller failed the</span>
<span class="cm"> * alloc call, then it can pass in doms_new == NULL &amp;&amp; ndoms_new == 1,</span>
<span class="cm"> * and partition_sched_domains() will fallback to the single partition</span>
<span class="cm"> * &#39;fallback_doms&#39;, it also forces the domains to be rebuilt.</span>
<span class="cm"> *</span>
<span class="cm"> * If doms_new == NULL it will be replaced with cpu_online_mask.</span>
<span class="cm"> * ndoms_new == 0 is a special case for destroying existing domains,</span>
<span class="cm"> * and it will not create the default domain.</span>
<span class="cm"> *</span>
<span class="cm"> * Call with hotplug lock held</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">partition_sched_domains</span><span class="p">(</span><span class="kt">int</span> <span class="n">ndoms_new</span><span class="p">,</span> <span class="n">cpumask_var_t</span> <span class="n">doms_new</span><span class="p">[],</span>
			     <span class="k">struct</span> <span class="n">sched_domain_attr</span> <span class="o">*</span><span class="n">dattr_new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">new_topology</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sched_domains_mutex</span><span class="p">);</span>

	<span class="cm">/* always unregister in case we don&#39;t destroy any domains */</span>
	<span class="n">unregister_sched_domain_sysctl</span><span class="p">();</span>

	<span class="cm">/* Let architecture update cpu core mappings. */</span>
	<span class="n">new_topology</span> <span class="o">=</span> <span class="n">arch_update_cpu_topology</span><span class="p">();</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">doms_new</span> <span class="o">?</span> <span class="n">ndoms_new</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Destroy deleted domains */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ndoms_cur</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">new_topology</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_equal</span><span class="p">(</span><span class="n">doms_cur</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">doms_new</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
			    <span class="o">&amp;&amp;</span> <span class="n">dattrs_equal</span><span class="p">(</span><span class="n">dattr_cur</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">dattr_new</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">match1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* no match - a current sched domain not in new doms_new[] */</span>
		<span class="n">detach_destroy_domains</span><span class="p">(</span><span class="n">doms_cur</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="nl">match1:</span>
		<span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">doms_new</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ndoms_cur</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">doms_new</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fallback_doms</span><span class="p">;</span>
		<span class="n">cpumask_andnot</span><span class="p">(</span><span class="n">doms_new</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cpu_active_mask</span><span class="p">,</span> <span class="n">cpu_isolated_map</span><span class="p">);</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">dattr_new</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Build new domains */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ndoms_new</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">ndoms_cur</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">new_topology</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_equal</span><span class="p">(</span><span class="n">doms_new</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">doms_cur</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
			    <span class="o">&amp;&amp;</span> <span class="n">dattrs_equal</span><span class="p">(</span><span class="n">dattr_new</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">dattr_cur</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">match2</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* no match - add a new doms_new */</span>
		<span class="n">build_sched_domains</span><span class="p">(</span><span class="n">doms_new</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dattr_new</span> <span class="o">?</span> <span class="n">dattr_new</span> <span class="o">+</span> <span class="n">i</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="nl">match2:</span>
		<span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Remember the new sched domains */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">doms_cur</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">fallback_doms</span><span class="p">)</span>
		<span class="n">free_sched_domains</span><span class="p">(</span><span class="n">doms_cur</span><span class="p">,</span> <span class="n">ndoms_cur</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dattr_cur</span><span class="p">);</span>	<span class="cm">/* kfree(NULL) is safe */</span>
	<span class="n">doms_cur</span> <span class="o">=</span> <span class="n">doms_new</span><span class="p">;</span>
	<span class="n">dattr_cur</span> <span class="o">=</span> <span class="n">dattr_new</span><span class="p">;</span>
	<span class="n">ndoms_cur</span> <span class="o">=</span> <span class="n">ndoms_new</span><span class="p">;</span>

	<span class="n">register_sched_domain_sysctl</span><span class="p">();</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sched_domains_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Update cpusets according to cpu_active mask.  If cpusets are</span>
<span class="cm"> * disabled, cpuset_update_active_cpus() becomes a simple wrapper</span>
<span class="cm"> * around partition_sched_domains().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cpuset_cpu_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nfb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span>
			     <span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CPU_TASKS_FROZEN</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_ONLINE</span>:
	<span class="k">case</span> <span class="n">CPU_DOWN_FAILED</span>:
		<span class="n">cpuset_update_active_cpus</span><span class="p">();</span>
		<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cpuset_cpu_inactive</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nfb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span>
			       <span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CPU_TASKS_FROZEN</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_DOWN_PREPARE</span>:
		<span class="n">cpuset_update_active_cpus</span><span class="p">();</span>
		<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">sched_init_smp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpumask_var_t</span> <span class="n">non_isolated_cpus</span><span class="p">;</span>

	<span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">non_isolated_cpus</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fallback_doms</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="n">sched_init_numa</span><span class="p">();</span>

	<span class="n">get_online_cpus</span><span class="p">();</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sched_domains_mutex</span><span class="p">);</span>
	<span class="n">init_sched_domains</span><span class="p">(</span><span class="n">cpu_active_mask</span><span class="p">);</span>
	<span class="n">cpumask_andnot</span><span class="p">(</span><span class="n">non_isolated_cpus</span><span class="p">,</span> <span class="n">cpu_possible_mask</span><span class="p">,</span> <span class="n">cpu_isolated_map</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="n">non_isolated_cpus</span><span class="p">))</span>
		<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">(),</span> <span class="n">non_isolated_cpus</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sched_domains_mutex</span><span class="p">);</span>
	<span class="n">put_online_cpus</span><span class="p">();</span>

	<span class="n">hotcpu_notifier</span><span class="p">(</span><span class="n">cpuset_cpu_active</span><span class="p">,</span> <span class="n">CPU_PRI_CPUSET_ACTIVE</span><span class="p">);</span>
	<span class="n">hotcpu_notifier</span><span class="p">(</span><span class="n">cpuset_cpu_inactive</span><span class="p">,</span> <span class="n">CPU_PRI_CPUSET_INACTIVE</span><span class="p">);</span>

	<span class="cm">/* RT runtime code needs to handle some hotplug events */</span>
	<span class="n">hotcpu_notifier</span><span class="p">(</span><span class="n">update_runtime</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">init_hrtick</span><span class="p">();</span>

	<span class="cm">/* Move init over to a non-isolated CPU */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">set_cpus_allowed_ptr</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">non_isolated_cpus</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="n">sched_init_granularity</span><span class="p">();</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">non_isolated_cpus</span><span class="p">);</span>

	<span class="n">init_sched_rt_class</span><span class="p">();</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">sched_init_smp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sched_init_granularity</span><span class="p">();</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="n">const_debug</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_timer_migration</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">in_sched_functions</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">in_lock_functions</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__sched_text_start</span>
		<span class="o">&amp;&amp;</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__sched_text_end</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_CGROUP_SCHED</span>
<span class="k">struct</span> <span class="n">task_group</span> <span class="n">root_task_group</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="n">DECLARE_PER_CPU</span><span class="p">(</span><span class="n">cpumask_var_t</span><span class="p">,</span> <span class="n">load_balance_tmpmask</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">sched_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">alloc_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ptr</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_FAIR_GROUP_SCHED</span>
	<span class="n">alloc_size</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nr_cpu_ids</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_RT_GROUP_SCHED</span>
	<span class="n">alloc_size</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nr_cpu_ids</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_CPUMASK_OFFSTACK</span>
	<span class="n">alloc_size</span> <span class="o">+=</span> <span class="n">num_possible_cpus</span><span class="p">()</span> <span class="o">*</span> <span class="n">cpumask_size</span><span class="p">();</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alloc_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">kzalloc</span><span class="p">(</span><span class="n">alloc_size</span><span class="p">,</span> <span class="n">GFP_NOWAIT</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_FAIR_GROUP_SCHED</span>
		<span class="n">root_task_group</span><span class="p">.</span><span class="n">se</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">**</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>
		<span class="n">ptr</span> <span class="o">+=</span> <span class="n">nr_cpu_ids</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">);</span>

		<span class="n">root_task_group</span><span class="p">.</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">**</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>
		<span class="n">ptr</span> <span class="o">+=</span> <span class="n">nr_cpu_ids</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_FAIR_GROUP_SCHED */</span><span class="cp"></span>
<span class="cp">#ifdef CONFIG_RT_GROUP_SCHED</span>
		<span class="n">root_task_group</span><span class="p">.</span><span class="n">rt_se</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">**</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>
		<span class="n">ptr</span> <span class="o">+=</span> <span class="n">nr_cpu_ids</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">);</span>

		<span class="n">root_task_group</span><span class="p">.</span><span class="n">rt_rq</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">**</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>
		<span class="n">ptr</span> <span class="o">+=</span> <span class="n">nr_cpu_ids</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_RT_GROUP_SCHED */</span><span class="cp"></span>
<span class="cp">#ifdef CONFIG_CPUMASK_OFFSTACK</span>
		<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">per_cpu</span><span class="p">(</span><span class="n">load_balance_tmpmask</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>
			<span class="n">ptr</span> <span class="o">+=</span> <span class="n">cpumask_size</span><span class="p">();</span>
		<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_CPUMASK_OFFSTACK */</span><span class="cp"></span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">init_defrootdomain</span><span class="p">();</span>
<span class="cp">#endif</span>

	<span class="n">init_rt_bandwidth</span><span class="p">(</span><span class="o">&amp;</span><span class="n">def_rt_bandwidth</span><span class="p">,</span>
			<span class="n">global_rt_period</span><span class="p">(),</span> <span class="n">global_rt_runtime</span><span class="p">());</span>

<span class="cp">#ifdef CONFIG_RT_GROUP_SCHED</span>
	<span class="n">init_rt_bandwidth</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_task_group</span><span class="p">.</span><span class="n">rt_bandwidth</span><span class="p">,</span>
			<span class="n">global_rt_period</span><span class="p">(),</span> <span class="n">global_rt_runtime</span><span class="p">());</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_RT_GROUP_SCHED */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_CGROUP_SCHED</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_task_group</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">task_groups</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_task_group</span><span class="p">.</span><span class="n">children</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_task_group</span><span class="p">.</span><span class="n">siblings</span><span class="p">);</span>
	<span class="n">autogroup_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_task</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_CGROUP_SCHED */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_CGROUP_CPUACCT</span>
	<span class="n">root_cpuacct</span><span class="p">.</span><span class="n">cpustat</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kernel_cpustat</span><span class="p">;</span>
	<span class="n">root_cpuacct</span><span class="p">.</span><span class="n">cpuusage</span> <span class="o">=</span> <span class="n">alloc_percpu</span><span class="p">(</span><span class="n">u64</span><span class="p">);</span>
	<span class="cm">/* Too early, not expected to fail */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">root_cpuacct</span><span class="p">.</span><span class="n">cpuusage</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>

		<span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="n">raw_spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">calc_load_active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">calc_load_update</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">LOAD_FREQ</span><span class="p">;</span>
		<span class="n">init_cfs_rq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">);</span>
		<span class="n">init_rt_rq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_FAIR_GROUP_SCHED</span>
		<span class="n">root_task_group</span><span class="p">.</span><span class="n">shares</span> <span class="o">=</span> <span class="n">ROOT_TASK_GROUP_LOAD</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">leaf_cfs_rq_list</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * How much cpu bandwidth does root_task_group get?</span>
<span class="cm">		 *</span>
<span class="cm">		 * In case of task-groups formed thr&#39; the cgroup filesystem, it</span>
<span class="cm">		 * gets 100% of the cpu resources in the system. This overall</span>
<span class="cm">		 * system cpu resource is divided among the tasks of</span>
<span class="cm">		 * root_task_group and its child task-groups in a fair manner,</span>
<span class="cm">		 * based on each entity&#39;s (task or task-group&#39;s) weight</span>
<span class="cm">		 * (se-&gt;load.weight).</span>
<span class="cm">		 *</span>
<span class="cm">		 * In other words, if root_task_group has 10 tasks of weight</span>
<span class="cm">		 * 1024) and two child groups A0 and A1 (of weight 1024 each),</span>
<span class="cm">		 * then A0&#39;s share of the cpu resource is:</span>
<span class="cm">		 *</span>
<span class="cm">		 *	A0&#39;s bandwidth = 1024 / (10*1024 + 1024 + 1024) = 8.33%</span>
<span class="cm">		 *</span>
<span class="cm">		 * We achieve this by letting root_task_group&#39;s tasks sit</span>
<span class="cm">		 * directly in rq-&gt;cfs (i.e root_task_group-&gt;se[] = NULL).</span>
<span class="cm">		 */</span>
		<span class="n">init_cfs_bandwidth</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_task_group</span><span class="p">.</span><span class="n">cfs_bandwidth</span><span class="p">);</span>
		<span class="n">init_tg_cfs_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_task_group</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_FAIR_GROUP_SCHED */</span><span class="cp"></span>

		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">rt_runtime</span> <span class="o">=</span> <span class="n">def_rt_bandwidth</span><span class="p">.</span><span class="n">rt_runtime</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_RT_GROUP_SCHED</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">leaf_rt_rq_list</span><span class="p">);</span>
		<span class="n">init_tg_rt_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_task_group</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="cp">#endif</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">CPU_LOAD_IDX_MAX</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu_load</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">last_load_update_tick</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SMP</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">sd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">rd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu_power</span> <span class="o">=</span> <span class="n">SCHED_POWER_SCALE</span><span class="p">;</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">post_schedule</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">active_balance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">next_balance</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">push_cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">online</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">idle_stamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">avg_idle</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">sysctl_sched_migration_cost</span><span class="p">;</span>

		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cfs_tasks</span><span class="p">);</span>

		<span class="n">rq_attach_root</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">def_root_domain</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_NO_HZ</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">nohz_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>
		<span class="n">init_rq_hrtick</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_iowait</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">set_load_weight</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_task</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PREEMPT_NOTIFIERS</span>
	<span class="n">INIT_HLIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_task</span><span class="p">.</span><span class="n">preempt_notifiers</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_RT_MUTEXES</span>
	<span class="n">plist_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_task</span><span class="p">.</span><span class="n">pi_waiters</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * The boot idle thread does lazy MMU switching as well:</span>
<span class="cm">	 */</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">.</span><span class="n">mm_count</span><span class="p">);</span>
	<span class="n">enter_lazy_tlb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make us the idle thread. Technically, schedule() should not be</span>
<span class="cm">	 * called from this thread, however somewhere below it might be,</span>
<span class="cm">	 * but because we are the idle thread, we just pick up running again</span>
<span class="cm">	 * when this runqueue becomes &quot;idle&quot;.</span>
<span class="cm">	 */</span>
	<span class="n">init_idle</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>

	<span class="n">calc_load_update</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">LOAD_FREQ</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * During early bootup we pretend to be a normal task:</span>
<span class="cm">	 */</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fair_sched_class</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">zalloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sched_domains_tmpmask</span><span class="p">,</span> <span class="n">GFP_NOWAIT</span><span class="p">);</span>
	<span class="cm">/* May be allocated at isolcpus cmdline parse time */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_isolated_map</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">zalloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_isolated_map</span><span class="p">,</span> <span class="n">GFP_NOWAIT</span><span class="p">);</span>
	<span class="n">idle_thread_set_boot_cpu</span><span class="p">();</span>
<span class="cp">#endif</span>
	<span class="n">init_sched_fair_class</span><span class="p">();</span>

	<span class="n">scheduler_running</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_DEBUG_ATOMIC_SLEEP</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">preempt_count_equals</span><span class="p">(</span><span class="kt">int</span> <span class="n">preempt_offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nested</span> <span class="o">=</span> <span class="p">(</span><span class="n">preempt_count</span><span class="p">()</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PREEMPT_ACTIVE</span><span class="p">)</span> <span class="o">+</span> <span class="n">rcu_preempt_depth</span><span class="p">();</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">nested</span> <span class="o">==</span> <span class="n">preempt_offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__might_sleep</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">line</span><span class="p">,</span> <span class="kt">int</span> <span class="n">preempt_offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prev_jiffy</span><span class="p">;</span>	<span class="cm">/* ratelimiting */</span>

	<span class="n">rcu_sleep_check</span><span class="p">();</span> <span class="cm">/* WARN_ON_ONCE() by default, no rate limit reqd. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">preempt_count_equals</span><span class="p">(</span><span class="n">preempt_offset</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">irqs_disabled</span><span class="p">())</span> <span class="o">||</span>
	    <span class="n">system_state</span> <span class="o">!=</span> <span class="n">SYSTEM_RUNNING</span> <span class="o">||</span> <span class="n">oops_in_progress</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">prev_jiffy</span> <span class="o">+</span> <span class="n">HZ</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">prev_jiffy</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">prev_jiffy</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
		<span class="s">&quot;BUG: sleeping function called from invalid context at %s:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">file</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
		<span class="s">&quot;in_atomic(): %d, irqs_disabled(): %d, pid: %d, name: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">in_atomic</span><span class="p">(),</span> <span class="n">irqs_disabled</span><span class="p">(),</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">);</span>

	<span class="n">debug_show_held_locks</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irqs_disabled</span><span class="p">())</span>
		<span class="n">print_irqtrace_events</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">dump_stack</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__might_sleep</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_MAGIC_SYSRQ</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">normalize_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sched_class</span> <span class="o">*</span><span class="n">prev_class</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">old_prio</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">on_rq</span><span class="p">;</span>

	<span class="n">on_rq</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">on_rq</span><span class="p">)</span>
		<span class="n">dequeue_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">__setscheduler</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">SCHED_NORMAL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">on_rq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">enqueue_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">resched_task</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">check_class_changed</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">prev_class</span><span class="p">,</span> <span class="n">old_prio</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">normalize_rt_tasks</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">g</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>

	<span class="n">read_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">do_each_thread</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Only normalize user tasks:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">exec_start</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SCHEDSTATS</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">statistics</span><span class="p">.</span><span class="n">wait_start</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">statistics</span><span class="p">.</span><span class="n">sleep_start</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">statistics</span><span class="p">.</span><span class="n">block_start</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rt_task</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Renice negative nice level userspace</span>
<span class="cm">			 * tasks back to 0:</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">TASK_NICE</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span>
				<span class="n">set_user_nice</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>
		<span class="n">rq</span> <span class="o">=</span> <span class="n">__task_rq_lock</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

		<span class="n">normalize_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

		<span class="n">__task_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="n">while_each_thread</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

	<span class="n">read_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_MAGIC_SYSRQ */</span><span class="cp"></span>

<span class="cp">#if defined(CONFIG_IA64) || defined(CONFIG_KGDB_KDB)</span>
<span class="cm">/*</span>
<span class="cm"> * These functions are only useful for the IA64 MCA handling, or kdb.</span>
<span class="cm"> *</span>
<span class="cm"> * They can only be called when the whole system has been</span>
<span class="cm"> * stopped - every CPU needs to be quiescent, and no scheduling</span>
<span class="cm"> * activity can take place. Using them for anything else would</span>
<span class="cm"> * be a serious bug, and as a result, they aren&#39;t even visible</span>
<span class="cm"> * under any other configuration.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * curr_task - return the current task for a given cpu.</span>
<span class="cm"> * @cpu: the processor in question.</span>
<span class="cm"> *</span>
<span class="cm"> * ONLY VALID WHEN THE WHOLE SYSTEM IS STOPPED!</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">curr_task</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cpu_curr</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* defined(CONFIG_IA64) || defined(CONFIG_KGDB_KDB) */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_IA64</span>
<span class="cm">/**</span>
<span class="cm"> * set_curr_task - set the current task for a given cpu.</span>
<span class="cm"> * @cpu: the processor in question.</span>
<span class="cm"> * @p: the task pointer to set.</span>
<span class="cm"> *</span>
<span class="cm"> * Description: This function must only be used when non-maskable interrupts</span>
<span class="cm"> * are serviced on a separate stack. It allows the architecture to switch the</span>
<span class="cm"> * notion of the current task on a cpu in a non-blocking manner. This function</span>
<span class="cm"> * must be called with all CPU&#39;s synchronized, and interrupts disabled, the</span>
<span class="cm"> * and caller must save the original value of the current task (see</span>
<span class="cm"> * curr_task() above) and restore that value before reenabling interrupts and</span>
<span class="cm"> * re-starting the system.</span>
<span class="cm"> *</span>
<span class="cm"> * ONLY VALID WHEN THE WHOLE SYSTEM IS STOPPED!</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">set_curr_task</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpu_curr</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_CGROUP_SCHED</span>
<span class="cm">/* task_group_lock serializes the addition/removal of task groups */</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">task_group_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_sched_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_fair_sched_group</span><span class="p">(</span><span class="n">tg</span><span class="p">);</span>
	<span class="n">free_rt_sched_group</span><span class="p">(</span><span class="n">tg</span><span class="p">);</span>
	<span class="n">autogroup_free</span><span class="p">(</span><span class="n">tg</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">tg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* allocate runqueue etc for a new task group */</span>
<span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="nf">sched_create_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">tg</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tg</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tg</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_fair_sched_group</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="n">parent</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_rt_sched_group</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="n">parent</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task_group_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_add_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">task_groups</span><span class="p">);</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">parent</span><span class="p">);</span> <span class="cm">/* root should already exist */</span>

	<span class="n">tg</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">);</span>
	<span class="n">list_add_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">siblings</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task_group_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">tg</span><span class="p">;</span>

<span class="nl">err:</span>
	<span class="n">free_sched_group</span><span class="p">(</span><span class="n">tg</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* rcu callback to free various structures associated with a task group */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_sched_group_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">rhp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* now it should be safe to free those cfs_rqs */</span>
	<span class="n">free_sched_group</span><span class="p">(</span><span class="n">container_of</span><span class="p">(</span><span class="n">rhp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_group</span><span class="p">,</span> <span class="n">rcu</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Destroy runqueue etc associated with a task group */</span>
<span class="kt">void</span> <span class="nf">sched_destroy_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* end participation in shares distribution */</span>
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="n">unregister_fair_sched_group</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task_group_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">siblings</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task_group_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* wait for possible concurrent references to cfs_rqs complete */</span>
	<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">rcu</span><span class="p">,</span> <span class="n">free_sched_group_rcu</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* change task&#39;s runqueue when it moves between groups.</span>
<span class="cm"> *	The caller of this function should have put the task in its new group</span>
<span class="cm"> *	by now. This function just updates tsk-&gt;se.cfs_rq and tsk-&gt;se.parent to</span>
<span class="cm"> *	reflect its new group.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sched_move_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">on_rq</span><span class="p">,</span> <span class="n">running</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>

	<span class="n">rq</span> <span class="o">=</span> <span class="n">task_rq_lock</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">running</span> <span class="o">=</span> <span class="n">task_current</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>
	<span class="n">on_rq</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">on_rq</span><span class="p">)</span>
		<span class="n">dequeue_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">tsk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">running</span><span class="p">))</span>
		<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">put_prev_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_FAIR_GROUP_SCHED</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">task_move_group</span><span class="p">)</span>
		<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">task_move_group</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">on_rq</span><span class="p">);</span>
	<span class="k">else</span>
<span class="cp">#endif</span>
		<span class="n">set_task_rq</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">task_cpu</span><span class="p">(</span><span class="n">tsk</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">running</span><span class="p">))</span>
		<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">set_curr_task</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">on_rq</span><span class="p">)</span>
		<span class="n">enqueue_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">tsk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">task_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">tsk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_CGROUP_SCHED */</span><span class="cp"></span>

<span class="cp">#if defined(CONFIG_RT_GROUP_SCHED) || defined(CONFIG_CFS_BANDWIDTH)</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">to_ratio</span><span class="p">(</span><span class="n">u64</span> <span class="n">period</span><span class="p">,</span> <span class="n">u64</span> <span class="n">runtime</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">runtime</span> <span class="o">==</span> <span class="n">RUNTIME_INF</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">div64_u64</span><span class="p">(</span><span class="n">runtime</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">,</span> <span class="n">period</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_RT_GROUP_SCHED</span>
<span class="cm">/*</span>
<span class="cm"> * Ensure that the real time constraints are schedulable.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">rt_constraints_mutex</span><span class="p">);</span>

<span class="cm">/* Must be called with tasklist_lock held */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tg_has_rt_tasks</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">g</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">do_each_thread</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rt_task</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">tg</span> <span class="o">==</span> <span class="n">tg</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">while_each_thread</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">rt_schedulable_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rt_period</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rt_runtime</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tg_rt_schedulable</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rt_schedulable_data</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total</span><span class="p">,</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">period</span><span class="p">,</span> <span class="n">runtime</span><span class="p">;</span>

	<span class="n">period</span> <span class="o">=</span> <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">rt_bandwidth</span><span class="p">.</span><span class="n">rt_period</span><span class="p">);</span>
	<span class="n">runtime</span> <span class="o">=</span> <span class="n">tg</span><span class="o">-&gt;</span><span class="n">rt_bandwidth</span><span class="p">.</span><span class="n">rt_runtime</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tg</span> <span class="o">==</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">tg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">period</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">rt_period</span><span class="p">;</span>
		<span class="n">runtime</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">rt_runtime</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Cannot have more runtime than the period.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">runtime</span> <span class="o">&gt;</span> <span class="n">period</span> <span class="o">&amp;&amp;</span> <span class="n">runtime</span> <span class="o">!=</span> <span class="n">RUNTIME_INF</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ensure we don&#39;t starve existing RT tasks.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rt_bandwidth_enabled</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">runtime</span> <span class="o">&amp;&amp;</span> <span class="n">tg_has_rt_tasks</span><span class="p">(</span><span class="n">tg</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">total</span> <span class="o">=</span> <span class="n">to_ratio</span><span class="p">(</span><span class="n">period</span><span class="p">,</span> <span class="n">runtime</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Nobody can have more than the global setting allows.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">total</span> <span class="o">&gt;</span> <span class="n">to_ratio</span><span class="p">(</span><span class="n">global_rt_period</span><span class="p">(),</span> <span class="n">global_rt_runtime</span><span class="p">()))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The sum of our children&#39;s runtime should not exceed our own.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">,</span> <span class="n">siblings</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">period</span> <span class="o">=</span> <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">rt_bandwidth</span><span class="p">.</span><span class="n">rt_period</span><span class="p">);</span>
		<span class="n">runtime</span> <span class="o">=</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">rt_bandwidth</span><span class="p">.</span><span class="n">rt_runtime</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">child</span> <span class="o">==</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">tg</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">period</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">rt_period</span><span class="p">;</span>
			<span class="n">runtime</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">rt_runtime</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">sum</span> <span class="o">+=</span> <span class="n">to_ratio</span><span class="p">(</span><span class="n">period</span><span class="p">,</span> <span class="n">runtime</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="o">&gt;</span> <span class="n">total</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__rt_schedulable</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="n">u64</span> <span class="n">period</span><span class="p">,</span> <span class="n">u64</span> <span class="n">runtime</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">rt_schedulable_data</span> <span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">tg</span> <span class="o">=</span> <span class="n">tg</span><span class="p">,</span>
		<span class="p">.</span><span class="n">rt_period</span> <span class="o">=</span> <span class="n">period</span><span class="p">,</span>
		<span class="p">.</span><span class="n">rt_runtime</span> <span class="o">=</span> <span class="n">runtime</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">walk_tg_tree</span><span class="p">(</span><span class="n">tg_rt_schedulable</span><span class="p">,</span> <span class="n">tg_nop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tg_set_rt_bandwidth</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span>
		<span class="n">u64</span> <span class="n">rt_period</span><span class="p">,</span> <span class="n">u64</span> <span class="n">rt_runtime</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_constraints_mutex</span><span class="p">);</span>
	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">__rt_schedulable</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="n">rt_period</span><span class="p">,</span> <span class="n">rt_runtime</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">rt_bandwidth</span><span class="p">.</span><span class="n">rt_runtime_lock</span><span class="p">);</span>
	<span class="n">tg</span><span class="o">-&gt;</span><span class="n">rt_bandwidth</span><span class="p">.</span><span class="n">rt_period</span> <span class="o">=</span> <span class="n">ns_to_ktime</span><span class="p">(</span><span class="n">rt_period</span><span class="p">);</span>
	<span class="n">tg</span><span class="o">-&gt;</span><span class="n">rt_bandwidth</span><span class="p">.</span><span class="n">rt_runtime</span> <span class="o">=</span> <span class="n">rt_runtime</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span> <span class="o">=</span> <span class="n">tg</span><span class="o">-&gt;</span><span class="n">rt_rq</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_runtime_lock</span><span class="p">);</span>
		<span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_runtime</span> <span class="o">=</span> <span class="n">rt_runtime</span><span class="p">;</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_runtime_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">rt_bandwidth</span><span class="p">.</span><span class="n">rt_runtime_lock</span><span class="p">);</span>
<span class="nl">unlock:</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_constraints_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">sched_group_set_rt_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="kt">long</span> <span class="n">rt_runtime_us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">rt_runtime</span><span class="p">,</span> <span class="n">rt_period</span><span class="p">;</span>

	<span class="n">rt_period</span> <span class="o">=</span> <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">rt_bandwidth</span><span class="p">.</span><span class="n">rt_period</span><span class="p">);</span>
	<span class="n">rt_runtime</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">rt_runtime_us</span> <span class="o">*</span> <span class="n">NSEC_PER_USEC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rt_runtime_us</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">rt_runtime</span> <span class="o">=</span> <span class="n">RUNTIME_INF</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">tg_set_rt_bandwidth</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="n">rt_period</span><span class="p">,</span> <span class="n">rt_runtime</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">long</span> <span class="nf">sched_group_rt_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">rt_runtime_us</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">rt_bandwidth</span><span class="p">.</span><span class="n">rt_runtime</span> <span class="o">==</span> <span class="n">RUNTIME_INF</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">rt_runtime_us</span> <span class="o">=</span> <span class="n">tg</span><span class="o">-&gt;</span><span class="n">rt_bandwidth</span><span class="p">.</span><span class="n">rt_runtime</span><span class="p">;</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">rt_runtime_us</span><span class="p">,</span> <span class="n">NSEC_PER_USEC</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rt_runtime_us</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">sched_group_set_rt_period</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="kt">long</span> <span class="n">rt_period_us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">rt_runtime</span><span class="p">,</span> <span class="n">rt_period</span><span class="p">;</span>

	<span class="n">rt_period</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">rt_period_us</span> <span class="o">*</span> <span class="n">NSEC_PER_USEC</span><span class="p">;</span>
	<span class="n">rt_runtime</span> <span class="o">=</span> <span class="n">tg</span><span class="o">-&gt;</span><span class="n">rt_bandwidth</span><span class="p">.</span><span class="n">rt_runtime</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rt_period</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">tg_set_rt_bandwidth</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="n">rt_period</span><span class="p">,</span> <span class="n">rt_runtime</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">long</span> <span class="nf">sched_group_rt_period</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">rt_period_us</span><span class="p">;</span>

	<span class="n">rt_period_us</span> <span class="o">=</span> <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">rt_bandwidth</span><span class="p">.</span><span class="n">rt_period</span><span class="p">);</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">rt_period_us</span><span class="p">,</span> <span class="n">NSEC_PER_USEC</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rt_period_us</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sched_rt_global_constraints</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">runtime</span><span class="p">,</span> <span class="n">period</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_sched_rt_period</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">runtime</span> <span class="o">=</span> <span class="n">global_rt_runtime</span><span class="p">();</span>
	<span class="n">period</span> <span class="o">=</span> <span class="n">global_rt_period</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Sanity check on the sysctl variables.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">runtime</span> <span class="o">&gt;</span> <span class="n">period</span> <span class="o">&amp;&amp;</span> <span class="n">runtime</span> <span class="o">!=</span> <span class="n">RUNTIME_INF</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_constraints_mutex</span><span class="p">);</span>
	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__rt_schedulable</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_constraints_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">sched_rt_can_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Don&#39;t accept realtime tasks when there is no way for them to run */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rt_task</span><span class="p">(</span><span class="n">tsk</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">tg</span><span class="o">-&gt;</span><span class="n">rt_bandwidth</span><span class="p">.</span><span class="n">rt_runtime</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* !CONFIG_RT_GROUP_SCHED */</span><span class="cp"></span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sched_rt_global_constraints</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_sched_rt_period</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * There&#39;s always some RT tasks in the root group</span>
<span class="cm">	 * -- migration, kstopmachine etc..</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_sched_rt_runtime</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">def_rt_bandwidth</span><span class="p">.</span><span class="n">rt_runtime_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cpu_rq</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">;</span>

		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_runtime_lock</span><span class="p">);</span>
		<span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_runtime</span> <span class="o">=</span> <span class="n">global_rt_runtime</span><span class="p">();</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">rt_runtime_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">def_rt_bandwidth</span><span class="p">.</span><span class="n">rt_runtime_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_RT_GROUP_SCHED */</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">sched_rt_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
		<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">lenp</span><span class="p">,</span>
		<span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">old_period</span><span class="p">,</span> <span class="n">old_runtime</span><span class="p">;</span>
	<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">old_period</span> <span class="o">=</span> <span class="n">sysctl_sched_rt_period</span><span class="p">;</span>
	<span class="n">old_runtime</span> <span class="o">=</span> <span class="n">sysctl_sched_rt_runtime</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">proc_dointvec</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">lenp</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">write</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sched_rt_global_constraints</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sysctl_sched_rt_period</span> <span class="o">=</span> <span class="n">old_period</span><span class="p">;</span>
			<span class="n">sysctl_sched_rt_runtime</span> <span class="o">=</span> <span class="n">old_runtime</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">def_rt_bandwidth</span><span class="p">.</span><span class="n">rt_runtime</span> <span class="o">=</span> <span class="n">global_rt_runtime</span><span class="p">();</span>
			<span class="n">def_rt_bandwidth</span><span class="p">.</span><span class="n">rt_period</span> <span class="o">=</span>
				<span class="n">ns_to_ktime</span><span class="p">(</span><span class="n">global_rt_period</span><span class="p">());</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_CGROUP_SCHED</span>

<span class="cm">/* return corresponding task_group object of a cgroup */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="nf">cgroup_tg</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">cgroup_subsys_state</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="n">cpu_cgroup_subsys_id</span><span class="p">),</span>
			    <span class="k">struct</span> <span class="n">task_group</span><span class="p">,</span> <span class="n">css</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="nf">cpu_cgroup_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This is early initialization for the top cgroup */</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">root_task_group</span><span class="p">.</span><span class="n">css</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">parent</span> <span class="o">=</span> <span class="n">cgroup_tg</span><span class="p">(</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">tg</span> <span class="o">=</span> <span class="n">sched_create_group</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tg</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cpu_cgroup_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span> <span class="o">=</span> <span class="n">cgroup_tg</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>

	<span class="n">sched_destroy_group</span><span class="p">(</span><span class="n">tg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cpu_cgroup_can_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">cgroup_taskset</span> <span class="o">*</span><span class="n">tset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>

	<span class="n">cgroup_taskset_for_each</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">cgrp</span><span class="p">,</span> <span class="n">tset</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_RT_GROUP_SCHED</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sched_rt_can_attach</span><span class="p">(</span><span class="n">cgroup_tg</span><span class="p">(</span><span class="n">cgrp</span><span class="p">),</span> <span class="n">task</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="cp">#else</span>
		<span class="cm">/* We don&#39;t support RT-tasks being in separate groups */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">fair_sched_class</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cpu_cgroup_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">cgroup_taskset</span> <span class="o">*</span><span class="n">tset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>

	<span class="n">cgroup_taskset_for_each</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">cgrp</span><span class="p">,</span> <span class="n">tset</span><span class="p">)</span>
		<span class="n">sched_move_task</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cpu_cgroup_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">old_cgrp</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * cgroup_exit() is called in the copy_process() failure path.</span>
<span class="cm">	 * Ignore this case since the task hasn&#39;t ran yet, this avoids</span>
<span class="cm">	 * trying to poke a half freed task state from generic code.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_EXITING</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">sched_move_task</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_FAIR_GROUP_SCHED</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cpu_shares_write_u64</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cftype</span><span class="p">,</span>
				<span class="n">u64</span> <span class="n">shareval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sched_group_set_shares</span><span class="p">(</span><span class="n">cgroup_tg</span><span class="p">(</span><span class="n">cgrp</span><span class="p">),</span> <span class="n">scale_load</span><span class="p">(</span><span class="n">shareval</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">cpu_shares_read_u64</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span> <span class="o">=</span> <span class="n">cgroup_tg</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">scale_load_down</span><span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">shares</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_CFS_BANDWIDTH</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">cfs_constraints_mutex</span><span class="p">);</span>

<span class="k">const</span> <span class="n">u64</span> <span class="n">max_cfs_quota_period</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span><span class="p">;</span> <span class="cm">/* 1s */</span>
<span class="k">const</span> <span class="n">u64</span> <span class="n">min_cfs_quota_period</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">NSEC_PER_MSEC</span><span class="p">;</span> <span class="cm">/* 1ms */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__cfs_schedulable</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="n">u64</span> <span class="n">period</span><span class="p">,</span> <span class="n">u64</span> <span class="n">runtime</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tg_set_cfs_bandwidth</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="n">u64</span> <span class="n">period</span><span class="p">,</span> <span class="n">u64</span> <span class="n">quota</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">runtime_enabled</span><span class="p">,</span> <span class="n">runtime_was_enabled</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_bandwidth</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tg</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">root_task_group</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ensure we have at some amount of bandwidth every period.  This is</span>
<span class="cm">	 * to prevent reaching a state of large arrears when throttled via</span>
<span class="cm">	 * entity_tick() resulting in prolonged exit starvation.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">quota</span> <span class="o">&lt;</span> <span class="n">min_cfs_quota_period</span> <span class="o">||</span> <span class="n">period</span> <span class="o">&lt;</span> <span class="n">min_cfs_quota_period</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Likewise, bound things on the otherside by preventing insane quota</span>
<span class="cm">	 * periods.  This also allows us to normalize in computing quota</span>
<span class="cm">	 * feasibility.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">period</span> <span class="o">&gt;</span> <span class="n">max_cfs_quota_period</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_constraints_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__cfs_schedulable</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">quota</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">runtime_enabled</span> <span class="o">=</span> <span class="n">quota</span> <span class="o">!=</span> <span class="n">RUNTIME_INF</span><span class="p">;</span>
	<span class="n">runtime_was_enabled</span> <span class="o">=</span> <span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">quota</span> <span class="o">!=</span> <span class="n">RUNTIME_INF</span><span class="p">;</span>
	<span class="n">account_cfs_bandwidth_used</span><span class="p">(</span><span class="n">runtime_enabled</span><span class="p">,</span> <span class="n">runtime_was_enabled</span><span class="p">);</span>
	<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">=</span> <span class="n">ns_to_ktime</span><span class="p">(</span><span class="n">period</span><span class="p">);</span>
	<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">quota</span> <span class="o">=</span> <span class="n">quota</span><span class="p">;</span>

	<span class="n">__refill_cfs_bandwidth_runtime</span><span class="p">(</span><span class="n">cfs_b</span><span class="p">);</span>
	<span class="cm">/* restart the period timer (if active) to handle new period expiry */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">runtime_enabled</span> <span class="o">&amp;&amp;</span> <span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">timer_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* force a reprogram */</span>
		<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">timer_active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">__start_cfs_bandwidth</span><span class="p">(</span><span class="n">cfs_b</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">;</span>

		<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_enabled</span> <span class="o">=</span> <span class="n">runtime_enabled</span><span class="p">;</span>
		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_remaining</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttled</span><span class="p">)</span>
			<span class="n">unthrottle_cfs_rq</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
		<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_constraints_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">tg_set_cfs_quota</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="kt">long</span> <span class="n">cfs_quota_us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">quota</span><span class="p">,</span> <span class="n">period</span><span class="p">;</span>

	<span class="n">period</span> <span class="o">=</span> <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_bandwidth</span><span class="p">.</span><span class="n">period</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_quota_us</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">quota</span> <span class="o">=</span> <span class="n">RUNTIME_INF</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">quota</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">cfs_quota_us</span> <span class="o">*</span> <span class="n">NSEC_PER_USEC</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">tg_set_cfs_bandwidth</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">quota</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">long</span> <span class="nf">tg_get_cfs_quota</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">quota_us</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_bandwidth</span><span class="p">.</span><span class="n">quota</span> <span class="o">==</span> <span class="n">RUNTIME_INF</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">quota_us</span> <span class="o">=</span> <span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_bandwidth</span><span class="p">.</span><span class="n">quota</span><span class="p">;</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">quota_us</span><span class="p">,</span> <span class="n">NSEC_PER_USEC</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">quota_us</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">tg_set_cfs_period</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="kt">long</span> <span class="n">cfs_period_us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">quota</span><span class="p">,</span> <span class="n">period</span><span class="p">;</span>

	<span class="n">period</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">cfs_period_us</span> <span class="o">*</span> <span class="n">NSEC_PER_USEC</span><span class="p">;</span>
	<span class="n">quota</span> <span class="o">=</span> <span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_bandwidth</span><span class="p">.</span><span class="n">quota</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">tg_set_cfs_bandwidth</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">quota</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">long</span> <span class="nf">tg_get_cfs_period</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">cfs_period_us</span><span class="p">;</span>

	<span class="n">cfs_period_us</span> <span class="o">=</span> <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_bandwidth</span><span class="p">.</span><span class="n">period</span><span class="p">);</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">cfs_period_us</span><span class="p">,</span> <span class="n">NSEC_PER_USEC</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">cfs_period_us</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">s64</span> <span class="nf">cpu_cfs_quota_read_s64</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tg_get_cfs_quota</span><span class="p">(</span><span class="n">cgroup_tg</span><span class="p">(</span><span class="n">cgrp</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cpu_cfs_quota_write_s64</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cftype</span><span class="p">,</span>
				<span class="n">s64</span> <span class="n">cfs_quota_us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tg_set_cfs_quota</span><span class="p">(</span><span class="n">cgroup_tg</span><span class="p">(</span><span class="n">cgrp</span><span class="p">),</span> <span class="n">cfs_quota_us</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">cpu_cfs_period_read_u64</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tg_get_cfs_period</span><span class="p">(</span><span class="n">cgroup_tg</span><span class="p">(</span><span class="n">cgrp</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cpu_cfs_period_write_u64</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cftype</span><span class="p">,</span>
				<span class="n">u64</span> <span class="n">cfs_period_us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tg_set_cfs_period</span><span class="p">(</span><span class="n">cgroup_tg</span><span class="p">(</span><span class="n">cgrp</span><span class="p">),</span> <span class="n">cfs_period_us</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">cfs_schedulable_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">period</span><span class="p">,</span> <span class="n">quota</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * normalize group quota/period to be quota/max_period</span>
<span class="cm"> * note: units are usecs</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="nf">normalize_cfs_quota</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">cfs_schedulable_data</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">quota</span><span class="p">,</span> <span class="n">period</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tg</span> <span class="o">==</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">tg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">period</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">;</span>
		<span class="n">quota</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">quota</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">period</span> <span class="o">=</span> <span class="n">tg_get_cfs_period</span><span class="p">(</span><span class="n">tg</span><span class="p">);</span>
		<span class="n">quota</span> <span class="o">=</span> <span class="n">tg_get_cfs_quota</span><span class="p">(</span><span class="n">tg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* note: these should typically be equivalent */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">quota</span> <span class="o">==</span> <span class="n">RUNTIME_INF</span> <span class="o">||</span> <span class="n">quota</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">RUNTIME_INF</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">to_ratio</span><span class="p">(</span><span class="n">period</span><span class="p">,</span> <span class="n">quota</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tg_cfs_schedulable_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfs_schedulable_data</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_bandwidth</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">quota</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">parent_quota</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">quota</span> <span class="o">=</span> <span class="n">RUNTIME_INF</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">parent_b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">cfs_bandwidth</span><span class="p">;</span>

		<span class="n">quota</span> <span class="o">=</span> <span class="n">normalize_cfs_quota</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
		<span class="n">parent_quota</span> <span class="o">=</span> <span class="n">parent_b</span><span class="o">-&gt;</span><span class="n">hierarchal_quota</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * ensure max(child_quota) &lt;= parent_quota, inherit when no</span>
<span class="cm">		 * limit is set</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">quota</span> <span class="o">==</span> <span class="n">RUNTIME_INF</span><span class="p">)</span>
			<span class="n">quota</span> <span class="o">=</span> <span class="n">parent_quota</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">parent_quota</span> <span class="o">!=</span> <span class="n">RUNTIME_INF</span> <span class="o">&amp;&amp;</span> <span class="n">quota</span> <span class="o">&gt;</span> <span class="n">parent_quota</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">hierarchal_quota</span> <span class="o">=</span> <span class="n">quota</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__cfs_schedulable</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="n">u64</span> <span class="n">period</span><span class="p">,</span> <span class="n">u64</span> <span class="n">quota</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfs_schedulable_data</span> <span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">tg</span> <span class="o">=</span> <span class="n">tg</span><span class="p">,</span>
		<span class="p">.</span><span class="n">period</span> <span class="o">=</span> <span class="n">period</span><span class="p">,</span>
		<span class="p">.</span><span class="n">quota</span> <span class="o">=</span> <span class="n">quota</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">quota</span> <span class="o">!=</span> <span class="n">RUNTIME_INF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">do_div</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">period</span><span class="p">,</span> <span class="n">NSEC_PER_USEC</span><span class="p">);</span>
		<span class="n">do_div</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">quota</span><span class="p">,</span> <span class="n">NSEC_PER_USEC</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">walk_tg_tree</span><span class="p">(</span><span class="n">tg_cfs_schedulable_down</span><span class="p">,</span> <span class="n">tg_nop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cpu_stats_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">cgroup_map_cb</span> <span class="o">*</span><span class="n">cb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span> <span class="o">=</span> <span class="n">cgroup_tg</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_bandwidth</span><span class="p">;</span>

	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">fill</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="s">&quot;nr_periods&quot;</span><span class="p">,</span> <span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">nr_periods</span><span class="p">);</span>
	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">fill</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="s">&quot;nr_throttled&quot;</span><span class="p">,</span> <span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">nr_throttled</span><span class="p">);</span>
	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">fill</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="s">&quot;throttled_time&quot;</span><span class="p">,</span> <span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">throttled_time</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_CFS_BANDWIDTH */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_FAIR_GROUP_SCHED */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_RT_GROUP_SCHED</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cpu_rt_runtime_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span>
				<span class="n">s64</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sched_group_set_rt_runtime</span><span class="p">(</span><span class="n">cgroup_tg</span><span class="p">(</span><span class="n">cgrp</span><span class="p">),</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">s64</span> <span class="nf">cpu_rt_runtime_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sched_group_rt_runtime</span><span class="p">(</span><span class="n">cgroup_tg</span><span class="p">(</span><span class="n">cgrp</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cpu_rt_period_write_uint</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cftype</span><span class="p">,</span>
		<span class="n">u64</span> <span class="n">rt_period_us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sched_group_set_rt_period</span><span class="p">(</span><span class="n">cgroup_tg</span><span class="p">(</span><span class="n">cgrp</span><span class="p">),</span> <span class="n">rt_period_us</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">cpu_rt_period_read_uint</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sched_group_rt_period</span><span class="p">(</span><span class="n">cgroup_tg</span><span class="p">(</span><span class="n">cgrp</span><span class="p">));</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_RT_GROUP_SCHED */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="n">cpu_files</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_FAIR_GROUP_SCHED</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;shares&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read_u64</span> <span class="o">=</span> <span class="n">cpu_shares_read_u64</span><span class="p">,</span>
		<span class="p">.</span><span class="n">write_u64</span> <span class="o">=</span> <span class="n">cpu_shares_write_u64</span><span class="p">,</span>
	<span class="p">},</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_CFS_BANDWIDTH</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;cfs_quota_us&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read_s64</span> <span class="o">=</span> <span class="n">cpu_cfs_quota_read_s64</span><span class="p">,</span>
		<span class="p">.</span><span class="n">write_s64</span> <span class="o">=</span> <span class="n">cpu_cfs_quota_write_s64</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;cfs_period_us&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read_u64</span> <span class="o">=</span> <span class="n">cpu_cfs_period_read_u64</span><span class="p">,</span>
		<span class="p">.</span><span class="n">write_u64</span> <span class="o">=</span> <span class="n">cpu_cfs_period_write_u64</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;stat&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read_map</span> <span class="o">=</span> <span class="n">cpu_stats_show</span><span class="p">,</span>
	<span class="p">},</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_RT_GROUP_SCHED</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;rt_runtime_us&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read_s64</span> <span class="o">=</span> <span class="n">cpu_rt_runtime_read</span><span class="p">,</span>
		<span class="p">.</span><span class="n">write_s64</span> <span class="o">=</span> <span class="n">cpu_rt_runtime_write</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;rt_period_us&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read_u64</span> <span class="o">=</span> <span class="n">cpu_rt_period_read_uint</span><span class="p">,</span>
		<span class="p">.</span><span class="n">write_u64</span> <span class="o">=</span> <span class="n">cpu_rt_period_write_uint</span><span class="p">,</span>
	<span class="p">},</span>
<span class="cp">#endif</span>
	<span class="p">{</span> <span class="p">}</span>	<span class="cm">/* terminate */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="n">cpu_cgroup_subsys</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;cpu&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">create</span>		<span class="o">=</span> <span class="n">cpu_cgroup_create</span><span class="p">,</span>
	<span class="p">.</span><span class="n">destroy</span>	<span class="o">=</span> <span class="n">cpu_cgroup_destroy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">can_attach</span>	<span class="o">=</span> <span class="n">cpu_cgroup_can_attach</span><span class="p">,</span>
	<span class="p">.</span><span class="n">attach</span>		<span class="o">=</span> <span class="n">cpu_cgroup_attach</span><span class="p">,</span>
	<span class="p">.</span><span class="n">exit</span>		<span class="o">=</span> <span class="n">cpu_cgroup_exit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">subsys_id</span>	<span class="o">=</span> <span class="n">cpu_cgroup_subsys_id</span><span class="p">,</span>
	<span class="p">.</span><span class="n">base_cftypes</span>	<span class="o">=</span> <span class="n">cpu_files</span><span class="p">,</span>
	<span class="p">.</span><span class="n">early_init</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#endif	</span><span class="cm">/* CONFIG_CGROUP_SCHED */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_CGROUP_CPUACCT</span>

<span class="cm">/*</span>
<span class="cm"> * CPU accounting code for task groups.</span>
<span class="cm"> *</span>
<span class="cm"> * Based on the work by Paul Menage (menage@google.com) and Balbir Singh</span>
<span class="cm"> * (balbir@in.ibm.com).</span>
<span class="cm"> */</span>

<span class="cm">/* create a new cpu accounting group */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="nf">cpuacct_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpuacct</span> <span class="o">*</span><span class="n">ca</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">root_cpuacct</span><span class="p">.</span><span class="n">css</span><span class="p">;</span>

	<span class="n">ca</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ca</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ca</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ca</span><span class="o">-&gt;</span><span class="n">cpuusage</span> <span class="o">=</span> <span class="n">alloc_percpu</span><span class="p">(</span><span class="n">u64</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">cpuusage</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_ca</span><span class="p">;</span>

	<span class="n">ca</span><span class="o">-&gt;</span><span class="n">cpustat</span> <span class="o">=</span> <span class="n">alloc_percpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">kernel_cpustat</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">cpustat</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_cpuusage</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">;</span>

<span class="nl">out_free_cpuusage:</span>
	<span class="n">free_percpu</span><span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">cpuusage</span><span class="p">);</span>
<span class="nl">out_free_ca:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ca</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* destroy an existing cpu accounting group */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cpuacct_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpuacct</span> <span class="o">*</span><span class="n">ca</span> <span class="o">=</span> <span class="n">cgroup_ca</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>

	<span class="n">free_percpu</span><span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">cpustat</span><span class="p">);</span>
	<span class="n">free_percpu</span><span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">cpuusage</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ca</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">cpuacct_cpuusage_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuacct</span> <span class="o">*</span><span class="n">ca</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">cpuusage</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">cpuusage</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">data</span><span class="p">;</span>

<span class="cp">#ifndef CONFIG_64BIT</span>
	<span class="cm">/*</span>
<span class="cm">	 * Take rq-&gt;lock to make 64-bit read safe on 32-bit platforms.</span>
<span class="cm">	 */</span>
	<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">data</span> <span class="o">=</span> <span class="o">*</span><span class="n">cpuusage</span><span class="p">;</span>
	<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">data</span> <span class="o">=</span> <span class="o">*</span><span class="n">cpuusage</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cpuacct_cpuusage_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuacct</span> <span class="o">*</span><span class="n">ca</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">u64</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">cpuusage</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">cpuusage</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

<span class="cp">#ifndef CONFIG_64BIT</span>
	<span class="cm">/*</span>
<span class="cm">	 * Take rq-&gt;lock to make 64-bit write safe on 32-bit platforms.</span>
<span class="cm">	 */</span>
	<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="o">*</span><span class="n">cpuusage</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="o">*</span><span class="n">cpuusage</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/* return total cpu usage (in nanoseconds) of a group */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="nf">cpuusage_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpuacct</span> <span class="o">*</span><span class="n">ca</span> <span class="o">=</span> <span class="n">cgroup_ca</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">totalcpuusage</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">for_each_present_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="n">totalcpuusage</span> <span class="o">+=</span> <span class="n">cpuacct_cpuusage_read</span><span class="p">(</span><span class="n">ca</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">totalcpuusage</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cpuusage_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cftype</span><span class="p">,</span>
								<span class="n">u64</span> <span class="n">reset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpuacct</span> <span class="o">*</span><span class="n">ca</span> <span class="o">=</span> <span class="n">cgroup_ca</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">for_each_present_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="n">cpuacct_cpuusage_write</span><span class="p">(</span><span class="n">ca</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cpuacct_percpu_seq_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgroup</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpuacct</span> <span class="o">*</span><span class="n">ca</span> <span class="o">=</span> <span class="n">cgroup_ca</span><span class="p">(</span><span class="n">cgroup</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">percpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">for_each_present_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">percpu</span> <span class="o">=</span> <span class="n">cpuacct_cpuusage_read</span><span class="p">(</span><span class="n">ca</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%llu &quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">percpu</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cpuacct_stat_desc</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">CPUACCT_STAT_USER</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;user&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">CPUACCT_STAT_SYSTEM</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;system&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cpuacct_stats_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">cgroup_map_cb</span> <span class="o">*</span><span class="n">cb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpuacct</span> <span class="o">*</span><span class="n">ca</span> <span class="o">=</span> <span class="n">cgroup_ca</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kernel_cpustat</span> <span class="o">*</span><span class="n">kcpustat</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">cpustat</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">+=</span> <span class="n">kcpustat</span><span class="o">-&gt;</span><span class="n">cpustat</span><span class="p">[</span><span class="n">CPUTIME_USER</span><span class="p">];</span>
		<span class="n">val</span> <span class="o">+=</span> <span class="n">kcpustat</span><span class="o">-&gt;</span><span class="n">cpustat</span><span class="p">[</span><span class="n">CPUTIME_NICE</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">cputime64_to_clock_t</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">fill</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">cpuacct_stat_desc</span><span class="p">[</span><span class="n">CPUACCT_STAT_USER</span><span class="p">],</span> <span class="n">val</span><span class="p">);</span>

	<span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kernel_cpustat</span> <span class="o">*</span><span class="n">kcpustat</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">cpustat</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">+=</span> <span class="n">kcpustat</span><span class="o">-&gt;</span><span class="n">cpustat</span><span class="p">[</span><span class="n">CPUTIME_SYSTEM</span><span class="p">];</span>
		<span class="n">val</span> <span class="o">+=</span> <span class="n">kcpustat</span><span class="o">-&gt;</span><span class="n">cpustat</span><span class="p">[</span><span class="n">CPUTIME_IRQ</span><span class="p">];</span>
		<span class="n">val</span> <span class="o">+=</span> <span class="n">kcpustat</span><span class="o">-&gt;</span><span class="n">cpustat</span><span class="p">[</span><span class="n">CPUTIME_SOFTIRQ</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">cputime64_to_clock_t</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">fill</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">cpuacct_stat_desc</span><span class="p">[</span><span class="n">CPUACCT_STAT_SYSTEM</span><span class="p">],</span> <span class="n">val</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="n">files</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;usage&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read_u64</span> <span class="o">=</span> <span class="n">cpuusage_read</span><span class="p">,</span>
		<span class="p">.</span><span class="n">write_u64</span> <span class="o">=</span> <span class="n">cpuusage_write</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;usage_percpu&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read_seq_string</span> <span class="o">=</span> <span class="n">cpuacct_percpu_seq_read</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;stat&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read_map</span> <span class="o">=</span> <span class="n">cpuacct_stats_show</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span> <span class="p">}</span>	<span class="cm">/* terminate */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * charge this task&#39;s execution time to its accounting group.</span>
<span class="cm"> *</span>
<span class="cm"> * called with rq-&gt;lock held.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">cpuacct_charge</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="n">u64</span> <span class="n">cputime</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpuacct</span> <span class="o">*</span><span class="n">ca</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">cpuacct_subsys</span><span class="p">.</span><span class="n">active</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="n">task_cpu</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>

	<span class="n">ca</span> <span class="o">=</span> <span class="n">task_ca</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">ca</span><span class="p">;</span> <span class="n">ca</span> <span class="o">=</span> <span class="n">parent_ca</span><span class="p">(</span><span class="n">ca</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="o">*</span><span class="n">cpuusage</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">cpuusage</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="o">*</span><span class="n">cpuusage</span> <span class="o">+=</span> <span class="n">cputime</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="n">cpuacct_subsys</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;cpuacct&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">create</span> <span class="o">=</span> <span class="n">cpuacct_create</span><span class="p">,</span>
	<span class="p">.</span><span class="n">destroy</span> <span class="o">=</span> <span class="n">cpuacct_destroy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">subsys_id</span> <span class="o">=</span> <span class="n">cpuacct_subsys_id</span><span class="p">,</span>
	<span class="p">.</span><span class="n">base_cftypes</span> <span class="o">=</span> <span class="n">files</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_CGROUP_CPUACCT */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
