<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › sched › fair.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>fair.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Completely Fair Scheduling (CFS) Class (SCHED_NORMAL/SCHED_BATCH)</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 2007 Red Hat, Inc., Ingo Molnar &lt;mingo@redhat.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  Interactivity improvements by Mike Galbraith</span>
<span class="cm"> *  (C) 2007 Mike Galbraith &lt;efault@gmx.de&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  Various enhancements by Dmitry Adamushko.</span>
<span class="cm"> *  (C) 2007 Dmitry Adamushko &lt;dmitry.adamushko@gmail.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  Group scheduling enhancements by Srivatsa Vaddagiri</span>
<span class="cm"> *  Copyright IBM Corporation, 2007</span>
<span class="cm"> *  Author: Srivatsa Vaddagiri &lt;vatsa@linux.vnet.ibm.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  Scaled math optimizations by Thomas Gleixner</span>
<span class="cm"> *  Copyright (C) 2007, Thomas Gleixner &lt;tglx@linutronix.de&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  Adaptive scheduling granularity, math enhancements by Peter Zijlstra</span>
<span class="cm"> *  Copyright (C) 2007 Red Hat, Inc., Peter Zijlstra &lt;pzijlstr@redhat.com&gt;</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/latencytop.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/cpumask.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/profile.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>

<span class="cp">#include &lt;trace/events/sched.h&gt;</span>

<span class="cp">#include &quot;sched.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Targeted preemption latency for CPU-bound tasks:</span>
<span class="cm"> * (default: 6ms * (1 + ilog(ncpus)), units: nanoseconds)</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: this latency value is not the same as the concept of</span>
<span class="cm"> * &#39;timeslice length&#39; - timeslices in CFS are of variable length</span>
<span class="cm"> * and have no persistent notion like in traditional, time-slice</span>
<span class="cm"> * based scheduling concepts.</span>
<span class="cm"> *</span>
<span class="cm"> * (to see the precise effective timeslice length of your workload,</span>
<span class="cm"> *  run vmstat and monitor the context-switches (cs) field)</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_sched_latency</span> <span class="o">=</span> <span class="mi">6000000ULL</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">normalized_sysctl_sched_latency</span> <span class="o">=</span> <span class="mi">6000000ULL</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The initial- and re-scaling of tunables is configurable</span>
<span class="cm"> * (default SCHED_TUNABLESCALING_LOG = *(1+ilog(ncpus))</span>
<span class="cm"> *</span>
<span class="cm"> * Options are:</span>
<span class="cm"> * SCHED_TUNABLESCALING_NONE - unscaled, always *1</span>
<span class="cm"> * SCHED_TUNABLESCALING_LOG - scaled logarithmical, *1+ilog(ncpus)</span>
<span class="cm"> * SCHED_TUNABLESCALING_LINEAR - scaled linear, *ncpus</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">sched_tunable_scaling</span> <span class="n">sysctl_sched_tunable_scaling</span>
	<span class="o">=</span> <span class="n">SCHED_TUNABLESCALING_LOG</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Minimal preemption granularity for CPU-bound tasks:</span>
<span class="cm"> * (default: 0.75 msec * (1 + ilog(ncpus)), units: nanoseconds)</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_sched_min_granularity</span> <span class="o">=</span> <span class="mi">750000ULL</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">normalized_sysctl_sched_min_granularity</span> <span class="o">=</span> <span class="mi">750000ULL</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * is kept at sysctl_sched_latency / sysctl_sched_min_granularity</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sched_nr_latency</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * After fork, child runs first. If set to 0 (default) then</span>
<span class="cm"> * parent will (try to) run first.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_sched_child_runs_first</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * SCHED_OTHER wake-up granularity.</span>
<span class="cm"> * (default: 1 msec * (1 + ilog(ncpus)), units: nanoseconds)</span>
<span class="cm"> *</span>
<span class="cm"> * This option delays the preemption effects of decoupled workloads</span>
<span class="cm"> * and reduces their over-scheduling. Synchronous workloads will still</span>
<span class="cm"> * have immediate wakeup/sleep latencies.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_sched_wakeup_granularity</span> <span class="o">=</span> <span class="mi">1000000UL</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">normalized_sysctl_sched_wakeup_granularity</span> <span class="o">=</span> <span class="mi">1000000UL</span><span class="p">;</span>

<span class="n">const_debug</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_sched_migration_cost</span> <span class="o">=</span> <span class="mi">500000UL</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The exponential sliding  window over which load is averaged for shares</span>
<span class="cm"> * distribution.</span>
<span class="cm"> * (default: 10msec)</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__read_mostly</span> <span class="n">sysctl_sched_shares_window</span> <span class="o">=</span> <span class="mi">10000000UL</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_CFS_BANDWIDTH</span>
<span class="cm">/*</span>
<span class="cm"> * Amount of runtime to allocate from global (tg) to local (per-cfs_rq) pool</span>
<span class="cm"> * each time a cfs_rq requests quota.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: in the case that the slice exceeds the runtime remaining (either due</span>
<span class="cm"> * to consumption or the quota being specified to be smaller than the slice)</span>
<span class="cm"> * we will always only issue the remaining available time.</span>
<span class="cm"> *</span>
<span class="cm"> * default: 5 msec, units: microseconds</span>
<span class="cm">  */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_sched_cfs_bandwidth_slice</span> <span class="o">=</span> <span class="mi">5000UL</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Increase the granularity value when there are more CPUs,</span>
<span class="cm"> * because with more CPUs the &#39;effective latency&#39; as visible</span>
<span class="cm"> * to users decreases. But the relationship is not linear,</span>
<span class="cm"> * so pick a second-best guess by going with the log2 of the</span>
<span class="cm"> * number of CPUs.</span>
<span class="cm"> *</span>
<span class="cm"> * This idea comes from the SD scheduler of Con Kolivas:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_update_sysctl_factor</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpus</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">num_online_cpus</span><span class="p">(),</span> <span class="mi">8</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">factor</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">sysctl_sched_tunable_scaling</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCHED_TUNABLESCALING_NONE</span>:
		<span class="n">factor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCHED_TUNABLESCALING_LINEAR</span>:
		<span class="n">factor</span> <span class="o">=</span> <span class="n">cpus</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCHED_TUNABLESCALING_LOG</span>:
	<span class="nl">default:</span>
		<span class="n">factor</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">cpus</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">factor</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_sysctl</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">factor</span> <span class="o">=</span> <span class="n">get_update_sysctl_factor</span><span class="p">();</span>

<span class="cp">#define SET_SYSCTL(name) \</span>
<span class="cp">	(sysctl_##name = (factor) * normalized_sysctl_##name)</span>
	<span class="n">SET_SYSCTL</span><span class="p">(</span><span class="n">sched_min_granularity</span><span class="p">);</span>
	<span class="n">SET_SYSCTL</span><span class="p">(</span><span class="n">sched_latency</span><span class="p">);</span>
	<span class="n">SET_SYSCTL</span><span class="p">(</span><span class="n">sched_wakeup_granularity</span><span class="p">);</span>
<span class="cp">#undef SET_SYSCTL</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sched_init_granularity</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">update_sysctl</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#if BITS_PER_LONG == 32</span>
<span class="cp"># define WMULT_CONST	(~0UL)</span>
<span class="cp">#else</span>
<span class="cp"># define WMULT_CONST	(1UL &lt;&lt; 32)</span>
<span class="cp">#endif</span>

<span class="cp">#define WMULT_SHIFT	32</span>

<span class="cm">/*</span>
<span class="cm"> * Shift right and round:</span>
<span class="cm"> */</span>
<span class="cp">#define SRR(x, y) (((x) + (1UL &lt;&lt; ((y) - 1))) &gt;&gt; (y))</span>

<span class="cm">/*</span>
<span class="cm"> * delta *= weight / lw</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">calc_delta_mine</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delta_exec</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">weight</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">load_weight</span> <span class="o">*</span><span class="n">lw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * weight can be less than 2^SCHED_LOAD_RESOLUTION for task group sched</span>
<span class="cm">	 * entities since MIN_SHARES = 2. Treat weight as 1 if less than</span>
<span class="cm">	 * 2^SCHED_LOAD_RESOLUTION.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">weight</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">SCHED_LOAD_RESOLUTION</span><span class="p">)))</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">delta_exec</span> <span class="o">*</span> <span class="n">scale_load_down</span><span class="p">(</span><span class="n">weight</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">delta_exec</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lw</span><span class="o">-&gt;</span><span class="n">inv_weight</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">w</span> <span class="o">=</span> <span class="n">scale_load_down</span><span class="p">(</span><span class="n">lw</span><span class="o">-&gt;</span><span class="n">weight</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">BITS_PER_LONG</span> <span class="o">&gt;</span> <span class="mi">32</span> <span class="o">&amp;&amp;</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">w</span> <span class="o">&gt;=</span> <span class="n">WMULT_CONST</span><span class="p">))</span>
			<span class="n">lw</span><span class="o">-&gt;</span><span class="n">inv_weight</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">w</span><span class="p">))</span>
			<span class="n">lw</span><span class="o">-&gt;</span><span class="n">inv_weight</span> <span class="o">=</span> <span class="n">WMULT_CONST</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">lw</span><span class="o">-&gt;</span><span class="n">inv_weight</span> <span class="o">=</span> <span class="n">WMULT_CONST</span> <span class="o">/</span> <span class="n">w</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check whether we&#39;d overflow the 64-bit multiplication:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;</span> <span class="n">WMULT_CONST</span><span class="p">))</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">SRR</span><span class="p">(</span><span class="n">SRR</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">WMULT_SHIFT</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">lw</span><span class="o">-&gt;</span><span class="n">inv_weight</span><span class="p">,</span>
			<span class="n">WMULT_SHIFT</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">SRR</span><span class="p">(</span><span class="n">tmp</span> <span class="o">*</span> <span class="n">lw</span><span class="o">-&gt;</span><span class="n">inv_weight</span><span class="p">,</span> <span class="n">WMULT_SHIFT</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">min</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">LONG_MAX</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">const</span> <span class="k">struct</span> <span class="n">sched_class</span> <span class="n">fair_sched_class</span><span class="p">;</span>

<span class="cm">/**************************************************************</span>
<span class="cm"> * CFS operations on generic schedulable entities:</span>
<span class="cm"> */</span>

<span class="cp">#ifdef CONFIG_FAIR_GROUP_SCHED</span>

<span class="cm">/* cpu runqueue to which this cfs_rq is attached */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="nf">rq_of</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* An entity is a task if it doesn&#39;t &quot;own&quot; a runqueue */</span>
<span class="cp">#define entity_is_task(se)	(!se-&gt;my_q)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">task_of</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SCHED_DEBUG</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">entity_is_task</span><span class="p">(</span><span class="n">se</span><span class="p">));</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">se</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Walk up scheduling entities hierarchy */</span>
<span class="cp">#define for_each_sched_entity(se) \</span>
<span class="cp">		for (; se; se = se-&gt;parent)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="nf">task_cfs_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">cfs_rq</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* runqueue on which this entity is (to be) queued */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="nf">cfs_rq_of</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* runqueue &quot;owned&quot; by this group */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="nf">group_cfs_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">grp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">grp</span><span class="o">-&gt;</span><span class="n">my_q</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">list_add_leaf_cfs_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">on_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Ensure we either appear before our parent (if already</span>
<span class="cm">		 * enqueued) or force our parent to appear after us when it is</span>
<span class="cm">		 * enqueued.  The fact that we always enqueue bottom-up</span>
<span class="cm">		 * reduces this to two cases.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">&amp;&amp;</span>
		    <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">[</span><span class="n">cpu_of</span><span class="p">(</span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">))]</span><span class="o">-&gt;</span><span class="n">on_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_add_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">leaf_cfs_rq_list</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">leaf_cfs_rq_list</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">list_add_tail_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">leaf_cfs_rq_list</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">leaf_cfs_rq_list</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">on_list</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">list_del_leaf_cfs_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">on_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">leaf_cfs_rq_list</span><span class="p">);</span>
		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">on_list</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Iterate thr&#39; all leaf cfs_rq&#39;s on a runqueue */</span>
<span class="cp">#define for_each_leaf_cfs_rq(rq, cfs_rq) \</span>
<span class="cp">	list_for_each_entry_rcu(cfs_rq, &amp;rq-&gt;leaf_cfs_rq_list, leaf_cfs_rq_list)</span>

<span class="cm">/* Do the two (enqueued) entities belong to the same group ? */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">is_same_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">pse</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">cfs_rq</span> <span class="o">==</span> <span class="n">pse</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="nf">parent_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* return depth at which a sched entity is present in the hierarchy */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">depth_se</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span>
		<span class="n">depth</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">depth</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">find_matching_se</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">**</span><span class="n">se</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">**</span><span class="n">pse</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">se_depth</span><span class="p">,</span> <span class="n">pse_depth</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * preemption test can be made between sibling entities who are in the</span>
<span class="cm">	 * same cfs_rq i.e who have a common parent. Walk up the hierarchy of</span>
<span class="cm">	 * both tasks until we find their ancestors who are siblings of common</span>
<span class="cm">	 * parent.</span>
<span class="cm">	 */</span>

	<span class="cm">/* First walk up until both entities are at same depth */</span>
	<span class="n">se_depth</span> <span class="o">=</span> <span class="n">depth_se</span><span class="p">(</span><span class="o">*</span><span class="n">se</span><span class="p">);</span>
	<span class="n">pse_depth</span> <span class="o">=</span> <span class="n">depth_se</span><span class="p">(</span><span class="o">*</span><span class="n">pse</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">se_depth</span> <span class="o">&gt;</span> <span class="n">pse_depth</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">se_depth</span><span class="o">--</span><span class="p">;</span>
		<span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="n">parent_entity</span><span class="p">(</span><span class="o">*</span><span class="n">se</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">pse_depth</span> <span class="o">&gt;</span> <span class="n">se_depth</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pse_depth</span><span class="o">--</span><span class="p">;</span>
		<span class="o">*</span><span class="n">pse</span> <span class="o">=</span> <span class="n">parent_entity</span><span class="p">(</span><span class="o">*</span><span class="n">pse</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">is_same_group</span><span class="p">(</span><span class="o">*</span><span class="n">se</span><span class="p">,</span> <span class="o">*</span><span class="n">pse</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="n">parent_entity</span><span class="p">(</span><span class="o">*</span><span class="n">se</span><span class="p">);</span>
		<span class="o">*</span><span class="n">pse</span> <span class="o">=</span> <span class="n">parent_entity</span><span class="p">(</span><span class="o">*</span><span class="n">pse</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#else	</span><span class="cm">/* !CONFIG_FAIR_GROUP_SCHED */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">task_of</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">se</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="nf">rq_of</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rq</span><span class="p">,</span> <span class="n">cfs</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define entity_is_task(se)	1</span>

<span class="cp">#define for_each_sched_entity(se) \</span>
<span class="cp">		for (; se; se = NULL)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="nf">task_cfs_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="nf">cfs_rq_of</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">task_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* runqueue &quot;owned&quot; by this group */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="nf">group_cfs_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">grp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">list_add_leaf_cfs_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">list_del_leaf_cfs_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#define for_each_leaf_cfs_rq(rq, cfs_rq) \</span>
<span class="cp">		for (cfs_rq = &amp;rq-&gt;cfs; cfs_rq; cfs_rq = NULL)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">is_same_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">pse</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="nf">parent_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">find_matching_se</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">**</span><span class="n">se</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">**</span><span class="n">pse</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#endif	</span><span class="cm">/* CONFIG_FAIR_GROUP_SCHED */</span><span class="cp"></span>

<span class="k">static</span> <span class="n">__always_inline</span>
<span class="kt">void</span> <span class="n">account_cfs_rq_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delta_exec</span><span class="p">);</span>

<span class="cm">/**************************************************************</span>
<span class="cm"> * Scheduling class tree data structure manipulation methods:</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">max_vruntime</span><span class="p">(</span><span class="n">u64</span> <span class="n">min_vruntime</span><span class="p">,</span> <span class="n">u64</span> <span class="n">vruntime</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s64</span> <span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">s64</span><span class="p">)(</span><span class="n">vruntime</span> <span class="o">-</span> <span class="n">min_vruntime</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">min_vruntime</span> <span class="o">=</span> <span class="n">vruntime</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">min_vruntime</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">min_vruntime</span><span class="p">(</span><span class="n">u64</span> <span class="n">min_vruntime</span><span class="p">,</span> <span class="n">u64</span> <span class="n">vruntime</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s64</span> <span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">s64</span><span class="p">)(</span><span class="n">vruntime</span> <span class="o">-</span> <span class="n">min_vruntime</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">min_vruntime</span> <span class="o">=</span> <span class="n">vruntime</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">min_vruntime</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">entity_before</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">s64</span><span class="p">)(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">vruntime</span> <span class="o">-</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">vruntime</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_min_vruntime</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">vruntime</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">min_vruntime</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">)</span>
		<span class="n">vruntime</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">vruntime</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">rb_leftmost</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">rb_leftmost</span><span class="p">,</span>
						   <span class="k">struct</span> <span class="n">sched_entity</span><span class="p">,</span>
						   <span class="n">run_node</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">)</span>
			<span class="n">vruntime</span> <span class="o">=</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">vruntime</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">vruntime</span> <span class="o">=</span> <span class="n">min_vruntime</span><span class="p">(</span><span class="n">vruntime</span><span class="p">,</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">vruntime</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">min_vruntime</span> <span class="o">=</span> <span class="n">max_vruntime</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">min_vruntime</span><span class="p">,</span> <span class="n">vruntime</span><span class="p">);</span>
<span class="cp">#ifndef CONFIG_64BIT</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">min_vruntime_copy</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">min_vruntime</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Enqueue an entity into the rb-tree:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__enqueue_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tasks_timeline</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">leftmost</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Find the right place in the rbtree:</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span><span class="p">,</span> <span class="n">run_node</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * We dont care about collisions. Nodes with</span>
<span class="cm">		 * the same key stay together.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entity_before</span><span class="p">(</span><span class="n">se</span><span class="p">,</span> <span class="n">entry</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
			<span class="n">leftmost</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Maintain a cache of leftmost tree entries (it is frequently</span>
<span class="cm">	 * used):</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">leftmost</span><span class="p">)</span>
		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">rb_leftmost</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">run_node</span><span class="p">;</span>

	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">run_node</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">run_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tasks_timeline</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__dequeue_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">rb_leftmost</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">run_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">next_node</span><span class="p">;</span>

		<span class="n">next_node</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">run_node</span><span class="p">);</span>
		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">rb_leftmost</span> <span class="o">=</span> <span class="n">next_node</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">run_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tasks_timeline</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="nf">__pick_first_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">left</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">rb_leftmost</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">left</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span><span class="p">,</span> <span class="n">run_node</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="nf">__pick_next_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">run_node</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span><span class="p">,</span> <span class="n">run_node</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SCHED_DEBUG</span>
<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="nf">__pick_last_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">last</span> <span class="o">=</span> <span class="n">rb_last</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tasks_timeline</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">last</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">last</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span><span class="p">,</span> <span class="n">run_node</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**************************************************************</span>
<span class="cm"> * Scheduling class statistics methods:</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">sched_proc_update_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
		<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">lenp</span><span class="p">,</span>
		<span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">proc_dointvec_minmax</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">lenp</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">factor</span> <span class="o">=</span> <span class="n">get_update_sysctl_factor</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">||</span> <span class="o">!</span><span class="n">write</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">sched_nr_latency</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">sysctl_sched_latency</span><span class="p">,</span>
					<span class="n">sysctl_sched_min_granularity</span><span class="p">);</span>

<span class="cp">#define WRT_SYSCTL(name) \</span>
<span class="cp">	(normalized_sysctl_##name = sysctl_##name / (factor))</span>
	<span class="n">WRT_SYSCTL</span><span class="p">(</span><span class="n">sched_min_granularity</span><span class="p">);</span>
	<span class="n">WRT_SYSCTL</span><span class="p">(</span><span class="n">sched_latency</span><span class="p">);</span>
	<span class="n">WRT_SYSCTL</span><span class="p">(</span><span class="n">sched_wakeup_granularity</span><span class="p">);</span>
<span class="cp">#undef WRT_SYSCTL</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * delta /= w</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">calc_delta_fair</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delta</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span> <span class="o">!=</span> <span class="n">NICE_0_LOAD</span><span class="p">))</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="n">calc_delta_mine</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">NICE_0_LOAD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">delta</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The idea is to set a period in which each task runs once.</span>
<span class="cm"> *</span>
<span class="cm"> * When there are too many tasks (sysctl_sched_nr_latency) we have to stretch</span>
<span class="cm"> * this period because otherwise the slices get too small.</span>
<span class="cm"> *</span>
<span class="cm"> * p = (nr &lt;= nl) ? l : l*nr/nl</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="nf">__sched_period</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_running</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">period</span> <span class="o">=</span> <span class="n">sysctl_sched_latency</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_latency</span> <span class="o">=</span> <span class="n">sched_nr_latency</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">nr_running</span> <span class="o">&gt;</span> <span class="n">nr_latency</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">period</span> <span class="o">=</span> <span class="n">sysctl_sched_min_granularity</span><span class="p">;</span>
		<span class="n">period</span> <span class="o">*=</span> <span class="n">nr_running</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">period</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We calculate the wall-time slice from the period by taking a part</span>
<span class="cm"> * proportional to the weight.</span>
<span class="cm"> *</span>
<span class="cm"> * s = p*P[w/rw]</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="nf">sched_slice</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">slice</span> <span class="o">=</span> <span class="n">__sched_period</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">+</span> <span class="o">!</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">);</span>

	<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">load_weight</span> <span class="o">*</span><span class="n">load</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">load_weight</span> <span class="n">lw</span><span class="p">;</span>

		<span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
		<span class="n">load</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">lw</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">;</span>

			<span class="n">update_load_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lw</span><span class="p">,</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">);</span>
			<span class="n">load</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lw</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">slice</span> <span class="o">=</span> <span class="n">calc_delta_mine</span><span class="p">(</span><span class="n">slice</span><span class="p">,</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">,</span> <span class="n">load</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">slice</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We calculate the vruntime slice of a to be inserted task</span>
<span class="cm"> *</span>
<span class="cm"> * vs = s/w</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="nf">sched_vslice</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">calc_delta_fair</span><span class="p">(</span><span class="n">sched_slice</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">),</span> <span class="n">se</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">update_cfs_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">global_update</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">update_cfs_shares</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Update the current task&#39;s runtime statistics. Skip current tasks that</span>
<span class="cm"> * are not in our scheduling class.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">__update_curr</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span>
	      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delta_exec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delta_exec_weighted</span><span class="p">;</span>

	<span class="n">schedstat_set</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">exec_max</span><span class="p">,</span>
		      <span class="n">max</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">delta_exec</span><span class="p">,</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">exec_max</span><span class="p">));</span>

	<span class="n">curr</span><span class="o">-&gt;</span><span class="n">sum_exec_runtime</span> <span class="o">+=</span> <span class="n">delta_exec</span><span class="p">;</span>
	<span class="n">schedstat_add</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">exec_clock</span><span class="p">,</span> <span class="n">delta_exec</span><span class="p">);</span>
	<span class="n">delta_exec_weighted</span> <span class="o">=</span> <span class="n">calc_delta_fair</span><span class="p">(</span><span class="n">delta_exec</span><span class="p">,</span> <span class="n">curr</span><span class="p">);</span>

	<span class="n">curr</span><span class="o">-&gt;</span><span class="n">vruntime</span> <span class="o">+=</span> <span class="n">delta_exec_weighted</span><span class="p">;</span>
	<span class="n">update_min_vruntime</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>

<span class="cp">#if defined CONFIG_SMP &amp;&amp; defined CONFIG_FAIR_GROUP_SCHED</span>
	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load_unacc_exec_time</span> <span class="o">+=</span> <span class="n">delta_exec</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_curr</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">now</span> <span class="o">=</span> <span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">clock_task</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delta_exec</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">curr</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the amount of time the current task was running</span>
<span class="cm">	 * since the last time we changed load (this cannot</span>
<span class="cm">	 * overflow on 32 bits):</span>
<span class="cm">	 */</span>
	<span class="n">delta_exec</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">now</span> <span class="o">-</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">exec_start</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">delta_exec</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">__update_curr</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">curr</span><span class="p">,</span> <span class="n">delta_exec</span><span class="p">);</span>
	<span class="n">curr</span><span class="o">-&gt;</span><span class="n">exec_start</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">entity_is_task</span><span class="p">(</span><span class="n">curr</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curtask</span> <span class="o">=</span> <span class="n">task_of</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>

		<span class="n">trace_sched_stat_runtime</span><span class="p">(</span><span class="n">curtask</span><span class="p">,</span> <span class="n">delta_exec</span><span class="p">,</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">vruntime</span><span class="p">);</span>
		<span class="n">cpuacct_charge</span><span class="p">(</span><span class="n">curtask</span><span class="p">,</span> <span class="n">delta_exec</span><span class="p">);</span>
		<span class="n">account_group_exec_runtime</span><span class="p">(</span><span class="n">curtask</span><span class="p">,</span> <span class="n">delta_exec</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">account_cfs_rq_runtime</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">delta_exec</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">update_stats_wait_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">schedstat_set</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">wait_start</span><span class="p">,</span> <span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Task is being enqueued - update stats:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_stats_enqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Are we enqueueing a waiting task? (for current tasks</span>
<span class="cm">	 * a dequeue/enqueue event is a NOP)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">se</span> <span class="o">!=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">)</span>
		<span class="n">update_stats_wait_start</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">update_stats_wait_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">schedstat_set</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">wait_max</span><span class="p">,</span> <span class="n">max</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">wait_max</span><span class="p">,</span>
			<span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">clock</span> <span class="o">-</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">wait_start</span><span class="p">));</span>
	<span class="n">schedstat_set</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">wait_count</span><span class="p">,</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">wait_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">schedstat_set</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">wait_sum</span><span class="p">,</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">wait_sum</span> <span class="o">+</span>
			<span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">clock</span> <span class="o">-</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">wait_start</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_SCHEDSTATS</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entity_is_task</span><span class="p">(</span><span class="n">se</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">trace_sched_stat_wait</span><span class="p">(</span><span class="n">task_of</span><span class="p">(</span><span class="n">se</span><span class="p">),</span>
			<span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">clock</span> <span class="o">-</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">wait_start</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">schedstat_set</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">wait_start</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">update_stats_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Mark the end of the wait period if dequeueing a</span>
<span class="cm">	 * waiting task:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">se</span> <span class="o">!=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">)</span>
		<span class="n">update_stats_wait_end</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We are picking a new current task - update its stats:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">update_stats_curr_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * We are starting a new run period:</span>
<span class="cm">	 */</span>
	<span class="n">se</span><span class="o">-&gt;</span><span class="n">exec_start</span> <span class="o">=</span> <span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">clock_task</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**************************************************</span>
<span class="cm"> * Scheduling class queueing methods:</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">account_entity_enqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">update_load_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">,</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent_entity</span><span class="p">(</span><span class="n">se</span><span class="p">))</span>
		<span class="n">update_load_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">,</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entity_is_task</span><span class="p">(</span><span class="n">se</span><span class="p">))</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">group_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cfs_tasks</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">nr_running</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">account_entity_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">update_load_sub</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">,</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent_entity</span><span class="p">(</span><span class="n">se</span><span class="p">))</span>
		<span class="n">update_load_sub</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">,</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entity_is_task</span><span class="p">(</span><span class="n">se</span><span class="p">))</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">group_node</span><span class="p">);</span>
	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">nr_running</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_FAIR_GROUP_SCHED</span>
<span class="cm">/* we need this in update_cfs_load and load-balance functions below */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">throttled_hierarchy</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="cp"># ifdef CONFIG_SMP</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_cfs_rq_load_contribution</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span>
					    <span class="kt">int</span> <span class="n">global_update</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tg</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">load_avg</span><span class="p">;</span>

	<span class="n">load_avg</span> <span class="o">=</span> <span class="n">div64_u64</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load_avg</span><span class="p">,</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load_period</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">load_avg</span> <span class="o">-=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load_contribution</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">global_update</span> <span class="o">||</span> <span class="n">abs</span><span class="p">(</span><span class="n">load_avg</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load_contribution</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atomic_add</span><span class="p">(</span><span class="n">load_avg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">load_weight</span><span class="p">);</span>
		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load_contribution</span> <span class="o">+=</span> <span class="n">load_avg</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_cfs_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">global_update</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">period</span> <span class="o">=</span> <span class="n">sysctl_sched_shares_window</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">now</span><span class="p">,</span> <span class="n">delta</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">load</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tg</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">root_task_group</span> <span class="o">||</span> <span class="n">throttled_hierarchy</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">now</span> <span class="o">=</span> <span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">clock_task</span><span class="p">;</span>
	<span class="n">delta</span> <span class="o">=</span> <span class="n">now</span> <span class="o">-</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load_stamp</span><span class="p">;</span>

	<span class="cm">/* truncate load history at 4 idle periods */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load_stamp</span> <span class="o">&gt;</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load_last</span> <span class="o">&amp;&amp;</span>
	    <span class="n">now</span> <span class="o">-</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load_last</span> <span class="o">&gt;</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">period</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load_period</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load_avg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="n">period</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load_stamp</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load_unacc_exec_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load_period</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">load</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load_last</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load_avg</span> <span class="o">+=</span> <span class="n">delta</span> <span class="o">*</span> <span class="n">load</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* consider updating load contribution on each fold or truncate */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">global_update</span> <span class="o">||</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load_period</span> <span class="o">&gt;</span> <span class="n">period</span>
	    <span class="o">||</span> <span class="o">!</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load_period</span><span class="p">)</span>
		<span class="n">update_cfs_rq_load_contribution</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">global_update</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load_period</span> <span class="o">&gt;</span> <span class="n">period</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Inline assembly required to prevent the compiler</span>
<span class="cm">		 * optimising this loop into a divmod call.</span>
<span class="cm">		 * See __iter_div_u64_rem() for another example of this.</span>
<span class="cm">		 */</span>
		<span class="n">asm</span><span class="p">(</span><span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;+rm&quot;</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load_period</span><span class="p">));</span>
		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load_period</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load_avg</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">curr</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load_avg</span><span class="p">)</span>
		<span class="n">list_del_leaf_cfs_rq</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">long</span> <span class="nf">calc_tg_weight</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">tg_weight</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Use this CPU&#39;s actual weight instead of the last load_contribution</span>
<span class="cm">	 * to gain a more accurate current total weight. See</span>
<span class="cm">	 * update_cfs_rq_load_contribution().</span>
<span class="cm">	 */</span>
	<span class="n">tg_weight</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">load_weight</span><span class="p">);</span>
	<span class="n">tg_weight</span> <span class="o">-=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load_contribution</span><span class="p">;</span>
	<span class="n">tg_weight</span> <span class="o">+=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">tg_weight</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">calc_cfs_shares</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">tg_weight</span><span class="p">,</span> <span class="n">load</span><span class="p">,</span> <span class="n">shares</span><span class="p">;</span>

	<span class="n">tg_weight</span> <span class="o">=</span> <span class="n">calc_tg_weight</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="n">cfs_rq</span><span class="p">);</span>
	<span class="n">load</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">;</span>

	<span class="n">shares</span> <span class="o">=</span> <span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">shares</span> <span class="o">*</span> <span class="n">load</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tg_weight</span><span class="p">)</span>
		<span class="n">shares</span> <span class="o">/=</span> <span class="n">tg_weight</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">shares</span> <span class="o">&lt;</span> <span class="n">MIN_SHARES</span><span class="p">)</span>
		<span class="n">shares</span> <span class="o">=</span> <span class="n">MIN_SHARES</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shares</span> <span class="o">&gt;</span> <span class="n">tg</span><span class="o">-&gt;</span><span class="n">shares</span><span class="p">)</span>
		<span class="n">shares</span> <span class="o">=</span> <span class="n">tg</span><span class="o">-&gt;</span><span class="n">shares</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">shares</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_entity_shares_tick</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load_unacc_exec_time</span> <span class="o">&gt;</span> <span class="n">sysctl_sched_shares_window</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">update_cfs_load</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">update_cfs_shares</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp"># else </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_cfs_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">global_update</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">long</span> <span class="nf">calc_cfs_shares</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tg</span><span class="o">-&gt;</span><span class="n">shares</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_entity_shares_tick</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp"># endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">reweight_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">weight</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* commit outstanding execution time */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">curr</span> <span class="o">==</span> <span class="n">se</span><span class="p">)</span>
			<span class="n">update_curr</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
		<span class="n">account_entity_dequeue</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">update_load_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">,</span> <span class="n">weight</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">)</span>
		<span class="n">account_entity_enqueue</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_cfs_shares</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">shares</span><span class="p">;</span>

	<span class="n">tg</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tg</span><span class="p">;</span>
	<span class="n">se</span> <span class="o">=</span> <span class="n">tg</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">[</span><span class="n">cpu_of</span><span class="p">(</span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">))];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">se</span> <span class="o">||</span> <span class="n">throttled_hierarchy</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
<span class="cp">#ifndef CONFIG_SMP</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span> <span class="o">==</span> <span class="n">tg</span><span class="o">-&gt;</span><span class="n">shares</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">shares</span> <span class="o">=</span> <span class="n">calc_cfs_shares</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">tg</span><span class="p">);</span>

	<span class="n">reweight_entity</span><span class="p">(</span><span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">),</span> <span class="n">se</span><span class="p">,</span> <span class="n">shares</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_FAIR_GROUP_SCHED */</span><span class="cp"></span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_cfs_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">global_update</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_cfs_shares</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_entity_shares_tick</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_FAIR_GROUP_SCHED */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enqueue_sleeper</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SCHEDSTATS</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">entity_is_task</span><span class="p">(</span><span class="n">se</span><span class="p">))</span>
		<span class="n">tsk</span> <span class="o">=</span> <span class="n">task_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">sleep_start</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">clock</span> <span class="o">-</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">sleep_start</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">s64</span><span class="p">)</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">delta</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">sleep_max</span><span class="p">))</span>
			<span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">sleep_max</span> <span class="o">=</span> <span class="n">delta</span><span class="p">;</span>

		<span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">sleep_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">sum_sleep_runtime</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">account_scheduler_latency</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">delta</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">trace_sched_stat_sleep</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">block_start</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">clock</span> <span class="o">-</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">block_start</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">s64</span><span class="p">)</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">delta</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">block_max</span><span class="p">))</span>
			<span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">block_max</span> <span class="o">=</span> <span class="n">delta</span><span class="p">;</span>

		<span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">block_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">sum_sleep_runtime</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">in_iowait</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">iowait_sum</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
				<span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">iowait_count</span><span class="o">++</span><span class="p">;</span>
				<span class="n">trace_sched_stat_iowait</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">trace_sched_stat_blocked</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Blocking time is in units of nanosecs, so shift by</span>
<span class="cm">			 * 20 to get a milliseconds-range estimation of the</span>
<span class="cm">			 * amount of time that the task spent sleeping:</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">prof_on</span> <span class="o">==</span> <span class="n">SLEEP_PROFILING</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">profile_hits</span><span class="p">(</span><span class="n">SLEEP_PROFILING</span><span class="p">,</span>
						<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">get_wchan</span><span class="p">(</span><span class="n">tsk</span><span class="p">),</span>
						<span class="n">delta</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">account_scheduler_latency</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">delta</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_spread</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SCHED_DEBUG</span>
	<span class="n">s64</span> <span class="n">d</span> <span class="o">=</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">vruntime</span> <span class="o">-</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">min_vruntime</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">d</span> <span class="o">=</span> <span class="o">-</span><span class="n">d</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="o">*</span><span class="n">sysctl_sched_latency</span><span class="p">)</span>
		<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">nr_spread_over</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">place_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">,</span> <span class="kt">int</span> <span class="n">initial</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">vruntime</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">min_vruntime</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The &#39;current&#39; period is already promised to the current tasks,</span>
<span class="cm">	 * however the extra weight of the new task will slow them down a</span>
<span class="cm">	 * little, place the new task so that it fits in the slot that</span>
<span class="cm">	 * stays open at the end.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">initial</span> <span class="o">&amp;&amp;</span> <span class="n">sched_feat</span><span class="p">(</span><span class="n">START_DEBIT</span><span class="p">))</span>
		<span class="n">vruntime</span> <span class="o">+=</span> <span class="n">sched_vslice</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>

	<span class="cm">/* sleeps up to a single latency don&#39;t count. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">initial</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">thresh</span> <span class="o">=</span> <span class="n">sysctl_sched_latency</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Halve their sleep time&#39;s effect, to allow</span>
<span class="cm">		 * for a gentler effect of sleepers:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sched_feat</span><span class="p">(</span><span class="n">GENTLE_FAIR_SLEEPERS</span><span class="p">))</span>
			<span class="n">thresh</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">vruntime</span> <span class="o">-=</span> <span class="n">thresh</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* ensure we never gain time by being placed backwards. */</span>
	<span class="n">vruntime</span> <span class="o">=</span> <span class="n">max_vruntime</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">vruntime</span><span class="p">,</span> <span class="n">vruntime</span><span class="p">);</span>

	<span class="n">se</span><span class="o">-&gt;</span><span class="n">vruntime</span> <span class="o">=</span> <span class="n">vruntime</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">check_enqueue_throttle</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">enqueue_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Update the normalized vruntime before updating min_vruntime</span>
<span class="cm">	 * through callig update_curr().</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ENQUEUE_WAKEUP</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ENQUEUE_WAKING</span><span class="p">))</span>
		<span class="n">se</span><span class="o">-&gt;</span><span class="n">vruntime</span> <span class="o">+=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">min_vruntime</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Update run-time statistics of the &#39;current&#39;.</span>
<span class="cm">	 */</span>
	<span class="n">update_curr</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
	<span class="n">update_cfs_load</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">account_entity_enqueue</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
	<span class="n">update_cfs_shares</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ENQUEUE_WAKEUP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">place_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">enqueue_sleeper</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">update_stats_enqueue</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
	<span class="n">check_spread</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">se</span> <span class="o">!=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">)</span>
		<span class="n">__enqueue_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
	<span class="n">se</span><span class="o">-&gt;</span><span class="n">on_rq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_add_leaf_cfs_rq</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
		<span class="n">check_enqueue_throttle</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__clear_buddies_last</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">==</span> <span class="n">se</span><span class="p">)</span>
			<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__clear_buddies_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="n">se</span><span class="p">)</span>
			<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__clear_buddies_skip</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">skip</span> <span class="o">==</span> <span class="n">se</span><span class="p">)</span>
			<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">skip</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">clear_buddies</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">==</span> <span class="n">se</span><span class="p">)</span>
		<span class="n">__clear_buddies_last</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="n">se</span><span class="p">)</span>
		<span class="n">__clear_buddies_next</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">skip</span> <span class="o">==</span> <span class="n">se</span><span class="p">)</span>
		<span class="n">__clear_buddies_skip</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="n">return_cfs_rq_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">dequeue_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Update run-time statistics of the &#39;current&#39;.</span>
<span class="cm">	 */</span>
	<span class="n">update_curr</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>

	<span class="n">update_stats_dequeue</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DEQUEUE_SLEEP</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_SCHEDSTATS</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entity_is_task</span><span class="p">(</span><span class="n">se</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">task_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">)</span>
				<span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">sleep_start</span> <span class="o">=</span> <span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">)</span>
				<span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">block_start</span> <span class="o">=</span> <span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="n">clear_buddies</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">se</span> <span class="o">!=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">)</span>
		<span class="n">__dequeue_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
	<span class="n">se</span><span class="o">-&gt;</span><span class="n">on_rq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">update_cfs_load</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">account_entity_dequeue</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Normalize the entity after updating the min_vruntime because the</span>
<span class="cm">	 * update can refer to the -&gt;curr item and we need to reflect this</span>
<span class="cm">	 * movement in our normalized position.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DEQUEUE_SLEEP</span><span class="p">))</span>
		<span class="n">se</span><span class="o">-&gt;</span><span class="n">vruntime</span> <span class="o">-=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">min_vruntime</span><span class="p">;</span>

	<span class="cm">/* return excess runtime on last dequeue */</span>
	<span class="n">return_cfs_rq_runtime</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>

	<span class="n">update_min_vruntime</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
	<span class="n">update_cfs_shares</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Preempt the current task with a newly woken task if needed:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">check_preempt_tick</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">curr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ideal_runtime</span><span class="p">,</span> <span class="n">delta_exec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">delta</span><span class="p">;</span>

	<span class="n">ideal_runtime</span> <span class="o">=</span> <span class="n">sched_slice</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">curr</span><span class="p">);</span>
	<span class="n">delta_exec</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">sum_exec_runtime</span> <span class="o">-</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">prev_sum_exec_runtime</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delta_exec</span> <span class="o">&gt;</span> <span class="n">ideal_runtime</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">resched_task</span><span class="p">(</span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * The current task ran long enough, ensure it doesn&#39;t get</span>
<span class="cm">		 * re-elected due to buddy favours.</span>
<span class="cm">		 */</span>
		<span class="n">clear_buddies</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">curr</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ensure that a task that missed wakeup preemption by a</span>
<span class="cm">	 * narrow margin doesn&#39;t have to wait for a full slice.</span>
<span class="cm">	 * This also mitigates buddy induced latencies under load.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delta_exec</span> <span class="o">&lt;</span> <span class="n">sysctl_sched_min_granularity</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">se</span> <span class="o">=</span> <span class="n">__pick_first_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
	<span class="n">delta</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">vruntime</span> <span class="o">-</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">vruntime</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="n">ideal_runtime</span><span class="p">)</span>
		<span class="n">resched_task</span><span class="p">(</span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">set_next_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* &#39;current&#39; is not kept within the tree. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Any task has to be enqueued before it get to execute on</span>
<span class="cm">		 * a CPU. So account for the time it spent waiting on the</span>
<span class="cm">		 * runqueue.</span>
<span class="cm">		 */</span>
		<span class="n">update_stats_wait_end</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
		<span class="n">__dequeue_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">update_stats_curr_start</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">curr</span> <span class="o">=</span> <span class="n">se</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SCHEDSTATS</span>
	<span class="cm">/*</span>
<span class="cm">	 * Track our maximum slice length, if the CPU&#39;s load is at</span>
<span class="cm">	 * least twice that of our own weight (i.e. dont track it</span>
<span class="cm">	 * when there are only lesser-weight tasks around):</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="o">*</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">slice_max</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">slice_max</span><span class="p">,</span>
			<span class="n">se</span><span class="o">-&gt;</span><span class="n">sum_exec_runtime</span> <span class="o">-</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">prev_sum_exec_runtime</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">se</span><span class="o">-&gt;</span><span class="n">prev_sum_exec_runtime</span> <span class="o">=</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">sum_exec_runtime</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="n">wakeup_preempt_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Pick the next process, keeping these things in mind, in this order:</span>
<span class="cm"> * 1) keep things fair between processes/task groups</span>
<span class="cm"> * 2) pick the &quot;next&quot; process, since someone really wants that to run</span>
<span class="cm"> * 3) pick the &quot;last&quot; process, for cache locality</span>
<span class="cm"> * 4) do not run the &quot;skip&quot; process, if something else is available</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="nf">pick_next_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="n">__pick_first_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">left</span> <span class="o">=</span> <span class="n">se</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Avoid running the skip buddy, if running something else can</span>
<span class="cm">	 * be done without getting too unfair.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">skip</span> <span class="o">==</span> <span class="n">se</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">second</span> <span class="o">=</span> <span class="n">__pick_next_entity</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">second</span> <span class="o">&amp;&amp;</span> <span class="n">wakeup_preempt_entity</span><span class="p">(</span><span class="n">second</span><span class="p">,</span> <span class="n">left</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">se</span> <span class="o">=</span> <span class="n">second</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Prefer last buddy, try to return the CPU to a preempted task.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">&amp;&amp;</span> <span class="n">wakeup_preempt_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">,</span> <span class="n">left</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">se</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Someone really wants this to run. If it&#39;s not unfair, run it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">&amp;&amp;</span> <span class="n">wakeup_preempt_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">left</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">se</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

	<span class="n">clear_buddies</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">se</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">check_cfs_rq_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">put_prev_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">prev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * If still on the runqueue then deactivate_task()</span>
<span class="cm">	 * was not called and update_curr() has to be done:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">)</span>
		<span class="n">update_curr</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>

	<span class="cm">/* throttle cfs_rqs exceeding runtime */</span>
	<span class="n">check_cfs_rq_runtime</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>

	<span class="n">check_spread</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">update_stats_wait_start</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>
		<span class="cm">/* Put &#39;current&#39; back into the tree. */</span>
		<span class="n">__enqueue_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">curr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">entity_tick</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">queued</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Update run-time statistics of the &#39;current&#39;.</span>
<span class="cm">	 */</span>
	<span class="n">update_curr</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Update share accounting for long-running entities.</span>
<span class="cm">	 */</span>
	<span class="n">update_entity_shares_tick</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SCHED_HRTICK</span>
	<span class="cm">/*</span>
<span class="cm">	 * queued ticks are scheduled to match the slice, so don&#39;t bother</span>
<span class="cm">	 * validating it and just reschedule.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">queued</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">resched_task</span><span class="p">(</span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * don&#39;t let the period tick interfere with the hrtick preemption</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sched_feat</span><span class="p">(</span><span class="n">DOUBLE_TICK</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">hrtimer_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">hrtick_timer</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">check_preempt_tick</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">curr</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**************************************************</span>
<span class="cm"> * CFS bandwidth control machinery</span>
<span class="cm"> */</span>

<span class="cp">#ifdef CONFIG_CFS_BANDWIDTH</span>

<span class="cp">#ifdef HAVE_JUMP_LABEL</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">static_key</span> <span class="n">__cfs_bandwidth_used</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">cfs_bandwidth_used</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">static_key_false</span><span class="p">(</span><span class="o">&amp;</span><span class="n">__cfs_bandwidth_used</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">account_cfs_bandwidth_used</span><span class="p">(</span><span class="kt">int</span> <span class="n">enabled</span><span class="p">,</span> <span class="kt">int</span> <span class="n">was_enabled</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* only need to count groups transitioning between enabled/!enabled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enabled</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">was_enabled</span><span class="p">)</span>
		<span class="n">static_key_slow_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">__cfs_bandwidth_used</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">enabled</span> <span class="o">&amp;&amp;</span> <span class="n">was_enabled</span><span class="p">)</span>
		<span class="n">static_key_slow_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">__cfs_bandwidth_used</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* HAVE_JUMP_LABEL */</span><span class="cp"></span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">cfs_bandwidth_used</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">account_cfs_bandwidth_used</span><span class="p">(</span><span class="kt">int</span> <span class="n">enabled</span><span class="p">,</span> <span class="kt">int</span> <span class="n">was_enabled</span><span class="p">)</span> <span class="p">{}</span>
<span class="cp">#endif </span><span class="cm">/* HAVE_JUMP_LABEL */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * default period for cfs group bandwidth.</span>
<span class="cm"> * default: 0.1s, units: nanoseconds</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">default_cfs_period</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">100000000ULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">sched_cfs_bandwidth_slice</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">sysctl_sched_cfs_bandwidth_slice</span> <span class="o">*</span> <span class="n">NSEC_PER_USEC</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Replenish runtime according to assigned quota and update expiration time.</span>
<span class="cm"> * We use sched_clock_cpu directly instead of rq-&gt;clock to avoid adding</span>
<span class="cm"> * additional synchronization around rq-&gt;lock.</span>
<span class="cm"> *</span>
<span class="cm"> * requires cfs_b-&gt;lock</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__refill_cfs_bandwidth_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">now</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">quota</span> <span class="o">==</span> <span class="n">RUNTIME_INF</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">now</span> <span class="o">=</span> <span class="n">sched_clock_cpu</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">());</span>
	<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">runtime</span> <span class="o">=</span> <span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">quota</span><span class="p">;</span>
	<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">runtime_expires</span> <span class="o">=</span> <span class="n">now</span> <span class="o">+</span> <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="nf">tg_cfs_bandwidth</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_bandwidth</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* returns 0 on failure to allocate runtime */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">assign_cfs_rq_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span> <span class="o">=</span> <span class="n">tg_cfs_bandwidth</span><span class="p">(</span><span class="n">tg</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">amount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">min_amount</span><span class="p">,</span> <span class="n">expires</span><span class="p">;</span>

	<span class="cm">/* note: this is a positive sum as runtime_remaining &lt;= 0 */</span>
	<span class="n">min_amount</span> <span class="o">=</span> <span class="n">sched_cfs_bandwidth_slice</span><span class="p">()</span> <span class="o">-</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_remaining</span><span class="p">;</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">quota</span> <span class="o">==</span> <span class="n">RUNTIME_INF</span><span class="p">)</span>
		<span class="n">amount</span> <span class="o">=</span> <span class="n">min_amount</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the bandwidth pool has become inactive, then at least one</span>
<span class="cm">		 * period must have elapsed since the last consumption.</span>
<span class="cm">		 * Refresh the global state and ensure bandwidth timer becomes</span>
<span class="cm">		 * active.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">timer_active</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__refill_cfs_bandwidth_runtime</span><span class="p">(</span><span class="n">cfs_b</span><span class="p">);</span>
			<span class="n">__start_cfs_bandwidth</span><span class="p">(</span><span class="n">cfs_b</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">runtime</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">amount</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">,</span> <span class="n">min_amount</span><span class="p">);</span>
			<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">runtime</span> <span class="o">-=</span> <span class="n">amount</span><span class="p">;</span>
			<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">expires</span> <span class="o">=</span> <span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">runtime_expires</span><span class="p">;</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_remaining</span> <span class="o">+=</span> <span class="n">amount</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * we may have advanced our local expiration to account for allowed</span>
<span class="cm">	 * spread between our sched_clock and the one on which runtime was</span>
<span class="cm">	 * issued.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">s64</span><span class="p">)(</span><span class="n">expires</span> <span class="o">-</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_expires</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_expires</span> <span class="o">=</span> <span class="n">expires</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_remaining</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Note: This depends on the synchronization provided by sched_clock and the</span>
<span class="cm"> * fact that rq-&gt;clock snapshots this value.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">expire_cfs_rq_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span> <span class="o">=</span> <span class="n">tg_cfs_bandwidth</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tg</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>

	<span class="cm">/* if the deadline is ahead of our clock, nothing to do */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">((</span><span class="n">s64</span><span class="p">)(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">clock</span> <span class="o">-</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_expires</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_remaining</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the local deadline has passed we have to consider the</span>
<span class="cm">	 * possibility that our sched_clock is &#39;fast&#39; and the global deadline</span>
<span class="cm">	 * has not truly expired.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Fortunately we can check determine whether this the case by checking</span>
<span class="cm">	 * whether the global deadline has advanced.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">s64</span><span class="p">)(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_expires</span> <span class="o">-</span> <span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">runtime_expires</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* extend local deadline, drift is bounded above by 2 ticks */</span>
		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_expires</span> <span class="o">+=</span> <span class="n">TICK_NSEC</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* global deadline is ahead, expiration has passed */</span>
		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_remaining</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__account_cfs_rq_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delta_exec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* dock delta_exec before expiring quota (as it could span periods) */</span>
	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_remaining</span> <span class="o">-=</span> <span class="n">delta_exec</span><span class="p">;</span>
	<span class="n">expire_cfs_rq_runtime</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_remaining</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * if we&#39;re unable to extend our runtime we resched so that the active</span>
<span class="cm">	 * hierarchy can be throttled</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">assign_cfs_rq_runtime</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">likely</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">))</span>
		<span class="n">resched_task</span><span class="p">(</span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__always_inline</span>
<span class="kt">void</span> <span class="nf">account_cfs_rq_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delta_exec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfs_bandwidth_used</span><span class="p">()</span> <span class="o">||</span> <span class="o">!</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">__account_cfs_rq_runtime</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">delta_exec</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cfs_rq_throttled</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cfs_bandwidth_used</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttled</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* check whether cfs_rq, or any parent, is throttled */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">throttled_hierarchy</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cfs_bandwidth_used</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttle_count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Ensure that neither of the group entities corresponding to src_cpu or</span>
<span class="cm"> * dest_cpu are members of a throttled hierarchy when performing group</span>
<span class="cm"> * load-balance operations.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">throttled_lb_pair</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">src_cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dest_cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">src_cfs_rq</span><span class="p">,</span> <span class="o">*</span><span class="n">dest_cfs_rq</span><span class="p">;</span>

	<span class="n">src_cfs_rq</span> <span class="o">=</span> <span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">[</span><span class="n">src_cpu</span><span class="p">];</span>
	<span class="n">dest_cfs_rq</span> <span class="o">=</span> <span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">[</span><span class="n">dest_cpu</span><span class="p">];</span>

	<span class="k">return</span> <span class="n">throttled_hierarchy</span><span class="p">(</span><span class="n">src_cfs_rq</span><span class="p">)</span> <span class="o">||</span>
	       <span class="n">throttled_hierarchy</span><span class="p">(</span><span class="n">dest_cfs_rq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* updated child weight may affect parent so we have to do this bottom up */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tg_unthrottle_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">[</span><span class="n">cpu_of</span><span class="p">(</span><span class="n">rq</span><span class="p">)];</span>

	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttle_count</span><span class="o">--</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttle_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">clock_task</span> <span class="o">-</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load_stamp</span><span class="p">;</span>

		<span class="cm">/* leaving throttled state, advance shares averaging windows */</span>
		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load_stamp</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load_last</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>

		<span class="cm">/* update entity weight now that we are on_rq again */</span>
		<span class="n">update_cfs_shares</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tg_throttle_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">[</span><span class="n">cpu_of</span><span class="p">(</span><span class="n">rq</span><span class="p">)];</span>

	<span class="cm">/* group is entering throttled state, record last load */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttle_count</span><span class="p">)</span>
		<span class="n">update_cfs_load</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttle_count</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">throttle_cfs_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span> <span class="o">=</span> <span class="n">tg_cfs_bandwidth</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tg</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">task_delta</span><span class="p">,</span> <span class="n">dequeue</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">se</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">[</span><span class="n">cpu_of</span><span class="p">(</span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">))];</span>

	<span class="cm">/* account load preceding throttle */</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">walk_tg_tree_from</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tg</span><span class="p">,</span> <span class="n">tg_throttle_down</span><span class="p">,</span> <span class="n">tg_nop</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">rq</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="n">task_delta</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">h_nr_running</span><span class="p">;</span>
	<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">qcfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
		<span class="cm">/* throttled entity or throttle-on-deactivate */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dequeue</span><span class="p">)</span>
			<span class="n">dequeue_entity</span><span class="p">(</span><span class="n">qcfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="n">DEQUEUE_SLEEP</span><span class="p">);</span>
		<span class="n">qcfs_rq</span><span class="o">-&gt;</span><span class="n">h_nr_running</span> <span class="o">-=</span> <span class="n">task_delta</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">qcfs_rq</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">)</span>
			<span class="n">dequeue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">se</span><span class="p">)</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">-=</span> <span class="n">task_delta</span><span class="p">;</span>

	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttled_timestamp</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">;</span>
	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">list_add_tail_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttled_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">throttled_cfs_rq</span><span class="p">);</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">unthrottle_cfs_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span> <span class="o">=</span> <span class="n">tg_cfs_bandwidth</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tg</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">enqueue</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">task_delta</span><span class="p">;</span>

	<span class="n">se</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">[</span><span class="n">cpu_of</span><span class="p">(</span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">))];</span>

	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">throttled_time</span> <span class="o">+=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">clock</span> <span class="o">-</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttled_timestamp</span><span class="p">;</span>
	<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttled_list</span><span class="p">);</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttled_timestamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="cm">/* update hierarchical throttle state */</span>
	<span class="n">walk_tg_tree_from</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tg</span><span class="p">,</span> <span class="n">tg_nop</span><span class="p">,</span> <span class="n">tg_unthrottle_up</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">rq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">task_delta</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">h_nr_running</span><span class="p">;</span>
	<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">)</span>
			<span class="n">enqueue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">enqueue</span><span class="p">)</span>
			<span class="n">enqueue_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="n">ENQUEUE_WAKEUP</span><span class="p">);</span>
		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">h_nr_running</span> <span class="o">+=</span> <span class="n">task_delta</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq_throttled</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">se</span><span class="p">)</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">+=</span> <span class="n">task_delta</span><span class="p">;</span>

	<span class="cm">/* determine whether we need to wake up potentially idle cpu */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span> <span class="o">==</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">&amp;&amp;</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">.</span><span class="n">nr_running</span><span class="p">)</span>
		<span class="n">resched_task</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">distribute_cfs_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span><span class="p">,</span>
		<span class="n">u64</span> <span class="n">remaining</span><span class="p">,</span> <span class="n">u64</span> <span class="n">expires</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">runtime</span> <span class="o">=</span> <span class="n">remaining</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">throttled_cfs_rq</span><span class="p">,</span>
				<span class="n">throttled_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>

		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfs_rq_throttled</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>

		<span class="n">runtime</span> <span class="o">=</span> <span class="o">-</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_remaining</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">runtime</span> <span class="o">&gt;</span> <span class="n">remaining</span><span class="p">)</span>
			<span class="n">runtime</span> <span class="o">=</span> <span class="n">remaining</span><span class="p">;</span>
		<span class="n">remaining</span> <span class="o">-=</span> <span class="n">runtime</span><span class="p">;</span>

		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_remaining</span> <span class="o">+=</span> <span class="n">runtime</span><span class="p">;</span>
		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_expires</span> <span class="o">=</span> <span class="n">expires</span><span class="p">;</span>

		<span class="cm">/* we check whether we&#39;re throttled above */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_remaining</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">unthrottle_cfs_rq</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>

<span class="nl">next:</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">remaining</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">remaining</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Responsible for refilling a task_group&#39;s bandwidth and unthrottling its</span>
<span class="cm"> * cfs_rqs as appropriate. If there has been no activity within the last</span>
<span class="cm"> * period the timer is deactivated until scheduling resumes; cfs_b-&gt;idle is</span>
<span class="cm"> * used to track this state.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_sched_cfs_period_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">overrun</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">runtime</span><span class="p">,</span> <span class="n">runtime_expires</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idle</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">throttled</span><span class="p">;</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="cm">/* no need to continue the timer with no bandwidth constraint */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">quota</span> <span class="o">==</span> <span class="n">RUNTIME_INF</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">throttled</span> <span class="o">=</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">throttled_cfs_rq</span><span class="p">);</span>
	<span class="cm">/* idle depends on !throttled (for the case of a large deficit) */</span>
	<span class="n">idle</span> <span class="o">=</span> <span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">throttled</span><span class="p">;</span>
	<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">nr_periods</span> <span class="o">+=</span> <span class="n">overrun</span><span class="p">;</span>

	<span class="cm">/* if we&#39;re going inactive then everything else can be deferred */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idle</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">__refill_cfs_bandwidth_runtime</span><span class="p">(</span><span class="n">cfs_b</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">throttled</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* mark as potentially idle for the upcoming period */</span>
		<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* account preceding periods in which throttling occurred */</span>
	<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">nr_throttled</span> <span class="o">+=</span> <span class="n">overrun</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * There are throttled entities so we must first use the new bandwidth</span>
<span class="cm">	 * to unthrottle them before making it generally available.  This</span>
<span class="cm">	 * ensures that all existing debts will be paid before a new cfs_rq is</span>
<span class="cm">	 * allowed to run.</span>
<span class="cm">	 */</span>
	<span class="n">runtime</span> <span class="o">=</span> <span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">;</span>
	<span class="n">runtime_expires</span> <span class="o">=</span> <span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">runtime_expires</span><span class="p">;</span>
	<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">runtime</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This check is repeated as we are holding onto the new bandwidth</span>
<span class="cm">	 * while we unthrottle.  This can potentially race with an unthrottled</span>
<span class="cm">	 * group trying to acquire new bandwidth from the global pool.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">throttled</span> <span class="o">&amp;&amp;</span> <span class="n">runtime</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="cm">/* we can&#39;t nest cfs_b-&gt;lock while distributing bandwidth */</span>
		<span class="n">runtime</span> <span class="o">=</span> <span class="n">distribute_cfs_runtime</span><span class="p">(</span><span class="n">cfs_b</span><span class="p">,</span> <span class="n">runtime</span><span class="p">,</span>
						 <span class="n">runtime_expires</span><span class="p">);</span>
		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">throttled</span> <span class="o">=</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">throttled_cfs_rq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* return (any) remaining runtime */</span>
	<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">runtime</span> <span class="o">=</span> <span class="n">runtime</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * While we are ensured activity in the period following an</span>
<span class="cm">	 * unthrottle, this also covers the case in which the new bandwidth is</span>
<span class="cm">	 * insufficient to cover the existing bandwidth deficit.  (Forcing the</span>
<span class="cm">	 * timer to remain active while there are any throttled entities.)</span>
<span class="cm">	 */</span>
	<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_unlock:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idle</span><span class="p">)</span>
		<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">timer_active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">idle</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* a cfs_rq won&#39;t donate quota below this amount */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u64</span> <span class="n">min_cfs_rq_runtime</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">NSEC_PER_MSEC</span><span class="p">;</span>
<span class="cm">/* minimum remaining period time to redistribute slack quota */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u64</span> <span class="n">min_bandwidth_expiration</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">NSEC_PER_MSEC</span><span class="p">;</span>
<span class="cm">/* how long we wait to gather additional slack before distributing */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u64</span> <span class="n">cfs_bandwidth_slack_period</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">NSEC_PER_MSEC</span><span class="p">;</span>

<span class="cm">/* are we near the end of the current quota period? */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">runtime_refresh_within</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span><span class="p">,</span> <span class="n">u64</span> <span class="n">min_expire</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">refresh_timer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">period_timer</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">remaining</span><span class="p">;</span>

	<span class="cm">/* if the call-back is running a quota refresh is already occurring */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hrtimer_callback_running</span><span class="p">(</span><span class="n">refresh_timer</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* is a quota refresh about to occur? */</span>
	<span class="n">remaining</span> <span class="o">=</span> <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">hrtimer_expires_remaining</span><span class="p">(</span><span class="n">refresh_timer</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">remaining</span> <span class="o">&lt;</span> <span class="n">min_expire</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">start_cfs_slack_bandwidth</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">min_left</span> <span class="o">=</span> <span class="n">cfs_bandwidth_slack_period</span> <span class="o">+</span> <span class="n">min_bandwidth_expiration</span><span class="p">;</span>

	<span class="cm">/* if there&#39;s a quota refresh soon don&#39;t bother with slack */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">runtime_refresh_within</span><span class="p">(</span><span class="n">cfs_b</span><span class="p">,</span> <span class="n">min_left</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">start_bandwidth_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">slack_timer</span><span class="p">,</span>
				<span class="n">ns_to_ktime</span><span class="p">(</span><span class="n">cfs_bandwidth_slack_period</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* we know any runtime found here is valid as update_curr() precedes return */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__return_cfs_rq_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span> <span class="o">=</span> <span class="n">tg_cfs_bandwidth</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tg</span><span class="p">);</span>
	<span class="n">s64</span> <span class="n">slack_runtime</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_remaining</span> <span class="o">-</span> <span class="n">min_cfs_rq_runtime</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">slack_runtime</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">quota</span> <span class="o">!=</span> <span class="n">RUNTIME_INF</span> <span class="o">&amp;&amp;</span>
	    <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_expires</span> <span class="o">==</span> <span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">runtime_expires</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">runtime</span> <span class="o">+=</span> <span class="n">slack_runtime</span><span class="p">;</span>

		<span class="cm">/* we are under rq-&gt;lock, defer unthrottling using a timer */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">runtime</span> <span class="o">&gt;</span> <span class="n">sched_cfs_bandwidth_slice</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">throttled_cfs_rq</span><span class="p">))</span>
			<span class="n">start_cfs_slack_bandwidth</span><span class="p">(</span><span class="n">cfs_b</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* even if it&#39;s not valid for return we don&#39;t want to try again */</span>
	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_remaining</span> <span class="o">-=</span> <span class="n">slack_runtime</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">return_cfs_rq_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfs_bandwidth_used</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_enabled</span> <span class="o">||</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">nr_running</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">__return_cfs_rq_runtime</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is done with a timer (instead of inline with bandwidth return) since</span>
<span class="cm"> * it&#39;s necessary to juggle rq-&gt;locks to unthrottle their respective cfs_rqs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_sched_cfs_slack_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">runtime</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">slice</span> <span class="o">=</span> <span class="n">sched_cfs_bandwidth_slice</span><span class="p">();</span>
	<span class="n">u64</span> <span class="n">expires</span><span class="p">;</span>

	<span class="cm">/* confirm we&#39;re still not at a refresh boundary */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">runtime_refresh_within</span><span class="p">(</span><span class="n">cfs_b</span><span class="p">,</span> <span class="n">min_bandwidth_expiration</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">quota</span> <span class="o">!=</span> <span class="n">RUNTIME_INF</span> <span class="o">&amp;&amp;</span> <span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">runtime</span> <span class="o">&gt;</span> <span class="n">slice</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">runtime</span> <span class="o">=</span> <span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">;</span>
		<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">runtime</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">expires</span> <span class="o">=</span> <span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">runtime_expires</span><span class="p">;</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">runtime</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">runtime</span> <span class="o">=</span> <span class="n">distribute_cfs_runtime</span><span class="p">(</span><span class="n">cfs_b</span><span class="p">,</span> <span class="n">runtime</span><span class="p">,</span> <span class="n">expires</span><span class="p">);</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">expires</span> <span class="o">==</span> <span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">runtime_expires</span><span class="p">)</span>
		<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">runtime</span> <span class="o">=</span> <span class="n">runtime</span><span class="p">;</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When a group wakes up we want to make sure that its quota is not already</span>
<span class="cm"> * expired/exceeded, otherwise it may be allowed to steal additional ticks of</span>
<span class="cm"> * runtime as update_curr() throttling can not not trigger until it&#39;s on-rq.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_enqueue_throttle</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfs_bandwidth_used</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* an active group must be handled by the update_curr()-&gt;put() path */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_enabled</span> <span class="o">||</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* ensure the group is not already throttled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq_throttled</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* update runtime allocation */</span>
	<span class="n">account_cfs_rq_runtime</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_remaining</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">throttle_cfs_rq</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* conditionally throttle active cfs_rq&#39;s from put_prev_entity() */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_cfs_rq_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfs_bandwidth_used</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_enabled</span> <span class="o">||</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_remaining</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * it&#39;s possible for a throttled entity to be forced into a running</span>
<span class="cm">	 * state (e.g. set_curr_task), in this case we&#39;re finished.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq_throttled</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">throttle_cfs_rq</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="n">default_cfs_period</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">do_sched_cfs_period_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">overrun</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">do_sched_cfs_slack_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span><span class="p">);</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">hrtimer_restart</span> <span class="nf">sched_cfs_slack_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfs_bandwidth</span><span class="p">,</span> <span class="n">slack_timer</span><span class="p">);</span>
	<span class="n">do_sched_cfs_slack_timer</span><span class="p">(</span><span class="n">cfs_b</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">HRTIMER_NORESTART</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">hrtimer_restart</span> <span class="nf">sched_cfs_period_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfs_bandwidth</span><span class="p">,</span> <span class="n">period_timer</span><span class="p">);</span>
	<span class="n">ktime_t</span> <span class="n">now</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">overrun</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">now</span> <span class="o">=</span> <span class="n">hrtimer_cb_get_time</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
		<span class="n">overrun</span> <span class="o">=</span> <span class="n">hrtimer_forward</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">now</span><span class="p">,</span> <span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">overrun</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">idle</span> <span class="o">=</span> <span class="n">do_sched_cfs_period_timer</span><span class="p">(</span><span class="n">cfs_b</span><span class="p">,</span> <span class="n">overrun</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">idle</span> <span class="o">?</span> <span class="n">HRTIMER_NORESTART</span> <span class="o">:</span> <span class="n">HRTIMER_RESTART</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">init_cfs_bandwidth</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">raw_spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">runtime</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">quota</span> <span class="o">=</span> <span class="n">RUNTIME_INF</span><span class="p">;</span>
	<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">=</span> <span class="n">ns_to_ktime</span><span class="p">(</span><span class="n">default_cfs_period</span><span class="p">());</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">throttled_cfs_rq</span><span class="p">);</span>
	<span class="n">hrtimer_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">period_timer</span><span class="p">,</span> <span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="n">HRTIMER_MODE_REL</span><span class="p">);</span>
	<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">period_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">sched_cfs_period_timer</span><span class="p">;</span>
	<span class="n">hrtimer_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">slack_timer</span><span class="p">,</span> <span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="n">HRTIMER_MODE_REL</span><span class="p">);</span>
	<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">slack_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">sched_cfs_slack_timer</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_cfs_rq_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttled_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* requires cfs_b-&gt;lock, may release to reprogram timer */</span>
<span class="kt">void</span> <span class="nf">__start_cfs_bandwidth</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The timer may be active because we&#39;re trying to set a new bandwidth</span>
<span class="cm">	 * period or because we&#39;re racing with the tear-down path</span>
<span class="cm">	 * (timer_active==0 becomes visible before the hrtimer call-back</span>
<span class="cm">	 * terminates).  In either case we ensure that it&#39;s re-programmed</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">hrtimer_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">period_timer</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="cm">/* ensure cfs_b-&gt;lock is available while we wait */</span>
		<span class="n">hrtimer_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">period_timer</span><span class="p">);</span>

		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="cm">/* if someone else restarted the timer then we&#39;re done */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">timer_active</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">timer_active</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">start_bandwidth_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">period_timer</span><span class="p">,</span> <span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">destroy_cfs_bandwidth</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hrtimer_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">period_timer</span><span class="p">);</span>
	<span class="n">hrtimer_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">slack_timer</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">unthrottle_offline_cfs_rqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">;</span>

	<span class="n">for_each_leaf_cfs_rq</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">cfs_rq</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span> <span class="o">=</span> <span class="n">tg_cfs_bandwidth</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tg</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_enabled</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * clock_task is not advancing so we just need to make sure</span>
<span class="cm">		 * there&#39;s some valid quota amount</span>
<span class="cm">		 */</span>
		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_remaining</span> <span class="o">=</span> <span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">quota</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq_throttled</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">))</span>
			<span class="n">unthrottle_cfs_rq</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_CFS_BANDWIDTH */</span><span class="cp"></span>
<span class="k">static</span> <span class="n">__always_inline</span>
<span class="kt">void</span> <span class="nf">account_cfs_rq_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delta_exec</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_cfs_rq_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_enqueue_throttle</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">return_cfs_rq_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span> <span class="p">{}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cfs_rq_throttled</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">throttled_hierarchy</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">throttled_lb_pair</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">src_cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dest_cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">init_cfs_bandwidth</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span><span class="p">)</span> <span class="p">{}</span>

<span class="cp">#ifdef CONFIG_FAIR_GROUP_SCHED</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_cfs_rq_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span> <span class="p">{}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="nf">tg_cfs_bandwidth</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">destroy_cfs_bandwidth</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span><span class="p">)</span> <span class="p">{}</span>
<span class="kt">void</span> <span class="nf">unthrottle_offline_cfs_rqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span> <span class="p">{}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_CFS_BANDWIDTH */</span><span class="cp"></span>

<span class="cm">/**************************************************</span>
<span class="cm"> * CFS operations on tasks:</span>
<span class="cm"> */</span>

<span class="cp">#ifdef CONFIG_SCHED_HRTICK</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hrtick_start_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">!=</span> <span class="n">rq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">slice</span> <span class="o">=</span> <span class="n">sched_slice</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
		<span class="n">u64</span> <span class="n">ran</span> <span class="o">=</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">sum_exec_runtime</span> <span class="o">-</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">prev_sum_exec_runtime</span><span class="p">;</span>
		<span class="n">s64</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">slice</span> <span class="o">-</span> <span class="n">ran</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span> <span class="o">==</span> <span class="n">p</span><span class="p">)</span>
				<span class="n">resched_task</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Don&#39;t schedule slices shorter than 10000ns, that just</span>
<span class="cm">		 * doesn&#39;t make sense. Rely on vruntime for fairness.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span> <span class="o">!=</span> <span class="n">p</span><span class="p">)</span>
			<span class="n">delta</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="n">s64</span><span class="p">,</span> <span class="mi">10000LL</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>

		<span class="n">hrtick_start</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * called from enqueue/dequeue and updates the hrtick when the</span>
<span class="cm"> * current task is from our class and nr_running is low enough</span>
<span class="cm"> * to matter.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hrtick_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hrtick_enabled</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">||</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">fair_sched_class</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq_of</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">&lt;</span> <span class="n">sched_nr_latency</span><span class="p">)</span>
		<span class="n">hrtick_start_fair</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">curr</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* !CONFIG_SCHED_HRTICK */</span><span class="cp"></span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">hrtick_start_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hrtick_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * The enqueue_task method is called before nr_running is</span>
<span class="cm"> * increased. Here we update the fair scheduling stats and</span>
<span class="cm"> * then put the task into the rbtree:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">enqueue_task_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">;</span>

	<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
		<span class="n">enqueue_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * end evaluation on encountering a throttled cfs_rq</span>
<span class="cm">		 *</span>
<span class="cm">		 * note: in the case of encountering a throttled cfs_rq we will</span>
<span class="cm">		 * post the final h_nr_running increment below.</span>
<span class="cm">		*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq_throttled</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">h_nr_running</span><span class="o">++</span><span class="p">;</span>

		<span class="n">flags</span> <span class="o">=</span> <span class="n">ENQUEUE_WAKEUP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">h_nr_running</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq_throttled</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">update_cfs_load</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">update_cfs_shares</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">se</span><span class="p">)</span>
		<span class="n">inc_nr_running</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="n">hrtick_update</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">set_next_buddy</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The dequeue_task method is called before nr_running is</span>
<span class="cm"> * decreased. We remove the task from the rbtree and</span>
<span class="cm"> * update the fair scheduling stats:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dequeue_task_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">task_sleep</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DEQUEUE_SLEEP</span><span class="p">;</span>

	<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
		<span class="n">dequeue_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * end evaluation on encountering a throttled cfs_rq</span>
<span class="cm">		 *</span>
<span class="cm">		 * note: in the case of encountering a throttled cfs_rq we will</span>
<span class="cm">		 * post the final h_nr_running decrement below.</span>
<span class="cm">		*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq_throttled</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">h_nr_running</span><span class="o">--</span><span class="p">;</span>

		<span class="cm">/* Don&#39;t dequeue parent if it has other entities besides us */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Bias pick_next to pick a task from this cfs_rq, as</span>
<span class="cm">			 * p is sleeping when it is within its sched_slice.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">task_sleep</span> <span class="o">&amp;&amp;</span> <span class="n">parent_entity</span><span class="p">(</span><span class="n">se</span><span class="p">))</span>
				<span class="n">set_next_buddy</span><span class="p">(</span><span class="n">parent_entity</span><span class="p">(</span><span class="n">se</span><span class="p">));</span>

			<span class="cm">/* avoid re-evaluating load for this entity */</span>
			<span class="n">se</span> <span class="o">=</span> <span class="n">parent_entity</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">DEQUEUE_SLEEP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">h_nr_running</span><span class="o">--</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq_throttled</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">update_cfs_load</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">update_cfs_shares</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">se</span><span class="p">)</span>
		<span class="n">dec_nr_running</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="n">hrtick_update</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cm">/* Used instead of source_load when we know the type == 0 */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">weighted_cpuload</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return a low guess at the load of a migration-source cpu weighted</span>
<span class="cm"> * according to the scheduling class and &quot;nice&quot; value.</span>
<span class="cm"> *</span>
<span class="cm"> * We want to under-estimate the load of migration sources, to</span>
<span class="cm"> * balance conservatively.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">source_load</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total</span> <span class="o">=</span> <span class="n">weighted_cpuload</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">sched_feat</span><span class="p">(</span><span class="n">LB_BIAS</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">total</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">min</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu_load</span><span class="p">[</span><span class="n">type</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">total</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return a high guess at the load of a migration-target cpu weighted</span>
<span class="cm"> * according to the scheduling class and &quot;nice&quot; value.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">target_load</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total</span> <span class="o">=</span> <span class="n">weighted_cpuload</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">sched_feat</span><span class="p">(</span><span class="n">LB_BIAS</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">total</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu_load</span><span class="p">[</span><span class="n">type</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">total</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">power_of</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cpu_power</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">cpu_avg_load_per_task</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_running</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_running</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr_running</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span> <span class="o">/</span> <span class="n">nr_running</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">task_waking_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">min_vruntime</span><span class="p">;</span>

<span class="cp">#ifndef CONFIG_64BIT</span>
	<span class="n">u64</span> <span class="n">min_vruntime_copy</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">min_vruntime_copy</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">min_vruntime_copy</span><span class="p">;</span>
		<span class="n">smp_rmb</span><span class="p">();</span>
		<span class="n">min_vruntime</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">min_vruntime</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">min_vruntime</span> <span class="o">!=</span> <span class="n">min_vruntime_copy</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">min_vruntime</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">min_vruntime</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">se</span><span class="o">-&gt;</span><span class="n">vruntime</span> <span class="o">-=</span> <span class="n">min_vruntime</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_FAIR_GROUP_SCHED</span>
<span class="cm">/*</span>
<span class="cm"> * effective_load() calculates the load change as seen from the root_task_group</span>
<span class="cm"> *</span>
<span class="cm"> * Adding load to a group doesn&#39;t make a group heavier, but can cause movement</span>
<span class="cm"> * of group shares between cpus. Assuming the shares were perfectly aligned one</span>
<span class="cm"> * can calculate the shift in shares.</span>
<span class="cm"> *</span>
<span class="cm"> * Calculate the effective load difference if @wl is added (subtracted) to @tg</span>
<span class="cm"> * on this @cpu and results in a total addition (subtraction) of @wg to the</span>
<span class="cm"> * total group weight.</span>
<span class="cm"> *</span>
<span class="cm"> * Given a runqueue weight distribution (rw_i) we can compute a shares</span>
<span class="cm"> * distribution (s_i) using:</span>
<span class="cm"> *</span>
<span class="cm"> *   s_i = rw_i / \Sum rw_j						(1)</span>
<span class="cm"> *</span>
<span class="cm"> * Suppose we have 4 CPUs and our @tg is a direct child of the root group and</span>
<span class="cm"> * has 7 equal weight tasks, distributed as below (rw_i), with the resulting</span>
<span class="cm"> * shares distribution (s_i):</span>
<span class="cm"> *</span>
<span class="cm"> *   rw_i = {   2,   4,   1,   0 }</span>
<span class="cm"> *   s_i  = { 2/7, 4/7, 1/7,   0 }</span>
<span class="cm"> *</span>
<span class="cm"> * As per wake_affine() we&#39;re interested in the load of two CPUs (the CPU the</span>
<span class="cm"> * task used to run on and the CPU the waker is running on), we need to</span>
<span class="cm"> * compute the effect of waking a task on either CPU and, in case of a sync</span>
<span class="cm"> * wakeup, compute the effect of the current task going to sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * So for a change of @wl to the local @cpu with an overall group weight change</span>
<span class="cm"> * of @wl we can compute the new shares distribution (s&#39;_i) using:</span>
<span class="cm"> *</span>
<span class="cm"> *   s&#39;_i = (rw_i + @wl) / (@wg + \Sum rw_j)				(2)</span>
<span class="cm"> *</span>
<span class="cm"> * Suppose we&#39;re interested in CPUs 0 and 1, and want to compute the load</span>
<span class="cm"> * differences in waking a task to CPU 0. The additional task changes the</span>
<span class="cm"> * weight and shares distributions like:</span>
<span class="cm"> *</span>
<span class="cm"> *   rw&#39;_i = {   3,   4,   1,   0 }</span>
<span class="cm"> *   s&#39;_i  = { 3/8, 4/8, 1/8,   0 }</span>
<span class="cm"> *</span>
<span class="cm"> * We can then compute the difference in effective weight by using:</span>
<span class="cm"> *</span>
<span class="cm"> *   dw_i = S * (s&#39;_i - s_i)						(3)</span>
<span class="cm"> *</span>
<span class="cm"> * Where &#39;S&#39; is the group weight as seen by its parent.</span>
<span class="cm"> *</span>
<span class="cm"> * Therefore the effective change in loads on CPU 0 would be 5/56 (3/8 - 2/7)</span>
<span class="cm"> * times the weight of the group. The effect on CPU 1 would be -4/56 (4/8 -</span>
<span class="cm"> * 4/7) times the weight of the group.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">effective_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">long</span> <span class="n">wl</span><span class="p">,</span> <span class="kt">long</span> <span class="n">wg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="n">tg</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>	<span class="cm">/* the trivial, non-cgroup case */</span>
		<span class="k">return</span> <span class="n">wl</span><span class="p">;</span>

	<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">long</span> <span class="n">w</span><span class="p">,</span> <span class="n">W</span><span class="p">;</span>

		<span class="n">tg</span> <span class="o">=</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">my_q</span><span class="o">-&gt;</span><span class="n">tg</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * W = @wg + \Sum rw_j</span>
<span class="cm">		 */</span>
		<span class="n">W</span> <span class="o">=</span> <span class="n">wg</span> <span class="o">+</span> <span class="n">calc_tg_weight</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">my_q</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * w = rw_i + @wl</span>
<span class="cm">		 */</span>
		<span class="n">w</span> <span class="o">=</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">my_q</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span> <span class="o">+</span> <span class="n">wl</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * wl = S * s&#39;_i; see (2)</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">W</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="n">W</span><span class="p">)</span>
			<span class="n">wl</span> <span class="o">=</span> <span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="n">tg</span><span class="o">-&gt;</span><span class="n">shares</span><span class="p">)</span> <span class="o">/</span> <span class="n">W</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">wl</span> <span class="o">=</span> <span class="n">tg</span><span class="o">-&gt;</span><span class="n">shares</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Per the above, wl is the new se-&gt;load.weight value; since</span>
<span class="cm">		 * those are clipped to [MIN_SHARES, ...) do so now. See</span>
<span class="cm">		 * calc_cfs_shares().</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wl</span> <span class="o">&lt;</span> <span class="n">MIN_SHARES</span><span class="p">)</span>
			<span class="n">wl</span> <span class="o">=</span> <span class="n">MIN_SHARES</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * wl = dw_i = S * (s&#39;_i - s_i); see (3)</span>
<span class="cm">		 */</span>
		<span class="n">wl</span> <span class="o">-=</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Recursively apply this logic to all parent groups to compute</span>
<span class="cm">		 * the final effective load change on the root group. Since</span>
<span class="cm">		 * only the @tg group gets extra weight, all parent groups can</span>
<span class="cm">		 * only redistribute existing shares. @wl is the shift in shares</span>
<span class="cm">		 * resulting from this level per the above.</span>
<span class="cm">		 */</span>
		<span class="n">wg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">wl</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">effective_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">wl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">wg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">wl</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">wake_affine</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s64</span> <span class="n">this_load</span><span class="p">,</span> <span class="n">load</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">this_cpu</span><span class="p">,</span> <span class="n">prev_cpu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tl_per_task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">weight</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">balanced</span><span class="p">;</span>

	<span class="n">idx</span>	  <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">wake_idx</span><span class="p">;</span>
	<span class="n">this_cpu</span>  <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="n">prev_cpu</span>  <span class="o">=</span> <span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">load</span>	  <span class="o">=</span> <span class="n">source_load</span><span class="p">(</span><span class="n">prev_cpu</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="n">this_load</span> <span class="o">=</span> <span class="n">target_load</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If sync wakeup then subtract the (maximum possible)</span>
<span class="cm">	 * effect of the currently running task from the load</span>
<span class="cm">	 * of the current CPU:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sync</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tg</span> <span class="o">=</span> <span class="n">task_group</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
		<span class="n">weight</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">;</span>

		<span class="n">this_load</span> <span class="o">+=</span> <span class="n">effective_load</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="n">this_cpu</span><span class="p">,</span> <span class="o">-</span><span class="n">weight</span><span class="p">,</span> <span class="o">-</span><span class="n">weight</span><span class="p">);</span>
		<span class="n">load</span> <span class="o">+=</span> <span class="n">effective_load</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="n">prev_cpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">weight</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">tg</span> <span class="o">=</span> <span class="n">task_group</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">weight</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * In low-load situations, where prev_cpu is idle and this_cpu is idle</span>
<span class="cm">	 * due to the sync cause above having dropped this_load to 0, we&#39;ll</span>
<span class="cm">	 * always have an imbalance, but there&#39;s really nothing you can do</span>
<span class="cm">	 * about that, so that&#39;s good too.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Otherwise check if either cpus are near enough in load to allow this</span>
<span class="cm">	 * task to be woken on this_cpu.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">this_load</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s64</span> <span class="n">this_eff_load</span><span class="p">,</span> <span class="n">prev_eff_load</span><span class="p">;</span>

		<span class="n">this_eff_load</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
		<span class="n">this_eff_load</span> <span class="o">*=</span> <span class="n">power_of</span><span class="p">(</span><span class="n">prev_cpu</span><span class="p">);</span>
		<span class="n">this_eff_load</span> <span class="o">*=</span> <span class="n">this_load</span> <span class="o">+</span>
			<span class="n">effective_load</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="n">this_cpu</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">weight</span><span class="p">);</span>

		<span class="n">prev_eff_load</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">+</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">imbalance_pct</span> <span class="o">-</span> <span class="mi">100</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">prev_eff_load</span> <span class="o">*=</span> <span class="n">power_of</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">);</span>
		<span class="n">prev_eff_load</span> <span class="o">*=</span> <span class="n">load</span> <span class="o">+</span> <span class="n">effective_load</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="n">prev_cpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">weight</span><span class="p">);</span>

		<span class="n">balanced</span> <span class="o">=</span> <span class="n">this_eff_load</span> <span class="o">&lt;=</span> <span class="n">prev_eff_load</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">balanced</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the currently running task will sleep within</span>
<span class="cm">	 * a reasonable amount of time then attract this newly</span>
<span class="cm">	 * woken task:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sync</span> <span class="o">&amp;&amp;</span> <span class="n">balanced</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">se</span><span class="p">.</span><span class="n">statistics</span><span class="p">.</span><span class="n">nr_wakeups_affine_attempts</span><span class="p">);</span>
	<span class="n">tl_per_task</span> <span class="o">=</span> <span class="n">cpu_avg_load_per_task</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">balanced</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">this_load</span> <span class="o">&lt;=</span> <span class="n">load</span> <span class="o">&amp;&amp;</span>
	     <span class="n">this_load</span> <span class="o">+</span> <span class="n">target_load</span><span class="p">(</span><span class="n">prev_cpu</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tl_per_task</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This domain has SD_WAKE_AFFINE and</span>
<span class="cm">		 * p is cache cold in this domain, and</span>
<span class="cm">		 * there is no bad imbalance.</span>
<span class="cm">		 */</span>
		<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">ttwu_move_affine</span><span class="p">);</span>
		<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">se</span><span class="p">.</span><span class="n">statistics</span><span class="p">.</span><span class="n">nr_wakeups_affine</span><span class="p">);</span>

		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * find_idlest_group finds and returns the least busy CPU group within the</span>
<span class="cm"> * domain.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span>
<span class="nf">find_idlest_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
		  <span class="kt">int</span> <span class="n">this_cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">load_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">idlest</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">group</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">min_load</span> <span class="o">=</span> <span class="n">ULONG_MAX</span><span class="p">,</span> <span class="n">this_load</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">imbalance</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">+</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">imbalance_pct</span><span class="o">-</span><span class="mi">100</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">load</span><span class="p">,</span> <span class="n">avg_load</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">local_group</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="cm">/* Skip over this group if it has no CPUs allowed */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_intersects</span><span class="p">(</span><span class="n">sched_group_cpus</span><span class="p">(</span><span class="n">group</span><span class="p">),</span>
					<span class="n">tsk_cpus_allowed</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">local_group</span> <span class="o">=</span> <span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">,</span>
					       <span class="n">sched_group_cpus</span><span class="p">(</span><span class="n">group</span><span class="p">));</span>

		<span class="cm">/* Tally up the load of all CPUs in the group */</span>
		<span class="n">avg_load</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">sched_group_cpus</span><span class="p">(</span><span class="n">group</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Bias balancing toward cpus of our domain */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">local_group</span><span class="p">)</span>
				<span class="n">load</span> <span class="o">=</span> <span class="n">source_load</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">load_idx</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">load</span> <span class="o">=</span> <span class="n">target_load</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">load_idx</span><span class="p">);</span>

			<span class="n">avg_load</span> <span class="o">+=</span> <span class="n">load</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Adjust by relative CPU power of the group */</span>
		<span class="n">avg_load</span> <span class="o">=</span> <span class="p">(</span><span class="n">avg_load</span> <span class="o">*</span> <span class="n">SCHED_POWER_SCALE</span><span class="p">)</span> <span class="o">/</span> <span class="n">group</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">local_group</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">this_load</span> <span class="o">=</span> <span class="n">avg_load</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">avg_load</span> <span class="o">&lt;</span> <span class="n">min_load</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">min_load</span> <span class="o">=</span> <span class="n">avg_load</span><span class="p">;</span>
			<span class="n">idlest</span> <span class="o">=</span> <span class="n">group</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">group</span> <span class="o">=</span> <span class="n">group</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">group</span> <span class="o">!=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">idlest</span> <span class="o">||</span> <span class="mi">100</span><span class="o">*</span><span class="n">this_load</span> <span class="o">&lt;</span> <span class="n">imbalance</span><span class="o">*</span><span class="n">min_load</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">idlest</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * find_idlest_cpu - find the idlest cpu among the cpus in group.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">find_idlest_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">group</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">this_cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">load</span><span class="p">,</span> <span class="n">min_load</span> <span class="o">=</span> <span class="n">ULONG_MAX</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idlest</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Traverse only the allowed CPUs */</span>
	<span class="n">for_each_cpu_and</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">sched_group_cpus</span><span class="p">(</span><span class="n">group</span><span class="p">),</span> <span class="n">tsk_cpus_allowed</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">load</span> <span class="o">=</span> <span class="n">weighted_cpuload</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">load</span> <span class="o">&lt;</span> <span class="n">min_load</span> <span class="o">||</span> <span class="p">(</span><span class="n">load</span> <span class="o">==</span> <span class="n">min_load</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">==</span> <span class="n">this_cpu</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">min_load</span> <span class="o">=</span> <span class="n">load</span><span class="p">;</span>
			<span class="n">idlest</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">idlest</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Try and locate an idle CPU in the sched_domain.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">select_idle_sibling</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">prev_cpu</span> <span class="o">=</span> <span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the task is going to be woken-up on this cpu and if it is</span>
<span class="cm">	 * already idle, then it is the right target.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">==</span> <span class="n">cpu</span> <span class="o">&amp;&amp;</span> <span class="n">idle_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the task is going to be woken-up on the cpu where it previously</span>
<span class="cm">	 * ran and if it is currently idle, then it the right target.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">==</span> <span class="n">prev_cpu</span> <span class="o">&amp;&amp;</span> <span class="n">idle_cpu</span><span class="p">(</span><span class="n">prev_cpu</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">prev_cpu</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Otherwise, iterate the domains and find an elegible idle cpu.</span>
<span class="cm">	 */</span>
	<span class="n">sd</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">sd_llc</span><span class="p">,</span> <span class="n">target</span><span class="p">));</span>
	<span class="n">for_each_lower_domain</span><span class="p">(</span><span class="n">sd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sg</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_intersects</span><span class="p">(</span><span class="n">sched_group_cpus</span><span class="p">(</span><span class="n">sg</span><span class="p">),</span>
						<span class="n">tsk_cpus_allowed</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span>
				<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>

			<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">sched_group_cpus</span><span class="p">(</span><span class="n">sg</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">idle_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">target</span> <span class="o">=</span> <span class="n">cpumask_first_and</span><span class="p">(</span><span class="n">sched_group_cpus</span><span class="p">(</span><span class="n">sg</span><span class="p">),</span>
					<span class="n">tsk_cpus_allowed</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
<span class="nl">next:</span>
			<span class="n">sg</span> <span class="o">=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">sg</span> <span class="o">!=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">target</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sched_balance_self: balance the current task (running on cpu) in domains</span>
<span class="cm"> * that have the &#39;flag&#39; flag set. In practice, this is SD_BALANCE_FORK and</span>
<span class="cm"> * SD_BALANCE_EXEC.</span>
<span class="cm"> *</span>
<span class="cm"> * Balance, ie. select the least loaded group.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the target CPU number, or the same CPU if no balancing is needed.</span>
<span class="cm"> *</span>
<span class="cm"> * preempt must be disabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">select_task_rq_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sd_flag</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wake_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">tmp</span><span class="p">,</span> <span class="o">*</span><span class="n">affine_sd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">prev_cpu</span> <span class="o">=</span> <span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">new_cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">want_affine</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">want_sd</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sync</span> <span class="o">=</span> <span class="n">wake_flags</span> <span class="o">&amp;</span> <span class="n">WF_SYNC</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">nr_cpus_allowed</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">prev_cpu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sd_flag</span> <span class="o">&amp;</span> <span class="n">SD_BALANCE_WAKE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">tsk_cpus_allowed</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span>
			<span class="n">want_affine</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">new_cpu</span> <span class="o">=</span> <span class="n">prev_cpu</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">for_each_domain</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SD_LOAD_BALANCE</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If power savings logic is enabled for a domain, see if we</span>
<span class="cm">		 * are not overloaded, if so, don&#39;t balance wider.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SD_PREFER_LOCAL</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">power</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">capacity</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

			<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">sched_domain_span</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">power</span> <span class="o">+=</span> <span class="n">power_of</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
				<span class="n">nr_running</span> <span class="o">+=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">.</span><span class="n">nr_running</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">capacity</span> <span class="o">=</span> <span class="n">DIV_ROUND_CLOSEST</span><span class="p">(</span><span class="n">power</span><span class="p">,</span> <span class="n">SCHED_POWER_SCALE</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">nr_running</span> <span class="o">&lt;</span> <span class="n">capacity</span><span class="p">)</span>
				<span class="n">want_sd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * If both cpu and prev_cpu are part of this domain,</span>
<span class="cm">		 * cpu is a valid SD_WAKE_AFFINE target.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">want_affine</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SD_WAKE_AFFINE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">prev_cpu</span><span class="p">,</span> <span class="n">sched_domain_span</span><span class="p">(</span><span class="n">tmp</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">affine_sd</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
			<span class="n">want_affine</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">want_sd</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">want_affine</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">sd_flag</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">want_sd</span><span class="p">)</span>
			<span class="n">sd</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">affine_sd</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">prev_cpu</span> <span class="o">||</span> <span class="n">wake_affine</span><span class="p">(</span><span class="n">affine_sd</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">sync</span><span class="p">))</span>
			<span class="n">prev_cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>

		<span class="n">new_cpu</span> <span class="o">=</span> <span class="n">select_idle_sibling</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">prev_cpu</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">sd</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">load_idx</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">forkexec_idx</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">group</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">weight</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">sd_flag</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sd</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sd_flag</span> <span class="o">&amp;</span> <span class="n">SD_BALANCE_WAKE</span><span class="p">)</span>
			<span class="n">load_idx</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">wake_idx</span><span class="p">;</span>

		<span class="n">group</span> <span class="o">=</span> <span class="n">find_idlest_group</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">load_idx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">group</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sd</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">new_cpu</span> <span class="o">=</span> <span class="n">find_idlest_cpu</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_cpu</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">new_cpu</span> <span class="o">==</span> <span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Now try balancing at a lower domain level of cpu */</span>
			<span class="n">sd</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Now try balancing at a lower domain level of new_cpu */</span>
		<span class="n">cpu</span> <span class="o">=</span> <span class="n">new_cpu</span><span class="p">;</span>
		<span class="n">weight</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">span_weight</span><span class="p">;</span>
		<span class="n">sd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">for_each_domain</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">weight</span> <span class="o">&lt;=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">span_weight</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">sd_flag</span><span class="p">)</span>
				<span class="n">sd</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* while loop will break here if sd == NULL */</span>
	<span class="p">}</span>
<span class="nl">unlock:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">new_cpu</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">wakeup_gran</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gran</span> <span class="o">=</span> <span class="n">sysctl_sched_wakeup_granularity</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since its curr running now, convert the gran from real-time</span>
<span class="cm">	 * to virtual-time in his units.</span>
<span class="cm">	 *</span>
<span class="cm">	 * By using &#39;se&#39; instead of &#39;curr&#39; we penalize light tasks, so</span>
<span class="cm">	 * they get preempted easier. That is, if &#39;se&#39; &lt; &#39;curr&#39; then</span>
<span class="cm">	 * the resulting gran will be larger, therefore penalizing the</span>
<span class="cm">	 * lighter, if otoh &#39;se&#39; &gt; &#39;curr&#39; then the resulting gran will</span>
<span class="cm">	 * be smaller, again penalizing the lighter task.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This is especially important for buddies when the leftmost</span>
<span class="cm">	 * task is higher priority than the buddy.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">calc_delta_fair</span><span class="p">(</span><span class="n">gran</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Should &#39;se&#39; preempt &#39;curr&#39;.</span>
<span class="cm"> *</span>
<span class="cm"> *             |s1</span>
<span class="cm"> *        |s2</span>
<span class="cm"> *   |s3</span>
<span class="cm"> *         g</span>
<span class="cm"> *      |&lt;---&gt;|c</span>
<span class="cm"> *</span>
<span class="cm"> *  w(c, s1) = -1</span>
<span class="cm"> *  w(c, s2) =  0</span>
<span class="cm"> *  w(c, s3) =  1</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">wakeup_preempt_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s64</span> <span class="n">gran</span><span class="p">,</span> <span class="n">vdiff</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">vruntime</span> <span class="o">-</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">vruntime</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vdiff</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">gran</span> <span class="o">=</span> <span class="n">wakeup_gran</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vdiff</span> <span class="o">&gt;</span> <span class="n">gran</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_last_buddy</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entity_is_task</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">task_of</span><span class="p">(</span><span class="n">se</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">==</span> <span class="n">SCHED_IDLE</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span>
		<span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">se</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_next_buddy</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entity_is_task</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">task_of</span><span class="p">(</span><span class="n">se</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">==</span> <span class="n">SCHED_IDLE</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span>
		<span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">se</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_skip_buddy</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span>
		<span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">skip</span> <span class="o">=</span> <span class="n">se</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Preempt the current task with a newly woken task if needed:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_preempt_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wake_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">,</span> <span class="o">*</span><span class="n">pse</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">task_cfs_rq</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">scale</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">&gt;=</span> <span class="n">sched_nr_latency</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">next_buddy_marked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">se</span> <span class="o">==</span> <span class="n">pse</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is possible from callers such as move_task(), in which we</span>
<span class="cm">	 * unconditionally check_prempt_curr() after an enqueue (which may have</span>
<span class="cm">	 * lead to a throttle).  This both saves work and prevents false</span>
<span class="cm">	 * next-buddy nomination below.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">throttled_hierarchy</span><span class="p">(</span><span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">pse</span><span class="p">))))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sched_feat</span><span class="p">(</span><span class="n">NEXT_BUDDY</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">scale</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">wake_flags</span> <span class="o">&amp;</span> <span class="n">WF_FORK</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">set_next_buddy</span><span class="p">(</span><span class="n">pse</span><span class="p">);</span>
		<span class="n">next_buddy_marked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We can come here with TIF_NEED_RESCHED already set from new task</span>
<span class="cm">	 * wake up path.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: this also catches the edge-case of curr being in a throttled</span>
<span class="cm">	 * group (e.g. via set_curr_task), since update_curr() (in the</span>
<span class="cm">	 * enqueue of curr) will have resulted in resched being set.  This</span>
<span class="cm">	 * prevents us from potentially nominating it as a false LAST_BUDDY</span>
<span class="cm">	 * below.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_tsk_need_resched</span><span class="p">(</span><span class="n">curr</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Idle tasks are by definition preempted by non-idle tasks. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">==</span> <span class="n">SCHED_IDLE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">likely</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">!=</span> <span class="n">SCHED_IDLE</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">preempt</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Batch and idle tasks do not preempt non-idle tasks (their preemption</span>
<span class="cm">	 * is driven by the tick):</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">!=</span> <span class="n">SCHED_NORMAL</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">find_matching_se</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pse</span><span class="p">);</span>
	<span class="n">update_curr</span><span class="p">(</span><span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pse</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wakeup_preempt_entity</span><span class="p">(</span><span class="n">se</span><span class="p">,</span> <span class="n">pse</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Bias pick_next to pick the sched entity that is</span>
<span class="cm">		 * triggering this preemption.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next_buddy_marked</span><span class="p">)</span>
			<span class="n">set_next_buddy</span><span class="p">(</span><span class="n">pse</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">preempt</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>

<span class="nl">preempt:</span>
	<span class="n">resched_task</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Only set the backward buddy when the current task is still</span>
<span class="cm">	 * on the rq. This can happen when a wakeup gets interleaved</span>
<span class="cm">	 * with schedule on the -&gt;pre_schedule() or idle_balance()</span>
<span class="cm">	 * point, either of which can * drop the rq lock.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Also, during early boot the idle thread is in the fair class,</span>
<span class="cm">	 * for obvious reasons its a bad idea to schedule back to it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">on_rq</span> <span class="o">||</span> <span class="n">curr</span> <span class="o">==</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">idle</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sched_feat</span><span class="p">(</span><span class="n">LAST_BUDDY</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">scale</span> <span class="o">&amp;&amp;</span> <span class="n">entity_is_task</span><span class="p">(</span><span class="n">se</span><span class="p">))</span>
		<span class="n">set_last_buddy</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">pick_next_task_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">nr_running</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">se</span> <span class="o">=</span> <span class="n">pick_next_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
		<span class="n">set_next_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
		<span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">group_cfs_rq</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">task_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hrtick_enabled</span><span class="p">(</span><span class="n">rq</span><span class="p">))</span>
		<span class="n">hrtick_start_fair</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Account for a descheduled task:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">put_prev_task_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">;</span>

	<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
		<span class="n">put_prev_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sched_yield() is very simple</span>
<span class="cm"> *</span>
<span class="cm"> * The magic of dealing with the -&gt;skip buddy is in pick_next_entity.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">yield_task_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">task_cfs_rq</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Are we the only task in the tree?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">clear_buddies</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">!=</span> <span class="n">SCHED_BATCH</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Update run-time statistics of the &#39;current&#39;.</span>
<span class="cm">		 */</span>
		<span class="n">update_curr</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Tell update_rq_clock() that we&#39;ve just updated,</span>
<span class="cm">		 * so we don&#39;t do microscopic update in schedule()</span>
<span class="cm">		 * and double the fastpath cost.</span>
<span class="cm">		 */</span>
		 <span class="n">rq</span><span class="o">-&gt;</span><span class="n">skip_clock_update</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">set_skip_buddy</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">yield_to_task_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">bool</span> <span class="n">preempt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">;</span>

	<span class="cm">/* throttled hierarchies are not runnable */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">on_rq</span> <span class="o">||</span> <span class="n">throttled_hierarchy</span><span class="p">(</span><span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">)))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Tell the scheduler that we&#39;d really like pse to run next. */</span>
	<span class="n">set_next_buddy</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>

	<span class="n">yield_task_fair</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cm">/**************************************************</span>
<span class="cm"> * Fair scheduling class load-balancing methods:</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__read_mostly</span> <span class="n">max_load_balance_interval</span> <span class="o">=</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">10</span><span class="p">;</span>

<span class="cp">#define LBF_ALL_PINNED	0x01</span>
<span class="cp">#define LBF_NEED_BREAK	0x02</span>

<span class="k">struct</span> <span class="n">lb_env</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_domain</span>	<span class="o">*</span><span class="n">sd</span><span class="p">;</span>

	<span class="kt">int</span>			<span class="n">src_cpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rq</span>		<span class="o">*</span><span class="n">src_rq</span><span class="p">;</span>

	<span class="kt">int</span>			<span class="n">dst_cpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rq</span>		<span class="o">*</span><span class="n">dst_rq</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">cpu_idle_type</span>	<span class="n">idle</span><span class="p">;</span>
	<span class="kt">long</span>			<span class="n">imbalance</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">flags</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">loop</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">loop_break</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">loop_max</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * move_task - move a task from one runqueue to another runqueue.</span>
<span class="cm"> * Both runqueues must be locked.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">move_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lb_env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">deactivate_task</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">src_rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">set_task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_cpu</span><span class="p">);</span>
	<span class="n">activate_task</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">check_preempt_curr</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Is this task likely cache-hot:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">task_hot</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">u64</span> <span class="n">now</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s64</span> <span class="n">delta</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">fair_sched_class</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">==</span> <span class="n">SCHED_IDLE</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Buddy candidates are cache hot:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sched_feat</span><span class="p">(</span><span class="n">CACHE_HOT_BUDDY</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">this_rq</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span> <span class="o">==</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">||</span>
			 <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span> <span class="o">==</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_sched_migration_cost</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_sched_migration_cost</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">delta</span> <span class="o">=</span> <span class="n">now</span> <span class="o">-</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">exec_start</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">delta</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span><span class="n">sysctl_sched_migration_cost</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * can_migrate_task - may task p from runqueue rq be migrated to this_cpu?</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">can_migrate_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lb_env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">tsk_cache_hot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We do not migrate tasks that are:</span>
<span class="cm">	 * 1) running (obviously), or</span>
<span class="cm">	 * 2) cannot be migrated to this CPU due to cpus_allowed, or</span>
<span class="cm">	 * 3) are cache-hot on their current CPU.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_cpu</span><span class="p">,</span> <span class="n">tsk_cpus_allowed</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">se</span><span class="p">.</span><span class="n">statistics</span><span class="p">.</span><span class="n">nr_failed_migrations_affine</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">env</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LBF_ALL_PINNED</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task_running</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">src_rq</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">se</span><span class="p">.</span><span class="n">statistics</span><span class="p">.</span><span class="n">nr_failed_migrations_running</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Aggressive migration if:</span>
<span class="cm">	 * 1) task is cache cold, or</span>
<span class="cm">	 * 2) too many balance attempts have failed.</span>
<span class="cm">	 */</span>

	<span class="n">tsk_cache_hot</span> <span class="o">=</span> <span class="n">task_hot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">src_rq</span><span class="o">-&gt;</span><span class="n">clock_task</span><span class="p">,</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tsk_cache_hot</span> <span class="o">||</span>
		<span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">nr_balance_failed</span> <span class="o">&gt;</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">cache_nice_tries</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_SCHEDSTATS</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tsk_cache_hot</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">,</span> <span class="n">lb_hot_gained</span><span class="p">[</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">idle</span><span class="p">]);</span>
			<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">se</span><span class="p">.</span><span class="n">statistics</span><span class="p">.</span><span class="n">nr_forced_migrations</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tsk_cache_hot</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">se</span><span class="p">.</span><span class="n">statistics</span><span class="p">.</span><span class="n">nr_failed_migrations_hot</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * move_one_task tries to move exactly one task from busiest to this_rq, as</span>
<span class="cm"> * part of active balancing operations within &quot;domain&quot;.</span>
<span class="cm"> * Returns 1 if successful and 0 otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> * Called with both runqueues locked.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">move_one_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">lb_env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">src_rq</span><span class="o">-&gt;</span><span class="n">cfs_tasks</span><span class="p">,</span> <span class="n">se</span><span class="p">.</span><span class="n">group_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">throttled_lb_pair</span><span class="p">(</span><span class="n">task_group</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">src_rq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_cpu</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">can_migrate_task</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">env</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">move_task</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">env</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Right now, this is only the second place move_task()</span>
<span class="cm">		 * is called, so we can safely collect move_task()</span>
<span class="cm">		 * stats here rather than inside move_task().</span>
<span class="cm">		 */</span>
		<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">,</span> <span class="n">lb_gained</span><span class="p">[</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">idle</span><span class="p">]);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">task_h_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sched_nr_migrate_break</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * move_tasks tries to move up to imbalance weighted load from busiest to</span>
<span class="cm"> * this_rq, as part of a balancing operation within domain &quot;sd&quot;.</span>
<span class="cm"> * Returns 1 if successful and 0 otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> * Called with both runqueues locked.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">move_tasks</span><span class="p">(</span><span class="k">struct</span> <span class="n">lb_env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">tasks</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">src_rq</span><span class="o">-&gt;</span><span class="n">cfs_tasks</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">load</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pulled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">imbalance</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">tasks</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="n">tasks</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span><span class="p">,</span> <span class="n">se</span><span class="p">.</span><span class="n">group_node</span><span class="p">);</span>

		<span class="n">env</span><span class="o">-&gt;</span><span class="n">loop</span><span class="o">++</span><span class="p">;</span>
		<span class="cm">/* We&#39;ve more or less seen every task there is, call it quits */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">loop</span> <span class="o">&gt;</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">loop_max</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* take a breather every nr_migrate tasks */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">loop</span> <span class="o">&gt;</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">loop_break</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">env</span><span class="o">-&gt;</span><span class="n">loop_break</span> <span class="o">+=</span> <span class="n">sched_nr_migrate_break</span><span class="p">;</span>
			<span class="n">env</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">LBF_NEED_BREAK</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">throttled_lb_pair</span><span class="p">(</span><span class="n">task_group</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">src_cpu</span><span class="p">,</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_cpu</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>

		<span class="n">load</span> <span class="o">=</span> <span class="n">task_h_load</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sched_feat</span><span class="p">(</span><span class="n">LB_MIN</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">load</span> <span class="o">&lt;</span> <span class="mi">16</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">nr_balance_failed</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">load</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">imbalance</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">can_migrate_task</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">env</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>

		<span class="n">move_task</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">env</span><span class="p">);</span>
		<span class="n">pulled</span><span class="o">++</span><span class="p">;</span>
		<span class="n">env</span><span class="o">-&gt;</span><span class="n">imbalance</span> <span class="o">-=</span> <span class="n">load</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PREEMPT</span>
		<span class="cm">/*</span>
<span class="cm">		 * NEWIDLE balancing is a source of latency, so preemptible</span>
<span class="cm">		 * kernels will stop after the first task is pulled to minimize</span>
<span class="cm">		 * the critical section.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">==</span> <span class="n">CPU_NEWLY_IDLE</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>

		<span class="cm">/*</span>
<span class="cm">		 * We only want to steal up to the prescribed amount of</span>
<span class="cm">		 * weighted load.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">imbalance</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">continue</span><span class="p">;</span>
<span class="nl">next:</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">group_node</span><span class="p">,</span> <span class="n">tasks</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Right now, this is one of only two places move_task() is called,</span>
<span class="cm">	 * so we can safely collect move_task() stats here rather than</span>
<span class="cm">	 * inside move_task().</span>
<span class="cm">	 */</span>
	<span class="n">schedstat_add</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">,</span> <span class="n">lb_gained</span><span class="p">[</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">idle</span><span class="p">],</span> <span class="n">pulled</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pulled</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_FAIR_GROUP_SCHED</span>
<span class="cm">/*</span>
<span class="cm"> * update tg-&gt;load_weight by folding this cpu&#39;s load_avg</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">update_shares_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">[</span><span class="n">cpu</span><span class="p">])</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="n">update_cfs_load</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to update shares after updating tg-&gt;load_weight in</span>
<span class="cm">	 * order to adjust the weight of groups with long running tasks.</span>
<span class="cm">	 */</span>
	<span class="n">update_cfs_shares</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>

	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_shares</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * Iterates the task_group tree in a bottom up fashion, see</span>
<span class="cm">	 * list_add_leaf_cfs_rq() for details.</span>
<span class="cm">	 */</span>
	<span class="n">for_each_leaf_cfs_rq</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">cfs_rq</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* throttled entities do not contribute to load */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">throttled_hierarchy</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">update_shares_cpu</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tg</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Compute the cpu&#39;s hierarchical load factor for each task group.</span>
<span class="cm"> * This needs to be done in a top-down fashion because the load of a child</span>
<span class="cm"> * group is a fraction of its parents load.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tg_load_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">load</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">cpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">load</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">load</span> <span class="o">=</span> <span class="n">tg</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">h_load</span><span class="p">;</span>
		<span class="n">load</span> <span class="o">*=</span> <span class="n">tg</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">;</span>
		<span class="n">load</span> <span class="o">/=</span> <span class="n">tg</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">h_load</span> <span class="o">=</span> <span class="n">load</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_h_load</span><span class="p">(</span><span class="kt">long</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">walk_tg_tree</span><span class="p">(</span><span class="n">tg_load_down</span><span class="p">,</span> <span class="n">tg_nop</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">task_h_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">task_cfs_rq</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">load</span><span class="p">;</span>

	<span class="n">load</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">;</span>
	<span class="n">load</span> <span class="o">=</span> <span class="n">div_u64</span><span class="p">(</span><span class="n">load</span> <span class="o">*</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">h_load</span><span class="p">,</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">load</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_shares</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_h_load</span><span class="p">(</span><span class="kt">long</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">task_h_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/********** Helpers for find_busiest_group ************************/</span>
<span class="cm">/*</span>
<span class="cm"> * sd_lb_stats - Structure to store the statistics of a sched_domain</span>
<span class="cm"> * 		during load balancing.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sd_lb_stats</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">busiest</span><span class="p">;</span> <span class="cm">/* Busiest group in this sd */</span>
	<span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>  <span class="cm">/* Local group in this sd */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total_load</span><span class="p">;</span>  <span class="cm">/* Total load of all groups in sd */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total_pwr</span><span class="p">;</span>   <span class="cm">/*	Total power of all groups in sd */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">avg_load</span><span class="p">;</span>	   <span class="cm">/* Average load across all groups in sd */</span>

	<span class="cm">/** Statistics of this group */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">this_load</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">this_load_per_task</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">this_nr_running</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">this_has_capacity</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">this_idle_cpus</span><span class="p">;</span>

	<span class="cm">/* Statistics of the busiest group */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">busiest_idle_cpus</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_load</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">busiest_load_per_task</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">busiest_nr_running</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">busiest_group_capacity</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">busiest_has_capacity</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">busiest_group_weight</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">group_imb</span><span class="p">;</span> <span class="cm">/* Is there imbalance in this sd */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * sg_lb_stats - stats of a sched_group required for load_balancing</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sg_lb_stats</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">avg_load</span><span class="p">;</span> <span class="cm">/*Avg load across the CPUs of the group */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">group_load</span><span class="p">;</span> <span class="cm">/* Total load over the CPUs of the group */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sum_nr_running</span><span class="p">;</span> <span class="cm">/* Nr tasks running in the group */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sum_weighted_load</span><span class="p">;</span> <span class="cm">/* Weighted load of group&#39;s tasks */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">group_capacity</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">idle_cpus</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">group_weight</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">group_imb</span><span class="p">;</span> <span class="cm">/* Is there an imbalance in the group ? */</span>
	<span class="kt">int</span> <span class="n">group_has_capacity</span><span class="p">;</span> <span class="cm">/* Is there extra capacity in the group? */</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * get_sd_load_idx - Obtain the load index for a given sched domain.</span>
<span class="cm"> * @sd: The sched_domain whose load_idx is to be obtained.</span>
<span class="cm"> * @idle: The Idle status of the CPU for whose sd load_icx is obtained.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">get_sd_load_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span>
					<span class="k">enum</span> <span class="n">cpu_idle_type</span> <span class="n">idle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">load_idx</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">idle</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_NOT_IDLE</span>:
		<span class="n">load_idx</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">busy_idx</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CPU_NEWLY_IDLE</span>:
		<span class="n">load_idx</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">newidle_idx</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">load_idx</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">idle_idx</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">load_idx</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">default_scale_freq_power</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">SCHED_POWER_SCALE</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__weak</span> <span class="nf">arch_scale_freq_power</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">default_scale_freq_power</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">default_scale_smt_power</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">span_weight</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">smt_gain</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">smt_gain</span><span class="p">;</span>

	<span class="n">smt_gain</span> <span class="o">/=</span> <span class="n">weight</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">smt_gain</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__weak</span> <span class="nf">arch_scale_smt_power</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">default_scale_smt_power</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">scale_rt_power</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">total</span><span class="p">,</span> <span class="n">available</span><span class="p">,</span> <span class="n">age_stamp</span><span class="p">,</span> <span class="n">avg</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since we&#39;re reading these variables without serialization make sure</span>
<span class="cm">	 * we read them once before doing sanity checks on them.</span>
<span class="cm">	 */</span>
	<span class="n">age_stamp</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">age_stamp</span><span class="p">);</span>
	<span class="n">avg</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt_avg</span><span class="p">);</span>

	<span class="n">total</span> <span class="o">=</span> <span class="n">sched_avg_period</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">clock</span> <span class="o">-</span> <span class="n">age_stamp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">total</span> <span class="o">&lt;</span> <span class="n">avg</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Ensures that power won&#39;t end up being negative */</span>
		<span class="n">available</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">available</span> <span class="o">=</span> <span class="n">total</span> <span class="o">-</span> <span class="n">avg</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">s64</span><span class="p">)</span><span class="n">total</span> <span class="o">&lt;</span> <span class="n">SCHED_POWER_SCALE</span><span class="p">))</span>
		<span class="n">total</span> <span class="o">=</span> <span class="n">SCHED_POWER_SCALE</span><span class="p">;</span>

	<span class="n">total</span> <span class="o">&gt;&gt;=</span> <span class="n">SCHED_POWER_SHIFT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">div_u64</span><span class="p">(</span><span class="n">available</span><span class="p">,</span> <span class="n">total</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_cpu_power</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">span_weight</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">power</span> <span class="o">=</span> <span class="n">SCHED_POWER_SCALE</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">sdg</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SD_SHARE_CPUPOWER</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">weight</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sched_feat</span><span class="p">(</span><span class="n">ARCH_POWER</span><span class="p">))</span>
			<span class="n">power</span> <span class="o">*=</span> <span class="n">arch_scale_smt_power</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">power</span> <span class="o">*=</span> <span class="n">default_scale_smt_power</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

		<span class="n">power</span> <span class="o">&gt;&gt;=</span> <span class="n">SCHED_POWER_SHIFT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sdg</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">power_orig</span> <span class="o">=</span> <span class="n">power</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sched_feat</span><span class="p">(</span><span class="n">ARCH_POWER</span><span class="p">))</span>
		<span class="n">power</span> <span class="o">*=</span> <span class="n">arch_scale_freq_power</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">power</span> <span class="o">*=</span> <span class="n">default_scale_freq_power</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="n">power</span> <span class="o">&gt;&gt;=</span> <span class="n">SCHED_POWER_SHIFT</span><span class="p">;</span>

	<span class="n">power</span> <span class="o">*=</span> <span class="n">scale_rt_power</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">power</span> <span class="o">&gt;&gt;=</span> <span class="n">SCHED_POWER_SHIFT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">power</span><span class="p">)</span>
		<span class="n">power</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cpu_power</span> <span class="o">=</span> <span class="n">power</span><span class="p">;</span>
	<span class="n">sdg</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">power</span> <span class="o">=</span> <span class="n">power</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">update_group_power</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">child</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">group</span><span class="p">,</span> <span class="o">*</span><span class="n">sdg</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">power</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">interval</span><span class="p">;</span>

	<span class="n">interval</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">balance_interval</span><span class="p">);</span>
	<span class="n">interval</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="mi">1UL</span><span class="p">,</span> <span class="n">max_load_balance_interval</span><span class="p">);</span>
	<span class="n">sdg</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">next_update</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">interval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">child</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">update_cpu_power</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">power</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SD_OVERLAP</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * SD_OVERLAP domains cannot assume that child groups</span>
<span class="cm">		 * span the current group.</span>
<span class="cm">		 */</span>

		<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">sched_group_cpus</span><span class="p">(</span><span class="n">sdg</span><span class="p">))</span>
			<span class="n">power</span> <span class="o">+=</span> <span class="n">power_of</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>  <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * !SD_OVERLAP domains can assume that child groups</span>
<span class="cm">		 * span the current group.</span>
<span class="cm">		 */</span> 

		<span class="n">group</span> <span class="o">=</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">power</span> <span class="o">+=</span> <span class="n">group</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">;</span>
			<span class="n">group</span> <span class="o">=</span> <span class="n">group</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">group</span> <span class="o">!=</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">sdg</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">power_orig</span> <span class="o">=</span> <span class="n">sdg</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">power</span> <span class="o">=</span> <span class="n">power</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Try and fix up capacity for tiny siblings, this is needed when</span>
<span class="cm"> * things like SD_ASYM_PACKING need f_b_g to select another sibling</span>
<span class="cm"> * which on its own isn&#39;t powerful enough.</span>
<span class="cm"> *</span>
<span class="cm"> * See update_sd_pick_busiest() and check_asym_packing().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">fix_small_capacity</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">group</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Only siblings can have significantly less than SCHED_POWER_SCALE</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SD_SHARE_CPUPOWER</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If ~90% of the cpu_power is still there, we&#39;re good.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">power</span> <span class="o">*</span> <span class="mi">32</span> <span class="o">&gt;</span> <span class="n">group</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">power_orig</span> <span class="o">*</span> <span class="mi">29</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * update_sg_lb_stats - Update sched_group&#39;s statistics for load balancing.</span>
<span class="cm"> * @env: The load balancing environment.</span>
<span class="cm"> * @group: sched_group whose statistics are to be updated.</span>
<span class="cm"> * @load_idx: Load index of sched_domain of this_cpu for load calc.</span>
<span class="cm"> * @local_group: Does group contain this_cpu.</span>
<span class="cm"> * @cpus: Set of cpus considered for load balancing.</span>
<span class="cm"> * @balance: Should we balance.</span>
<span class="cm"> * @sgs: variable to hold the statistics for this group.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_sg_lb_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">lb_env</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">group</span><span class="p">,</span> <span class="kt">int</span> <span class="n">load_idx</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">local_group</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpus</span><span class="p">,</span>
			<span class="kt">int</span> <span class="o">*</span><span class="n">balance</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sg_lb_stats</span> <span class="o">*</span><span class="n">sgs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_running</span><span class="p">,</span> <span class="n">max_nr_running</span><span class="p">,</span> <span class="n">min_nr_running</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">load</span><span class="p">,</span> <span class="n">max_cpu_load</span><span class="p">,</span> <span class="n">min_cpu_load</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">balance_cpu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">first_idle_cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">avg_load_per_task</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">local_group</span><span class="p">)</span>
		<span class="n">balance_cpu</span> <span class="o">=</span> <span class="n">group_balance_cpu</span><span class="p">(</span><span class="n">group</span><span class="p">);</span>

	<span class="cm">/* Tally up the load of all CPUs in the group */</span>
	<span class="n">max_cpu_load</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">min_cpu_load</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span>
	<span class="n">max_nr_running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">min_nr_running</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span>

	<span class="n">for_each_cpu_and</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">sched_group_cpus</span><span class="p">(</span><span class="n">group</span><span class="p">),</span> <span class="n">cpus</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

		<span class="n">nr_running</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_running</span><span class="p">;</span>

		<span class="cm">/* Bias balancing toward cpus of our domain */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">local_group</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">idle_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">first_idle_cpu</span> <span class="o">&amp;&amp;</span>
					<span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">sched_group_mask</span><span class="p">(</span><span class="n">group</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">first_idle_cpu</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">balance_cpu</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">load</span> <span class="o">=</span> <span class="n">target_load</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">load_idx</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">load</span> <span class="o">=</span> <span class="n">source_load</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">load_idx</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">load</span> <span class="o">&gt;</span> <span class="n">max_cpu_load</span><span class="p">)</span>
				<span class="n">max_cpu_load</span> <span class="o">=</span> <span class="n">load</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">min_cpu_load</span> <span class="o">&gt;</span> <span class="n">load</span><span class="p">)</span>
				<span class="n">min_cpu_load</span> <span class="o">=</span> <span class="n">load</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">nr_running</span> <span class="o">&gt;</span> <span class="n">max_nr_running</span><span class="p">)</span>
				<span class="n">max_nr_running</span> <span class="o">=</span> <span class="n">nr_running</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">min_nr_running</span> <span class="o">&gt;</span> <span class="n">nr_running</span><span class="p">)</span>
				<span class="n">min_nr_running</span> <span class="o">=</span> <span class="n">nr_running</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">sgs</span><span class="o">-&gt;</span><span class="n">group_load</span> <span class="o">+=</span> <span class="n">load</span><span class="p">;</span>
		<span class="n">sgs</span><span class="o">-&gt;</span><span class="n">sum_nr_running</span> <span class="o">+=</span> <span class="n">nr_running</span><span class="p">;</span>
		<span class="n">sgs</span><span class="o">-&gt;</span><span class="n">sum_weighted_load</span> <span class="o">+=</span> <span class="n">weighted_cpuload</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">idle_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
			<span class="n">sgs</span><span class="o">-&gt;</span><span class="n">idle_cpus</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * First idle cpu or the first cpu(busiest) in this sched group</span>
<span class="cm">	 * is eligible for doing load balancing at this and above</span>
<span class="cm">	 * domains. In the newly idle case, we will allow all the cpu&#39;s</span>
<span class="cm">	 * to do the newly idle load balance.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">local_group</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">!=</span> <span class="n">CPU_NEWLY_IDLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">balance_cpu</span> <span class="o">!=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_cpu</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">balance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">update_group_power</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">,</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_cpu</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">time_after_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">group</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">next_update</span><span class="p">))</span>
			<span class="n">update_group_power</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">,</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_cpu</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Adjust by relative CPU power of the group */</span>
	<span class="n">sgs</span><span class="o">-&gt;</span><span class="n">avg_load</span> <span class="o">=</span> <span class="p">(</span><span class="n">sgs</span><span class="o">-&gt;</span><span class="n">group_load</span><span class="o">*</span><span class="n">SCHED_POWER_SCALE</span><span class="p">)</span> <span class="o">/</span> <span class="n">group</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Consider the group unbalanced when the imbalance is larger</span>
<span class="cm">	 * than the average weight of a task.</span>
<span class="cm">	 *</span>
<span class="cm">	 * APZ: with cgroup the avg task weight can vary wildly and</span>
<span class="cm">	 *      might not be a suitable number - should we keep a</span>
<span class="cm">	 *      normalized nr_running number somewhere that negates</span>
<span class="cm">	 *      the hierarchy?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sgs</span><span class="o">-&gt;</span><span class="n">sum_nr_running</span><span class="p">)</span>
		<span class="n">avg_load_per_task</span> <span class="o">=</span> <span class="n">sgs</span><span class="o">-&gt;</span><span class="n">sum_weighted_load</span> <span class="o">/</span> <span class="n">sgs</span><span class="o">-&gt;</span><span class="n">sum_nr_running</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">max_cpu_load</span> <span class="o">-</span> <span class="n">min_cpu_load</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">avg_load_per_task</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">max_nr_running</span> <span class="o">-</span> <span class="n">min_nr_running</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">sgs</span><span class="o">-&gt;</span><span class="n">group_imb</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">sgs</span><span class="o">-&gt;</span><span class="n">group_capacity</span> <span class="o">=</span> <span class="n">DIV_ROUND_CLOSEST</span><span class="p">(</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">,</span>
						<span class="n">SCHED_POWER_SCALE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sgs</span><span class="o">-&gt;</span><span class="n">group_capacity</span><span class="p">)</span>
		<span class="n">sgs</span><span class="o">-&gt;</span><span class="n">group_capacity</span> <span class="o">=</span> <span class="n">fix_small_capacity</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">,</span> <span class="n">group</span><span class="p">);</span>
	<span class="n">sgs</span><span class="o">-&gt;</span><span class="n">group_weight</span> <span class="o">=</span> <span class="n">group</span><span class="o">-&gt;</span><span class="n">group_weight</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sgs</span><span class="o">-&gt;</span><span class="n">group_capacity</span> <span class="o">&gt;</span> <span class="n">sgs</span><span class="o">-&gt;</span><span class="n">sum_nr_running</span><span class="p">)</span>
		<span class="n">sgs</span><span class="o">-&gt;</span><span class="n">group_has_capacity</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * update_sd_pick_busiest - return 1 on busiest group</span>
<span class="cm"> * @env: The load balancing environment.</span>
<span class="cm"> * @sds: sched_domain statistics</span>
<span class="cm"> * @sg: sched_group candidate to be checked for being the busiest</span>
<span class="cm"> * @sgs: sched_group statistics</span>
<span class="cm"> *</span>
<span class="cm"> * Determine if @sg is a busier group than the previously selected</span>
<span class="cm"> * busiest group.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">update_sd_pick_busiest</span><span class="p">(</span><span class="k">struct</span> <span class="n">lb_env</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">sd_lb_stats</span> <span class="o">*</span><span class="n">sds</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">sg_lb_stats</span> <span class="o">*</span><span class="n">sgs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sgs</span><span class="o">-&gt;</span><span class="n">avg_load</span> <span class="o">&lt;=</span> <span class="n">sds</span><span class="o">-&gt;</span><span class="n">max_load</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sgs</span><span class="o">-&gt;</span><span class="n">sum_nr_running</span> <span class="o">&gt;</span> <span class="n">sgs</span><span class="o">-&gt;</span><span class="n">group_capacity</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sgs</span><span class="o">-&gt;</span><span class="n">group_imb</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * ASYM_PACKING needs to move all the work to the lowest</span>
<span class="cm">	 * numbered CPUs in the group, therefore mark all groups</span>
<span class="cm">	 * higher than ourself as busy.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SD_ASYM_PACKING</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">sgs</span><span class="o">-&gt;</span><span class="n">sum_nr_running</span> <span class="o">&amp;&amp;</span>
	    <span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_cpu</span> <span class="o">&lt;</span> <span class="n">group_first_cpu</span><span class="p">(</span><span class="n">sg</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">group_first_cpu</span><span class="p">(</span><span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">group_first_cpu</span><span class="p">(</span><span class="n">sg</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * update_sd_lb_stats - Update sched_domain&#39;s statistics for load balancing.</span>
<span class="cm"> * @env: The load balancing environment.</span>
<span class="cm"> * @cpus: Set of cpus considered for load balancing.</span>
<span class="cm"> * @balance: Should we balance.</span>
<span class="cm"> * @sds: variable to hold the statistics for this sched_domain.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_sd_lb_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">lb_env</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpus</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="o">*</span><span class="n">balance</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sd_lb_stats</span> <span class="o">*</span><span class="n">sds</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">child</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">sg</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sg_lb_stats</span> <span class="n">sgs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">load_idx</span><span class="p">,</span> <span class="n">prefer_sibling</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">child</span> <span class="o">&amp;&amp;</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SD_PREFER_SIBLING</span><span class="p">)</span>
		<span class="n">prefer_sibling</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">load_idx</span> <span class="o">=</span> <span class="n">get_sd_load_idx</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">,</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">idle</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">local_group</span><span class="p">;</span>

		<span class="n">local_group</span> <span class="o">=</span> <span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_cpu</span><span class="p">,</span> <span class="n">sched_group_cpus</span><span class="p">(</span><span class="n">sg</span><span class="p">));</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sgs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sgs</span><span class="p">));</span>
		<span class="n">update_sg_lb_stats</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">load_idx</span><span class="p">,</span> <span class="n">local_group</span><span class="p">,</span>
				   <span class="n">cpus</span><span class="p">,</span> <span class="n">balance</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sgs</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">local_group</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">balance</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">sds</span><span class="o">-&gt;</span><span class="n">total_load</span> <span class="o">+=</span> <span class="n">sgs</span><span class="p">.</span><span class="n">group_load</span><span class="p">;</span>
		<span class="n">sds</span><span class="o">-&gt;</span><span class="n">total_pwr</span> <span class="o">+=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * In case the child domain prefers tasks go to siblings</span>
<span class="cm">		 * first, lower the sg capacity to one so that we&#39;ll try</span>
<span class="cm">		 * and move all the excess tasks away. We lower the capacity</span>
<span class="cm">		 * of a group only if the local group has the capacity to fit</span>
<span class="cm">		 * these excess tasks, i.e. nr_running &lt; group_capacity. The</span>
<span class="cm">		 * extra check prevents the case where you always pull from the</span>
<span class="cm">		 * heaviest group when it is already under-utilized (possible</span>
<span class="cm">		 * with a large weight task outweighs the tasks on the system).</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prefer_sibling</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">local_group</span> <span class="o">&amp;&amp;</span> <span class="n">sds</span><span class="o">-&gt;</span><span class="n">this_has_capacity</span><span class="p">)</span>
			<span class="n">sgs</span><span class="p">.</span><span class="n">group_capacity</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">sgs</span><span class="p">.</span><span class="n">group_capacity</span><span class="p">,</span> <span class="mi">1UL</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">local_group</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sds</span><span class="o">-&gt;</span><span class="n">this_load</span> <span class="o">=</span> <span class="n">sgs</span><span class="p">.</span><span class="n">avg_load</span><span class="p">;</span>
			<span class="n">sds</span><span class="o">-&gt;</span><span class="n">this</span> <span class="o">=</span> <span class="n">sg</span><span class="p">;</span>
			<span class="n">sds</span><span class="o">-&gt;</span><span class="n">this_nr_running</span> <span class="o">=</span> <span class="n">sgs</span><span class="p">.</span><span class="n">sum_nr_running</span><span class="p">;</span>
			<span class="n">sds</span><span class="o">-&gt;</span><span class="n">this_load_per_task</span> <span class="o">=</span> <span class="n">sgs</span><span class="p">.</span><span class="n">sum_weighted_load</span><span class="p">;</span>
			<span class="n">sds</span><span class="o">-&gt;</span><span class="n">this_has_capacity</span> <span class="o">=</span> <span class="n">sgs</span><span class="p">.</span><span class="n">group_has_capacity</span><span class="p">;</span>
			<span class="n">sds</span><span class="o">-&gt;</span><span class="n">this_idle_cpus</span> <span class="o">=</span> <span class="n">sgs</span><span class="p">.</span><span class="n">idle_cpus</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">update_sd_pick_busiest</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">sds</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sgs</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sds</span><span class="o">-&gt;</span><span class="n">max_load</span> <span class="o">=</span> <span class="n">sgs</span><span class="p">.</span><span class="n">avg_load</span><span class="p">;</span>
			<span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest</span> <span class="o">=</span> <span class="n">sg</span><span class="p">;</span>
			<span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest_nr_running</span> <span class="o">=</span> <span class="n">sgs</span><span class="p">.</span><span class="n">sum_nr_running</span><span class="p">;</span>
			<span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest_idle_cpus</span> <span class="o">=</span> <span class="n">sgs</span><span class="p">.</span><span class="n">idle_cpus</span><span class="p">;</span>
			<span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest_group_capacity</span> <span class="o">=</span> <span class="n">sgs</span><span class="p">.</span><span class="n">group_capacity</span><span class="p">;</span>
			<span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest_load_per_task</span> <span class="o">=</span> <span class="n">sgs</span><span class="p">.</span><span class="n">sum_weighted_load</span><span class="p">;</span>
			<span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest_has_capacity</span> <span class="o">=</span> <span class="n">sgs</span><span class="p">.</span><span class="n">group_has_capacity</span><span class="p">;</span>
			<span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest_group_weight</span> <span class="o">=</span> <span class="n">sgs</span><span class="p">.</span><span class="n">group_weight</span><span class="p">;</span>
			<span class="n">sds</span><span class="o">-&gt;</span><span class="n">group_imb</span> <span class="o">=</span> <span class="n">sgs</span><span class="p">.</span><span class="n">group_imb</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">sg</span> <span class="o">=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">sg</span> <span class="o">!=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * check_asym_packing - Check to see if the group is packed into the</span>
<span class="cm"> *			sched doman.</span>
<span class="cm"> *</span>
<span class="cm"> * This is primarily intended to used at the sibling level.  Some</span>
<span class="cm"> * cores like POWER7 prefer to use lower numbered SMT threads.  In the</span>
<span class="cm"> * case of POWER7, it can move to lower SMT modes only when higher</span>
<span class="cm"> * threads are idle.  When in lower SMT modes, the threads will</span>
<span class="cm"> * perform better since they share less core resources.  Hence when we</span>
<span class="cm"> * have idle threads, we want them to be the higher ones.</span>
<span class="cm"> *</span>
<span class="cm"> * This packing function is run on idle threads.  It checks to see if</span>
<span class="cm"> * the busiest CPU in this domain (core in the P7 case) has a higher</span>
<span class="cm"> * CPU number than the packing function is being run on.  Here we are</span>
<span class="cm"> * assuming lower CPU number will be equivalent to lower a SMT thread</span>
<span class="cm"> * number.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 when packing is required and a task should be moved to</span>
<span class="cm"> * this CPU.  The amount of the imbalance is returned in *imbalance.</span>
<span class="cm"> *</span>
<span class="cm"> * @env: The load balancing environment.</span>
<span class="cm"> * @sds: Statistics of the sched_domain which is to be packed</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_asym_packing</span><span class="p">(</span><span class="k">struct</span> <span class="n">lb_env</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sd_lb_stats</span> <span class="o">*</span><span class="n">sds</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">busiest_cpu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SD_ASYM_PACKING</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">busiest_cpu</span> <span class="o">=</span> <span class="n">group_first_cpu</span><span class="p">(</span><span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_cpu</span> <span class="o">&gt;</span> <span class="n">busiest_cpu</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">env</span><span class="o">-&gt;</span><span class="n">imbalance</span> <span class="o">=</span> <span class="n">DIV_ROUND_CLOSEST</span><span class="p">(</span>
		<span class="n">sds</span><span class="o">-&gt;</span><span class="n">max_load</span> <span class="o">*</span> <span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">,</span> <span class="n">SCHED_POWER_SCALE</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fix_small_imbalance - Calculate the minor imbalance that exists</span>
<span class="cm"> *			amongst the groups of a sched_domain, during</span>
<span class="cm"> *			load balancing.</span>
<span class="cm"> * @env: The load balancing environment.</span>
<span class="cm"> * @sds: Statistics of the sched_domain whose imbalance is to be calculated.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">fix_small_imbalance</span><span class="p">(</span><span class="k">struct</span> <span class="n">lb_env</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sd_lb_stats</span> <span class="o">*</span><span class="n">sds</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">pwr_now</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pwr_move</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">imbn</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">scaled_busy_load_per_task</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sds</span><span class="o">-&gt;</span><span class="n">this_nr_running</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sds</span><span class="o">-&gt;</span><span class="n">this_load_per_task</span> <span class="o">/=</span> <span class="n">sds</span><span class="o">-&gt;</span><span class="n">this_nr_running</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest_load_per_task</span> <span class="o">&gt;</span>
				<span class="n">sds</span><span class="o">-&gt;</span><span class="n">this_load_per_task</span><span class="p">)</span>
			<span class="n">imbn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sds</span><span class="o">-&gt;</span><span class="n">this_load_per_task</span> <span class="o">=</span>
			<span class="n">cpu_avg_load_per_task</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_cpu</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">scaled_busy_load_per_task</span> <span class="o">=</span> <span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest_load_per_task</span>
					 <span class="o">*</span> <span class="n">SCHED_POWER_SCALE</span><span class="p">;</span>
	<span class="n">scaled_busy_load_per_task</span> <span class="o">/=</span> <span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sds</span><span class="o">-&gt;</span><span class="n">max_load</span> <span class="o">-</span> <span class="n">sds</span><span class="o">-&gt;</span><span class="n">this_load</span> <span class="o">+</span> <span class="n">scaled_busy_load_per_task</span> <span class="o">&gt;=</span>
			<span class="p">(</span><span class="n">scaled_busy_load_per_task</span> <span class="o">*</span> <span class="n">imbn</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">env</span><span class="o">-&gt;</span><span class="n">imbalance</span> <span class="o">=</span> <span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest_load_per_task</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * OK, we don&#39;t have enough imbalance to justify moving tasks,</span>
<span class="cm">	 * however we may be able to increase total CPU power used by</span>
<span class="cm">	 * moving them.</span>
<span class="cm">	 */</span>

	<span class="n">pwr_now</span> <span class="o">+=</span> <span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">power</span> <span class="o">*</span>
			<span class="n">min</span><span class="p">(</span><span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest_load_per_task</span><span class="p">,</span> <span class="n">sds</span><span class="o">-&gt;</span><span class="n">max_load</span><span class="p">);</span>
	<span class="n">pwr_now</span> <span class="o">+=</span> <span class="n">sds</span><span class="o">-&gt;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">power</span> <span class="o">*</span>
			<span class="n">min</span><span class="p">(</span><span class="n">sds</span><span class="o">-&gt;</span><span class="n">this_load_per_task</span><span class="p">,</span> <span class="n">sds</span><span class="o">-&gt;</span><span class="n">this_load</span><span class="p">);</span>
	<span class="n">pwr_now</span> <span class="o">/=</span> <span class="n">SCHED_POWER_SCALE</span><span class="p">;</span>

	<span class="cm">/* Amount of load we&#39;d subtract */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest_load_per_task</span> <span class="o">*</span> <span class="n">SCHED_POWER_SCALE</span><span class="p">)</span> <span class="o">/</span>
		<span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sds</span><span class="o">-&gt;</span><span class="n">max_load</span> <span class="o">&gt;</span> <span class="n">tmp</span><span class="p">)</span>
		<span class="n">pwr_move</span> <span class="o">+=</span> <span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">power</span> <span class="o">*</span>
			<span class="n">min</span><span class="p">(</span><span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest_load_per_task</span><span class="p">,</span> <span class="n">sds</span><span class="o">-&gt;</span><span class="n">max_load</span> <span class="o">-</span> <span class="n">tmp</span><span class="p">);</span>

	<span class="cm">/* Amount of load we&#39;d add */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sds</span><span class="o">-&gt;</span><span class="n">max_load</span> <span class="o">*</span> <span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">power</span> <span class="o">&lt;</span>
		<span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest_load_per_task</span> <span class="o">*</span> <span class="n">SCHED_POWER_SCALE</span><span class="p">)</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">sds</span><span class="o">-&gt;</span><span class="n">max_load</span> <span class="o">*</span> <span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">)</span> <span class="o">/</span>
			<span class="n">sds</span><span class="o">-&gt;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest_load_per_task</span> <span class="o">*</span> <span class="n">SCHED_POWER_SCALE</span><span class="p">)</span> <span class="o">/</span>
			<span class="n">sds</span><span class="o">-&gt;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">;</span>
	<span class="n">pwr_move</span> <span class="o">+=</span> <span class="n">sds</span><span class="o">-&gt;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">power</span> <span class="o">*</span>
			<span class="n">min</span><span class="p">(</span><span class="n">sds</span><span class="o">-&gt;</span><span class="n">this_load_per_task</span><span class="p">,</span> <span class="n">sds</span><span class="o">-&gt;</span><span class="n">this_load</span> <span class="o">+</span> <span class="n">tmp</span><span class="p">);</span>
	<span class="n">pwr_move</span> <span class="o">/=</span> <span class="n">SCHED_POWER_SCALE</span><span class="p">;</span>

	<span class="cm">/* Move if we gain throughput */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pwr_move</span> <span class="o">&gt;</span> <span class="n">pwr_now</span><span class="p">)</span>
		<span class="n">env</span><span class="o">-&gt;</span><span class="n">imbalance</span> <span class="o">=</span> <span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest_load_per_task</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * calculate_imbalance - Calculate the amount of imbalance present within the</span>
<span class="cm"> *			 groups of a given sched_domain during load balance.</span>
<span class="cm"> * @env: load balance environment</span>
<span class="cm"> * @sds: statistics of the sched_domain whose imbalance is to be calculated.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">calculate_imbalance</span><span class="p">(</span><span class="k">struct</span> <span class="n">lb_env</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sd_lb_stats</span> <span class="o">*</span><span class="n">sds</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_pull</span><span class="p">,</span> <span class="n">load_above_capacity</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span>

	<span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest_load_per_task</span> <span class="o">/=</span> <span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest_nr_running</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sds</span><span class="o">-&gt;</span><span class="n">group_imb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest_load_per_task</span> <span class="o">=</span>
			<span class="n">min</span><span class="p">(</span><span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest_load_per_task</span><span class="p">,</span> <span class="n">sds</span><span class="o">-&gt;</span><span class="n">avg_load</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * In the presence of smp nice balancing, certain scenarios can have</span>
<span class="cm">	 * max load less than avg load(as we skip the groups at or below</span>
<span class="cm">	 * its cpu_power, while calculating max_load..)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sds</span><span class="o">-&gt;</span><span class="n">max_load</span> <span class="o">&lt;</span> <span class="n">sds</span><span class="o">-&gt;</span><span class="n">avg_load</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">env</span><span class="o">-&gt;</span><span class="n">imbalance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">fix_small_imbalance</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">sds</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sds</span><span class="o">-&gt;</span><span class="n">group_imb</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Don&#39;t want to pull so many tasks that a group would go idle.</span>
<span class="cm">		 */</span>
		<span class="n">load_above_capacity</span> <span class="o">=</span> <span class="p">(</span><span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest_nr_running</span> <span class="o">-</span>
						<span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest_group_capacity</span><span class="p">);</span>

		<span class="n">load_above_capacity</span> <span class="o">*=</span> <span class="p">(</span><span class="n">SCHED_LOAD_SCALE</span> <span class="o">*</span> <span class="n">SCHED_POWER_SCALE</span><span class="p">);</span>

		<span class="n">load_above_capacity</span> <span class="o">/=</span> <span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We&#39;re trying to get all the cpus to the average_load, so we don&#39;t</span>
<span class="cm">	 * want to push ourselves above the average load, nor do we wish to</span>
<span class="cm">	 * reduce the max loaded cpu below the average load. At the same time,</span>
<span class="cm">	 * we also don&#39;t want to reduce the group load below the group capacity</span>
<span class="cm">	 * (so that we can implement power-savings policies etc). Thus we look</span>
<span class="cm">	 * for the minimum possible imbalance.</span>
<span class="cm">	 * Be careful of negative numbers as they&#39;ll appear as very large values</span>
<span class="cm">	 * with unsigned longs.</span>
<span class="cm">	 */</span>
	<span class="n">max_pull</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">sds</span><span class="o">-&gt;</span><span class="n">max_load</span> <span class="o">-</span> <span class="n">sds</span><span class="o">-&gt;</span><span class="n">avg_load</span><span class="p">,</span> <span class="n">load_above_capacity</span><span class="p">);</span>

	<span class="cm">/* How much load to actually move to equalise the imbalance */</span>
	<span class="n">env</span><span class="o">-&gt;</span><span class="n">imbalance</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">max_pull</span> <span class="o">*</span> <span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">,</span>
		<span class="p">(</span><span class="n">sds</span><span class="o">-&gt;</span><span class="n">avg_load</span> <span class="o">-</span> <span class="n">sds</span><span class="o">-&gt;</span><span class="n">this_load</span><span class="p">)</span> <span class="o">*</span> <span class="n">sds</span><span class="o">-&gt;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">)</span>
			<span class="o">/</span> <span class="n">SCHED_POWER_SCALE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * if *imbalance is less than the average load per runnable task</span>
<span class="cm">	 * there is no guarantee that any tasks will be moved so we&#39;ll have</span>
<span class="cm">	 * a think about bumping its value to force at least one task to be</span>
<span class="cm">	 * moved</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">imbalance</span> <span class="o">&lt;</span> <span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest_load_per_task</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">fix_small_imbalance</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">sds</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/******* find_busiest_group() helpers end here *********************/</span>

<span class="cm">/**</span>
<span class="cm"> * find_busiest_group - Returns the busiest group within the sched_domain</span>
<span class="cm"> * if there is an imbalance. If there isn&#39;t an imbalance, and</span>
<span class="cm"> * the user has opted for power-savings, it returns a group whose</span>
<span class="cm"> * CPUs can be put to idle by rebalancing those tasks elsewhere, if</span>
<span class="cm"> * such a group exists.</span>
<span class="cm"> *</span>
<span class="cm"> * Also calculates the amount of weighted load which should be moved</span>
<span class="cm"> * to restore balance.</span>
<span class="cm"> *</span>
<span class="cm"> * @env: The load balancing environment.</span>
<span class="cm"> * @cpus: The set of CPUs under consideration for load-balancing.</span>
<span class="cm"> * @balance: Pointer to a variable indicating if this_cpu</span>
<span class="cm"> *	is the appropriate cpu to perform load balancing at this_level.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:	- the busiest group if imbalance exists.</span>
<span class="cm"> *		- If no imbalance and user has opted for power-savings balance,</span>
<span class="cm"> *		   return the least loaded group whose CPUs can be</span>
<span class="cm"> *		   put to idle by rebalancing its tasks onto our group.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span>
<span class="nf">find_busiest_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">lb_env</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpus</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">balance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sd_lb_stats</span> <span class="n">sds</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sds</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sds</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Compute the various statistics relavent for load balancing at</span>
<span class="cm">	 * this level.</span>
<span class="cm">	 */</span>
	<span class="n">update_sd_lb_stats</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">cpus</span><span class="p">,</span> <span class="n">balance</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sds</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * this_cpu is not the appropriate cpu to perform load balancing at</span>
<span class="cm">	 * this level.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">balance</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">==</span> <span class="n">CPU_IDLE</span> <span class="o">||</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">==</span> <span class="n">CPU_NEWLY_IDLE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">check_asym_packing</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sds</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sds</span><span class="p">.</span><span class="n">busiest</span><span class="p">;</span>

	<span class="cm">/* There is no busy sibling group to pull tasks from */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sds</span><span class="p">.</span><span class="n">busiest</span> <span class="o">||</span> <span class="n">sds</span><span class="p">.</span><span class="n">busiest_nr_running</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_balanced</span><span class="p">;</span>

	<span class="n">sds</span><span class="p">.</span><span class="n">avg_load</span> <span class="o">=</span> <span class="p">(</span><span class="n">SCHED_POWER_SCALE</span> <span class="o">*</span> <span class="n">sds</span><span class="p">.</span><span class="n">total_load</span><span class="p">)</span> <span class="o">/</span> <span class="n">sds</span><span class="p">.</span><span class="n">total_pwr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the busiest group is imbalanced the below checks don&#39;t</span>
<span class="cm">	 * work because they assumes all things are equal, which typically</span>
<span class="cm">	 * isn&#39;t true due to cpus_allowed constraints and the like.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sds</span><span class="p">.</span><span class="n">group_imb</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">force_balance</span><span class="p">;</span>

	<span class="cm">/* SD_BALANCE_NEWIDLE trumps SMP nice when underutilized */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">==</span> <span class="n">CPU_NEWLY_IDLE</span> <span class="o">&amp;&amp;</span> <span class="n">sds</span><span class="p">.</span><span class="n">this_has_capacity</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">sds</span><span class="p">.</span><span class="n">busiest_has_capacity</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">force_balance</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the local group is more busy than the selected busiest group</span>
<span class="cm">	 * don&#39;t try and pull any tasks.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sds</span><span class="p">.</span><span class="n">this_load</span> <span class="o">&gt;=</span> <span class="n">sds</span><span class="p">.</span><span class="n">max_load</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_balanced</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t pull any tasks if this group is already above the domain</span>
<span class="cm">	 * average load.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sds</span><span class="p">.</span><span class="n">this_load</span> <span class="o">&gt;=</span> <span class="n">sds</span><span class="p">.</span><span class="n">avg_load</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_balanced</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">==</span> <span class="n">CPU_IDLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This cpu is idle. If the busiest group load doesn&#39;t</span>
<span class="cm">		 * have more tasks than the number of available cpu&#39;s and</span>
<span class="cm">		 * there is no imbalance between this and busiest group</span>
<span class="cm">		 * wrt to idle cpu&#39;s, it is balanced.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">sds</span><span class="p">.</span><span class="n">this_idle_cpus</span> <span class="o">&lt;=</span> <span class="n">sds</span><span class="p">.</span><span class="n">busiest_idle_cpus</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">sds</span><span class="p">.</span><span class="n">busiest_nr_running</span> <span class="o">&lt;=</span> <span class="n">sds</span><span class="p">.</span><span class="n">busiest_group_weight</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_balanced</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * In the CPU_NEWLY_IDLE, CPU_NOT_IDLE cases, use</span>
<span class="cm">		 * imbalance_pct to be conservative.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="n">sds</span><span class="p">.</span><span class="n">max_load</span> <span class="o">&lt;=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">imbalance_pct</span> <span class="o">*</span> <span class="n">sds</span><span class="p">.</span><span class="n">this_load</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_balanced</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">force_balance:</span>
	<span class="cm">/* Looks like there is an imbalance. Compute it */</span>
	<span class="n">calculate_imbalance</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sds</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sds</span><span class="p">.</span><span class="n">busiest</span><span class="p">;</span>

<span class="nl">out_balanced:</span>
<span class="nl">ret:</span>
	<span class="n">env</span><span class="o">-&gt;</span><span class="n">imbalance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * find_busiest_queue - find the busiest runqueue among the cpus in group.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="nf">find_busiest_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">lb_env</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">group</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">busiest</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_load</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">sched_group_cpus</span><span class="p">(</span><span class="n">group</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">power</span> <span class="o">=</span> <span class="n">power_of</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">capacity</span> <span class="o">=</span> <span class="n">DIV_ROUND_CLOSEST</span><span class="p">(</span><span class="n">power</span><span class="p">,</span>
							   <span class="n">SCHED_POWER_SCALE</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">wl</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capacity</span><span class="p">)</span>
			<span class="n">capacity</span> <span class="o">=</span> <span class="n">fix_small_capacity</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">,</span> <span class="n">group</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">cpus</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="n">wl</span> <span class="o">=</span> <span class="n">weighted_cpuload</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * When comparing with imbalance, use weighted_cpuload()</span>
<span class="cm">		 * which is not scaled with the cpu power.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">capacity</span> <span class="o">&amp;&amp;</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">wl</span> <span class="o">&gt;</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">imbalance</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * For the load comparisons with the other cpu&#39;s, consider</span>
<span class="cm">		 * the weighted_cpuload() scaled with the cpu power, so that</span>
<span class="cm">		 * the load can be moved away from the cpu that is potentially</span>
<span class="cm">		 * running at a lower capacity.</span>
<span class="cm">		 */</span>
		<span class="n">wl</span> <span class="o">=</span> <span class="p">(</span><span class="n">wl</span> <span class="o">*</span> <span class="n">SCHED_POWER_SCALE</span><span class="p">)</span> <span class="o">/</span> <span class="n">power</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">wl</span> <span class="o">&gt;</span> <span class="n">max_load</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">max_load</span> <span class="o">=</span> <span class="n">wl</span><span class="p">;</span>
			<span class="n">busiest</span> <span class="o">=</span> <span class="n">rq</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">busiest</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Max backoff if we encounter pinned tasks. Pretty arbitrary value, but</span>
<span class="cm"> * so long as it is large enough.</span>
<span class="cm"> */</span>
<span class="cp">#define MAX_PINNED_INTERVAL	512</span>

<span class="cm">/* Working cpumask for load_balance and load_balance_newidle. */</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">cpumask_var_t</span><span class="p">,</span> <span class="n">load_balance_tmpmask</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">need_active_balance</span><span class="p">(</span><span class="k">struct</span> <span class="n">lb_env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">==</span> <span class="n">CPU_NEWLY_IDLE</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * ASYM_PACKING needs to force migrate tasks from busy but</span>
<span class="cm">		 * higher numbered CPUs in order to pack all tasks in the</span>
<span class="cm">		 * lowest numbered CPUs.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SD_ASYM_PACKING</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">src_cpu</span> <span class="o">&gt;</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_cpu</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">nr_balance_failed</span> <span class="o">&gt;</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">cache_nice_tries</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">active_load_balance_cpu_stop</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Check this_cpu to ensure it is balanced within domain. Attempt to move</span>
<span class="cm"> * tasks if there is an imbalance.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">load_balance</span><span class="p">(</span><span class="kt">int</span> <span class="n">this_cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">enum</span> <span class="n">cpu_idle_type</span> <span class="n">idle</span><span class="p">,</span>
			<span class="kt">int</span> <span class="o">*</span><span class="n">balance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ld_moved</span><span class="p">,</span> <span class="n">active_balance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">group</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">busiest</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpus</span> <span class="o">=</span> <span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">load_balance_tmpmask</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">lb_env</span> <span class="n">env</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">sd</span>		<span class="o">=</span> <span class="n">sd</span><span class="p">,</span>
		<span class="p">.</span><span class="n">dst_cpu</span>	<span class="o">=</span> <span class="n">this_cpu</span><span class="p">,</span>
		<span class="p">.</span><span class="n">dst_rq</span>		<span class="o">=</span> <span class="n">this_rq</span><span class="p">,</span>
		<span class="p">.</span><span class="n">idle</span>		<span class="o">=</span> <span class="n">idle</span><span class="p">,</span>
		<span class="p">.</span><span class="n">loop_break</span>	<span class="o">=</span> <span class="n">sched_nr_migrate_break</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">cpus</span><span class="p">,</span> <span class="n">cpu_active_mask</span><span class="p">);</span>

	<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">lb_count</span><span class="p">[</span><span class="n">idle</span><span class="p">]);</span>

<span class="nl">redo:</span>
	<span class="n">group</span> <span class="o">=</span> <span class="n">find_busiest_group</span><span class="p">(</span><span class="o">&amp;</span><span class="n">env</span><span class="p">,</span> <span class="n">cpus</span><span class="p">,</span> <span class="n">balance</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">balance</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_balanced</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">group</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">lb_nobusyg</span><span class="p">[</span><span class="n">idle</span><span class="p">]);</span>
		<span class="k">goto</span> <span class="n">out_balanced</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">busiest</span> <span class="o">=</span> <span class="n">find_busiest_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">env</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">cpus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">busiest</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">lb_nobusyq</span><span class="p">[</span><span class="n">idle</span><span class="p">]);</span>
		<span class="k">goto</span> <span class="n">out_balanced</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">busiest</span> <span class="o">==</span> <span class="n">this_rq</span><span class="p">);</span>

	<span class="n">schedstat_add</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">lb_imbalance</span><span class="p">[</span><span class="n">idle</span><span class="p">],</span> <span class="n">env</span><span class="p">.</span><span class="n">imbalance</span><span class="p">);</span>

	<span class="n">ld_moved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Attempt to move tasks. If find_busiest_group has found</span>
<span class="cm">		 * an imbalance but busiest-&gt;nr_running &lt;= 1, the group is</span>
<span class="cm">		 * still unbalanced. ld_moved simply stays zero, so it is</span>
<span class="cm">		 * correctly treated as an imbalance.</span>
<span class="cm">		 */</span>
		<span class="n">env</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">LBF_ALL_PINNED</span><span class="p">;</span>
		<span class="n">env</span><span class="p">.</span><span class="n">src_cpu</span>   <span class="o">=</span> <span class="n">busiest</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">;</span>
		<span class="n">env</span><span class="p">.</span><span class="n">src_rq</span>    <span class="o">=</span> <span class="n">busiest</span><span class="p">;</span>
		<span class="n">env</span><span class="p">.</span><span class="n">loop_max</span>  <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">sysctl_sched_nr_migrate</span><span class="p">,</span> <span class="n">busiest</span><span class="o">-&gt;</span><span class="n">nr_running</span><span class="p">);</span>

<span class="nl">more_balance:</span>
		<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">double_rq_lock</span><span class="p">(</span><span class="n">this_rq</span><span class="p">,</span> <span class="n">busiest</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">env</span><span class="p">.</span><span class="n">loop</span><span class="p">)</span>
			<span class="n">update_h_load</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">src_cpu</span><span class="p">);</span>
		<span class="n">ld_moved</span> <span class="o">+=</span> <span class="n">move_tasks</span><span class="p">(</span><span class="o">&amp;</span><span class="n">env</span><span class="p">);</span>
		<span class="n">double_rq_unlock</span><span class="p">(</span><span class="n">this_rq</span><span class="p">,</span> <span class="n">busiest</span><span class="p">);</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LBF_NEED_BREAK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">env</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LBF_NEED_BREAK</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">more_balance</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * some other cpu did the load balance for us.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ld_moved</span> <span class="o">&amp;&amp;</span> <span class="n">this_cpu</span> <span class="o">!=</span> <span class="n">smp_processor_id</span><span class="p">())</span>
			<span class="n">resched_cpu</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">);</span>

		<span class="cm">/* All tasks on this runqueue were pinned by CPU affinity */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LBF_ALL_PINNED</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu_of</span><span class="p">(</span><span class="n">busiest</span><span class="p">),</span> <span class="n">cpus</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="n">cpus</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">redo</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_balanced</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ld_moved</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">lb_failed</span><span class="p">[</span><span class="n">idle</span><span class="p">]);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Increment the failure counter only on periodic balance.</span>
<span class="cm">		 * We do not want newidle balance, which can be very</span>
<span class="cm">		 * frequent, pollute the failure counter causing</span>
<span class="cm">		 * excessive cache_hot migrations and active balances.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">idle</span> <span class="o">!=</span> <span class="n">CPU_NEWLY_IDLE</span><span class="p">)</span>
			<span class="n">sd</span><span class="o">-&gt;</span><span class="n">nr_balance_failed</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">need_active_balance</span><span class="p">(</span><span class="o">&amp;</span><span class="n">env</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

			<span class="cm">/* don&#39;t kick the active_load_balance_cpu_stop,</span>
<span class="cm">			 * if the curr task on busiest cpu can&#39;t be</span>
<span class="cm">			 * moved to this_cpu</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">,</span>
					<span class="n">tsk_cpus_allowed</span><span class="p">(</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span>
							    <span class="n">flags</span><span class="p">);</span>
				<span class="n">env</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">LBF_ALL_PINNED</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out_one_pinned</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * -&gt;active_balance synchronizes accesses to</span>
<span class="cm">			 * -&gt;active_balance_work.  Once set, it&#39;s cleared</span>
<span class="cm">			 * only after active load balance is finished.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">active_balance</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">busiest</span><span class="o">-&gt;</span><span class="n">active_balance</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">busiest</span><span class="o">-&gt;</span><span class="n">push_cpu</span> <span class="o">=</span> <span class="n">this_cpu</span><span class="p">;</span>
				<span class="n">active_balance</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">active_balance</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">stop_one_cpu_nowait</span><span class="p">(</span><span class="n">cpu_of</span><span class="p">(</span><span class="n">busiest</span><span class="p">),</span>
					<span class="n">active_load_balance_cpu_stop</span><span class="p">,</span> <span class="n">busiest</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">active_balance_work</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * We&#39;ve kicked active balancing, reset the failure</span>
<span class="cm">			 * counter.</span>
<span class="cm">			 */</span>
			<span class="n">sd</span><span class="o">-&gt;</span><span class="n">nr_balance_failed</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">cache_nice_tries</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">sd</span><span class="o">-&gt;</span><span class="n">nr_balance_failed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">active_balance</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* We were unbalanced, so reset the balancing interval */</span>
		<span class="n">sd</span><span class="o">-&gt;</span><span class="n">balance_interval</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">min_interval</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we&#39;ve begun active balancing, start to back off. This</span>
<span class="cm">		 * case may not be covered by the all_pinned logic if there</span>
<span class="cm">		 * is only 1 task on the busy runqueue (because we don&#39;t call</span>
<span class="cm">		 * move_tasks).</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">balance_interval</span> <span class="o">&lt;</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">max_interval</span><span class="p">)</span>
			<span class="n">sd</span><span class="o">-&gt;</span><span class="n">balance_interval</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">out_balanced:</span>
	<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">lb_balanced</span><span class="p">[</span><span class="n">idle</span><span class="p">]);</span>

	<span class="n">sd</span><span class="o">-&gt;</span><span class="n">nr_balance_failed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_one_pinned:</span>
	<span class="cm">/* tune up the balancing interval */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">env</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LBF_ALL_PINNED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">sd</span><span class="o">-&gt;</span><span class="n">balance_interval</span> <span class="o">&lt;</span> <span class="n">MAX_PINNED_INTERVAL</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">balance_interval</span> <span class="o">&lt;</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">max_interval</span><span class="p">))</span>
		<span class="n">sd</span><span class="o">-&gt;</span><span class="n">balance_interval</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">ld_moved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ld_moved</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * idle_balance is called by schedule() if this_cpu is about to become</span>
<span class="cm"> * idle. Attempts to pull tasks from other CPUs.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">idle_balance</span><span class="p">(</span><span class="kt">int</span> <span class="n">this_cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pulled_task</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next_balance</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="p">;</span>

	<span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">idle_stamp</span> <span class="o">=</span> <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">avg_idle</span> <span class="o">&lt;</span> <span class="n">sysctl_sched_migration_cost</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Drop the rq-&gt;lock, but keep IRQ/preempt disabled.</span>
<span class="cm">	 */</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">update_shares</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">);</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">for_each_domain</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">,</span> <span class="n">sd</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">interval</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">balance</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SD_LOAD_BALANCE</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SD_BALANCE_NEWIDLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* If we&#39;ve pulled tasks over stop searching: */</span>
			<span class="n">pulled_task</span> <span class="o">=</span> <span class="n">load_balance</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">,</span> <span class="n">this_rq</span><span class="p">,</span>
						   <span class="n">sd</span><span class="p">,</span> <span class="n">CPU_NEWLY_IDLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">balance</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">interval</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">balance_interval</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">next_balance</span><span class="p">,</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">last_balance</span> <span class="o">+</span> <span class="n">interval</span><span class="p">))</span>
			<span class="n">next_balance</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">last_balance</span> <span class="o">+</span> <span class="n">interval</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pulled_task</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">idle_stamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pulled_task</span> <span class="o">||</span> <span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">next_balance</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We are going idle. next_balance may be set based on</span>
<span class="cm">		 * a busy processor. So reset next_balance.</span>
<span class="cm">		 */</span>
		<span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">next_balance</span> <span class="o">=</span> <span class="n">next_balance</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * active_load_balance_cpu_stop is run by cpu stopper. It pushes</span>
<span class="cm"> * running tasks off the busiest CPU onto idle CPUs. It requires at</span>
<span class="cm"> * least 1 task to be running on each physical CPU where possible, and</span>
<span class="cm"> * avoids physical / logical imbalances.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">active_load_balance_cpu_stop</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">busiest_rq</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">busiest_cpu</span> <span class="o">=</span> <span class="n">cpu_of</span><span class="p">(</span><span class="n">busiest_rq</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">target_cpu</span> <span class="o">=</span> <span class="n">busiest_rq</span><span class="o">-&gt;</span><span class="n">push_cpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">target_rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">target_cpu</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">busiest_rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* make sure the requested cpu hasn&#39;t gone down in the meantime */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">busiest_cpu</span> <span class="o">!=</span> <span class="n">smp_processor_id</span><span class="p">()</span> <span class="o">||</span>
		     <span class="o">!</span><span class="n">busiest_rq</span><span class="o">-&gt;</span><span class="n">active_balance</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="cm">/* Is there any task to move? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">busiest_rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This condition is &quot;impossible&quot;, if it occurs</span>
<span class="cm">	 * we need to fix it. Originally reported by</span>
<span class="cm">	 * Bjorn Helgaas on a 128-cpu setup.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">busiest_rq</span> <span class="o">==</span> <span class="n">target_rq</span><span class="p">);</span>

	<span class="cm">/* move a task from busiest_rq to target_rq */</span>
	<span class="n">double_lock_balance</span><span class="p">(</span><span class="n">busiest_rq</span><span class="p">,</span> <span class="n">target_rq</span><span class="p">);</span>

	<span class="cm">/* Search for an sd spanning us and the target CPU. */</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">for_each_domain</span><span class="p">(</span><span class="n">target_cpu</span><span class="p">,</span> <span class="n">sd</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SD_LOAD_BALANCE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">busiest_cpu</span><span class="p">,</span> <span class="n">sched_domain_span</span><span class="p">(</span><span class="n">sd</span><span class="p">)))</span>
				<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">sd</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">lb_env</span> <span class="n">env</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">sd</span>		<span class="o">=</span> <span class="n">sd</span><span class="p">,</span>
			<span class="p">.</span><span class="n">dst_cpu</span>	<span class="o">=</span> <span class="n">target_cpu</span><span class="p">,</span>
			<span class="p">.</span><span class="n">dst_rq</span>		<span class="o">=</span> <span class="n">target_rq</span><span class="p">,</span>
			<span class="p">.</span><span class="n">src_cpu</span>	<span class="o">=</span> <span class="n">busiest_rq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span>
			<span class="p">.</span><span class="n">src_rq</span>		<span class="o">=</span> <span class="n">busiest_rq</span><span class="p">,</span>
			<span class="p">.</span><span class="n">idle</span>		<span class="o">=</span> <span class="n">CPU_IDLE</span><span class="p">,</span>
		<span class="p">};</span>

		<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">alb_count</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">move_one_task</span><span class="p">(</span><span class="o">&amp;</span><span class="n">env</span><span class="p">))</span>
			<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">alb_pushed</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">alb_failed</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="n">double_unlock_balance</span><span class="p">(</span><span class="n">busiest_rq</span><span class="p">,</span> <span class="n">target_rq</span><span class="p">);</span>
<span class="nl">out_unlock:</span>
	<span class="n">busiest_rq</span><span class="o">-&gt;</span><span class="n">active_balance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">busiest_rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NO_HZ</span>
<span class="cm">/*</span>
<span class="cm"> * idle load balancing details</span>
<span class="cm"> * - When one of the busy CPUs notice that there may be an idle rebalancing</span>
<span class="cm"> *   needed, they will kick the idle load balancer, which then does idle</span>
<span class="cm"> *   load balancing for all the idle CPUs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">cpumask_var_t</span> <span class="n">idle_cpus_mask</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">nr_cpus</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next_balance</span><span class="p">;</span>     <span class="cm">/* in jiffy units */</span>
<span class="p">}</span> <span class="n">nohz</span> <span class="n">____cacheline_aligned</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">find_new_ilb</span><span class="p">(</span><span class="kt">int</span> <span class="n">call_cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ilb</span> <span class="o">=</span> <span class="n">cpumask_first</span><span class="p">(</span><span class="n">nohz</span><span class="p">.</span><span class="n">idle_cpus_mask</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ilb</span> <span class="o">&lt;</span> <span class="n">nr_cpu_ids</span> <span class="o">&amp;&amp;</span> <span class="n">idle_cpu</span><span class="p">(</span><span class="n">ilb</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ilb</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">nr_cpu_ids</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Kick a CPU to do the nohz balancing, if it is time for it. We pick the</span>
<span class="cm"> * nohz_load_balancer CPU (if there is one) otherwise fallback to any idle</span>
<span class="cm"> * CPU (if there is one).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nohz_balancer_kick</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ilb_cpu</span><span class="p">;</span>

	<span class="n">nohz</span><span class="p">.</span><span class="n">next_balance</span><span class="o">++</span><span class="p">;</span>

	<span class="n">ilb_cpu</span> <span class="o">=</span> <span class="n">find_new_ilb</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ilb_cpu</span> <span class="o">&gt;=</span> <span class="n">nr_cpu_ids</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">NOHZ_BALANCE_KICK</span><span class="p">,</span> <span class="n">nohz_flags</span><span class="p">(</span><span class="n">ilb_cpu</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Use smp_send_reschedule() instead of resched_cpu().</span>
<span class="cm">	 * This way we generate a sched IPI on the target cpu which</span>
<span class="cm">	 * is idle. And the softirq performing nohz idle load balance</span>
<span class="cm">	 * will be run before returning from the IPI.</span>
<span class="cm">	 */</span>
	<span class="n">smp_send_reschedule</span><span class="p">(</span><span class="n">ilb_cpu</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clear_nohz_tick_stopped</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NOHZ_TICK_STOPPED</span><span class="p">,</span> <span class="n">nohz_flags</span><span class="p">(</span><span class="n">cpu</span><span class="p">))))</span> <span class="p">{</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">nohz</span><span class="p">.</span><span class="n">idle_cpus_mask</span><span class="p">);</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nohz</span><span class="p">.</span><span class="n">nr_cpus</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">NOHZ_TICK_STOPPED</span><span class="p">,</span> <span class="n">nohz_flags</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_cpu_sd_state_busy</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NOHZ_IDLE</span><span class="p">,</span> <span class="n">nohz_flags</span><span class="p">(</span><span class="n">cpu</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">NOHZ_IDLE</span><span class="p">,</span> <span class="n">nohz_flags</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">for_each_domain</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">sd</span><span class="p">)</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">groups</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">nr_busy_cpus</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">set_cpu_sd_state_idle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NOHZ_IDLE</span><span class="p">,</span> <span class="n">nohz_flags</span><span class="p">(</span><span class="n">cpu</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">NOHZ_IDLE</span><span class="p">,</span> <span class="n">nohz_flags</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">for_each_domain</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">sd</span><span class="p">)</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">groups</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">nr_busy_cpus</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This routine will record that this cpu is going idle with tick stopped.</span>
<span class="cm"> * This info will be used in performing idle load balancing in the future.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">select_nohz_load_balancer</span><span class="p">(</span><span class="kt">int</span> <span class="n">stop_tick</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this cpu is going down, then nothing needs to be done.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_active</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stop_tick</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NOHZ_TICK_STOPPED</span><span class="p">,</span> <span class="n">nohz_flags</span><span class="p">(</span><span class="n">cpu</span><span class="p">)))</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">nohz</span><span class="p">.</span><span class="n">idle_cpus_mask</span><span class="p">);</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nohz</span><span class="p">.</span><span class="n">nr_cpus</span><span class="p">);</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">NOHZ_TICK_STOPPED</span><span class="p">,</span> <span class="n">nohz_flags</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">sched_ilb_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nfb</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CPU_TASKS_FROZEN</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_DYING</span>:
		<span class="n">clear_nohz_tick_stopped</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">());</span>
		<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">balancing</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Scale the max load_balance interval with the number of CPUs in the system.</span>
<span class="cm"> * This trades load-balance latency on larger machines for less cross talk.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">update_max_interval</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">max_load_balance_interval</span> <span class="o">=</span> <span class="n">HZ</span><span class="o">*</span><span class="n">num_online_cpus</span><span class="p">()</span><span class="o">/</span><span class="mi">10</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * It checks each scheduling domain to see if it is due to be balanced,</span>
<span class="cm"> * and initiates a balancing operation if so.</span>
<span class="cm"> *</span>
<span class="cm"> * Balancing parameters are set up in arch_init_sched_domains.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rebalance_domains</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">enum</span> <span class="n">cpu_idle_type</span> <span class="n">idle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">balance</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">interval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>
	<span class="cm">/* Earliest time when we have to do rebalance again */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next_balance</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">60</span><span class="o">*</span><span class="n">HZ</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">update_next_balance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">need_serialize</span><span class="p">;</span>

	<span class="n">update_shares</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">for_each_domain</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">sd</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SD_LOAD_BALANCE</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">interval</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">balance_interval</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">idle</span> <span class="o">!=</span> <span class="n">CPU_IDLE</span><span class="p">)</span>
			<span class="n">interval</span> <span class="o">*=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">busy_factor</span><span class="p">;</span>

		<span class="cm">/* scale ms to jiffies */</span>
		<span class="n">interval</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">interval</span><span class="p">);</span>
		<span class="n">interval</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="mi">1UL</span><span class="p">,</span> <span class="n">max_load_balance_interval</span><span class="p">);</span>

		<span class="n">need_serialize</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SD_SERIALIZE</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">need_serialize</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spin_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">balancing</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">time_after_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">last_balance</span> <span class="o">+</span> <span class="n">interval</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">load_balance</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">rq</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="n">idle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">balance</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * We&#39;ve pulled tasks over so either we&#39;re no</span>
<span class="cm">				 * longer idle.</span>
<span class="cm">				 */</span>
				<span class="n">idle</span> <span class="o">=</span> <span class="n">CPU_NOT_IDLE</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">sd</span><span class="o">-&gt;</span><span class="n">last_balance</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">need_serialize</span><span class="p">)</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">balancing</span><span class="p">);</span>
<span class="nl">out:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">next_balance</span><span class="p">,</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">last_balance</span> <span class="o">+</span> <span class="n">interval</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">next_balance</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">last_balance</span> <span class="o">+</span> <span class="n">interval</span><span class="p">;</span>
			<span class="n">update_next_balance</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Stop the load balance at this level. There is another</span>
<span class="cm">		 * CPU in our sched group which is doing load balancing more</span>
<span class="cm">		 * actively.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">balance</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * next_balance will be updated only when there is a need.</span>
<span class="cm">	 * When the cpu is attached to null domain for ex, it will not be</span>
<span class="cm">	 * updated.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">update_next_balance</span><span class="p">))</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">next_balance</span> <span class="o">=</span> <span class="n">next_balance</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NO_HZ</span>
<span class="cm">/*</span>
<span class="cm"> * In CONFIG_NO_HZ case, the idle balance kickee will do the</span>
<span class="cm"> * rebalancing for all the cpus for whom scheduler ticks are stopped.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nohz_idle_balance</span><span class="p">(</span><span class="kt">int</span> <span class="n">this_cpu</span><span class="p">,</span> <span class="k">enum</span> <span class="n">cpu_idle_type</span> <span class="n">idle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">balance_cpu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">idle</span> <span class="o">!=</span> <span class="n">CPU_IDLE</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NOHZ_BALANCE_KICK</span><span class="p">,</span> <span class="n">nohz_flags</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">end</span><span class="p">;</span>

	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">balance_cpu</span><span class="p">,</span> <span class="n">nohz</span><span class="p">.</span><span class="n">idle_cpus_mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">balance_cpu</span> <span class="o">==</span> <span class="n">this_cpu</span> <span class="o">||</span> <span class="o">!</span><span class="n">idle_cpu</span><span class="p">(</span><span class="n">balance_cpu</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If this cpu gets work to do, stop the load balancing</span>
<span class="cm">		 * work being done for other cpus. Next load</span>
<span class="cm">		 * balancing owner will pick it up.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">need_resched</span><span class="p">())</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">this_rq</span><span class="p">);</span>
		<span class="n">update_idle_cpu_load</span><span class="p">(</span><span class="n">this_rq</span><span class="p">);</span>
		<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">rebalance_domains</span><span class="p">(</span><span class="n">balance_cpu</span><span class="p">,</span> <span class="n">CPU_IDLE</span><span class="p">);</span>

		<span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">balance_cpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">next_balance</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">next_balance</span><span class="p">))</span>
			<span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">next_balance</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">next_balance</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">nohz</span><span class="p">.</span><span class="n">next_balance</span> <span class="o">=</span> <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">next_balance</span><span class="p">;</span>
<span class="nl">end:</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">NOHZ_BALANCE_KICK</span><span class="p">,</span> <span class="n">nohz_flags</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Current heuristic for kicking the idle load balancer in the presence</span>
<span class="cm"> * of an idle cpu is the system.</span>
<span class="cm"> *   - This rq has more than one task.</span>
<span class="cm"> *   - At any scheduler domain level, this cpu&#39;s scheduler group has multiple</span>
<span class="cm"> *     busy cpu&#39;s exceeding the group&#39;s power.</span>
<span class="cm"> *   - For SD_ASYM_PACKING, if the lower numbered cpu&#39;s in the scheduler</span>
<span class="cm"> *     domain span are idle.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nohz_kick_needed</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">idle_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

       <span class="cm">/*</span>
<span class="cm">	* We may be recently in ticked or tickless idle mode. At the first</span>
<span class="cm">	* busy tick after returning from idle, we will update the busy stats.</span>
<span class="cm">	*/</span>
	<span class="n">set_cpu_sd_state_busy</span><span class="p">();</span>
	<span class="n">clear_nohz_tick_stopped</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * None are in tickless mode and hence no need for NOHZ idle load</span>
<span class="cm">	 * balancing.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nohz</span><span class="p">.</span><span class="n">nr_cpus</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">nohz</span><span class="p">.</span><span class="n">next_balance</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">need_kick</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">for_each_domain</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">sd</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">sg</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sched_group_power</span> <span class="o">*</span><span class="n">sgp</span> <span class="o">=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">nr_busy</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">nr_busy_cpus</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SD_SHARE_PKG_RESOURCES</span> <span class="o">&amp;&amp;</span> <span class="n">nr_busy</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">need_kick_unlock</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SD_ASYM_PACKING</span> <span class="o">&amp;&amp;</span> <span class="n">nr_busy</span> <span class="o">!=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">group_weight</span>
		    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cpumask_first_and</span><span class="p">(</span><span class="n">nohz</span><span class="p">.</span><span class="n">idle_cpus_mask</span><span class="p">,</span>
					  <span class="n">sched_domain_span</span><span class="p">(</span><span class="n">sd</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">cpu</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">need_kick_unlock</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SD_SHARE_PKG_RESOURCES</span> <span class="o">|</span> <span class="n">SD_ASYM_PACKING</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">need_kick_unlock:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="nl">need_kick:</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nohz_idle_balance</span><span class="p">(</span><span class="kt">int</span> <span class="n">this_cpu</span><span class="p">,</span> <span class="k">enum</span> <span class="n">cpu_idle_type</span> <span class="n">idle</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * run_rebalance_domains is triggered when needed from the scheduler tick.</span>
<span class="cm"> * Also triggered for nohz idle balancing (with nohz_balancing_kick set).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">run_rebalance_domains</span><span class="p">(</span><span class="k">struct</span> <span class="n">softirq_action</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">this_cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">);</span>
	<span class="k">enum</span> <span class="n">cpu_idle_type</span> <span class="n">idle</span> <span class="o">=</span> <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">idle_balance</span> <span class="o">?</span>
						<span class="n">CPU_IDLE</span> <span class="o">:</span> <span class="n">CPU_NOT_IDLE</span><span class="p">;</span>

	<span class="n">rebalance_domains</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">,</span> <span class="n">idle</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this cpu has a pending nohz_balance_kick, then do the</span>
<span class="cm">	 * balancing on behalf of the other idle cpus whose ticks are</span>
<span class="cm">	 * stopped.</span>
<span class="cm">	 */</span>
	<span class="n">nohz_idle_balance</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">,</span> <span class="n">idle</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">on_null_domain</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">rcu_dereference_sched</span><span class="p">(</span><span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Trigger the SCHED_SOFTIRQ if it is time to do periodic load balancing.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">trigger_load_balance</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Don&#39;t need to rebalance while attached to NULL domain */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">time_after_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">next_balance</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">on_null_domain</span><span class="p">(</span><span class="n">cpu</span><span class="p">)))</span>
		<span class="n">raise_softirq</span><span class="p">(</span><span class="n">SCHED_SOFTIRQ</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_NO_HZ</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nohz_kick_needed</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">on_null_domain</span><span class="p">(</span><span class="n">cpu</span><span class="p">)))</span>
		<span class="n">nohz_balancer_kick</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rq_online_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">update_sysctl</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rq_offline_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">update_sysctl</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * scheduler tick hitting a task of our scheduling class:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">task_tick_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">queued</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">;</span>

	<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
		<span class="n">entity_tick</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="n">queued</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * called on fork with the child task as argument from the parent&#39;s context</span>
<span class="cm"> *  - child not yet on the tasklist</span>
<span class="cm"> *  - preemption disabled</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">task_fork_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">,</span> <span class="o">*</span><span class="n">curr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">this_cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">this_rq</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>

	<span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">task_cfs_rq</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">curr</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">!=</span> <span class="n">this_cpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rcu_read_lock</span><span class="p">();</span>
		<span class="n">__set_task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">this_cpu</span><span class="p">);</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">update_curr</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="p">)</span>
		<span class="n">se</span><span class="o">-&gt;</span><span class="n">vruntime</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">vruntime</span><span class="p">;</span>
	<span class="n">place_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_sched_child_runs_first</span> <span class="o">&amp;&amp;</span> <span class="n">curr</span> <span class="o">&amp;&amp;</span> <span class="n">entity_before</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">se</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Upon rescheduling, sched_class::put_prev_task() will place</span>
<span class="cm">		 * &#39;current&#39; within the tree based on its new key value.</span>
<span class="cm">		 */</span>
		<span class="n">swap</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">vruntime</span><span class="p">,</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">vruntime</span><span class="p">);</span>
		<span class="n">resched_task</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">se</span><span class="o">-&gt;</span><span class="n">vruntime</span> <span class="o">-=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">min_vruntime</span><span class="p">;</span>

	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Priority of the task has changed. Check to see if we preempt</span>
<span class="cm"> * the current task.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">prio_changed_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oldprio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">on_rq</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reschedule if we are currently running on this runqueue and</span>
<span class="cm">	 * our priority decreased, or if we are not currently running on</span>
<span class="cm">	 * this runqueue and our priority is higher than the current&#39;s</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span> <span class="o">==</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">&gt;</span> <span class="n">oldprio</span><span class="p">)</span>
			<span class="n">resched_task</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">check_preempt_curr</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">switched_from_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ensure the task&#39;s vruntime is normalized, so that when its</span>
<span class="cm">	 * switched back to the fair class the enqueue_entity(.flags=0) will</span>
<span class="cm">	 * do the right thing.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If it was on_rq, then the dequeue_entity(.flags=0) will already</span>
<span class="cm">	 * have normalized the vruntime, if it was !on_rq, then only when</span>
<span class="cm">	 * the task is sleeping will it still have non-normalized vruntime.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">on_rq</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">TASK_RUNNING</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Fix up our vruntime so that the current sleep doesn&#39;t</span>
<span class="cm">		 * cause &#39;unlimited&#39; sleep bonus.</span>
<span class="cm">		 */</span>
		<span class="n">place_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">se</span><span class="o">-&gt;</span><span class="n">vruntime</span> <span class="o">-=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">min_vruntime</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We switched to the sched_fair class.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">switched_to_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">on_rq</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We were most likely switched from sched_rt, so</span>
<span class="cm">	 * kick off the schedule if running, otherwise just see</span>
<span class="cm">	 * if we can still preempt the current task.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span> <span class="o">==</span> <span class="n">p</span><span class="p">)</span>
		<span class="n">resched_task</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">check_preempt_curr</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Account for a task changing its policy or group.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is mostly called to set cfs_rq-&gt;curr field when a task</span>
<span class="cm"> * migrates between groups/classes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_curr_task_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">;</span>

	<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>

		<span class="n">set_next_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
		<span class="cm">/* ensure bandwidth has been allocated on our new cfs_rq */</span>
		<span class="n">account_cfs_rq_runtime</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">init_cfs_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tasks_timeline</span> <span class="o">=</span> <span class="n">RB_ROOT</span><span class="p">;</span>
	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">min_vruntime</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)(</span><span class="o">-</span><span class="p">(</span><span class="mi">1LL</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">));</span>
<span class="cp">#ifndef CONFIG_64BIT</span>
	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">min_vruntime_copy</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">min_vruntime</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_FAIR_GROUP_SCHED</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">task_move_group_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the task was not on the rq at the time of this cgroup movement</span>
<span class="cm">	 * it must have been asleep, sleeping tasks keep their -&gt;vruntime</span>
<span class="cm">	 * absolute on their old rq until wakeup (needed for the fair sleeper</span>
<span class="cm">	 * bonus in place_entity()).</span>
<span class="cm">	 *</span>
<span class="cm">	 * If it was on the rq, we&#39;ve just &#39;preempted&#39; it, which does convert</span>
<span class="cm">	 * -&gt;vruntime to a relative base.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Make sure both cases convert their relative position when migrating</span>
<span class="cm">	 * to another cgroup&#39;s rq. This does somewhat interfere with the</span>
<span class="cm">	 * fair sleeper stuff for the first placement, but who cares.</span>
<span class="cm">	 */</span>
	<span class="cm">/*</span>
<span class="cm">	 * When !on_rq, vruntime of the task has usually NOT been normalized.</span>
<span class="cm">	 * But there are some cases where it has already been normalized:</span>
<span class="cm">	 *</span>
<span class="cm">	 * - Moving a forked child which is waiting for being woken up by</span>
<span class="cm">	 *   wake_up_new_task().</span>
<span class="cm">	 * - Moving a task which has been woken up by try_to_wake_up() and</span>
<span class="cm">	 *   waiting for actually being woken up by sched_ttwu_pending().</span>
<span class="cm">	 *</span>
<span class="cm">	 * To prevent boost or penalty in the new cfs_rq caused by delta</span>
<span class="cm">	 * min_vruntime between the two cfs_rqs, we skip vruntime adjustment.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">on_rq</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">sum_exec_runtime</span> <span class="o">||</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">TASK_WAKING</span><span class="p">))</span>
		<span class="n">on_rq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">on_rq</span><span class="p">)</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">vruntime</span> <span class="o">-=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">min_vruntime</span><span class="p">;</span>
	<span class="n">set_task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">on_rq</span><span class="p">)</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">vruntime</span> <span class="o">+=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">min_vruntime</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">free_fair_sched_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">destroy_cfs_bandwidth</span><span class="p">(</span><span class="n">tg_cfs_bandwidth</span><span class="p">(</span><span class="n">tg</span><span class="p">));</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">)</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">)</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">alloc_fair_sched_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)</span> <span class="o">*</span> <span class="n">nr_cpu_ids</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">tg</span><span class="o">-&gt;</span><span class="n">se</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="o">*</span> <span class="n">nr_cpu_ids</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">tg</span><span class="o">-&gt;</span><span class="n">shares</span> <span class="o">=</span> <span class="n">NICE_0_LOAD</span><span class="p">;</span>

	<span class="n">init_cfs_bandwidth</span><span class="p">(</span><span class="n">tg_cfs_bandwidth</span><span class="p">(</span><span class="n">tg</span><span class="p">));</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">kzalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span><span class="p">),</span>
				      <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfs_rq</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">se</span> <span class="o">=</span> <span class="n">kzalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span><span class="p">),</span>
				  <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">se</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_free_rq</span><span class="p">;</span>

		<span class="n">init_cfs_rq</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
		<span class="n">init_tg_cfs_entry</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">err_free_rq:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="nl">err:</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">unregister_fair_sched_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	* Only empty task groups can be destroyed; so we can speculatively</span>
<span class="cm">	* check on_list without danger of it being re-added.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">on_list</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_del_leaf_cfs_rq</span><span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">[</span><span class="n">cpu</span><span class="p">]);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">init_tg_cfs_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tg</span> <span class="o">=</span> <span class="n">tg</span><span class="p">;</span>
	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">rq</span> <span class="o">=</span> <span class="n">rq</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="cm">/* allow initial update_cfs_load() to truncate */</span>
	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load_stamp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">init_cfs_rq_runtime</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>

	<span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="p">;</span>
	<span class="n">tg</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">se</span><span class="p">;</span>

	<span class="cm">/* se could be NULL for root_task_group */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">se</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">se</span><span class="o">-&gt;</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">se</span><span class="o">-&gt;</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">my_q</span><span class="p">;</span>

	<span class="n">se</span><span class="o">-&gt;</span><span class="n">my_q</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="p">;</span>
	<span class="n">update_load_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">se</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">shares_mutex</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sched_group_set_shares</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">shares</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We can&#39;t change the weight of the root cgroup.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">shares</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">(</span><span class="n">shares</span><span class="p">,</span> <span class="n">scale_load</span><span class="p">(</span><span class="n">MIN_SHARES</span><span class="p">),</span> <span class="n">scale_load</span><span class="p">(</span><span class="n">MAX_SHARES</span><span class="p">));</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shares_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">shares</span> <span class="o">==</span> <span class="n">shares</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">tg</span><span class="o">-&gt;</span><span class="n">shares</span> <span class="o">=</span> <span class="n">shares</span><span class="p">;</span>
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">;</span>

		<span class="n">se</span> <span class="o">=</span> <span class="n">tg</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="cm">/* Propagate contribution to hierarchy */</span>
		<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span>
			<span class="n">update_cfs_shares</span><span class="p">(</span><span class="n">group_cfs_rq</span><span class="p">(</span><span class="n">se</span><span class="p">));</span>
		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">done:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shares_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_FAIR_GROUP_SCHED */</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">free_fair_sched_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="kt">int</span> <span class="nf">alloc_fair_sched_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">unregister_fair_sched_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_FAIR_GROUP_SCHED */</span><span class="cp"></span>


<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">get_rr_interval_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rr_interval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Time slice is 0 for SCHED_OTHER tasks that are on an otherwise</span>
<span class="cm">	 * idle runqueue:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">.</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">)</span>
		<span class="n">rr_interval</span> <span class="o">=</span> <span class="n">NS_TO_JIFFIES</span><span class="p">(</span><span class="n">sched_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">,</span> <span class="n">se</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">rr_interval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * All the scheduling class methods:</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">sched_class</span> <span class="n">fair_sched_class</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">next</span>			<span class="o">=</span> <span class="o">&amp;</span><span class="n">idle_sched_class</span><span class="p">,</span>
	<span class="p">.</span><span class="n">enqueue_task</span>		<span class="o">=</span> <span class="n">enqueue_task_fair</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dequeue_task</span>		<span class="o">=</span> <span class="n">dequeue_task_fair</span><span class="p">,</span>
	<span class="p">.</span><span class="n">yield_task</span>		<span class="o">=</span> <span class="n">yield_task_fair</span><span class="p">,</span>
	<span class="p">.</span><span class="n">yield_to_task</span>		<span class="o">=</span> <span class="n">yield_to_task_fair</span><span class="p">,</span>

	<span class="p">.</span><span class="n">check_preempt_curr</span>	<span class="o">=</span> <span class="n">check_preempt_wakeup</span><span class="p">,</span>

	<span class="p">.</span><span class="n">pick_next_task</span>		<span class="o">=</span> <span class="n">pick_next_task_fair</span><span class="p">,</span>
	<span class="p">.</span><span class="n">put_prev_task</span>		<span class="o">=</span> <span class="n">put_prev_task_fair</span><span class="p">,</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="p">.</span><span class="n">select_task_rq</span>		<span class="o">=</span> <span class="n">select_task_rq_fair</span><span class="p">,</span>

	<span class="p">.</span><span class="n">rq_online</span>		<span class="o">=</span> <span class="n">rq_online_fair</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rq_offline</span>		<span class="o">=</span> <span class="n">rq_offline_fair</span><span class="p">,</span>

	<span class="p">.</span><span class="n">task_waking</span>		<span class="o">=</span> <span class="n">task_waking_fair</span><span class="p">,</span>
<span class="cp">#endif</span>

	<span class="p">.</span><span class="n">set_curr_task</span>          <span class="o">=</span> <span class="n">set_curr_task_fair</span><span class="p">,</span>
	<span class="p">.</span><span class="n">task_tick</span>		<span class="o">=</span> <span class="n">task_tick_fair</span><span class="p">,</span>
	<span class="p">.</span><span class="n">task_fork</span>		<span class="o">=</span> <span class="n">task_fork_fair</span><span class="p">,</span>

	<span class="p">.</span><span class="n">prio_changed</span>		<span class="o">=</span> <span class="n">prio_changed_fair</span><span class="p">,</span>
	<span class="p">.</span><span class="n">switched_from</span>		<span class="o">=</span> <span class="n">switched_from_fair</span><span class="p">,</span>
	<span class="p">.</span><span class="n">switched_to</span>		<span class="o">=</span> <span class="n">switched_to_fair</span><span class="p">,</span>

	<span class="p">.</span><span class="n">get_rr_interval</span>	<span class="o">=</span> <span class="n">get_rr_interval_fair</span><span class="p">,</span>

<span class="cp">#ifdef CONFIG_FAIR_GROUP_SCHED</span>
	<span class="p">.</span><span class="n">task_move_group</span>	<span class="o">=</span> <span class="n">task_move_group_fair</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_SCHED_DEBUG</span>
<span class="kt">void</span> <span class="nf">print_cfs_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">for_each_leaf_cfs_rq</span><span class="p">(</span><span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">),</span> <span class="n">cfs_rq</span><span class="p">)</span>
		<span class="n">print_cfs_rq</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">cfs_rq</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="n">__init</span> <span class="kt">void</span> <span class="nf">init_sched_fair_class</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">open_softirq</span><span class="p">(</span><span class="n">SCHED_SOFTIRQ</span><span class="p">,</span> <span class="n">run_rebalance_domains</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_NO_HZ</span>
	<span class="n">nohz</span><span class="p">.</span><span class="n">next_balance</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">zalloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nohz</span><span class="p">.</span><span class="n">idle_cpus_mask</span><span class="p">,</span> <span class="n">GFP_NOWAIT</span><span class="p">);</span>
	<span class="n">cpu_notifier</span><span class="p">(</span><span class="n">sched_ilb_notifier</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#endif </span><span class="cm">/* SMP */</span><span class="cp"></span>

<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
