<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › sched › clock.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>clock.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * sched_clock for unstable cpu clocks</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 2008 Red Hat, Inc., Peter Zijlstra &lt;pzijlstr@redhat.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  Updates and enhancements:</span>
<span class="cm"> *    Copyright (C) 2008 Red Hat, Inc. Steven Rostedt &lt;srostedt@redhat.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Based on code by:</span>
<span class="cm"> *   Ingo Molnar &lt;mingo@redhat.com&gt;</span>
<span class="cm"> *   Guillaume Chazarain &lt;guichaz@gmail.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * What:</span>
<span class="cm"> *</span>
<span class="cm"> * cpu_clock(i) provides a fast (execution time) high resolution</span>
<span class="cm"> * clock with bounded drift between CPUs. The value of cpu_clock(i)</span>
<span class="cm"> * is monotonic for constant i. The timestamp returned is in nanoseconds.</span>
<span class="cm"> *</span>
<span class="cm"> * ######################### BIG FAT WARNING ##########################</span>
<span class="cm"> * # when comparing cpu_clock(i) to cpu_clock(j) for i != j, time can #</span>
<span class="cm"> * # go backwards !!                                                  #</span>
<span class="cm"> * ####################################################################</span>
<span class="cm"> *</span>
<span class="cm"> * There is no strict promise about the base, although it tends to start</span>
<span class="cm"> * at 0 on boot (but people really shouldn&#39;t rely on that).</span>
<span class="cm"> *</span>
<span class="cm"> * cpu_clock(i)       -- can be used from any context, including NMI.</span>
<span class="cm"> * sched_clock_cpu(i) -- must be used with local IRQs disabled (implied by NMI)</span>
<span class="cm"> * local_clock()      -- is cpu_clock() on the current cpu.</span>
<span class="cm"> *</span>
<span class="cm"> * How:</span>
<span class="cm"> *</span>
<span class="cm"> * The implementation either uses sched_clock() when</span>
<span class="cm"> * !CONFIG_HAVE_UNSTABLE_SCHED_CLOCK, which means in that case the</span>
<span class="cm"> * sched_clock() is assumed to provide these properties (mostly it means</span>
<span class="cm"> * the architecture provides a globally synchronized highres time source).</span>
<span class="cm"> *</span>
<span class="cm"> * Otherwise it tries to create a semi stable clock from a mixture of other</span>
<span class="cm"> * clocks, including:</span>
<span class="cm"> *</span>
<span class="cm"> *  - GTOD (clock monotomic)</span>
<span class="cm"> *  - sched_clock()</span>
<span class="cm"> *  - explicit idle events</span>
<span class="cm"> *</span>
<span class="cm"> * We use GTOD as base and use sched_clock() deltas to improve resolution. The</span>
<span class="cm"> * deltas are filtered to provide monotonicity and keeping it within an</span>
<span class="cm"> * expected window.</span>
<span class="cm"> *</span>
<span class="cm"> * Furthermore, explicit sleep and wakeup hooks allow us to account for time</span>
<span class="cm"> * that is otherwise invisible (TSC gets stopped).</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> *</span>
<span class="cm"> * The !IRQ-safetly of sched_clock() and sched_clock_cpu() comes from things</span>
<span class="cm"> * like cpufreq interrupts that can change the base clock (TSC) multiplier</span>
<span class="cm"> * and cause funny jumps in time -- although the filtering provided by</span>
<span class="cm"> * sched_clock_cpu() should mitigate serious artifacts we cannot rely on it</span>
<span class="cm"> * in general since for !CONFIG_HAVE_UNSTABLE_SCHED_CLOCK we fully rely on</span>
<span class="cm"> * sched_clock().</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/hardirq.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/ktime.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Scheduler clock - returns current time in nanosec units.</span>
<span class="cm"> * This is default implementation.</span>
<span class="cm"> * Architectures and sub-architectures can override this.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">weak</span><span class="p">))</span> <span class="n">sched_clock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)(</span><span class="n">jiffies</span> <span class="o">-</span> <span class="n">INITIAL_JIFFIES</span><span class="p">)</span>
					<span class="o">*</span> <span class="p">(</span><span class="n">NSEC_PER_SEC</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sched_clock</span><span class="p">);</span>

<span class="n">__read_mostly</span> <span class="kt">int</span> <span class="n">sched_clock_running</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_HAVE_UNSTABLE_SCHED_CLOCK</span>
<span class="n">__read_mostly</span> <span class="kt">int</span> <span class="n">sched_clock_stable</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">sched_clock_data</span> <span class="p">{</span>
	<span class="n">u64</span>			<span class="n">tick_raw</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">tick_gtod</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">clock</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU_SHARED_ALIGNED</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_clock_data</span><span class="p">,</span> <span class="n">sched_clock_data</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sched_clock_data</span> <span class="o">*</span><span class="nf">this_scd</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">sched_clock_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sched_clock_data</span> <span class="o">*</span><span class="nf">cpu_sdc</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">sched_clock_data</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sched_clock_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">ktime_now</span> <span class="o">=</span> <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">ktime_get</span><span class="p">());</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sched_clock_data</span> <span class="o">*</span><span class="n">scd</span> <span class="o">=</span> <span class="n">cpu_sdc</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

		<span class="n">scd</span><span class="o">-&gt;</span><span class="n">tick_raw</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">scd</span><span class="o">-&gt;</span><span class="n">tick_gtod</span> <span class="o">=</span> <span class="n">ktime_now</span><span class="p">;</span>
		<span class="n">scd</span><span class="o">-&gt;</span><span class="n">clock</span> <span class="o">=</span> <span class="n">ktime_now</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sched_clock_running</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * min, max except they take wrapping into account</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">wrap_min</span><span class="p">(</span><span class="n">u64</span> <span class="n">x</span><span class="p">,</span> <span class="n">u64</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">s64</span><span class="p">)(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">x</span> <span class="o">:</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">wrap_max</span><span class="p">(</span><span class="n">u64</span> <span class="n">x</span><span class="p">,</span> <span class="n">u64</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">s64</span><span class="p">)(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">x</span> <span class="o">:</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * update the percpu scd from the raw @now value</span>
<span class="cm"> *</span>
<span class="cm"> *  - filter out backward motion</span>
<span class="cm"> *  - use the GTOD tick value to create a window to filter crazy TSC values</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="nf">sched_clock_local</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_clock_data</span> <span class="o">*</span><span class="n">scd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">now</span><span class="p">,</span> <span class="n">clock</span><span class="p">,</span> <span class="n">old_clock</span><span class="p">,</span> <span class="n">min_clock</span><span class="p">,</span> <span class="n">max_clock</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">delta</span><span class="p">;</span>

<span class="nl">again:</span>
	<span class="n">now</span> <span class="o">=</span> <span class="n">sched_clock</span><span class="p">();</span>
	<span class="n">delta</span> <span class="o">=</span> <span class="n">now</span> <span class="o">-</span> <span class="n">scd</span><span class="o">-&gt;</span><span class="n">tick_raw</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">old_clock</span> <span class="o">=</span> <span class="n">scd</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * scd-&gt;clock = clamp(scd-&gt;tick_gtod + delta,</span>
<span class="cm">	 *		      max(scd-&gt;tick_gtod, scd-&gt;clock),</span>
<span class="cm">	 *		      scd-&gt;tick_gtod + TICK_NSEC);</span>
<span class="cm">	 */</span>

	<span class="n">clock</span> <span class="o">=</span> <span class="n">scd</span><span class="o">-&gt;</span><span class="n">tick_gtod</span> <span class="o">+</span> <span class="n">delta</span><span class="p">;</span>
	<span class="n">min_clock</span> <span class="o">=</span> <span class="n">wrap_max</span><span class="p">(</span><span class="n">scd</span><span class="o">-&gt;</span><span class="n">tick_gtod</span><span class="p">,</span> <span class="n">old_clock</span><span class="p">);</span>
	<span class="n">max_clock</span> <span class="o">=</span> <span class="n">wrap_max</span><span class="p">(</span><span class="n">old_clock</span><span class="p">,</span> <span class="n">scd</span><span class="o">-&gt;</span><span class="n">tick_gtod</span> <span class="o">+</span> <span class="n">TICK_NSEC</span><span class="p">);</span>

	<span class="n">clock</span> <span class="o">=</span> <span class="n">wrap_max</span><span class="p">(</span><span class="n">clock</span><span class="p">,</span> <span class="n">min_clock</span><span class="p">);</span>
	<span class="n">clock</span> <span class="o">=</span> <span class="n">wrap_min</span><span class="p">(</span><span class="n">clock</span><span class="p">,</span> <span class="n">max_clock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmpxchg64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scd</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">,</span> <span class="n">old_clock</span><span class="p">,</span> <span class="n">clock</span><span class="p">)</span> <span class="o">!=</span> <span class="n">old_clock</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">clock</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">sched_clock_remote</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_clock_data</span> <span class="o">*</span><span class="n">scd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_clock_data</span> <span class="o">*</span><span class="n">my_scd</span> <span class="o">=</span> <span class="n">this_scd</span><span class="p">();</span>
	<span class="n">u64</span> <span class="n">this_clock</span><span class="p">,</span> <span class="n">remote_clock</span><span class="p">;</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">old_val</span><span class="p">,</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">sched_clock_local</span><span class="p">(</span><span class="n">my_scd</span><span class="p">);</span>
<span class="nl">again:</span>
	<span class="n">this_clock</span> <span class="o">=</span> <span class="n">my_scd</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">;</span>
	<span class="n">remote_clock</span> <span class="o">=</span> <span class="n">scd</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Use the opportunity that we have both locks</span>
<span class="cm">	 * taken to couple the two clocks: we take the</span>
<span class="cm">	 * larger time as the latest time for both</span>
<span class="cm">	 * runqueues. (this creates monotonic movement)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">((</span><span class="n">s64</span><span class="p">)(</span><span class="n">remote_clock</span> <span class="o">-</span> <span class="n">this_clock</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">scd</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">;</span>
		<span class="n">old_val</span> <span class="o">=</span> <span class="n">remote_clock</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">this_clock</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Should be rare, but possible:</span>
<span class="cm">		 */</span>
		<span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_scd</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">;</span>
		<span class="n">old_val</span> <span class="o">=</span> <span class="n">this_clock</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">remote_clock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmpxchg64</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">old_val</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="n">old_val</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Similar to cpu_clock(), but requires local IRQs to be disabled.</span>
<span class="cm"> *</span>
<span class="cm"> * See cpu_clock().</span>
<span class="cm"> */</span>
<span class="n">u64</span> <span class="nf">sched_clock_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_clock_data</span> <span class="o">*</span><span class="n">scd</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">clock</span><span class="p">;</span>

	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">());</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sched_clock_stable</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sched_clock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">sched_clock_running</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0ull</span><span class="p">;</span>

	<span class="n">scd</span> <span class="o">=</span> <span class="n">cpu_sdc</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">smp_processor_id</span><span class="p">())</span>
		<span class="n">clock</span> <span class="o">=</span> <span class="n">sched_clock_remote</span><span class="p">(</span><span class="n">scd</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">clock</span> <span class="o">=</span> <span class="n">sched_clock_local</span><span class="p">(</span><span class="n">scd</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">clock</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sched_clock_tick</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_clock_data</span> <span class="o">*</span><span class="n">scd</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">now</span><span class="p">,</span> <span class="n">now_gtod</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sched_clock_stable</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">sched_clock_running</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">());</span>

	<span class="n">scd</span> <span class="o">=</span> <span class="n">this_scd</span><span class="p">();</span>
	<span class="n">now_gtod</span> <span class="o">=</span> <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">ktime_get</span><span class="p">());</span>
	<span class="n">now</span> <span class="o">=</span> <span class="n">sched_clock</span><span class="p">();</span>

	<span class="n">scd</span><span class="o">-&gt;</span><span class="n">tick_raw</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
	<span class="n">scd</span><span class="o">-&gt;</span><span class="n">tick_gtod</span> <span class="o">=</span> <span class="n">now_gtod</span><span class="p">;</span>
	<span class="n">sched_clock_local</span><span class="p">(</span><span class="n">scd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We are going deep-idle (irqs are disabled):</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sched_clock_idle_sleep_event</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sched_clock_cpu</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">());</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sched_clock_idle_sleep_event</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * We just idled delta nanoseconds (called with irqs disabled):</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sched_clock_idle_wakeup_event</span><span class="p">(</span><span class="n">u64</span> <span class="n">delta_ns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timekeeping_suspended</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">sched_clock_tick</span><span class="p">();</span>
	<span class="n">touch_softlockup_watchdog</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sched_clock_idle_wakeup_event</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * As outlined at the top, provides a fast, high resolution, nanosecond</span>
<span class="cm"> * time source that is monotonic per cpu argument and has bounded drift</span>
<span class="cm"> * between cpus.</span>
<span class="cm"> *</span>
<span class="cm"> * ######################### BIG FAT WARNING ##########################</span>
<span class="cm"> * # when comparing cpu_clock(i) to cpu_clock(j) for i != j, time can #</span>
<span class="cm"> * # go backwards !!                                                  #</span>
<span class="cm"> * ####################################################################</span>
<span class="cm"> */</span>
<span class="n">u64</span> <span class="nf">cpu_clock</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">clock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">clock</span> <span class="o">=</span> <span class="n">sched_clock_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">clock</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Similar to cpu_clock() for the current cpu. Time will only be observed</span>
<span class="cm"> * to be monotonic if care is taken to only compare timestampt taken on the</span>
<span class="cm"> * same CPU.</span>
<span class="cm"> *</span>
<span class="cm"> * See cpu_clock().</span>
<span class="cm"> */</span>
<span class="n">u64</span> <span class="nf">local_clock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">clock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">clock</span> <span class="o">=</span> <span class="n">sched_clock_cpu</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">());</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">clock</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_HAVE_UNSTABLE_SCHED_CLOCK */</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">sched_clock_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sched_clock_running</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">u64</span> <span class="nf">sched_clock_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">sched_clock_running</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sched_clock</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">u64</span> <span class="nf">cpu_clock</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sched_clock_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">u64</span> <span class="nf">local_clock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sched_clock_cpu</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_HAVE_UNSTABLE_SCHED_CLOCK */</span><span class="cp"></span>

<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">cpu_clock</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">local_clock</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
