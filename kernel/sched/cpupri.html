<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › sched › cpupri.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>cpupri.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _LINUX_CPUPRI_H</span>
<span class="cp">#define _LINUX_CPUPRI_H</span>

<span class="cp">#include &lt;linux/sched.h&gt;</span>

<span class="cp">#define CPUPRI_NR_PRIORITIES	(MAX_RT_PRIO + 2)</span>

<span class="cp">#define CPUPRI_INVALID -1</span>
<span class="cp">#define CPUPRI_IDLE     0</span>
<span class="cp">#define CPUPRI_NORMAL   1</span>
<span class="cm">/* values 2-101 are RT priorities 0-99 */</span>

<span class="k">struct</span> <span class="n">cpupri_vec</span> <span class="p">{</span>
	<span class="n">atomic_t</span>	<span class="n">count</span><span class="p">;</span>
	<span class="n">cpumask_var_t</span>	<span class="n">mask</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">cpupri</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpupri_vec</span> <span class="n">pri_to_cpu</span><span class="p">[</span><span class="n">CPUPRI_NR_PRIORITIES</span><span class="p">];</span>
	<span class="kt">int</span>               <span class="n">cpu_to_pri</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="kt">int</span>  <span class="n">cpupri_find</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpupri</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">lowest_mask</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">cpupri_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpupri</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pri</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">cpupri_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpupri</span> <span class="o">*</span><span class="n">cp</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">cpupri_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpupri</span> <span class="o">*</span><span class="n">cp</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp">#define cpupri_set(cp, cpu, pri) do { } while (0)</span>
<span class="cp">#define cpupri_init() do { } while (0)</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* _LINUX_CPUPRI_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
pan> <span class="n">MAX_RT_PRIO</span> <span class="o">-</span> <span class="n">prio</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cpupri</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpupri_find - find the best (lowest-pri) CPU in the system</span>
<span class="cm"> * @cp: The cpupri context</span>
<span class="cm"> * @p: The task</span>
<span class="cm"> * @lowest_mask: A mask to fill in with selected CPUs (or NULL)</span>
<span class="cm"> *</span>
<span class="cm"> * Note: This function returns the recommended CPUs as calculated during the</span>
<span class="cm"> * current invocation.  By the time the call returns, the CPUs may have in</span>
<span class="cm"> * fact changed priorities any number of times.  While not ideal, it is not</span>
<span class="cm"> * an issue of correctness since the normal rebalancer logic will correct</span>
<span class="cm"> * any discrepancies created by racing against the uncertainty of the current</span>
<span class="cm"> * priority configuration.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: (int)bool - CPUs were found</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cpupri_find</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpupri</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">lowest_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>                  <span class="n">idx</span>      <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>                  <span class="n">task_pri</span> <span class="o">=</span> <span class="n">convert_prio</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task_pri</span> <span class="o">&gt;=</span> <span class="n">MAX_RT_PRIO</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">task_pri</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cpupri_vec</span> <span class="o">*</span><span class="n">vec</span>  <span class="o">=</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pri_to_cpu</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">skip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">))</span>
			<span class="n">skip</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * When looking at the vector, we need to read the counter,</span>
<span class="cm">		 * do a memory barrier, then read the mask.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Note: This is still all racey, but we can deal with it.</span>
<span class="cm">		 *  Ideally, we only want to look at masks that are set.</span>
<span class="cm">		 *</span>
<span class="cm">		 *  If a mask is not set, then the only thing wrong is that we</span>
<span class="cm">		 *  did a little more work than necessary.</span>
<span class="cm">		 *</span>
<span class="cm">		 *  If we read a zero count but the mask is set, because of the</span>
<span class="cm">		 *  memory barriers, that can only happen when the highest prio</span>
<span class="cm">		 *  task for a run queue has left the run queue, in which case,</span>
<span class="cm">		 *  it will be followed by a pull. If the task we are processing</span>
<span class="cm">		 *  fails to find a proper place to go, that pull request will</span>
<span class="cm">		 *  pull this task if the run queue is running at a lower</span>
<span class="cm">		 *  priority.</span>
<span class="cm">		 */</span>
		<span class="n">smp_rmb</span><span class="p">();</span>

		<span class="cm">/* Need to do the rmb for every iteration */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skip</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_any_and</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">,</span> <span class="n">vec</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">nr_cpu_ids</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lowest_mask</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cpumask_and</span><span class="p">(</span><span class="n">lowest_mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">,</span> <span class="n">vec</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * We have to ensure that we have at least one bit</span>
<span class="cm">			 * still set in the array, since the map could have</span>
<span class="cm">			 * been concurrently emptied between the first and</span>
<span class="cm">			 * second reads of vec-&gt;mask.  If we hit this</span>
<span class="cm">			 * condition, simply act as though we never hit this</span>
<span class="cm">			 * priority level and continue on.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_any</span><span class="p">(</span><span class="n">lowest_mask</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">nr_cpu_ids</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpupri_set - update the cpu priority setting</span>
<span class="cm"> * @cp: The cpupri context</span>
<span class="cm"> * @cpu: The target cpu</span>
<span class="cm"> * @newpri: The priority (INVALID-RT99) to assign to this CPU</span>
<span class="cm"> *</span>
<span class="cm"> * Note: Assumes cpu_rq(cpu)-&gt;lock is locked</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: (void)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">cpupri_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpupri</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">newpri</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>                 <span class="o">*</span><span class="n">currpri</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cpu_to_pri</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
	<span class="kt">int</span>                  <span class="n">oldpri</span>  <span class="o">=</span> <span class="o">*</span><span class="n">currpri</span><span class="p">;</span>
	<span class="kt">int</span>                  <span class="n">do_mb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">newpri</span> <span class="o">=</span> <span class="n">convert_prio</span><span class="p">(</span><span class="n">newpri</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">newpri</span> <span class="o">&gt;=</span> <span class="n">CPUPRI_NR_PRIORITIES</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">newpri</span> <span class="o">==</span> <span class="n">oldpri</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the cpu was currently mapped to a different value, we</span>
<span class="cm">	 * need to map it to the new value then remove the old value.</span>
<span class="cm">	 * Note, we must add the new value first, otherwise we risk the</span>
<span class="cm">	 * cpu being missed by the priority loop in cpupri_find.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">newpri</span> <span class="o">!=</span> <span class="n">CPUPRI_INVALID</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cpupri_vec</span> <span class="o">*</span><span class="n">vec</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pri_to_cpu</span><span class="p">[</span><span class="n">newpri</span><span class="p">];</span>

		<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">vec</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * When adding a new vector, we update the mask first,</span>
<span class="cm">		 * do a write memory barrier, and then update the count, to</span>
<span class="cm">		 * make sure the vector is visible when count is set.</span>
<span class="cm">		 */</span>
		<span class="n">smp_mb__before_atomic_inc</span><span class="p">();</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
		<span class="n">do_mb</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">oldpri</span> <span class="o">!=</span> <span class="n">CPUPRI_INVALID</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cpupri_vec</span> <span class="o">*</span><span class="n">vec</span>  <span class="o">=</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pri_to_cpu</span><span class="p">[</span><span class="n">oldpri</span><span class="p">];</span>

		<span class="cm">/*</span>
<span class="cm">		 * Because the order of modification of the vec-&gt;count</span>
<span class="cm">		 * is important, we must make sure that the update</span>
<span class="cm">		 * of the new prio is seen before we decrement the</span>
<span class="cm">		 * old prio. This makes sure that the loop sees</span>
<span class="cm">		 * one or the other when we raise the priority of</span>
<span class="cm">		 * the run queue. We don&#39;t care about when we lower the</span>
<span class="cm">		 * priority, as that will trigger an rt pull anyway.</span>
<span class="cm">		 *</span>
<span class="cm">		 * We only need to do a memory barrier if we updated</span>
<span class="cm">		 * the new priority vec.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">do_mb</span><span class="p">)</span>
			<span class="n">smp_mb__after_atomic_inc</span><span class="p">();</span>

		<span class="cm">/*</span>
<span class="cm">		 * When removing from the vector, we decrement the counter first</span>
<span class="cm">		 * do a memory barrier and then clear the mask.</span>
<span class="cm">		 */</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
		<span class="n">smp_mb__after_atomic_inc</span><span class="p">();</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">vec</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">currpri</span> <span class="o">=</span> <span class="n">newpri</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpupri_init - initialize the cpupri structure</span>
<span class="cm"> * @cp: The cpupri context</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: -ENOMEM if memory fails.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cpupri_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpupri</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cp</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CPUPRI_NR_PRIORITIES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cpupri_vec</span> <span class="o">*</span><span class="n">vec</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pri_to_cpu</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vec</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zalloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vec</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">cpu_to_pri</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">CPUPRI_INVALID</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">cleanup:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
		<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pri_to_cpu</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mask</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpupri_cleanup - clean up the cpupri structure</span>
<span class="cm"> * @cp: The cpupri context</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">cpupri_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpupri</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CPUPRI_NR_PRIORITIES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pri_to_cpu</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
