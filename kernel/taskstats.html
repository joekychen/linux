<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › taskstats.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>taskstats.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * taskstats.c - Export per-task statistics to userland</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) Shailabh Nagar, IBM Corp. 2006</span>
<span class="cm"> *           (C) Balbir Singh,   IBM Corp. 2006</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/taskstats_kern.h&gt;</span>
<span class="cp">#include &lt;linux/tsacct_kern.h&gt;</span>
<span class="cp">#include &lt;linux/delayacct.h&gt;</span>
<span class="cp">#include &lt;linux/cpumask.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/cgroupstats.h&gt;</span>
<span class="cp">#include &lt;linux/cgroup.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;net/genetlink.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Maximum length of a cpumask that can be specified in</span>
<span class="cm"> * the TASKSTATS_CMD_ATTR_REGISTER/DEREGISTER_CPUMASK attribute</span>
<span class="cm"> */</span>
<span class="cp">#define TASKSTATS_CPUMASK_MAXLEN	(100+6*NR_CPUS)</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">__u32</span><span class="p">,</span> <span class="n">taskstats_seqnum</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">family_registered</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">taskstats_cache</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">genl_family</span> <span class="n">family</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">id</span>		<span class="o">=</span> <span class="n">GENL_ID_GENERATE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="n">TASKSTATS_GENL_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">version</span>	<span class="o">=</span> <span class="n">TASKSTATS_GENL_VERSION</span><span class="p">,</span>
	<span class="p">.</span><span class="n">maxattr</span>	<span class="o">=</span> <span class="n">TASKSTATS_CMD_ATTR_MAX</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">nla_policy</span> <span class="n">taskstats_cmd_get_policy</span><span class="p">[</span><span class="n">TASKSTATS_CMD_ATTR_MAX</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">TASKSTATS_CMD_ATTR_PID</span><span class="p">]</span>  <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_U32</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">TASKSTATS_CMD_ATTR_TGID</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_U32</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">TASKSTATS_CMD_ATTR_REGISTER_CPUMASK</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_STRING</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_STRING</span> <span class="p">},};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">nla_policy</span> <span class="n">cgroupstats_cmd_get_policy</span><span class="p">[</span><span class="n">CGROUPSTATS_CMD_ATTR_MAX</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">CGROUPSTATS_CMD_ATTR_FD</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_U32</span> <span class="p">},</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">listener</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">valid</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">listener_list</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rw_semaphore</span> <span class="n">sem</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">listener_list</span><span class="p">,</span> <span class="n">listener_array</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">actions</span> <span class="p">{</span>
	<span class="n">REGISTER</span><span class="p">,</span>
	<span class="n">DEREGISTER</span><span class="p">,</span>
	<span class="n">CPU_DONT_CARE</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">prepare_reply</span><span class="p">(</span><span class="k">struct</span> <span class="n">genl_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">u8</span> <span class="n">cmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="n">skbp</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">reply</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If new attributes are added, please revisit this allocation</span>
<span class="cm">	 */</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">genlmsg_new</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">seq</span> <span class="o">=</span> <span class="n">this_cpu_inc_return</span><span class="p">(</span><span class="n">taskstats_seqnum</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">reply</span> <span class="o">=</span> <span class="n">genlmsg_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">family</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">reply</span> <span class="o">=</span> <span class="n">genlmsg_put_reply</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">family</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reply</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nlmsg_free</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">skbp</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Send taskstats data in @skb to listener with nl_pid @pid</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">send_reply</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">genl_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">genlmsghdr</span> <span class="o">*</span><span class="n">genlhdr</span> <span class="o">=</span> <span class="n">nlmsg_data</span><span class="p">(</span><span class="n">nlmsg_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">reply</span> <span class="o">=</span> <span class="n">genlmsg_data</span><span class="p">(</span><span class="n">genlhdr</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">genlmsg_end</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">reply</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nlmsg_free</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">genlmsg_reply</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Send taskstats data in @skb to listeners registered for @cpu&#39;s exit data</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">send_cpu_listeners</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">listener_list</span> <span class="o">*</span><span class="n">listeners</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">genlmsghdr</span> <span class="o">*</span><span class="n">genlhdr</span> <span class="o">=</span> <span class="n">nlmsg_data</span><span class="p">(</span><span class="n">nlmsg_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
	<span class="k">struct</span> <span class="n">listener</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb_next</span><span class="p">,</span> <span class="o">*</span><span class="n">skb_cur</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">reply</span> <span class="o">=</span> <span class="n">genlmsg_data</span><span class="p">(</span><span class="n">genlhdr</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">delcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">genlmsg_end</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">reply</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nlmsg_free</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">listeners</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">listeners</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb_next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_is_last</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">listeners</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">skb_next</span> <span class="o">=</span> <span class="n">skb_clone</span><span class="p">(</span><span class="n">skb_cur</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_next</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">genlmsg_unicast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="n">skb_cur</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">ECONNREFUSED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">delcount</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">skb_cur</span> <span class="o">=</span> <span class="n">skb_next</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">listeners</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_cur</span><span class="p">)</span>
		<span class="n">nlmsg_free</span><span class="p">(</span><span class="n">skb_cur</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">delcount</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Delete invalidated entries */</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">listeners</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">listeners</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">listeners</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fill_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">taskstats</span> <span class="o">*</span><span class="n">stats</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">stats</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * Each accounting subsystem adds calls to its functions to</span>
<span class="cm">	 * fill in relevant parts of struct taskstsats as follows</span>
<span class="cm">	 *</span>
<span class="cm">	 *	per-task-foo(stats, tsk);</span>
<span class="cm">	 */</span>

	<span class="n">delayacct_add_tsk</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>

	<span class="cm">/* fill in basic acct fields */</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">=</span> <span class="n">TASKSTATS_VERSION</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">nvcsw</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">nvcsw</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">nivcsw</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">nivcsw</span><span class="p">;</span>
	<span class="n">bacct_add_tsk</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>

	<span class="cm">/* fill in extended acct fields */</span>
	<span class="n">xacct_add_tsk</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fill_stats_for_pid</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">taskstats</span> <span class="o">*</span><span class="n">stats</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">tsk</span> <span class="o">=</span> <span class="n">find_task_by_vpid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="p">)</span>
		<span class="n">get_task_struct</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tsk</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
	<span class="n">fill_stats</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">stats</span><span class="p">);</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fill_stats_for_tgid</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">tgid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">taskstats</span> <span class="o">*</span><span class="n">stats</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="o">*</span><span class="n">first</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Add additional stats from live tasks except zombie thread group</span>
<span class="cm">	 * leaders who are already counted with the dead tasks</span>
<span class="cm">	 */</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">first</span> <span class="o">=</span> <span class="n">find_task_by_vpid</span><span class="p">(</span><span class="n">tgid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">first</span> <span class="o">||</span> <span class="o">!</span><span class="n">lock_task_sighand</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="n">first</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">stats</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">stats</span><span class="p">));</span>

	<span class="n">tsk</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">exit_state</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Accounting subsystem can call its functions here to</span>
<span class="cm">		 * fill in relevant parts of struct taskstsats as follows</span>
<span class="cm">		 *</span>
<span class="cm">		 *	per-task-foo(stats, tsk);</span>
<span class="cm">		 */</span>
		<span class="n">delayacct_add_tsk</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>

		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">nvcsw</span> <span class="o">+=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">nvcsw</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">nivcsw</span> <span class="o">+=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">nivcsw</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">while_each_thread</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>

	<span class="n">unlock_task_sighand</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">=</span> <span class="n">TASKSTATS_VERSION</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Accounting subsystems can also add calls here to modify</span>
<span class="cm">	 * fields of taskstats.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fill_tgid_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Each accounting subsystem calls its functions here to</span>
<span class="cm">	 * accumalate its per-task stats for tsk, into the per-tgid structure</span>
<span class="cm">	 *</span>
<span class="cm">	 *	per-task-foo(tsk-&gt;signal-&gt;stats, tsk);</span>
<span class="cm">	 */</span>
	<span class="n">delayacct_add_tsk</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>
<span class="nl">ret:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">add_del_listener</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span> <span class="kt">int</span> <span class="n">isadd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">listener_list</span> <span class="o">*</span><span class="n">listeners</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">listener</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">,</span> <span class="o">*</span><span class="n">s2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_subset</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">cpu_possible_mask</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">isadd</span> <span class="o">==</span> <span class="n">REGISTER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">s</span> <span class="o">=</span> <span class="n">kmalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">listener</span><span class="p">),</span>
					<span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>

			<span class="n">s</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="n">pid</span><span class="p">;</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="n">listeners</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">listener_array</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
			<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">listeners</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>
			<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">listeners</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">s2</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">==</span> <span class="n">pid</span> <span class="o">&amp;&amp;</span> <span class="n">s2</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">exists</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">listeners</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">s</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">exists:</span>
			<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">listeners</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="cm">/* nop if NULL */</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Deregister or cleanup */</span>
<span class="nl">cleanup:</span>
	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">listeners</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">listener_array</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">listeners</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">listeners</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">==</span> <span class="n">pid</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">listeners</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">parse</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">na</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">na</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">nla_len</span><span class="p">(</span><span class="n">na</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">TASKSTATS_CPUMASK_MAXLEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E2BIG</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">nla_strlcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">na</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">cpulist_parse</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if defined(CONFIG_64BIT) &amp;&amp; !defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)</span>
<span class="cp">#define TASKSTATS_NEEDS_PADDING 1</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">taskstats</span> <span class="o">*</span><span class="nf">mk_reply</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="n">u32</span> <span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">na</span><span class="p">,</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">aggr</span><span class="p">;</span>

	<span class="n">aggr</span> <span class="o">=</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">TASKSTATS_TYPE_PID</span><span class="p">)</span>
			<span class="o">?</span> <span class="n">TASKSTATS_TYPE_AGGR_PID</span>
			<span class="o">:</span> <span class="n">TASKSTATS_TYPE_AGGR_TGID</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The taskstats structure is internally aligned on 8 byte</span>
<span class="cm">	 * boundaries but the layout of the aggregrate reply, with</span>
<span class="cm">	 * two NLA headers and the pid (each 4 bytes), actually</span>
<span class="cm">	 * force the entire structure to be unaligned. This causes</span>
<span class="cm">	 * the kernel to issue unaligned access warnings on some</span>
<span class="cm">	 * architectures like ia64. Unfortunately, some software out there</span>
<span class="cm">	 * doesn&#39;t properly unroll the NLA packet and assumes that the start</span>
<span class="cm">	 * of the taskstats structure will always be 20 bytes from the start</span>
<span class="cm">	 * of the netlink payload. Aligning the start of the taskstats</span>
<span class="cm">	 * structure breaks this software, which we don&#39;t want. So, for now</span>
<span class="cm">	 * the alignment only happens on architectures that require it</span>
<span class="cm">	 * and those users will have to update to fixed versions of those</span>
<span class="cm">	 * packages. Space is reserved in the packet only when needed.</span>
<span class="cm">	 * This ifdef should be removed in several years e.g. 2012 once</span>
<span class="cm">	 * we can be confident that fixed versions are installed on most</span>
<span class="cm">	 * systems. We add the padding before the aggregate since the</span>
<span class="cm">	 * aggregate is already a defined type.</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef TASKSTATS_NEEDS_PADDING</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nla_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">TASKSTATS_TYPE_NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">na</span> <span class="o">=</span> <span class="n">nla_nest_start</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">aggr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">na</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nla_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pid</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">pid</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">nla_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">TASKSTATS_TYPE_STATS</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">taskstats</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">nla_nest_end</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">na</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">nla_data</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
<span class="nl">err:</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroupstats_user_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">genl_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">rep_skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroupstats</span> <span class="o">*</span><span class="n">stats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">na</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">fd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fput_needed</span><span class="p">;</span>

	<span class="n">na</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">CGROUPSTATS_CMD_ATTR_FD</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">na</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">fd</span> <span class="o">=</span> <span class="n">nla_get_u32</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">CGROUPSTATS_CMD_ATTR_FD</span><span class="p">]);</span>
	<span class="n">file</span> <span class="o">=</span> <span class="n">fget_light</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fput_needed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">nla_total_size</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroupstats</span><span class="p">));</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">prepare_reply</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">CGROUPSTATS_CMD_NEW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rep_skb</span><span class="p">,</span>
				<span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">na</span> <span class="o">=</span> <span class="n">nla_reserve</span><span class="p">(</span><span class="n">rep_skb</span><span class="p">,</span> <span class="n">CGROUPSTATS_TYPE_CGROUP_STATS</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroupstats</span><span class="p">));</span>
	<span class="n">stats</span> <span class="o">=</span> <span class="n">nla_data</span><span class="p">(</span><span class="n">na</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">stats</span><span class="p">));</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">cgroupstats_build</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nlmsg_free</span><span class="p">(</span><span class="n">rep_skb</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">send_reply</span><span class="p">(</span><span class="n">rep_skb</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>

<span class="nl">err:</span>
	<span class="n">fput_light</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cmd_attr_register_cpumask</span><span class="p">(</span><span class="k">struct</span> <span class="n">genl_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpumask_var_t</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mask</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">parse</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">TASKSTATS_CMD_ATTR_REGISTER_CPUMASK</span><span class="p">],</span> <span class="n">mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">add_del_listener</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">snd_pid</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">REGISTER</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cmd_attr_deregister_cpumask</span><span class="p">(</span><span class="k">struct</span> <span class="n">genl_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpumask_var_t</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mask</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">parse</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK</span><span class="p">],</span> <span class="n">mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">add_del_listener</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">snd_pid</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">DEREGISTER</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">taskstats_packet_size</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">nla_total_size</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span> <span class="o">+</span>
		<span class="n">nla_total_size</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">taskstats</span><span class="p">))</span> <span class="o">+</span> <span class="n">nla_total_size</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="cp">#ifdef TASKSTATS_NEEDS_PADDING</span>
	<span class="n">size</span> <span class="o">+=</span> <span class="n">nla_total_size</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="cm">/* Padding for alignment */</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cmd_attr_pid</span><span class="p">(</span><span class="k">struct</span> <span class="n">genl_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">taskstats</span> <span class="o">*</span><span class="n">stats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">rep_skb</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">taskstats_packet_size</span><span class="p">();</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">prepare_reply</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">TASKSTATS_CMD_NEW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rep_skb</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">pid</span> <span class="o">=</span> <span class="n">nla_get_u32</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">TASKSTATS_CMD_ATTR_PID</span><span class="p">]);</span>
	<span class="n">stats</span> <span class="o">=</span> <span class="n">mk_reply</span><span class="p">(</span><span class="n">rep_skb</span><span class="p">,</span> <span class="n">TASKSTATS_TYPE_PID</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stats</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">fill_stats_for_pid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">stats</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">send_reply</span><span class="p">(</span><span class="n">rep_skb</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
<span class="nl">err:</span>
	<span class="n">nlmsg_free</span><span class="p">(</span><span class="n">rep_skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cmd_attr_tgid</span><span class="p">(</span><span class="k">struct</span> <span class="n">genl_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">taskstats</span> <span class="o">*</span><span class="n">stats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">rep_skb</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tgid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">taskstats_packet_size</span><span class="p">();</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">prepare_reply</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">TASKSTATS_CMD_NEW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rep_skb</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">tgid</span> <span class="o">=</span> <span class="n">nla_get_u32</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">TASKSTATS_CMD_ATTR_TGID</span><span class="p">]);</span>
	<span class="n">stats</span> <span class="o">=</span> <span class="n">mk_reply</span><span class="p">(</span><span class="n">rep_skb</span><span class="p">,</span> <span class="n">TASKSTATS_TYPE_TGID</span><span class="p">,</span> <span class="n">tgid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stats</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">fill_stats_for_tgid</span><span class="p">(</span><span class="n">tgid</span><span class="p">,</span> <span class="n">stats</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">send_reply</span><span class="p">(</span><span class="n">rep_skb</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
<span class="nl">err:</span>
	<span class="n">nlmsg_free</span><span class="p">(</span><span class="n">rep_skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">taskstats_user_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">genl_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">TASKSTATS_CMD_ATTR_REGISTER_CPUMASK</span><span class="p">])</span>
		<span class="k">return</span> <span class="n">cmd_attr_register_cpumask</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK</span><span class="p">])</span>
		<span class="k">return</span> <span class="n">cmd_attr_deregister_cpumask</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">TASKSTATS_CMD_ATTR_PID</span><span class="p">])</span>
		<span class="k">return</span> <span class="n">cmd_attr_pid</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">TASKSTATS_CMD_ATTR_TGID</span><span class="p">])</span>
		<span class="k">return</span> <span class="n">cmd_attr_tgid</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">taskstats</span> <span class="o">*</span><span class="nf">taskstats_tgid_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">signal_struct</span> <span class="o">*</span><span class="n">sig</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">taskstats</span> <span class="o">*</span><span class="n">stats</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">stats</span> <span class="o">||</span> <span class="n">thread_group_empty</span><span class="p">(</span><span class="n">tsk</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* No problem if kmem_cache_zalloc() fails */</span>
	<span class="n">stats</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">taskstats_cache</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sig</span><span class="o">-&gt;</span><span class="n">stats</span> <span class="o">=</span> <span class="n">stats</span><span class="p">;</span>
		<span class="n">stats</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stats</span><span class="p">)</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">taskstats_cache</span><span class="p">,</span> <span class="n">stats</span><span class="p">);</span>
<span class="nl">ret:</span>
	<span class="k">return</span> <span class="n">sig</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Send pid data out on exit */</span>
<span class="kt">void</span> <span class="nf">taskstats_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">group_dead</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">listener_list</span> <span class="o">*</span><span class="n">listeners</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">taskstats</span> <span class="o">*</span><span class="n">stats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">rep_skb</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_thread_group</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">family_registered</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Size includes space for nested attributes</span>
<span class="cm">	 */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">taskstats_packet_size</span><span class="p">();</span>

	<span class="n">is_thread_group</span> <span class="o">=</span> <span class="o">!!</span><span class="n">taskstats_tgid_alloc</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_thread_group</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* PID + STATS + TGID + STATS */</span>
		<span class="n">size</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">size</span><span class="p">;</span>
		<span class="cm">/* fill the tsk-&gt;signal-&gt;stats structure */</span>
		<span class="n">fill_tgid_exit</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">listeners</span> <span class="o">=</span> <span class="n">__this_cpu_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">listener_array</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">listeners</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">prepare_reply</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">TASKSTATS_CMD_NEW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rep_skb</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">stats</span> <span class="o">=</span> <span class="n">mk_reply</span><span class="p">(</span><span class="n">rep_skb</span><span class="p">,</span> <span class="n">TASKSTATS_TYPE_PID</span><span class="p">,</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stats</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">fill_stats</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">stats</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Doesn&#39;t matter if tsk is the leader or the last group member leaving</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_thread_group</span> <span class="o">||</span> <span class="o">!</span><span class="n">group_dead</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">send</span><span class="p">;</span>

	<span class="n">stats</span> <span class="o">=</span> <span class="n">mk_reply</span><span class="p">(</span><span class="n">rep_skb</span><span class="p">,</span> <span class="n">TASKSTATS_TYPE_TGID</span><span class="p">,</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stats</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">stats</span><span class="p">));</span>

<span class="nl">send:</span>
	<span class="n">send_cpu_listeners</span><span class="p">(</span><span class="n">rep_skb</span><span class="p">,</span> <span class="n">listeners</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="nl">err:</span>
	<span class="n">nlmsg_free</span><span class="p">(</span><span class="n">rep_skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">genl_ops</span> <span class="n">taskstats_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">cmd</span>		<span class="o">=</span> <span class="n">TASKSTATS_CMD_GET</span><span class="p">,</span>
	<span class="p">.</span><span class="n">doit</span>		<span class="o">=</span> <span class="n">taskstats_user_cmd</span><span class="p">,</span>
	<span class="p">.</span><span class="n">policy</span>		<span class="o">=</span> <span class="n">taskstats_cmd_get_policy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span>		<span class="o">=</span> <span class="n">GENL_ADMIN_PERM</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">genl_ops</span> <span class="n">cgroupstats_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">cmd</span>		<span class="o">=</span> <span class="n">CGROUPSTATS_CMD_GET</span><span class="p">,</span>
	<span class="p">.</span><span class="n">doit</span>		<span class="o">=</span> <span class="n">cgroupstats_user_cmd</span><span class="p">,</span>
	<span class="p">.</span><span class="n">policy</span>		<span class="o">=</span> <span class="n">cgroupstats_cmd_get_policy</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Needed early in initialization */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">taskstats_init_early</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">taskstats_cache</span> <span class="o">=</span> <span class="n">KMEM_CACHE</span><span class="p">(</span><span class="n">taskstats</span><span class="p">,</span> <span class="n">SLAB_PANIC</span><span class="p">);</span>
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">listener_array</span><span class="p">,</span> <span class="n">i</span><span class="p">).</span><span class="n">list</span><span class="p">));</span>
		<span class="n">init_rwsem</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">listener_array</span><span class="p">,</span> <span class="n">i</span><span class="p">).</span><span class="n">sem</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">taskstats_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">genl_register_family</span><span class="p">(</span><span class="o">&amp;</span><span class="n">family</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">genl_register_ops</span><span class="p">(</span><span class="o">&amp;</span><span class="n">family</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">taskstats_ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">genl_register_ops</span><span class="p">(</span><span class="o">&amp;</span><span class="n">family</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cgroupstats_ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_cgroup_ops</span><span class="p">;</span>

	<span class="n">family_registered</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;registered taskstats version %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">TASKSTATS_GENL_VERSION</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">err_cgroup_ops:</span>
	<span class="n">genl_unregister_ops</span><span class="p">(</span><span class="o">&amp;</span><span class="n">family</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">taskstats_ops</span><span class="p">);</span>
<span class="nl">err:</span>
	<span class="n">genl_unregister_family</span><span class="p">(</span><span class="o">&amp;</span><span class="n">family</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * late initcall ensures initialization of statistics collection</span>
<span class="cm"> * mechanisms precedes initialization of the taskstats interface</span>
<span class="cm"> */</span>
<span class="n">late_initcall</span><span class="p">(</span><span class="n">taskstats_init</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
