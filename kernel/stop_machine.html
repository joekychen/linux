<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › stop_machine.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>stop_machine.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * kernel/stop_machine.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2008, 2005	IBM Corporation.</span>
<span class="cm"> * Copyright (C) 2008, 2005	Rusty Russell rusty@rustcorp.com.au</span>
<span class="cm"> * Copyright (C) 2010		SUSE Linux Products GmbH</span>
<span class="cm"> * Copyright (C) 2010		Tejun Heo &lt;tj@kernel.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This file is released under the GPLv2 and any later version.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/stop_machine.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/kallsyms.h&gt;</span>

<span class="cp">#include &lt;linux/atomic.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Structure to determine completion condition and record errors.  May</span>
<span class="cm"> * be shared by works on different cpus.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cpu_stop_done</span> <span class="p">{</span>
	<span class="n">atomic_t</span>		<span class="n">nr_todo</span><span class="p">;</span>	<span class="cm">/* nr left to execute */</span>
	<span class="n">bool</span>			<span class="n">executed</span><span class="p">;</span>	<span class="cm">/* actually executed? */</span>
	<span class="kt">int</span>			<span class="n">ret</span><span class="p">;</span>		<span class="cm">/* collected return value */</span>
	<span class="k">struct</span> <span class="n">completion</span>	<span class="n">completion</span><span class="p">;</span>	<span class="cm">/* fired if nr_todo reaches 0 */</span>
<span class="p">};</span>

<span class="cm">/* the actual stopper, one per every possible cpu, enabled on online cpus */</span>
<span class="k">struct</span> <span class="n">cpu_stopper</span> <span class="p">{</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>
	<span class="n">bool</span>			<span class="n">enabled</span><span class="p">;</span>	<span class="cm">/* is this stopper enabled? */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">works</span><span class="p">;</span>		<span class="cm">/* list of pending works */</span>
	<span class="k">struct</span> <span class="n">task_struct</span>	<span class="o">*</span><span class="kr">thread</span><span class="p">;</span>	<span class="cm">/* stopper thread */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu_stopper</span><span class="p">,</span> <span class="n">cpu_stopper</span><span class="p">);</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">stop_machine_initialized</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cpu_stop_init_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu_stop_done</span> <span class="o">*</span><span class="n">done</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_todo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">done</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">done</span><span class="p">));</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">done</span><span class="o">-&gt;</span><span class="n">nr_todo</span><span class="p">,</span> <span class="n">nr_todo</span><span class="p">);</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">done</span><span class="o">-&gt;</span><span class="n">completion</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* signal completion unless @done is NULL */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cpu_stop_signal_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu_stop_done</span> <span class="o">*</span><span class="n">done</span><span class="p">,</span> <span class="n">bool</span> <span class="n">executed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">executed</span><span class="p">)</span>
			<span class="n">done</span><span class="o">-&gt;</span><span class="n">executed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">done</span><span class="o">-&gt;</span><span class="n">nr_todo</span><span class="p">))</span>
			<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">done</span><span class="o">-&gt;</span><span class="n">completion</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* queue @work to @stopper.  if offline, @work is completed immediately */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cpu_stop_queue_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu_stopper</span> <span class="o">*</span><span class="n">stopper</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">cpu_stop_work</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stopper</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stopper</span><span class="o">-&gt;</span><span class="n">enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stopper</span><span class="o">-&gt;</span><span class="n">works</span><span class="p">);</span>
		<span class="n">wake_up_process</span><span class="p">(</span><span class="n">stopper</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">cpu_stop_signal_done</span><span class="p">(</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stopper</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * stop_one_cpu - stop a cpu</span>
<span class="cm"> * @cpu: cpu to stop</span>
<span class="cm"> * @fn: function to execute</span>
<span class="cm"> * @arg: argument to @fn</span>
<span class="cm"> *</span>
<span class="cm"> * Execute @fn(@arg) on @cpu.  @fn is run in a process context with</span>
<span class="cm"> * the highest priority preempting any task on the cpu and</span>
<span class="cm"> * monopolizing it.  This function returns after the execution is</span>
<span class="cm"> * complete.</span>
<span class="cm"> *</span>
<span class="cm"> * This function doesn&#39;t guarantee @cpu stays online till @fn</span>
<span class="cm"> * completes.  If @cpu goes down in the middle, execution may happen</span>
<span class="cm"> * partially or fully on different cpus.  @fn should either be ready</span>
<span class="cm"> * for that or the caller should ensure that @cpu stays online until</span>
<span class="cm"> * this function completes.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * Might sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * -ENOENT if @fn(@arg) was not executed because @cpu was offline;</span>
<span class="cm"> * otherwise, the return value of @fn.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">stop_one_cpu</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_stop_fn_t</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_stop_done</span> <span class="n">done</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpu_stop_work</span> <span class="n">work</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">fn</span> <span class="o">=</span> <span class="n">fn</span><span class="p">,</span> <span class="p">.</span><span class="n">arg</span> <span class="o">=</span> <span class="n">arg</span><span class="p">,</span> <span class="p">.</span><span class="n">done</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">done</span> <span class="p">};</span>

	<span class="n">cpu_stop_init_done</span><span class="p">(</span><span class="o">&amp;</span><span class="n">done</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">cpu_stop_queue_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_stopper</span><span class="p">,</span> <span class="n">cpu</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">work</span><span class="p">);</span>
	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">done</span><span class="p">.</span><span class="n">completion</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">done</span><span class="p">.</span><span class="n">executed</span> <span class="o">?</span> <span class="n">done</span><span class="p">.</span><span class="n">ret</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * stop_one_cpu_nowait - stop a cpu but don&#39;t wait for completion</span>
<span class="cm"> * @cpu: cpu to stop</span>
<span class="cm"> * @fn: function to execute</span>
<span class="cm"> * @arg: argument to @fn</span>
<span class="cm"> *</span>
<span class="cm"> * Similar to stop_one_cpu() but doesn&#39;t wait for completion.  The</span>
<span class="cm"> * caller is responsible for ensuring @work_buf is currently unused</span>
<span class="cm"> * and will remain untouched until stopper starts executing @fn.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * Don&#39;t care.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">stop_one_cpu_nowait</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_stop_fn_t</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">cpu_stop_work</span> <span class="o">*</span><span class="n">work_buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">work_buf</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">cpu_stop_work</span><span class="p">){</span> <span class="p">.</span><span class="n">fn</span> <span class="o">=</span> <span class="n">fn</span><span class="p">,</span> <span class="p">.</span><span class="n">arg</span> <span class="o">=</span> <span class="n">arg</span><span class="p">,</span> <span class="p">};</span>
	<span class="n">cpu_stop_queue_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_stopper</span><span class="p">,</span> <span class="n">cpu</span><span class="p">),</span> <span class="n">work_buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* static data for stop_cpus */</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">stop_cpus_mutex</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu_stop_work</span><span class="p">,</span> <span class="n">stop_cpus_work</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">queue_stop_cpus_work</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpumask</span><span class="p">,</span>
				 <span class="n">cpu_stop_fn_t</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">cpu_stop_done</span> <span class="o">*</span><span class="n">done</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_stop_work</span> <span class="o">*</span><span class="n">work</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="cm">/* initialize works and done */</span>
	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpumask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">work</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">stop_cpus_work</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">work</span><span class="o">-&gt;</span><span class="n">fn</span> <span class="o">=</span> <span class="n">fn</span><span class="p">;</span>
		<span class="n">work</span><span class="o">-&gt;</span><span class="n">arg</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
		<span class="n">work</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">=</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Disable preemption while queueing to avoid getting</span>
<span class="cm">	 * preempted by a stopper which might wait for other stoppers</span>
<span class="cm">	 * to enter @fn which can lead to deadlock.</span>
<span class="cm">	 */</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpumask</span><span class="p">)</span>
		<span class="n">cpu_stop_queue_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_stopper</span><span class="p">,</span> <span class="n">cpu</span><span class="p">),</span>
				    <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">stop_cpus_work</span><span class="p">,</span> <span class="n">cpu</span><span class="p">));</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__stop_cpus</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpumask</span><span class="p">,</span>
		       <span class="n">cpu_stop_fn_t</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_stop_done</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">cpu_stop_init_done</span><span class="p">(</span><span class="o">&amp;</span><span class="n">done</span><span class="p">,</span> <span class="n">cpumask_weight</span><span class="p">(</span><span class="n">cpumask</span><span class="p">));</span>
	<span class="n">queue_stop_cpus_work</span><span class="p">(</span><span class="n">cpumask</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">done</span><span class="p">);</span>
	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">done</span><span class="p">.</span><span class="n">completion</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">done</span><span class="p">.</span><span class="n">executed</span> <span class="o">?</span> <span class="n">done</span><span class="p">.</span><span class="n">ret</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * stop_cpus - stop multiple cpus</span>
<span class="cm"> * @cpumask: cpus to stop</span>
<span class="cm"> * @fn: function to execute</span>
<span class="cm"> * @arg: argument to @fn</span>
<span class="cm"> *</span>
<span class="cm"> * Execute @fn(@arg) on online cpus in @cpumask.  On each target cpu,</span>
<span class="cm"> * @fn is run in a process context with the highest priority</span>
<span class="cm"> * preempting any task on the cpu and monopolizing it.  This function</span>
<span class="cm"> * returns after all executions are complete.</span>
<span class="cm"> *</span>
<span class="cm"> * This function doesn&#39;t guarantee the cpus in @cpumask stay online</span>
<span class="cm"> * till @fn completes.  If some cpus go down in the middle, execution</span>
<span class="cm"> * on the cpu may happen partially or fully on different cpus.  @fn</span>
<span class="cm"> * should either be ready for that or the caller should ensure that</span>
<span class="cm"> * the cpus stay online until this function completes.</span>
<span class="cm"> *</span>
<span class="cm"> * All stop_cpus() calls are serialized making it safe for @fn to wait</span>
<span class="cm"> * for all cpus to start executing it.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * Might sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * -ENOENT if @fn(@arg) was not executed at all because all cpus in</span>
<span class="cm"> * @cpumask were offline; otherwise, 0 if all executions of @fn</span>
<span class="cm"> * returned 0, any non zero return value if any returned non zero.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">stop_cpus</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpumask</span><span class="p">,</span> <span class="n">cpu_stop_fn_t</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* static works are used, process one request at a time */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stop_cpus_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__stop_cpus</span><span class="p">(</span><span class="n">cpumask</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stop_cpus_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * try_stop_cpus - try to stop multiple cpus</span>
<span class="cm"> * @cpumask: cpus to stop</span>
<span class="cm"> * @fn: function to execute</span>
<span class="cm"> * @arg: argument to @fn</span>
<span class="cm"> *</span>
<span class="cm"> * Identical to stop_cpus() except that it fails with -EAGAIN if</span>
<span class="cm"> * someone else is already using the facility.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * Might sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * -EAGAIN if someone else is already stopping cpus, -ENOENT if</span>
<span class="cm"> * @fn(@arg) was not executed at all because all cpus in @cpumask were</span>
<span class="cm"> * offline; otherwise, 0 if all executions of @fn returned 0, any non</span>
<span class="cm"> * zero return value if any returned non zero.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">try_stop_cpus</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpumask</span><span class="p">,</span> <span class="n">cpu_stop_fn_t</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* static works are used, process one request at a time */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stop_cpus_mutex</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__stop_cpus</span><span class="p">(</span><span class="n">cpumask</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stop_cpus_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cpu_stopper_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_stopper</span> <span class="o">*</span><span class="n">stopper</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpu_stop_work</span> <span class="o">*</span><span class="n">work</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">repeat:</span>
	<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>	<span class="cm">/* mb paired w/ kthread_stop */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kthread_should_stop</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">work</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stopper</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stopper</span><span class="o">-&gt;</span><span class="n">works</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">work</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stopper</span><span class="o">-&gt;</span><span class="n">works</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">cpu_stop_work</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stopper</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">work</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpu_stop_fn_t</span> <span class="n">fn</span> <span class="o">=</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">fn</span><span class="p">;</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span> <span class="o">=</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">arg</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">cpu_stop_done</span> <span class="o">*</span><span class="n">done</span> <span class="o">=</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">;</span>
		<span class="kt">char</span> <span class="n">ksym_buf</span><span class="p">[</span><span class="n">KSYM_NAME_LEN</span><span class="p">]</span> <span class="n">__maybe_unused</span><span class="p">;</span>

		<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>

		<span class="cm">/* cpu stop callbacks are not allowed to sleep */</span>
		<span class="n">preempt_disable</span><span class="p">();</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">done</span><span class="o">-&gt;</span><span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>

		<span class="cm">/* restore preemption and check it&#39;s still balanced */</span>
		<span class="n">preempt_enable</span><span class="p">();</span>
		<span class="n">WARN_ONCE</span><span class="p">(</span><span class="n">preempt_count</span><span class="p">(),</span>
			  <span class="s">&quot;cpu_stop: %s(%p) leaked preempt count</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">kallsyms_lookup</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">fn</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					  <span class="n">ksym_buf</span><span class="p">),</span> <span class="n">arg</span><span class="p">);</span>

		<span class="n">cpu_stop_signal_done</span><span class="p">(</span><span class="n">done</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">schedule</span><span class="p">();</span>

	<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">sched_set_stop_task</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">stop</span><span class="p">);</span>

<span class="cm">/* manage stopper for a cpu, mostly lifted from sched migration thread mgmt */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">cpu_stop_cpu_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nfb</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">hcpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpu_stopper</span> <span class="o">*</span><span class="n">stopper</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_stopper</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CPU_TASKS_FROZEN</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_UP_PREPARE</span>:
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">stopper</span><span class="o">-&gt;</span><span class="kr">thread</span> <span class="o">||</span> <span class="n">stopper</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">||</span>
		       <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stopper</span><span class="o">-&gt;</span><span class="n">works</span><span class="p">));</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">kthread_create_on_node</span><span class="p">(</span><span class="n">cpu_stopper_thread</span><span class="p">,</span>
					   <span class="n">stopper</span><span class="p">,</span>
					   <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">),</span>
					   <span class="s">&quot;migration/%d&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">notifier_from_errno</span><span class="p">(</span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
		<span class="n">get_task_struct</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">kthread_bind</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">sched_set_stop_task</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="n">stopper</span><span class="o">-&gt;</span><span class="kr">thread</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CPU_ONLINE</span>:
		<span class="cm">/* strictly unnecessary, as first user will wake it */</span>
		<span class="n">wake_up_process</span><span class="p">(</span><span class="n">stopper</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">);</span>
		<span class="cm">/* mark enabled */</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stopper</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">stopper</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stopper</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
	<span class="k">case</span> <span class="n">CPU_UP_CANCELED</span>:
	<span class="k">case</span> <span class="n">CPU_POST_DEAD</span>:
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">cpu_stop_work</span> <span class="o">*</span><span class="n">work</span><span class="p">;</span>

		<span class="n">sched_set_stop_task</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="cm">/* kill the stopper */</span>
		<span class="n">kthread_stop</span><span class="p">(</span><span class="n">stopper</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">);</span>
		<span class="cm">/* drain remaining works */</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stopper</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stopper</span><span class="o">-&gt;</span><span class="n">works</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
			<span class="n">cpu_stop_signal_done</span><span class="p">(</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="n">stopper</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stopper</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="cm">/* release the stopper */</span>
		<span class="n">put_task_struct</span><span class="p">(</span><span class="n">stopper</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">);</span>
		<span class="n">stopper</span><span class="o">-&gt;</span><span class="kr">thread</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Give it a higher priority so that cpu stopper is available to other</span>
<span class="cm"> * cpu notifiers.  It currently shares the same priority as sched</span>
<span class="cm"> * migration_notifier.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">__cpuinitdata</span> <span class="n">cpu_stop_cpu_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span>	<span class="o">=</span> <span class="n">cpu_stop_cpu_callback</span><span class="p">,</span>
	<span class="p">.</span><span class="n">priority</span>	<span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">cpu_stop_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">bcpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">long</span><span class="p">)</span><span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cpu_stopper</span> <span class="o">*</span><span class="n">stopper</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_stopper</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stopper</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stopper</span><span class="o">-&gt;</span><span class="n">works</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* start one for the boot cpu */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">cpu_stop_cpu_callback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_stop_cpu_notifier</span><span class="p">,</span> <span class="n">CPU_UP_PREPARE</span><span class="p">,</span>
				    <span class="n">bcpu</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="n">NOTIFY_OK</span><span class="p">);</span>
	<span class="n">cpu_stop_cpu_callback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_stop_cpu_notifier</span><span class="p">,</span> <span class="n">CPU_ONLINE</span><span class="p">,</span> <span class="n">bcpu</span><span class="p">);</span>
	<span class="n">register_cpu_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_stop_cpu_notifier</span><span class="p">);</span>

	<span class="n">stop_machine_initialized</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_initcall</span><span class="p">(</span><span class="n">cpu_stop_init</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_STOP_MACHINE</span>

<span class="cm">/* This controls the threads on each CPU. */</span>
<span class="k">enum</span> <span class="n">stopmachine_state</span> <span class="p">{</span>
	<span class="cm">/* Dummy starting state for thread. */</span>
	<span class="n">STOPMACHINE_NONE</span><span class="p">,</span>
	<span class="cm">/* Awaiting everyone to be scheduled. */</span>
	<span class="n">STOPMACHINE_PREPARE</span><span class="p">,</span>
	<span class="cm">/* Disable interrupts. */</span>
	<span class="n">STOPMACHINE_DISABLE_IRQ</span><span class="p">,</span>
	<span class="cm">/* Run the function */</span>
	<span class="n">STOPMACHINE_RUN</span><span class="p">,</span>
	<span class="cm">/* Exit */</span>
	<span class="n">STOPMACHINE_EXIT</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">stop_machine_data</span> <span class="p">{</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="cm">/* Like num_online_cpus(), but hotplug cpu uses us, so we need this. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">num_threads</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span>	<span class="o">*</span><span class="n">active_cpus</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">stopmachine_state</span>	<span class="n">state</span><span class="p">;</span>
	<span class="n">atomic_t</span>		<span class="n">thread_ack</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">stop_machine_data</span> <span class="o">*</span><span class="n">smdata</span><span class="p">,</span>
		      <span class="k">enum</span> <span class="n">stopmachine_state</span> <span class="n">newstate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Reset ack counter. */</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smdata</span><span class="o">-&gt;</span><span class="n">thread_ack</span><span class="p">,</span> <span class="n">smdata</span><span class="o">-&gt;</span><span class="n">num_threads</span><span class="p">);</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">smdata</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">newstate</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Last one to ack a state moves to the next state. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ack_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">stop_machine_data</span> <span class="o">*</span><span class="n">smdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smdata</span><span class="o">-&gt;</span><span class="n">thread_ack</span><span class="p">))</span>
		<span class="n">set_state</span><span class="p">(</span><span class="n">smdata</span><span class="p">,</span> <span class="n">smdata</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This is the cpu_stop function which stops the CPU. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">stop_machine_cpu_stop</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">stop_machine_data</span> <span class="o">*</span><span class="n">smdata</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">stopmachine_state</span> <span class="n">curstate</span> <span class="o">=</span> <span class="n">STOPMACHINE_NONE</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">(),</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">is_active</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * When called from stop_machine_from_inactive_cpu(), irq might</span>
<span class="cm">	 * already be disabled.  Save the state and restore it on exit.</span>
<span class="cm">	 */</span>
	<span class="n">local_save_flags</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smdata</span><span class="o">-&gt;</span><span class="n">active_cpus</span><span class="p">)</span>
		<span class="n">is_active</span> <span class="o">=</span> <span class="n">cpu</span> <span class="o">==</span> <span class="n">cpumask_first</span><span class="p">(</span><span class="n">cpu_online_mask</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">is_active</span> <span class="o">=</span> <span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">smdata</span><span class="o">-&gt;</span><span class="n">active_cpus</span><span class="p">);</span>

	<span class="cm">/* Simple state machine */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* Chill out and ensure we re-read stopmachine_state. */</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">smdata</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">curstate</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">curstate</span> <span class="o">=</span> <span class="n">smdata</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">curstate</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">STOPMACHINE_DISABLE_IRQ</span>:
				<span class="n">local_irq_disable</span><span class="p">();</span>
				<span class="n">hard_irq_disable</span><span class="p">();</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">STOPMACHINE_RUN</span>:
				<span class="k">if</span> <span class="p">(</span><span class="n">is_active</span><span class="p">)</span>
					<span class="n">err</span> <span class="o">=</span> <span class="n">smdata</span><span class="o">-&gt;</span><span class="n">fn</span><span class="p">(</span><span class="n">smdata</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ack_state</span><span class="p">(</span><span class="n">smdata</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">curstate</span> <span class="o">!=</span> <span class="n">STOPMACHINE_EXIT</span><span class="p">);</span>

	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">__stop_machine</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">stop_machine_data</span> <span class="n">smdata</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">fn</span> <span class="o">=</span> <span class="n">fn</span><span class="p">,</span> <span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">,</span>
					    <span class="p">.</span><span class="n">num_threads</span> <span class="o">=</span> <span class="n">num_online_cpus</span><span class="p">(),</span>
					    <span class="p">.</span><span class="n">active_cpus</span> <span class="o">=</span> <span class="n">cpus</span> <span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stop_machine_initialized</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Handle the case where stop_machine() is called</span>
<span class="cm">		 * early in boot before stop_machine() has been</span>
<span class="cm">		 * initialized.</span>
<span class="cm">		 */</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">smdata</span><span class="p">.</span><span class="n">num_threads</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">hard_irq_disable</span><span class="p">();</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="n">data</span><span class="p">);</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set the initial state and stop all online cpus. */</span>
	<span class="n">set_state</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smdata</span><span class="p">,</span> <span class="n">STOPMACHINE_PREPARE</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">stop_cpus</span><span class="p">(</span><span class="n">cpu_online_mask</span><span class="p">,</span> <span class="n">stop_machine_cpu_stop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smdata</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">stop_machine</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* No CPUs can come up or down during this. */</span>
	<span class="n">get_online_cpus</span><span class="p">();</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__stop_machine</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">cpus</span><span class="p">);</span>
	<span class="n">put_online_cpus</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">stop_machine</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * stop_machine_from_inactive_cpu - stop_machine() from inactive CPU</span>
<span class="cm"> * @fn: the function to run</span>
<span class="cm"> * @data: the data ptr for the @fn()</span>
<span class="cm"> * @cpus: the cpus to run the @fn() on (NULL = any online cpu)</span>
<span class="cm"> *</span>
<span class="cm"> * This is identical to stop_machine() but can be called from a CPU which</span>
<span class="cm"> * is not active.  The local CPU is in the process of hotplug (so no other</span>
<span class="cm"> * CPU hotplug can start) and not marked active and doesn&#39;t have enough</span>
<span class="cm"> * context to sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * This function provides stop_machine() functionality for such state by</span>
<span class="cm"> * using busy-wait for synchronization and executing @fn directly for local</span>
<span class="cm"> * CPU.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * Local CPU is inactive.  Temporarily stops all active CPUs.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * 0 if all executions of @fn returned 0, any non zero return value if any</span>
<span class="cm"> * returned non zero.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">stop_machine_from_inactive_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">stop_machine_data</span> <span class="n">smdata</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">fn</span> <span class="o">=</span> <span class="n">fn</span><span class="p">,</span> <span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">,</span>
					    <span class="p">.</span><span class="n">active_cpus</span> <span class="o">=</span> <span class="n">cpus</span> <span class="p">};</span>
	<span class="k">struct</span> <span class="n">cpu_stop_done</span> <span class="n">done</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Local CPU must be inactive and CPU hotplug in progress. */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cpu_active</span><span class="p">(</span><span class="n">raw_smp_processor_id</span><span class="p">()));</span>
	<span class="n">smdata</span><span class="p">.</span><span class="n">num_threads</span> <span class="o">=</span> <span class="n">num_active_cpus</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* +1 for local */</span>

	<span class="cm">/* No proper task established and can&#39;t sleep - busy wait for lock. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stop_cpus_mutex</span><span class="p">))</span>
		<span class="n">cpu_relax</span><span class="p">();</span>

	<span class="cm">/* Schedule work on other CPUs and execute directly for local CPU */</span>
	<span class="n">set_state</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smdata</span><span class="p">,</span> <span class="n">STOPMACHINE_PREPARE</span><span class="p">);</span>
	<span class="n">cpu_stop_init_done</span><span class="p">(</span><span class="o">&amp;</span><span class="n">done</span><span class="p">,</span> <span class="n">num_active_cpus</span><span class="p">());</span>
	<span class="n">queue_stop_cpus_work</span><span class="p">(</span><span class="n">cpu_active_mask</span><span class="p">,</span> <span class="n">stop_machine_cpu_stop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smdata</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">done</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">stop_machine_cpu_stop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smdata</span><span class="p">);</span>

	<span class="cm">/* Busy wait for completion. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">completion_done</span><span class="p">(</span><span class="o">&amp;</span><span class="n">done</span><span class="p">.</span><span class="n">completion</span><span class="p">))</span>
		<span class="n">cpu_relax</span><span class="p">();</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stop_cpus_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span> <span class="o">?:</span> <span class="n">done</span><span class="p">.</span><span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif	</span><span class="cm">/* CONFIG_STOP_MACHINE */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
