<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › trace › trace_events.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>trace_events.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * event tracer</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2008 Red Hat Inc, Steven Rostedt &lt;srostedt@redhat.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  - Added format output of fields of the trace point.</span>
<span class="cm"> *    This was based off of work by Tom Zanussi &lt;tzanussi@gmail.com&gt;.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>

<span class="cp">#include &lt;asm/setup.h&gt;</span>

<span class="cp">#include &quot;trace_output.h&quot;</span>

<span class="cp">#undef TRACE_SYSTEM</span>
<span class="cp">#define TRACE_SYSTEM &quot;TRACE_SYSTEM&quot;</span>

<span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">event_mutex</span><span class="p">);</span>

<span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">event_storage_mutex</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">event_storage_mutex</span><span class="p">);</span>

<span class="kt">char</span> <span class="n">event_storage</span><span class="p">[</span><span class="n">EVENT_STORAGE_SIZE</span><span class="p">];</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">event_storage</span><span class="p">);</span>

<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">ftrace_events</span><span class="p">);</span>
<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">ftrace_common_fields</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span>
<span class="nf">trace_get_fields</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">event_call</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event_call</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">get_fields</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">event_call</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">fields</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">event_call</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">get_fields</span><span class="p">(</span><span class="n">event_call</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__trace_define_field</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">is_signed</span><span class="p">,</span> <span class="kt">int</span> <span class="n">filter_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_event_field</span> <span class="o">*</span><span class="n">field</span><span class="p">;</span>

	<span class="n">field</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">field</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">field</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">field</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">field</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">field</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">field</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">filter_type</span> <span class="o">==</span> <span class="n">FILTER_OTHER</span><span class="p">)</span>
		<span class="n">field</span><span class="o">-&gt;</span><span class="n">filter_type</span> <span class="o">=</span> <span class="n">filter_assign_type</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">field</span><span class="o">-&gt;</span><span class="n">filter_type</span> <span class="o">=</span> <span class="n">filter_type</span><span class="p">;</span>

	<span class="n">field</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">field</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">field</span><span class="o">-&gt;</span><span class="n">is_signed</span> <span class="o">=</span> <span class="n">is_signed</span><span class="p">;</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">field</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">field</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">field</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">field</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">trace_define_field</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span>
		       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_signed</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">filter_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">head</span> <span class="o">=</span> <span class="n">trace_get_fields</span><span class="p">(</span><span class="n">call</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">__trace_define_field</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
				    <span class="n">is_signed</span><span class="p">,</span> <span class="n">filter_type</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">trace_define_field</span><span class="p">);</span>

<span class="cp">#define __common_field(type, item)					\</span>
<span class="cp">	ret = __trace_define_field(&amp;ftrace_common_fields, #type,	\</span>
<span class="cp">				   &quot;common_&quot; #item,			\</span>
<span class="cp">				   offsetof(typeof(ent), item),		\</span>
<span class="cp">				   sizeof(ent.item),			\</span>
<span class="cp">				   is_signed_type(type), FILTER_OTHER);	\</span>
<span class="cp">	if (ret)							\</span>
<span class="cp">		return ret;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">trace_define_common_fields</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">trace_entry</span> <span class="n">ent</span><span class="p">;</span>

	<span class="n">__common_field</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="n">__common_field</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__common_field</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">,</span> <span class="n">preempt_count</span><span class="p">);</span>
	<span class="n">__common_field</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
	<span class="n">__common_field</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">trace_destroy_fields</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_event_field</span> <span class="o">*</span><span class="n">field</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>

	<span class="n">head</span> <span class="o">=</span> <span class="n">trace_get_fields</span><span class="p">(</span><span class="n">call</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">field</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">field</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">field</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">field</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">trace_event_raw_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">id</span><span class="p">;</span>

	<span class="n">id</span> <span class="o">=</span> <span class="n">register_ftrace_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">id</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">trace_event_raw_init</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">ftrace_event_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span><span class="p">,</span>
		     <span class="k">enum</span> <span class="n">trace_reg</span> <span class="n">type</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TRACE_REG_REGISTER</span>:
		<span class="k">return</span> <span class="n">tracepoint_probe_register</span><span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
						 <span class="n">call</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">,</span>
						 <span class="n">call</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">TRACE_REG_UNREGISTER</span>:
		<span class="n">tracepoint_probe_unregister</span><span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
					    <span class="n">call</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">,</span>
					    <span class="n">call</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PERF_EVENTS</span>
	<span class="k">case</span> <span class="n">TRACE_REG_PERF_REGISTER</span>:
		<span class="k">return</span> <span class="n">tracepoint_probe_register</span><span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
						 <span class="n">call</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">perf_probe</span><span class="p">,</span>
						 <span class="n">call</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">TRACE_REG_PERF_UNREGISTER</span>:
		<span class="n">tracepoint_probe_unregister</span><span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
					    <span class="n">call</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">perf_probe</span><span class="p">,</span>
					    <span class="n">call</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TRACE_REG_PERF_OPEN</span>:
	<span class="k">case</span> <span class="n">TRACE_REG_PERF_CLOSE</span>:
	<span class="k">case</span> <span class="n">TRACE_REG_PERF_ADD</span>:
	<span class="k">case</span> <span class="n">TRACE_REG_PERF_DEL</span>:
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ftrace_event_reg</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">trace_event_enable_cmd_record</span><span class="p">(</span><span class="n">bool</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event_mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ftrace_events</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TRACE_EVENT_FL_ENABLED</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tracing_start_cmdline_record</span><span class="p">();</span>
			<span class="n">call</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">TRACE_EVENT_FL_RECORDED_CMD</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">tracing_stop_cmdline_record</span><span class="p">();</span>
			<span class="n">call</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TRACE_EVENT_FL_RECORDED_CMD</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ftrace_event_enable_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TRACE_EVENT_FL_ENABLED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">call</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TRACE_EVENT_FL_ENABLED</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TRACE_EVENT_FL_RECORDED_CMD</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tracing_stop_cmdline_record</span><span class="p">();</span>
				<span class="n">call</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TRACE_EVENT_FL_RECORDED_CMD</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">call</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="n">TRACE_REG_UNREGISTER</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TRACE_EVENT_FL_ENABLED</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">trace_flags</span> <span class="o">&amp;</span> <span class="n">TRACE_ITER_RECORD_CMD</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tracing_start_cmdline_record</span><span class="p">();</span>
				<span class="n">call</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">TRACE_EVENT_FL_RECORDED_CMD</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">call</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="n">TRACE_REG_REGISTER</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tracing_stop_cmdline_record</span><span class="p">();</span>
				<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;event trace: Could not enable event &quot;</span>
					<span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">call</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">call</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">TRACE_EVENT_FL_ENABLED</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ftrace_clear_events</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event_mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ftrace_events</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ftrace_event_enable_disable</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__put_system</span><span class="p">(</span><span class="k">struct</span> <span class="n">event_subsystem</span> <span class="o">*</span><span class="n">system</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">event_filter</span> <span class="o">*</span><span class="n">filter</span> <span class="o">=</span> <span class="n">system</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">;</span>

	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">system</span><span class="o">-&gt;</span><span class="n">ref_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">system</span><span class="o">-&gt;</span><span class="n">ref_count</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">filter</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">filter</span><span class="o">-&gt;</span><span class="n">filter_string</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">filter</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">system</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">system</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__get_system</span><span class="p">(</span><span class="k">struct</span> <span class="n">event_subsystem</span> <span class="o">*</span><span class="n">system</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">system</span><span class="o">-&gt;</span><span class="n">ref_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">system</span><span class="o">-&gt;</span><span class="n">ref_count</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">put_system</span><span class="p">(</span><span class="k">struct</span> <span class="n">event_subsystem</span> <span class="o">*</span><span class="n">system</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event_mutex</span><span class="p">);</span>
	<span class="n">__put_system</span><span class="p">(</span><span class="n">system</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * __ftrace_set_clr_event(NULL, NULL, NULL, set) will set/unset all events.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__ftrace_set_clr_event</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">match</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sub</span><span class="p">,</span>
				  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event_mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ftrace_events</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">||</span> <span class="o">!</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">||</span> <span class="o">!</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TRACE_EVENT_FL_IGNORE_ENABLE</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">match</span> <span class="o">&amp;&amp;</span>
		    <span class="n">strcmp</span><span class="p">(</span><span class="n">match</span><span class="p">,</span> <span class="n">call</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">strcmp</span><span class="p">(</span><span class="n">match</span><span class="p">,</span> <span class="n">call</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">system</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sub</span> <span class="o">&amp;&amp;</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">call</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">system</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">&amp;&amp;</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">call</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">ftrace_event_enable_disable</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="n">set</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ftrace_set_clr_event</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">event</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">sub</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">match</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The buf format can be &lt;subsystem&gt;:&lt;event-name&gt;</span>
<span class="cm">	 *  *:&lt;event-name&gt; means any event by that name.</span>
<span class="cm">	 *  :&lt;event-name&gt; is the same.</span>
<span class="cm">	 *</span>
<span class="cm">	 *  &lt;subsystem&gt;:* means all events in that subsystem</span>
<span class="cm">	 *  &lt;subsystem&gt;: means the same.</span>
<span class="cm">	 *</span>
<span class="cm">	 *  &lt;name&gt; (no &#39;:&#39;) means all events in a subsystem with</span>
<span class="cm">	 *  the name &lt;name&gt; or any event that matches &lt;name&gt;</span>
<span class="cm">	 */</span>

	<span class="n">match</span> <span class="o">=</span> <span class="n">strsep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;:&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sub</span> <span class="o">=</span> <span class="n">match</span><span class="p">;</span>
		<span class="n">event</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
		<span class="n">match</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strlen</span><span class="p">(</span><span class="n">sub</span><span class="p">)</span> <span class="o">||</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="s">&quot;*&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">sub</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strlen</span><span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="o">||</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="s">&quot;*&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">event</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">__ftrace_set_clr_event</span><span class="p">(</span><span class="n">match</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">set</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * trace_set_clr_event - enable or disable an event</span>
<span class="cm"> * @system: system name to match (NULL for any system)</span>
<span class="cm"> * @event: event name to match (NULL for all events, within system)</span>
<span class="cm"> * @set: 1 to enable, 0 to disable</span>
<span class="cm"> *</span>
<span class="cm"> * This is a way for other parts of the kernel to enable or disable</span>
<span class="cm"> * event recording.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, -EINVAL if the parameters do not match any</span>
<span class="cm"> * registered events.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">trace_set_clr_event</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">system</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__ftrace_set_clr_event</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">system</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">set</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">trace_set_clr_event</span><span class="p">);</span>

<span class="cm">/* 128 should be much more than enough */</span>
<span class="cp">#define EVENT_BUF_SIZE		127</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">ftrace_event_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
		   <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trace_parser</span> <span class="n">parser</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">read</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cnt</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">tracing_update_buffers</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trace_parser_get_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parser</span><span class="p">,</span> <span class="n">EVENT_BUF_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">read</span> <span class="o">=</span> <span class="n">trace_get_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parser</span><span class="p">,</span> <span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">read</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">trace_parser_loaded</span><span class="p">((</span><span class="o">&amp;</span><span class="n">parser</span><span class="p">)))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">set</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">parser</span><span class="p">.</span><span class="n">buffer</span> <span class="o">==</span> <span class="sc">&#39;!&#39;</span><span class="p">)</span>
			<span class="n">set</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">parser</span><span class="p">.</span><span class="n">buffer</span><span class="p">[</span><span class="n">parser</span><span class="p">.</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">ftrace_set_clr_event</span><span class="p">(</span><span class="n">parser</span><span class="p">.</span><span class="n">buffer</span> <span class="o">+</span> <span class="o">!</span><span class="n">set</span><span class="p">,</span> <span class="n">set</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">read</span><span class="p">;</span>

 <span class="nl">out_put:</span>
	<span class="n">trace_parser_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parser</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">t_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>

	<span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>

	<span class="n">list_for_each_entry_continue</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ftrace_events</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The ftrace subsystem is for showing formats only.</span>
<span class="cm">		 * They can not be enabled or disabled via the event files.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">&amp;&amp;</span> <span class="n">call</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">call</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">t_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">l</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event_mutex</span><span class="p">);</span>

	<span class="n">call</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_events</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ftrace_event_call</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">l</span> <span class="o">&lt;=</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">call</span> <span class="o">=</span> <span class="n">t_next</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">call</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">call</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">call</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">s_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>

	<span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>

	<span class="n">list_for_each_entry_continue</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ftrace_events</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TRACE_EVENT_FL_ENABLED</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">call</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">s_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">l</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event_mutex</span><span class="p">);</span>

	<span class="n">call</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_events</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ftrace_event_call</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">l</span> <span class="o">&lt;=</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">call</span> <span class="o">=</span> <span class="n">s_next</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">call</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">call</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">call</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">t_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">system</span><span class="p">,</span> <span class="n">TRACE_SYSTEM</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%s:&quot;</span><span class="p">,</span> <span class="n">call</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">system</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">call</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">t_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ftrace_event_seq_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="o">*</span><span class="n">seq_ops</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_TRUNC</span><span class="p">))</span>
		<span class="n">ftrace_clear_events</span><span class="p">();</span>

	<span class="n">seq_ops</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">seq_ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">event_enable_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span>
		  <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TRACE_EVENT_FL_ENABLED</span><span class="p">)</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="s">&quot;1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="s">&quot;0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">event_enable_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span>
		   <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">kstrtoul_from_user</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">tracing_update_buffers</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event_mutex</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ftrace_event_enable_disable</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event_mutex</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">ppos</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">system_enable_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span>
		   <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="n">set_to_char</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="sc">&#39;?&#39;</span><span class="p">,</span> <span class="sc">&#39;0&#39;</span><span class="p">,</span> <span class="sc">&#39;1&#39;</span><span class="p">,</span> <span class="sc">&#39;X&#39;</span> <span class="p">};</span>
	<span class="k">struct</span> <span class="n">event_subsystem</span> <span class="o">*</span><span class="n">system</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">set</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event_mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ftrace_events</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">||</span> <span class="o">!</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">||</span> <span class="o">!</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">system</span> <span class="o">&amp;&amp;</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">system</span><span class="p">,</span> <span class="n">system</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We need to find out if all the events are set</span>
<span class="cm">		 * or if all events or cleared, or if we have</span>
<span class="cm">		 * a mixture.</span>
<span class="cm">		 */</span>
		<span class="n">set</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="o">!!</span><span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TRACE_EVENT_FL_ENABLED</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * If we have a mixture, no need to look further.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">set</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event_mutex</span><span class="p">);</span>

	<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">set_to_char</span><span class="p">[</span><span class="n">set</span><span class="p">];</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">system_enable_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span>
		    <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">event_subsystem</span> <span class="o">*</span><span class="n">system</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">kstrtoul_from_user</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">tracing_update_buffers</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">val</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Opening of &quot;enable&quot; adds a ref count to system,</span>
<span class="cm">	 * so the name is safe to use.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">system</span><span class="p">)</span>
		<span class="n">name</span> <span class="o">=</span> <span class="n">system</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__ftrace_set_clr_event</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="o">*</span><span class="n">ppos</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">FORMAT_HEADER</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">FORMAT_FIELD_SEPERATOR</span>	<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">FORMAT_PRINTFMT</span>		<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">f_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_event_field</span> <span class="o">*</span><span class="n">field</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">common_head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ftrace_common_fields</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">trace_get_fields</span><span class="p">(</span><span class="n">call</span><span class="p">);</span>

	<span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FORMAT_HEADER</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="n">common_head</span><span class="p">)))</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">field</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">common_head</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">ftrace_event_field</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">field</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FORMAT_FIELD_SEPERATOR</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="n">head</span><span class="p">)))</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">field</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ftrace_event_field</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">field</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FORMAT_PRINTFMT</span>:
		<span class="cm">/* all done */</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">field</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">field</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">prev</span> <span class="o">==</span> <span class="n">common_head</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">FORMAT_FIELD_SEPERATOR</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">field</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">prev</span> <span class="o">==</span> <span class="n">head</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">FORMAT_PRINTFMT</span><span class="p">;</span>

	<span class="n">field</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">field</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ftrace_event_field</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">field</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">f_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">loff_t</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="cm">/* Start by showing the header */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">pos</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">FORMAT_HEADER</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">FORMAT_HEADER</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">f_next</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">pos</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">f_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_event_field</span> <span class="o">*</span><span class="n">field</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">array_descriptor</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FORMAT_HEADER</span>:
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;name: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">call</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;ID: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">call</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">type</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;format:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FORMAT_FIELD_SEPERATOR</span>:
		<span class="n">seq_putc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FORMAT_PRINTFMT</span>:
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">print fmt: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">call</span><span class="o">-&gt;</span><span class="n">print_fmt</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">field</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Smartly shows the array type(except dynamic array).</span>
<span class="cm">	 * Normal:</span>
<span class="cm">	 *	field:TYPE VAR</span>
<span class="cm">	 * If TYPE := TYPE[LEN], it is shown:</span>
<span class="cm">	 *	field:TYPE VAR[LEN]</span>
<span class="cm">	 */</span>
	<span class="n">array_descriptor</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">field</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="sc">&#39;[&#39;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">field</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="s">&quot;__data_loc&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
		<span class="n">array_descriptor</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">array_descriptor</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">field:%s %s;</span><span class="se">\t</span><span class="s">offset:%u;</span><span class="se">\t</span><span class="s">size:%u;</span><span class="se">\t</span><span class="s">signed:%d;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">field</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span>
			   <span class="n">field</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="o">!!</span><span class="n">field</span><span class="o">-&gt;</span><span class="n">is_signed</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">field:%.*s %s%s;</span><span class="se">\t</span><span class="s">offset:%u;</span><span class="se">\t</span><span class="s">size:%u;</span><span class="se">\t</span><span class="s">signed:%d;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">array_descriptor</span> <span class="o">-</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">),</span>
			   <span class="n">field</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			   <span class="n">array_descriptor</span><span class="p">,</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span>
			   <span class="n">field</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="o">!!</span><span class="n">field</span><span class="o">-&gt;</span><span class="n">is_signed</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">f_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">trace_format_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span>		<span class="o">=</span> <span class="n">f_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>		<span class="o">=</span> <span class="n">f_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>		<span class="o">=</span> <span class="n">f_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>		<span class="o">=</span> <span class="n">f_show</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">trace_format_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trace_format_seq_ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">m</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">call</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">event_id_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">trace_seq</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">trace_seq_init</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="n">trace_seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">call</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">type</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span>
				    <span class="n">s</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">event_filter_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span>
		  <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">trace_seq</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">trace_seq_init</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

	<span class="n">print_event_filter</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">event_filter_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span>
		   <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_TEMPORARY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">buf</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">apply_event_filter</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">buf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="o">*</span><span class="n">ppos</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">event_subsystems</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">subsystem_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">event_subsystem</span> <span class="o">*</span><span class="n">system</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">skip_search</span><span class="p">;</span>

	<span class="cm">/* Make sure the system still exists */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event_mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event_subsystems</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">system</span> <span class="o">==</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Don&#39;t open systems with no events */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">system</span><span class="o">-&gt;</span><span class="n">nr_events</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">system</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">__get_system</span><span class="p">(</span><span class="n">system</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">system</span> <span class="o">!=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

 <span class="nl">skip_search:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">tracing_open_generic</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">filp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">system</span><span class="p">)</span>
		<span class="n">put_system</span><span class="p">(</span><span class="n">system</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">subsystem_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">event_subsystem</span> <span class="o">*</span><span class="n">system</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">system</span><span class="p">)</span>
		<span class="n">put_system</span><span class="p">(</span><span class="n">system</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">subsystem_filter_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span>
		      <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">event_subsystem</span> <span class="o">*</span><span class="n">system</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">trace_seq</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">trace_seq_init</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

	<span class="n">print_subsystem_event_filter</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">subsystem_filter_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span>
		       <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">event_subsystem</span> <span class="o">*</span><span class="n">system</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_TEMPORARY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">buf</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">apply_subsystem_event_filter</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">buf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="o">*</span><span class="n">ppos</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">show_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="k">struct</span> <span class="n">trace_seq</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">trace_seq</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">trace_seq_init</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

	<span class="n">func</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">show_event_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">t_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">t_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span> <span class="o">=</span> <span class="n">t_show</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span> <span class="o">=</span> <span class="n">t_stop</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">show_set_event_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">s_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">s_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span> <span class="o">=</span> <span class="n">t_show</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span> <span class="o">=</span> <span class="n">t_stop</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ftrace_avail_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">ftrace_event_seq_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">seq_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ftrace_set_event_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">ftrace_event_seq_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">ftrace_event_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">seq_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ftrace_enable_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">tracing_open_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">event_enable_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">event_enable_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">default_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ftrace_event_format_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">trace_format_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">seq_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ftrace_event_id_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">tracing_open_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">event_id_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">default_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ftrace_event_filter_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">tracing_open_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">event_filter_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">event_filter_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">default_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ftrace_subsystem_filter_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">subsystem_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">subsystem_filter_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">subsystem_filter_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">default_llseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">subsystem_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ftrace_system_enable_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">subsystem_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">system_enable_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">system_enable_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">default_llseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">subsystem_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ftrace_show_header_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">tracing_open_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">show_header</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">default_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">event_trace_events_dir</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d_tracer</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d_events</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">d_events</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">d_events</span><span class="p">;</span>

	<span class="n">d_tracer</span> <span class="o">=</span> <span class="n">tracing_init_dentry</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d_tracer</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">d_events</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="s">&quot;events&quot;</span><span class="p">,</span> <span class="n">d_tracer</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d_events</span><span class="p">)</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Could not create debugfs &quot;</span>
			   <span class="s">&quot;&#39;events&#39; directory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">d_events</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span>
<span class="nf">event_subsystem_dir</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d_events</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">event_subsystem</span> <span class="o">*</span><span class="n">system</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

	<span class="cm">/* First see if we did not already create this dir */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event_subsystems</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">system</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">system</span><span class="o">-&gt;</span><span class="n">nr_events</span><span class="o">++</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">system</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* need to create new entry */</span>
	<span class="n">system</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">system</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">system</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;No memory to create event subsystem %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">d_events</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">system</span><span class="o">-&gt;</span><span class="n">entry</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">d_events</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">system</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Could not create event subsystem %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">name</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">system</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">d_events</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">system</span><span class="o">-&gt;</span><span class="n">nr_events</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">system</span><span class="o">-&gt;</span><span class="n">ref_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">system</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">system</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">system</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">system</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">d_events</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">system</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event_subsystems</span><span class="p">);</span>

	<span class="n">system</span><span class="o">-&gt;</span><span class="n">filter</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">system</span><span class="o">-&gt;</span><span class="n">filter</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">event_filter</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">system</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Could not allocate filter for subsystem &quot;</span>
			   <span class="s">&quot;&#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">system</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="s">&quot;filter&quot;</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">system</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="n">system</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">ftrace_subsystem_filter_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">system</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">);</span>
		<span class="n">system</span><span class="o">-&gt;</span><span class="n">filter</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Could not create debugfs &quot;</span>
			   <span class="s">&quot;&#39;%s/filter&#39; entry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">trace_create_file</span><span class="p">(</span><span class="s">&quot;enable&quot;</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">system</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="n">system</span><span class="p">,</span>
			  <span class="o">&amp;</span><span class="n">ftrace_system_enable_fops</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">system</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">event_create_dir</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d_events</span><span class="p">,</span>
		 <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span><span class="n">id</span><span class="p">,</span>
		 <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span><span class="n">enable</span><span class="p">,</span>
		 <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span><span class="n">filter</span><span class="p">,</span>
		 <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span><span class="n">format</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the trace point header did not define TRACE_SYSTEM</span>
<span class="cm">	 * then the system would be called &quot;TRACE_SYSTEM&quot;.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">system</span><span class="p">,</span> <span class="n">TRACE_SYSTEM</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">d_events</span> <span class="o">=</span> <span class="n">event_subsystem_dir</span><span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">system</span><span class="p">,</span> <span class="n">d_events</span><span class="p">);</span>

	<span class="n">call</span><span class="o">-&gt;</span><span class="n">dir</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">d_events</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">dir</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Could not create debugfs &quot;</span>
			   <span class="s">&quot;&#39;%s&#39; directory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">call</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">reg</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TRACE_EVENT_FL_IGNORE_ENABLE</span><span class="p">))</span>
		<span class="n">trace_create_file</span><span class="p">(</span><span class="s">&quot;enable&quot;</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">call</span><span class="o">-&gt;</span><span class="n">dir</span><span class="p">,</span> <span class="n">call</span><span class="p">,</span>
				  <span class="n">enable</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PERF_EVENTS</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">type</span> <span class="o">&amp;&amp;</span> <span class="n">call</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">)</span>
		<span class="n">trace_create_file</span><span class="p">(</span><span class="s">&quot;id&quot;</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">call</span><span class="o">-&gt;</span><span class="n">dir</span><span class="p">,</span> <span class="n">call</span><span class="p">,</span>
		 		  <span class="n">id</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Other events may have the same class. Only update</span>
<span class="cm">	 * the fields if they are not already defined.</span>
<span class="cm">	 */</span>
	<span class="n">head</span> <span class="o">=</span> <span class="n">trace_get_fields</span><span class="p">(</span><span class="n">call</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="n">head</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">call</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">define_fields</span><span class="p">(</span><span class="n">call</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Could not initialize trace point&quot;</span>
				   <span class="s">&quot; events/%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">call</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">trace_create_file</span><span class="p">(</span><span class="s">&quot;filter&quot;</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">call</span><span class="o">-&gt;</span><span class="n">dir</span><span class="p">,</span> <span class="n">call</span><span class="p">,</span>
			  <span class="n">filter</span><span class="p">);</span>

	<span class="n">trace_create_file</span><span class="p">(</span><span class="s">&quot;format&quot;</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">call</span><span class="o">-&gt;</span><span class="n">dir</span><span class="p">,</span> <span class="n">call</span><span class="p">,</span>
			  <span class="n">format</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">__trace_add_event_call</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span><span class="p">,</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span>
		       <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span><span class="n">id</span><span class="p">,</span>
		       <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span><span class="n">enable</span><span class="p">,</span>
		       <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span><span class="n">filter</span><span class="p">,</span>
		       <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span><span class="n">format</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d_events</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* The linker may leave blanks */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">raw_init</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">call</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">raw_init</span><span class="p">(</span><span class="n">call</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">)</span>
				<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Could not initialize trace events/%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					   <span class="n">call</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">d_events</span> <span class="o">=</span> <span class="n">event_trace_events_dir</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d_events</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">event_create_dir</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="n">d_events</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">enable</span><span class="p">,</span> <span class="n">filter</span><span class="p">,</span> <span class="n">format</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ftrace_events</span><span class="p">);</span>
	<span class="n">call</span><span class="o">-&gt;</span><span class="n">mod</span> <span class="o">=</span> <span class="n">mod</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Add an additional event_call dynamically */</span>
<span class="kt">int</span> <span class="nf">trace_add_event_call</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__trace_add_event_call</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ftrace_event_id_fops</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">ftrace_enable_fops</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">ftrace_event_filter_fops</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">ftrace_event_format_fops</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">remove_subsystem_dir</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">event_subsystem</span> <span class="o">*</span><span class="n">system</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">TRACE_SYSTEM</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event_subsystems</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">system</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">system</span><span class="o">-&gt;</span><span class="n">nr_events</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">debugfs_remove_recursive</span><span class="p">(</span><span class="n">system</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>
				<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">system</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
				<span class="n">__put_system</span><span class="p">(</span><span class="n">system</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Must be called under locking both of event_mutex and trace_event_mutex.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__trace_remove_event_call</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ftrace_event_enable_disable</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">funcs</span><span class="p">)</span>
		<span class="n">__unregister_ftrace_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">);</span>
	<span class="n">debugfs_remove_recursive</span><span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">dir</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">trace_destroy_fields</span><span class="p">(</span><span class="n">call</span><span class="p">);</span>
	<span class="n">destroy_preds</span><span class="p">(</span><span class="n">call</span><span class="p">);</span>
	<span class="n">remove_subsystem_dir</span><span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">system</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Remove an event_call */</span>
<span class="kt">void</span> <span class="nf">trace_remove_event_call</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event_mutex</span><span class="p">);</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_event_mutex</span><span class="p">);</span>
	<span class="n">__trace_remove_event_call</span><span class="p">(</span><span class="n">call</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_event_mutex</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define for_each_event(event, start, end)			\</span>
<span class="cp">	for (event = start;					\</span>
<span class="cp">	     (unsigned long)event &lt; (unsigned long)end;		\</span>
<span class="cp">	     event++)</span>

<span class="cp">#ifdef CONFIG_MODULES</span>

<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">ftrace_module_file_list</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Modules must own their file_operations to keep up with</span>
<span class="cm"> * reference counting.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ftrace_module_file_ops</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>		<span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">module</span>			<span class="o">*</span><span class="n">mod</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file_operations</span>		<span class="n">id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file_operations</span>		<span class="n">enable</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file_operations</span>		<span class="n">format</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file_operations</span>		<span class="n">filter</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ftrace_module_file_ops</span> <span class="o">*</span>
<span class="nf">trace_create_file_ops</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_module_file_ops</span> <span class="o">*</span><span class="n">file_ops</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is a bit of a PITA. To allow for correct reference</span>
<span class="cm">	 * counting, modules must &quot;own&quot; their file_operations.</span>
<span class="cm">	 * To do this, we allocate the file operations that will be</span>
<span class="cm">	 * used in the event directory.</span>
<span class="cm">	 */</span>

	<span class="n">file_ops</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">file_ops</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file_ops</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">file_ops</span><span class="o">-&gt;</span><span class="n">mod</span> <span class="o">=</span> <span class="n">mod</span><span class="p">;</span>

	<span class="n">file_ops</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">ftrace_event_id_fops</span><span class="p">;</span>
	<span class="n">file_ops</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">mod</span><span class="p">;</span>

	<span class="n">file_ops</span><span class="o">-&gt;</span><span class="n">enable</span> <span class="o">=</span> <span class="n">ftrace_enable_fops</span><span class="p">;</span>
	<span class="n">file_ops</span><span class="o">-&gt;</span><span class="n">enable</span><span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">mod</span><span class="p">;</span>

	<span class="n">file_ops</span><span class="o">-&gt;</span><span class="n">filter</span> <span class="o">=</span> <span class="n">ftrace_event_filter_fops</span><span class="p">;</span>
	<span class="n">file_ops</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">mod</span><span class="p">;</span>

	<span class="n">file_ops</span><span class="o">-&gt;</span><span class="n">format</span> <span class="o">=</span> <span class="n">ftrace_event_format_fops</span><span class="p">;</span>
	<span class="n">file_ops</span><span class="o">-&gt;</span><span class="n">format</span><span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">mod</span><span class="p">;</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file_ops</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ftrace_module_file_list</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">file_ops</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">trace_module_add_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_module_file_ops</span> <span class="o">*</span><span class="n">file_ops</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">**</span><span class="n">call</span><span class="p">,</span> <span class="o">**</span><span class="n">start</span><span class="p">,</span> <span class="o">**</span><span class="n">end</span><span class="p">;</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">trace_events</span><span class="p">;</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">trace_events</span> <span class="o">+</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_trace_events</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">file_ops</span> <span class="o">=</span> <span class="n">trace_create_file_ops</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file_ops</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">for_each_event</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__trace_add_event_call</span><span class="p">(</span><span class="o">*</span><span class="n">call</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">file_ops</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">file_ops</span><span class="o">-&gt;</span><span class="n">enable</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">file_ops</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">file_ops</span><span class="o">-&gt;</span><span class="n">format</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">trace_module_remove_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_module_file_ops</span> <span class="o">*</span><span class="n">file_ops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">found</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_event_mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ftrace_events</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">mod</span> <span class="o">==</span> <span class="n">mod</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">found</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">__trace_remove_event_call</span><span class="p">(</span><span class="n">call</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Now free the file_operations */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">file_ops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ftrace_module_file_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">file_ops</span><span class="o">-&gt;</span><span class="n">mod</span> <span class="o">==</span> <span class="n">mod</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">file_ops</span><span class="o">-&gt;</span><span class="n">list</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">ftrace_module_file_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file_ops</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">file_ops</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * It is safest to reset the ring buffer if the module being unloaded</span>
<span class="cm">	 * registered any events.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span>
		<span class="n">tracing_reset_current_online_cpus</span><span class="p">();</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_event_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">trace_module_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event_mutex</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MODULE_STATE_COMING</span>:
		<span class="n">trace_module_add_events</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MODULE_STATE_GOING</span>:
		<span class="n">trace_module_remove_events</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">trace_module_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MODULES */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">trace_module_nb</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">trace_module_notify</span><span class="p">,</span>
	<span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">__start_ftrace_events</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">__stop_ftrace_events</span><span class="p">[];</span>

<span class="k">static</span> <span class="kt">char</span> <span class="n">bootup_event_buf</span><span class="p">[</span><span class="n">COMMAND_LINE_SIZE</span><span class="p">]</span> <span class="n">__initdata</span><span class="p">;</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">setup_trace_event</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">bootup_event_buf</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">COMMAND_LINE_SIZE</span><span class="p">);</span>
	<span class="n">ring_buffer_expanded</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">tracing_selftest_disabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;trace_event=&quot;</span><span class="p">,</span> <span class="n">setup_trace_event</span><span class="p">);</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">event_trace_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">**</span><span class="n">call</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d_tracer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d_events</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">bootup_event_buf</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">token</span><span class="p">;</span>

	<span class="n">d_tracer</span> <span class="o">=</span> <span class="n">tracing_init_dentry</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d_tracer</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="s">&quot;available_events&quot;</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">d_tracer</span><span class="p">,</span>
				    <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">show_event_seq_ops</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">ftrace_avail_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">)</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Could not create debugfs &quot;</span>
			   <span class="s">&quot;&#39;available_events&#39; entry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="s">&quot;set_event&quot;</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">d_tracer</span><span class="p">,</span>
				    <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">show_set_event_seq_ops</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">ftrace_set_event_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">)</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Could not create debugfs &quot;</span>
			   <span class="s">&quot;&#39;set_event&#39; entry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">d_events</span> <span class="o">=</span> <span class="n">event_trace_events_dir</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d_events</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* ring buffer internal formats */</span>
	<span class="n">trace_create_file</span><span class="p">(</span><span class="s">&quot;header_page&quot;</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">d_events</span><span class="p">,</span>
			  <span class="n">ring_buffer_print_page_header</span><span class="p">,</span>
			  <span class="o">&amp;</span><span class="n">ftrace_show_header_fops</span><span class="p">);</span>

	<span class="n">trace_create_file</span><span class="p">(</span><span class="s">&quot;header_event&quot;</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">d_events</span><span class="p">,</span>
			  <span class="n">ring_buffer_print_entry_header</span><span class="p">,</span>
			  <span class="o">&amp;</span><span class="n">ftrace_show_header_fops</span><span class="p">);</span>

	<span class="n">trace_create_file</span><span class="p">(</span><span class="s">&quot;enable&quot;</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">d_events</span><span class="p">,</span>
			  <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ftrace_system_enable_fops</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trace_define_common_fields</span><span class="p">())</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;tracing: Failed to allocate common fields&quot;</span><span class="p">);</span>

	<span class="n">for_each_event</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="n">__start_ftrace_events</span><span class="p">,</span> <span class="n">__stop_ftrace_events</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__trace_add_event_call</span><span class="p">(</span><span class="o">*</span><span class="n">call</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ftrace_event_id_fops</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">ftrace_enable_fops</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">ftrace_event_filter_fops</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">ftrace_event_format_fops</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">token</span> <span class="o">=</span> <span class="n">strsep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;,&quot;</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">token</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">token</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">ftrace_set_clr_event</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Failed to enable trace event: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">token</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">register_module_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_module_nb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Failed to register trace events module notifier</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">fs_initcall</span><span class="p">(</span><span class="n">event_trace_init</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_FTRACE_STARTUP_TEST</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">test_spinlock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">test_spinlock_irq</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">test_mutex</span><span class="p">);</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">void</span> <span class="nf">test_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">dummy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">test_spinlock</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">test_spinlock_irq</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">test_spinlock_irq</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">test_spinlock</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">test_mutex</span><span class="p">);</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">test_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">event_test_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">test_malloc</span><span class="p">;</span>

	<span class="n">test_malloc</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="mi">1234</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_malloc</span><span class="p">)</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;failed to kmalloc</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">schedule_on_each_cpu</span><span class="p">(</span><span class="n">test_work</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">test_malloc</span><span class="p">);</span>

	<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">())</span>
		<span class="n">schedule</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Do various things that may trigger events.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__init</span> <span class="kt">void</span> <span class="nf">event_test_stuff</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">test_thread</span><span class="p">;</span>

	<span class="n">test_thread</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">event_test_thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;test-events&quot;</span><span class="p">);</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">kthread_stop</span><span class="p">(</span><span class="n">test_thread</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * For every trace event defined, we will test each trace point separately,</span>
<span class="cm"> * and then by groups, and finally all trace points.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__init</span> <span class="kt">void</span> <span class="nf">event_trace_self_tests</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">event_subsystem</span> <span class="o">*</span><span class="n">system</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Running tests on trace events:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ftrace_events</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Only test those that have a probe */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">||</span> <span class="o">!</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Testing syscall events here is pretty useless, but</span>
<span class="cm"> * we still do it if configured. But this is time consuming.</span>
<span class="cm"> * What we really need is a user thread to perform the</span>
<span class="cm"> * syscalls as we test.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef CONFIG_EVENT_TRACE_TEST_SYSCALLS</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">system</span> <span class="o">&amp;&amp;</span>
		    <span class="n">strcmp</span><span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">system</span><span class="p">,</span> <span class="s">&quot;syscalls&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
<span class="cp">#endif</span>

		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Testing event %s: &quot;</span><span class="p">,</span> <span class="n">call</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If an event is already enabled, someone is using</span>
<span class="cm">		 * it and the self test should not be on.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TRACE_EVENT_FL_ENABLED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Enabled event during self test!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ftrace_event_enable_disable</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">event_test_stuff</span><span class="p">();</span>
		<span class="n">ftrace_event_enable_disable</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;OK</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Now test at the sub system level */</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Running tests on trace event systems:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event_subsystems</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* the ftrace system is special, skip it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">system</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;ftrace&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Testing event system %s: &quot;</span><span class="p">,</span> <span class="n">system</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">__ftrace_set_clr_event</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">system</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;error enabling system %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">system</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">event_test_stuff</span><span class="p">();</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">__ftrace_set_clr_event</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">system</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;error disabling system %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">system</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

		<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;OK</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Test with all events enabled */</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Running tests on all trace events:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Testing all events: &quot;</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__ftrace_set_clr_event</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;error enabling all events</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">event_test_stuff</span><span class="p">();</span>

	<span class="cm">/* reset sysname */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__ftrace_set_clr_event</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;error disabling all events</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;OK</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_FUNCTION_TRACER</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">atomic_t</span><span class="p">,</span> <span class="n">ftrace_test_event_disable</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">function_test_events_call</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">parent_ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">disabled</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pc</span><span class="p">;</span>

	<span class="n">pc</span> <span class="o">=</span> <span class="n">preempt_count</span><span class="p">();</span>
	<span class="n">preempt_disable_notrace</span><span class="p">();</span>
	<span class="n">cpu</span> <span class="o">=</span> <span class="n">raw_smp_processor_id</span><span class="p">();</span>
	<span class="n">disabled</span> <span class="o">=</span> <span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">ftrace_test_event_disable</span><span class="p">,</span> <span class="n">cpu</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">disabled</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">local_save_flags</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">trace_current_buffer_lock_reserve</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">,</span>
						  <span class="n">TRACE_FN</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">),</span>
						  <span class="n">flags</span><span class="p">,</span> <span class="n">pc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">entry</span>	<span class="o">=</span> <span class="n">ring_buffer_event_data</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">ip</span>			<span class="o">=</span> <span class="n">ip</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">parent_ip</span>		<span class="o">=</span> <span class="n">parent_ip</span><span class="p">;</span>

	<span class="n">trace_nowake_buffer_unlock_commit</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">pc</span><span class="p">);</span>

 <span class="nl">out:</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">ftrace_test_event_disable</span><span class="p">,</span> <span class="n">cpu</span><span class="p">));</span>
	<span class="n">preempt_enable_notrace</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="n">trace_ops</span> <span class="n">__initdata</span>  <span class="o">=</span>
<span class="p">{</span>
	<span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">function_test_events_call</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">void</span> <span class="nf">event_trace_self_test_with_function</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">register_ftrace_function</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Failed to enable function tracer for event tests</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Running tests again, along with the function tracer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">event_trace_self_tests</span><span class="p">();</span>
	<span class="n">unregister_ftrace_function</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_ops</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="n">__init</span> <span class="kt">void</span> <span class="nf">event_trace_self_test_with_function</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">event_trace_self_tests_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tracing_selftest_disabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">event_trace_self_tests</span><span class="p">();</span>
		<span class="n">event_trace_self_test_with_function</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">late_initcall</span><span class="p">(</span><span class="n">event_trace_self_tests_init</span><span class="p">);</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
