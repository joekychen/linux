<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › trace › ring_buffer.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ring_buffer.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Generic ring buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2008 Steven Rostedt &lt;srostedt@redhat.com&gt;</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/ring_buffer.h&gt;</span>
<span class="cp">#include &lt;linux/trace_clock.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/hardirq.h&gt;</span>
<span class="cp">#include &lt;linux/kmemcheck.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/hash.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>

<span class="cp">#include &lt;asm/local.h&gt;</span>
<span class="cp">#include &quot;trace.h&quot;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">update_pages_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The ring buffer header is special. We must manually up keep it.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ring_buffer_print_entry_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_seq</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">trace_seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;# compressed entry header</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">trace_seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">type_len    :    5 bits</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">trace_seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">time_delta  :   27 bits</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">trace_seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">array       :   32 bits</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">trace_seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">trace_seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">padding     : type == %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">RINGBUF_TYPE_PADDING</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">trace_seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">time_extend : type == %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">RINGBUF_TYPE_TIME_EXTEND</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">trace_seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">data max type_len  == %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">RINGBUF_TYPE_DATA_TYPE_LEN_MAX</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The ring buffer is made up of a list of pages. A separate list of pages is</span>
<span class="cm"> * allocated for each CPU. A writer may only write to a buffer that is</span>
<span class="cm"> * associated with the CPU it is currently executing on.  A reader may read</span>
<span class="cm"> * from any per cpu buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * The reader is special. For each per cpu buffer, the reader has its own</span>
<span class="cm"> * reader page. When a reader has read the entire reader page, this reader</span>
<span class="cm"> * page is swapped with another page in the ring buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * Now, as long as the writer is off the reader page, the reader can do what</span>
<span class="cm"> * ever it wants with that page. The writer will never write to that page</span>
<span class="cm"> * again (as long as it is out of the ring buffer).</span>
<span class="cm"> *</span>
<span class="cm"> * Here&#39;s some silly ASCII art.</span>
<span class="cm"> *</span>
<span class="cm"> *   +------+</span>
<span class="cm"> *   |reader|          RING BUFFER</span>
<span class="cm"> *   |page  |</span>
<span class="cm"> *   +------+        +---+   +---+   +---+</span>
<span class="cm"> *                   |   |--&gt;|   |--&gt;|   |</span>
<span class="cm"> *                   +---+   +---+   +---+</span>
<span class="cm"> *                     ^               |</span>
<span class="cm"> *                     |               |</span>
<span class="cm"> *                     +---------------+</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *   +------+</span>
<span class="cm"> *   |reader|          RING BUFFER</span>
<span class="cm"> *   |page  |------------------v</span>
<span class="cm"> *   +------+        +---+   +---+   +---+</span>
<span class="cm"> *                   |   |--&gt;|   |--&gt;|   |</span>
<span class="cm"> *                   +---+   +---+   +---+</span>
<span class="cm"> *                     ^               |</span>
<span class="cm"> *                     |               |</span>
<span class="cm"> *                     +---------------+</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *   +------+</span>
<span class="cm"> *   |reader|          RING BUFFER</span>
<span class="cm"> *   |page  |------------------v</span>
<span class="cm"> *   +------+        +---+   +---+   +---+</span>
<span class="cm"> *      ^            |   |--&gt;|   |--&gt;|   |</span>
<span class="cm"> *      |            +---+   +---+   +---+</span>
<span class="cm"> *      |                              |</span>
<span class="cm"> *      |                              |</span>
<span class="cm"> *      +------------------------------+</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *   +------+</span>
<span class="cm"> *   |buffer|          RING BUFFER</span>
<span class="cm"> *   |page  |------------------v</span>
<span class="cm"> *   +------+        +---+   +---+   +---+</span>
<span class="cm"> *      ^            |   |   |   |--&gt;|   |</span>
<span class="cm"> *      |   New      +---+   +---+   +---+</span>
<span class="cm"> *      |  Reader------^               |</span>
<span class="cm"> *      |   page                       |</span>
<span class="cm"> *      +------------------------------+</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * After we make this swap, the reader can hand this page off to the splice</span>
<span class="cm"> * code and be done with it. It can even allocate a new page if it needs to</span>
<span class="cm"> * and swap that into the ring buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * We will be using cmpxchg soon to make all this lockless.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * A fast way to enable or disable all ring buffers is to</span>
<span class="cm"> * call tracing_on or tracing_off. Turning off the ring buffers</span>
<span class="cm"> * prevents all ring buffers from being recorded to.</span>
<span class="cm"> * Turning this switch on, makes it OK to write to the</span>
<span class="cm"> * ring buffer, if the ring buffer is enabled itself.</span>
<span class="cm"> *</span>
<span class="cm"> * There&#39;s three layers that must be on in order to write</span>
<span class="cm"> * to the ring buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * 1) This global flag must be set.</span>
<span class="cm"> * 2) The ring buffer must be enabled for recording.</span>
<span class="cm"> * 3) The per cpu buffer must be enabled for recording.</span>
<span class="cm"> *</span>
<span class="cm"> * In case of an anomaly, this global flag has a bit set that</span>
<span class="cm"> * will permantly disable all ring buffers.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Global flag to disable all recording to ring buffers</span>
<span class="cm"> *  This has two bits: ON, DISABLED</span>
<span class="cm"> *</span>
<span class="cm"> *  ON   DISABLED</span>
<span class="cm"> * ---- ----------</span>
<span class="cm"> *   0      0        : ring buffers are off</span>
<span class="cm"> *   1      0        : ring buffers are on</span>
<span class="cm"> *   X      1        : ring buffers are permanently disabled</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">RB_BUFFERS_ON_BIT</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">RB_BUFFERS_DISABLED_BIT</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">RB_BUFFERS_ON</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">RB_BUFFERS_ON_BIT</span><span class="p">,</span>
	<span class="n">RB_BUFFERS_DISABLED</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">RB_BUFFERS_DISABLED_BIT</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ring_buffer_flags</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="n">RB_BUFFERS_ON</span><span class="p">;</span>

<span class="cm">/* Used for individual buffers (after the counter) */</span>
<span class="cp">#define RB_BUFFER_OFF		(1 &lt;&lt; 20)</span>

<span class="cp">#define BUF_PAGE_HDR_SIZE offsetof(struct buffer_data_page, data)</span>

<span class="cm">/**</span>
<span class="cm"> * tracing_off_permanent - permanently disable ring buffers</span>
<span class="cm"> *</span>
<span class="cm"> * This function, once called, will disable all ring buffers</span>
<span class="cm"> * permanently.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tracing_off_permanent</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">RB_BUFFERS_DISABLED_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ring_buffer_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define RB_EVNT_HDR_SIZE (offsetof(struct ring_buffer_event, array))</span>
<span class="cp">#define RB_ALIGNMENT		4U</span>
<span class="cp">#define RB_MAX_SMALL_DATA	(RB_ALIGNMENT * RINGBUF_TYPE_DATA_TYPE_LEN_MAX)</span>
<span class="cp">#define RB_EVNT_MIN_SIZE	8U	</span><span class="cm">/* two 32bit words */</span><span class="cp"></span>

<span class="cp">#if !defined(CONFIG_64BIT) || defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)</span>
<span class="cp"># define RB_FORCE_8BYTE_ALIGNMENT	0</span>
<span class="cp"># define RB_ARCH_ALIGNMENT		RB_ALIGNMENT</span>
<span class="cp">#else</span>
<span class="cp"># define RB_FORCE_8BYTE_ALIGNMENT	1</span>
<span class="cp"># define RB_ARCH_ALIGNMENT		8U</span>
<span class="cp">#endif</span>

<span class="cm">/* define RINGBUF_TYPE_DATA for &#39;case RINGBUF_TYPE_DATA:&#39; */</span>
<span class="cp">#define RINGBUF_TYPE_DATA 0 ... RINGBUF_TYPE_DATA_TYPE_LEN_MAX</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">RB_LEN_TIME_EXTEND</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
	<span class="n">RB_LEN_TIME_STAMP</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define skip_time_extend(event) \</span>
<span class="cp">	((struct ring_buffer_event *)((char *)event + RB_LEN_TIME_EXTEND))</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">rb_null_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">type_len</span> <span class="o">==</span> <span class="n">RINGBUF_TYPE_PADDING</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">time_delta</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rb_event_set_padding</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* padding has a NULL time_delta */</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">type_len</span> <span class="o">=</span> <span class="n">RINGBUF_TYPE_PADDING</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">time_delta</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span>
<span class="nf">rb_event_data_length</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">length</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">type_len</span><span class="p">)</span>
		<span class="n">length</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">type_len</span> <span class="o">*</span> <span class="n">RB_ALIGNMENT</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">length</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">return</span> <span class="n">length</span> <span class="o">+</span> <span class="n">RB_EVNT_HDR_SIZE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the length of the given event. Will return</span>
<span class="cm"> * the length of the time extend if the event is a</span>
<span class="cm"> * time extend.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span>
<span class="nf">rb_event_length</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">type_len</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">RINGBUF_TYPE_PADDING</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">rb_null_event</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
			<span class="cm">/* undefined */</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span>  <span class="n">event</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">RB_EVNT_HDR_SIZE</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">RINGBUF_TYPE_TIME_EXTEND</span>:
		<span class="k">return</span> <span class="n">RB_LEN_TIME_EXTEND</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">RINGBUF_TYPE_TIME_STAMP</span>:
		<span class="k">return</span> <span class="n">RB_LEN_TIME_STAMP</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">RINGBUF_TYPE_DATA</span>:
		<span class="k">return</span> <span class="n">rb_event_data_length</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="cm">/* not hit */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return total length of time extend and data,</span>
<span class="cm"> *   or just the event length for all other events.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span>
<span class="nf">rb_event_ts_length</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">type_len</span> <span class="o">==</span> <span class="n">RINGBUF_TYPE_TIME_EXTEND</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* time extends include the data event after it */</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">RB_LEN_TIME_EXTEND</span><span class="p">;</span>
		<span class="n">event</span> <span class="o">=</span> <span class="n">skip_time_extend</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">len</span> <span class="o">+</span> <span class="n">rb_event_length</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_event_length - return the length of the event</span>
<span class="cm"> * @event: the event to get the length of</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the size of the data load of a data event.</span>
<span class="cm"> * If the event is something other than a data event, it</span>
<span class="cm"> * returns the size of the event itself. With the exception</span>
<span class="cm"> * of a TIME EXTEND, where it still returns the size of the</span>
<span class="cm"> * data load of the data event after it.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="nf">ring_buffer_event_length</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">length</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">type_len</span> <span class="o">==</span> <span class="n">RINGBUF_TYPE_TIME_EXTEND</span><span class="p">)</span>
		<span class="n">event</span> <span class="o">=</span> <span class="n">skip_time_extend</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="n">length</span> <span class="o">=</span> <span class="n">rb_event_length</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">type_len</span> <span class="o">&gt;</span> <span class="n">RINGBUF_TYPE_DATA_TYPE_LEN_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">length</span> <span class="o">-=</span> <span class="n">RB_EVNT_HDR_SIZE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">RB_MAX_SMALL_DATA</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="n">length</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">return</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_event_length</span><span class="p">);</span>

<span class="cm">/* inline for ring buffer fast paths */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">rb_event_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">type_len</span> <span class="o">==</span> <span class="n">RINGBUF_TYPE_TIME_EXTEND</span><span class="p">)</span>
		<span class="n">event</span> <span class="o">=</span> <span class="n">skip_time_extend</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">type_len</span> <span class="o">&gt;</span> <span class="n">RINGBUF_TYPE_DATA_TYPE_LEN_MAX</span><span class="p">);</span>
	<span class="cm">/* If length is in len field, then array[0] has the data */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">type_len</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="cm">/* Otherwise length is in array[0] and array[1] has the data */</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_event_data - return the data of the event</span>
<span class="cm"> * @event: the event to get the data from</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">ring_buffer_event_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rb_event_data</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_event_data</span><span class="p">);</span>

<span class="cp">#define for_each_buffer_cpu(buffer, cpu)		\</span>
<span class="cp">	for_each_cpu(cpu, buffer-&gt;cpumask)</span>

<span class="cp">#define TS_SHIFT	27</span>
<span class="cp">#define TS_MASK		((1ULL &lt;&lt; TS_SHIFT) - 1)</span>
<span class="cp">#define TS_DELTA_TEST	(~TS_MASK)</span>

<span class="cm">/* Flag when events were overwritten */</span>
<span class="cp">#define RB_MISSED_EVENTS	(1 &lt;&lt; 31)</span>
<span class="cm">/* Missed count stored at end */</span>
<span class="cp">#define RB_MISSED_STORED	(1 &lt;&lt; 30)</span>

<span class="k">struct</span> <span class="n">buffer_data_page</span> <span class="p">{</span>
	<span class="n">u64</span>		 <span class="n">time_stamp</span><span class="p">;</span>	<span class="cm">/* page time stamp */</span>
	<span class="n">local_t</span>		 <span class="n">commit</span><span class="p">;</span>	<span class="cm">/* write committed index */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	 <span class="n">data</span><span class="p">[];</span>	<span class="cm">/* data of buffer page */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Note, the buffer_page list must be first. The buffer pages</span>
<span class="cm"> * are allocated in cache lines, which means that each buffer</span>
<span class="cm"> * page will be at the beginning of a cache line, and thus</span>
<span class="cm"> * the least significant bits will be zero. We use this to</span>
<span class="cm"> * add flags in the list struct pointers, to make the ring buffer</span>
<span class="cm"> * lockless.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">buffer_page</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>		<span class="cm">/* list of buffer pages */</span>
	<span class="n">local_t</span>		 <span class="n">write</span><span class="p">;</span>		<span class="cm">/* index for next write */</span>
	<span class="kt">unsigned</span>	 <span class="n">read</span><span class="p">;</span>		<span class="cm">/* index for next read */</span>
	<span class="n">local_t</span>		 <span class="n">entries</span><span class="p">;</span>	<span class="cm">/* entries on this page */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	 <span class="n">real_end</span><span class="p">;</span>	<span class="cm">/* real end of data */</span>
	<span class="k">struct</span> <span class="n">buffer_data_page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>	<span class="cm">/* Actual data page */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The buffer page counters, write and entries, must be reset</span>
<span class="cm"> * atomically when crossing page boundaries. To synchronize this</span>
<span class="cm"> * update, two counters are inserted into the number. One is</span>
<span class="cm"> * the actual counter for the write position or count on the page.</span>
<span class="cm"> *</span>
<span class="cm"> * The other is a counter of updaters. Before an update happens</span>
<span class="cm"> * the update partition of the counter is incremented. This will</span>
<span class="cm"> * allow the updater to update the counter atomically.</span>
<span class="cm"> *</span>
<span class="cm"> * The counter is 20 bits, and the state data is 12.</span>
<span class="cm"> */</span>
<span class="cp">#define RB_WRITE_MASK		0xfffff</span>
<span class="cp">#define RB_WRITE_INTCNT		(1 &lt;&lt; 20)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rb_init_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_data_page</span> <span class="o">*</span><span class="n">bpage</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">local_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bpage</span><span class="o">-&gt;</span><span class="n">commit</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_page_len - the size of data on the page.</span>
<span class="cm"> * @page: The page to read</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the amount of data on the page, including buffer page header.</span>
<span class="cm"> */</span>
<span class="kt">size_t</span> <span class="nf">ring_buffer_page_len</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">local_read</span><span class="p">(</span><span class="o">&amp;</span><span class="p">((</span><span class="k">struct</span> <span class="n">buffer_data_page</span> <span class="o">*</span><span class="p">)</span><span class="n">page</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">commit</span><span class="p">)</span>
		<span class="o">+</span> <span class="n">BUF_PAGE_HDR_SIZE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Also stolen from mm/slob.c. Thanks to Mathieu Desnoyers for pointing</span>
<span class="cm"> * this issue out.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_buffer_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">bpage</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">bpage</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">bpage</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We need to fit the time_stamp delta into 27 bits.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">test_time_stamp</span><span class="p">(</span><span class="n">u64</span> <span class="n">delta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&amp;</span> <span class="n">TS_DELTA_TEST</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define BUF_PAGE_SIZE (PAGE_SIZE - BUF_PAGE_HDR_SIZE)</span>

<span class="cm">/* Max payload is BUF_PAGE_SIZE - header (8bytes) */</span>
<span class="cp">#define BUF_MAX_DATA_SIZE (BUF_PAGE_SIZE - (sizeof(u32) * 2))</span>

<span class="kt">int</span> <span class="nf">ring_buffer_print_page_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_seq</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_data_page</span> <span class="n">field</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">trace_seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">field: u64 timestamp;</span><span class="se">\t</span><span class="s">&quot;</span>
			       <span class="s">&quot;offset:0;</span><span class="se">\t</span><span class="s">size:%u;</span><span class="se">\t</span><span class="s">signed:%u;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">field</span><span class="p">.</span><span class="n">time_stamp</span><span class="p">),</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">is_signed_type</span><span class="p">(</span><span class="n">u64</span><span class="p">));</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">trace_seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">field: local_t commit;</span><span class="se">\t</span><span class="s">&quot;</span>
			       <span class="s">&quot;offset:%u;</span><span class="se">\t</span><span class="s">size:%u;</span><span class="se">\t</span><span class="s">signed:%u;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">offsetof</span><span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">field</span><span class="p">),</span> <span class="n">commit</span><span class="p">),</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">field</span><span class="p">.</span><span class="n">commit</span><span class="p">),</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">is_signed_type</span><span class="p">(</span><span class="kt">long</span><span class="p">));</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">trace_seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">field: int overwrite;</span><span class="se">\t</span><span class="s">&quot;</span>
			       <span class="s">&quot;offset:%u;</span><span class="se">\t</span><span class="s">size:%u;</span><span class="se">\t</span><span class="s">signed:%u;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">offsetof</span><span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">field</span><span class="p">),</span> <span class="n">commit</span><span class="p">),</span>
			       <span class="mi">1</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">is_signed_type</span><span class="p">(</span><span class="kt">long</span><span class="p">));</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">trace_seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">field: char data;</span><span class="se">\t</span><span class="s">&quot;</span>
			       <span class="s">&quot;offset:%u;</span><span class="se">\t</span><span class="s">size:%u;</span><span class="se">\t</span><span class="s">signed:%u;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">offsetof</span><span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">field</span><span class="p">),</span> <span class="n">data</span><span class="p">),</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">BUF_PAGE_SIZE</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">is_signed_type</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * head_page == tail_page &amp;&amp; head == tail then buffer is empty.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="p">{</span>
	<span class="kt">int</span>				<span class="n">cpu</span><span class="p">;</span>
	<span class="n">atomic_t</span>			<span class="n">record_disabled</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring_buffer</span>		<span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
	<span class="n">raw_spinlock_t</span>			<span class="n">reader_lock</span><span class="p">;</span>	<span class="cm">/* serialize readers */</span>
	<span class="n">arch_spinlock_t</span>			<span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock_class_key</span>		<span class="n">lock_key</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>			<span class="n">nr_pages</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>		<span class="o">*</span><span class="n">pages</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_page</span>		<span class="o">*</span><span class="n">head_page</span><span class="p">;</span>	<span class="cm">/* read from head */</span>
	<span class="k">struct</span> <span class="n">buffer_page</span>		<span class="o">*</span><span class="n">tail_page</span><span class="p">;</span>	<span class="cm">/* write to tail */</span>
	<span class="k">struct</span> <span class="n">buffer_page</span>		<span class="o">*</span><span class="n">commit_page</span><span class="p">;</span>	<span class="cm">/* committed pages */</span>
	<span class="k">struct</span> <span class="n">buffer_page</span>		<span class="o">*</span><span class="n">reader_page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>			<span class="n">lost_events</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>			<span class="n">last_overrun</span><span class="p">;</span>
	<span class="n">local_t</span>				<span class="n">entries_bytes</span><span class="p">;</span>
	<span class="n">local_t</span>				<span class="n">commit_overrun</span><span class="p">;</span>
	<span class="n">local_t</span>				<span class="n">overrun</span><span class="p">;</span>
	<span class="n">local_t</span>				<span class="n">entries</span><span class="p">;</span>
	<span class="n">local_t</span>				<span class="n">committing</span><span class="p">;</span>
	<span class="n">local_t</span>				<span class="n">commits</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>			<span class="n">read</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>			<span class="n">read_bytes</span><span class="p">;</span>
	<span class="n">u64</span>				<span class="n">write_stamp</span><span class="p">;</span>
	<span class="n">u64</span>				<span class="n">read_stamp</span><span class="p">;</span>
	<span class="cm">/* ring buffer pages to update, &gt; 0 to add, &lt; 0 to remove */</span>
	<span class="kt">int</span>				<span class="n">nr_pages_to_update</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>		<span class="n">new_pages</span><span class="p">;</span> <span class="cm">/* new pages to add */</span>
	<span class="k">struct</span> <span class="n">work_struct</span>		<span class="n">update_pages_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span>		<span class="n">update_done</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ring_buffer</span> <span class="p">{</span>
	<span class="kt">unsigned</span>			<span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="n">cpus</span><span class="p">;</span>
	<span class="n">atomic_t</span>			<span class="n">record_disabled</span><span class="p">;</span>
	<span class="n">atomic_t</span>			<span class="n">resize_disabled</span><span class="p">;</span>
	<span class="n">cpumask_var_t</span>			<span class="n">cpumask</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">lock_class_key</span>		<span class="o">*</span><span class="n">reader_lock_key</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mutex</span>			<span class="n">mutex</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span>	<span class="o">**</span><span class="n">buffers</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
	<span class="k">struct</span> <span class="n">notifier_block</span>		<span class="n">cpu_notify</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">u64</span>				<span class="p">(</span><span class="o">*</span><span class="n">clock</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ring_buffer_iter</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span>	<span class="o">*</span><span class="n">cpu_buffer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>			<span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_page</span>		<span class="o">*</span><span class="n">head_page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_page</span>		<span class="o">*</span><span class="n">cache_reader_page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>			<span class="n">cache_read</span><span class="p">;</span>
	<span class="n">u64</span>				<span class="n">read_stamp</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* buffer may be either ring_buffer or ring_buffer_per_cpu */</span>
<span class="cp">#define RB_WARN_ON(b, cond)						\</span>
<span class="cp">	({								\</span>
<span class="cp">		int _____ret = unlikely(cond);				\</span>
<span class="cp">		if (_____ret) {						\</span>
<span class="cp">			if (__same_type(*(b), struct ring_buffer_per_cpu)) { \</span>
<span class="cp">				struct ring_buffer_per_cpu *__b =	\</span>
<span class="cp">					(void *)b;			\</span>
<span class="cp">				atomic_inc(&amp;__b-&gt;buffer-&gt;record_disabled); \</span>
<span class="cp">			} else						\</span>
<span class="cp">				atomic_inc(&amp;b-&gt;record_disabled);	\</span>
<span class="cp">			WARN_ON(1);					\</span>
<span class="cp">		}							\</span>
<span class="cp">		_____ret;						\</span>
<span class="cp">	})</span>

<span class="cm">/* Up this if you want to test the TIME_EXTENTS and normalization */</span>
<span class="cp">#define DEBUG_SHIFT 0</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">rb_time_stamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* shift to debug/test normalization and TIME_EXTENTS */</span>
	<span class="k">return</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">DEBUG_SHIFT</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">u64</span> <span class="nf">ring_buffer_time_stamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">time</span><span class="p">;</span>

	<span class="n">preempt_disable_notrace</span><span class="p">();</span>
	<span class="n">time</span> <span class="o">=</span> <span class="n">rb_time_stamp</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
	<span class="n">preempt_enable_no_resched_notrace</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">time</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_time_stamp</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">ring_buffer_normalize_time_stamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">ts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Just stupid testing the normalize function and deltas */</span>
	<span class="o">*</span><span class="n">ts</span> <span class="o">&gt;&gt;=</span> <span class="n">DEBUG_SHIFT</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_normalize_time_stamp</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Making the ring buffer lockless makes things tricky.</span>
<span class="cm"> * Although writes only happen on the CPU that they are on,</span>
<span class="cm"> * and they only need to worry about interrupts. Reads can</span>
<span class="cm"> * happen on any CPU.</span>
<span class="cm"> *</span>
<span class="cm"> * The reader page is always off the ring buffer, but when the</span>
<span class="cm"> * reader finishes with a page, it needs to swap its page with</span>
<span class="cm"> * a new one from the buffer. The reader needs to take from</span>
<span class="cm"> * the head (writes go to the tail). But if a writer is in overwrite</span>
<span class="cm"> * mode and wraps, it must push the head page forward.</span>
<span class="cm"> *</span>
<span class="cm"> * Here lies the problem.</span>
<span class="cm"> *</span>
<span class="cm"> * The reader must be careful to replace only the head page, and</span>
<span class="cm"> * not another one. As described at the top of the file in the</span>
<span class="cm"> * ASCII art, the reader sets its old page to point to the next</span>
<span class="cm"> * page after head. It then sets the page after head to point to</span>
<span class="cm"> * the old reader page. But if the writer moves the head page</span>
<span class="cm"> * during this operation, the reader could end up with the tail.</span>
<span class="cm"> *</span>
<span class="cm"> * We use cmpxchg to help prevent this race. We also do something</span>
<span class="cm"> * special with the page before head. We set the LSB to 1.</span>
<span class="cm"> *</span>
<span class="cm"> * When the writer must push the page forward, it will clear the</span>
<span class="cm"> * bit that points to the head page, move the head, and then set</span>
<span class="cm"> * the bit that points to the new head page.</span>
<span class="cm"> *</span>
<span class="cm"> * We also don&#39;t want an interrupt coming in and moving the head</span>
<span class="cm"> * page on another writer. Thus we use the second LSB to catch</span>
<span class="cm"> * that too. Thus:</span>
<span class="cm"> *</span>
<span class="cm"> * head-&gt;list-&gt;prev-&gt;next        bit 1          bit 0</span>
<span class="cm"> *                              -------        -------</span>
<span class="cm"> * Normal page                     0              0</span>
<span class="cm"> * Points to head page             0              1</span>
<span class="cm"> * New head page                   1              0</span>
<span class="cm"> *</span>
<span class="cm"> * Note we can not trust the prev pointer of the head page, because:</span>
<span class="cm"> *</span>
<span class="cm"> * +----+       +-----+        +-----+</span>
<span class="cm"> * |    |------&gt;|  T  |---X---&gt;|  N  |</span>
<span class="cm"> * |    |&lt;------|     |        |     |</span>
<span class="cm"> * +----+       +-----+        +-----+</span>
<span class="cm"> *   ^                           ^ |</span>
<span class="cm"> *   |          +-----+          | |</span>
<span class="cm"> *   +----------|  R  |----------+ |</span>
<span class="cm"> *              |     |&lt;-----------+</span>
<span class="cm"> *              +-----+</span>
<span class="cm"> *</span>
<span class="cm"> * Key:  ---X--&gt;  HEAD flag set in pointer</span>
<span class="cm"> *         T      Tail page</span>
<span class="cm"> *         R      Reader page</span>
<span class="cm"> *         N      Next page</span>
<span class="cm"> *</span>
<span class="cm"> * (see __rb_reserve_next() to see where this happens)</span>
<span class="cm"> *</span>
<span class="cm"> *  What the above shows is that the reader just swapped out</span>
<span class="cm"> *  the reader page with a page in the buffer, but before it</span>
<span class="cm"> *  could make the new header point back to the new page added</span>
<span class="cm"> *  it was preempted by a writer. The writer moved forward onto</span>
<span class="cm"> *  the new page added by the reader and is about to move forward</span>
<span class="cm"> *  again.</span>
<span class="cm"> *</span>
<span class="cm"> *  You can see, it is legitimate for the previous pointer of</span>
<span class="cm"> *  the head (or any page) not to point back to itself. But only</span>
<span class="cm"> *  temporarially.</span>
<span class="cm"> */</span>

<span class="cp">#define RB_PAGE_NORMAL		0UL</span>
<span class="cp">#define RB_PAGE_HEAD		1UL</span>
<span class="cp">#define RB_PAGE_UPDATE		2UL</span>


<span class="cp">#define RB_FLAG_MASK		3UL</span>

<span class="cm">/* PAGE_MOVED is not part of the mask */</span>
<span class="cp">#define RB_PAGE_MOVED		4UL</span>

<span class="cm">/*</span>
<span class="cm"> * rb_list_head - remove any bit</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="nf">rb_list_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">list</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="p">)(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">RB_FLAG_MASK</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * rb_is_head_page - test if the given page is the head page</span>
<span class="cm"> *</span>
<span class="cm"> * Because the reader may move the head_page pointer, we can</span>
<span class="cm"> * not trust what the head page is (it may be pointing to</span>
<span class="cm"> * the reader page). But if the next page is a header page,</span>
<span class="cm"> * its flags will be non zero.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">rb_is_head_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">val</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">RB_FLAG_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">RB_PAGE_MOVED</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="n">RB_FLAG_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * rb_is_reader_page</span>
<span class="cm"> *</span>
<span class="cm"> * The unique thing about the reader page, is that, if the</span>
<span class="cm"> * writer is ever on it, the previous pointer never points</span>
<span class="cm"> * back to the reader page.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rb_is_reader_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">prev</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rb_list_head</span><span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * rb_set_list_to_head - set a list_head to be pointing to head.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rb_set_list_to_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

	<span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="o">*</span><span class="n">ptr</span> <span class="o">|=</span> <span class="n">RB_PAGE_HEAD</span><span class="p">;</span>
	<span class="o">*</span><span class="n">ptr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RB_PAGE_UPDATE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * rb_head_page_activate - sets up head page</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rb_head_page_activate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>

	<span class="n">head</span> <span class="o">=</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">head_page</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">head</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the previous list pointer to have the HEAD flag.</span>
<span class="cm">	 */</span>
	<span class="n">rb_set_list_to_head</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">prev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rb_list_head_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

	<span class="o">*</span><span class="n">ptr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RB_FLAG_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * rb_head_page_dactivate - clears head page ptr (for free list)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">rb_head_page_deactivate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">hd</span><span class="p">;</span>

	<span class="cm">/* Go through the whole list and clear any pointers found. */</span>
	<span class="n">rb_list_head_clear</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">);</span>

	<span class="n">list_for_each</span><span class="p">(</span><span class="n">hd</span><span class="p">,</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">)</span>
		<span class="n">rb_list_head_clear</span><span class="p">(</span><span class="n">hd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rb_head_page_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">old_flag</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RB_FLAG_MASK</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">cmpxchg</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span>
		      <span class="n">val</span> <span class="o">|</span> <span class="n">old_flag</span><span class="p">,</span> <span class="n">val</span> <span class="o">|</span> <span class="n">new_flag</span><span class="p">);</span>

	<span class="cm">/* check if the reader took the page */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">RB_FLAG_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">RB_PAGE_MOVED</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span> <span class="o">&amp;</span> <span class="n">RB_FLAG_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rb_head_page_set_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">old_flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rb_head_page_set</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span>
				<span class="n">old_flag</span><span class="p">,</span> <span class="n">RB_PAGE_UPDATE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rb_head_page_set_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">old_flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rb_head_page_set</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span>
				<span class="n">old_flag</span><span class="p">,</span> <span class="n">RB_PAGE_HEAD</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rb_head_page_set_normal</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">old_flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rb_head_page_set</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span>
				<span class="n">old_flag</span><span class="p">,</span> <span class="n">RB_PAGE_NORMAL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rb_inc_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">**</span><span class="n">bpage</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">rb_list_head</span><span class="p">((</span><span class="o">*</span><span class="n">bpage</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>

	<span class="o">*</span><span class="n">bpage</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_page</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span>
<span class="nf">rb_set_head_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">RB_WARN_ON</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="o">!</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">head_page</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* sanity check */</span>
	<span class="n">list</span> <span class="o">=</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">RB_WARN_ON</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">rb_list_head</span><span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="o">!=</span> <span class="n">list</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">head</span> <span class="o">=</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">head_page</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * It is possible that the writer moves the header behind</span>
<span class="cm">	 * where we started, and we miss in one loop.</span>
<span class="cm">	 * A second loop should grab the header, but we&#39;ll do</span>
<span class="cm">	 * three loops just because I&#39;m paranoid.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rb_is_head_page</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">prev</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">head_page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
				<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">rb_inc_page</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">page</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">RB_WARN_ON</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rb_head_page_replace</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">RB_FLAG_MASK</span><span class="p">;</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="n">RB_PAGE_HEAD</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">cmpxchg</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span> <span class="o">==</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * rb_tail_page_update - move the tail page forward</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 if moved tail page, 0 if someone else did.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rb_tail_page_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">tail_page</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">next_page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">old_tail</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old_entries</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old_write</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The tail page now needs to be moved forward.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We need to reset the tail page, but without messing</span>
<span class="cm">	 * with possible erasing of data brought in by interrupts</span>
<span class="cm">	 * that have moved the tail page and are currently on it.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We add a counter to the write field to denote this.</span>
<span class="cm">	 */</span>
	<span class="n">old_write</span> <span class="o">=</span> <span class="n">local_add_return</span><span class="p">(</span><span class="n">RB_WRITE_INTCNT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">next_page</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">);</span>
	<span class="n">old_entries</span> <span class="o">=</span> <span class="n">local_add_return</span><span class="p">(</span><span class="n">RB_WRITE_INTCNT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">next_page</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Just make sure we have seen our old_write and synchronize</span>
<span class="cm">	 * with any interrupts that come in.</span>
<span class="cm">	 */</span>
	<span class="n">barrier</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the tail page is still the same as what we think</span>
<span class="cm">	 * it is, then it is up to us to update the tail</span>
<span class="cm">	 * pointer.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tail_page</span> <span class="o">==</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">tail_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Zero the write counter */</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span> <span class="o">=</span> <span class="n">old_write</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">RB_WRITE_MASK</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">eval</span> <span class="o">=</span> <span class="n">old_entries</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">RB_WRITE_MASK</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * This will only succeed if an interrupt did</span>
<span class="cm">		 * not come in and change it. In which case, we</span>
<span class="cm">		 * do not want to modify it.</span>
<span class="cm">		 *</span>
<span class="cm">		 * We add (void) to let the compiler know that we do not care</span>
<span class="cm">		 * about the return value of these functions. We use the</span>
<span class="cm">		 * cmpxchg to only update if an interrupt did not already</span>
<span class="cm">		 * do it for us. If the cmpxchg fails, we don&#39;t care.</span>
<span class="cm">		 */</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">local_cmpxchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next_page</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">,</span> <span class="n">old_write</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">local_cmpxchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next_page</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">,</span> <span class="n">old_entries</span><span class="p">,</span> <span class="n">eval</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * No need to worry about races with clearing out the commit.</span>
<span class="cm">		 * it only can increment when a commit takes place. But that</span>
<span class="cm">		 * only happens in the outer most nested commit.</span>
<span class="cm">		 */</span>
		<span class="n">local_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next_page</span><span class="o">-&gt;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">commit</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">old_tail</span> <span class="o">=</span> <span class="n">cmpxchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">tail_page</span><span class="p">,</span>
				   <span class="n">tail_page</span><span class="p">,</span> <span class="n">next_page</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">old_tail</span> <span class="o">==</span> <span class="n">tail_page</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rb_check_bpage</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">bpage</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">bpage</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">RB_WARN_ON</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="n">RB_FLAG_MASK</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rb_check_list - make sure a pointer to a list has the last bits zero</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rb_check_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">RB_WARN_ON</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">rb_list_head</span><span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">)</span> <span class="o">!=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">RB_WARN_ON</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">rb_list_head</span><span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="o">!=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * check_pages - integrity check of buffer pages</span>
<span class="cm"> * @cpu_buffer: CPU buffer with pages to test</span>
<span class="cm"> *</span>
<span class="cm"> * As a safety measure we check to make sure the data pages have not</span>
<span class="cm"> * been corrupted.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rb_check_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">bpage</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/* Reset the head page if it exists */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">head_page</span><span class="p">)</span>
		<span class="n">rb_set_head_page</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>

	<span class="n">rb_head_page_deactivate</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">RB_WARN_ON</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">!=</span> <span class="n">head</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">RB_WARN_ON</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="n">head</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rb_check_list</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">head</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">bpage</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">RB_WARN_ON</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span>
			       <span class="n">bpage</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">bpage</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">RB_WARN_ON</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span>
			       <span class="n">bpage</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">bpage</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rb_check_list</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bpage</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rb_head_page_activate</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__rb_allocate_pages</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">bpage</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * __GFP_NORETRY flag makes sure that the allocation fails</span>
<span class="cm">		 * gracefully without invoking oom-killer and the system is</span>
<span class="cm">		 * not destabilized.</span>
<span class="cm">		 */</span>
		<span class="n">bpage</span> <span class="o">=</span> <span class="n">kzalloc_node</span><span class="p">(</span><span class="n">ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bpage</span><span class="p">),</span> <span class="n">cache_line_size</span><span class="p">()),</span>
				    <span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_NORETRY</span><span class="p">,</span>
				    <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bpage</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">free_pages</span><span class="p">;</span>

		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bpage</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">pages</span><span class="p">);</span>

		<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_pages_node</span><span class="p">(</span><span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">),</span>
					<span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_NORETRY</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">free_pages</span><span class="p">;</span>
		<span class="n">bpage</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">rb_init_page</span><span class="p">(</span><span class="n">bpage</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">free_pages:</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">bpage</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bpage</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">free_buffer_page</span><span class="p">(</span><span class="n">bpage</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rb_allocate_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="n">nr_pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">nr_pages</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__rb_allocate_pages</span><span class="p">(</span><span class="n">nr_pages</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pages</span><span class="p">,</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The ring buffer page list is a circular list that does not</span>
<span class="cm">	 * start and end with a list head. All page list items point to</span>
<span class="cm">	 * other pages.</span>
<span class="cm">	 */</span>
	<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">pages</span> <span class="o">=</span> <span class="n">pages</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pages</span><span class="p">);</span>

	<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">nr_pages</span> <span class="o">=</span> <span class="n">nr_pages</span><span class="p">;</span>

	<span class="n">rb_check_pages</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span>
<span class="nf">rb_allocate_cpu_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">bpage</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">cpu_buffer</span> <span class="o">=</span> <span class="n">kzalloc_node</span><span class="p">(</span><span class="n">ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cpu_buffer</span><span class="p">),</span> <span class="n">cache_line_size</span><span class="p">()),</span>
				  <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_buffer</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
	<span class="n">raw_spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_lock</span><span class="p">);</span>
	<span class="n">lockdep_set_class</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_lock</span><span class="p">,</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">reader_lock_key</span><span class="p">);</span>
	<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">lock</span> <span class="o">=</span> <span class="p">(</span><span class="n">arch_spinlock_t</span><span class="p">)</span><span class="n">__ARCH_SPIN_LOCK_UNLOCKED</span><span class="p">;</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">update_pages_work</span><span class="p">,</span> <span class="n">update_pages_handler</span><span class="p">);</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">update_done</span><span class="p">);</span>

	<span class="n">bpage</span> <span class="o">=</span> <span class="n">kzalloc_node</span><span class="p">(</span><span class="n">ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bpage</span><span class="p">),</span> <span class="n">cache_line_size</span><span class="p">()),</span>
			    <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bpage</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_free_buffer</span><span class="p">;</span>

	<span class="n">rb_check_bpage</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">bpage</span><span class="p">);</span>

	<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span> <span class="o">=</span> <span class="n">bpage</span><span class="p">;</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_pages_node</span><span class="p">(</span><span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_free_reader</span><span class="p">;</span>
	<span class="n">bpage</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">rb_init_page</span><span class="p">(</span><span class="n">bpage</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">rb_allocate_pages</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_free_reader</span><span class="p">;</span>

	<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">head_page</span>
		<span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_page</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">tail_page</span> <span class="o">=</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">commit_page</span> <span class="o">=</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">head_page</span><span class="p">;</span>

	<span class="n">rb_head_page_activate</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">cpu_buffer</span><span class="p">;</span>

 <span class="nl">fail_free_reader:</span>
	<span class="n">free_buffer_page</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span><span class="p">);</span>

 <span class="nl">fail_free_buffer:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rb_free_cpu_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">bpage</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">free_buffer_page</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span><span class="p">);</span>

	<span class="n">rb_head_page_deactivate</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">bpage</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bpage</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">free_buffer_page</span><span class="p">(</span><span class="n">bpage</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">bpage</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_page</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">free_buffer_page</span><span class="p">(</span><span class="n">bpage</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">rb_cpu_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_alloc - allocate a new ring_buffer</span>
<span class="cm"> * @size: the size in bytes per cpu that is needed.</span>
<span class="cm"> * @flags: attributes to set for the ring buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * Currently the only flag that is available is the RB_FL_OVERWRITE</span>
<span class="cm"> * flag. This flag means that the buffer will overwrite old data</span>
<span class="cm"> * when the buffer wraps. If this flag is not set, the buffer will</span>
<span class="cm"> * drop data when the tail hits the head.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="nf">__ring_buffer_alloc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">lock_class_key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bsize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">;</span>

	<span class="cm">/* keep it in its own cache line */</span>
	<span class="n">buffer</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">buffer</span><span class="p">),</span> <span class="n">cache_line_size</span><span class="p">()),</span>
			 <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail_free_buffer</span><span class="p">;</span>

	<span class="n">nr_pages</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">BUF_PAGE_SIZE</span><span class="p">);</span>
	<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">clock</span> <span class="o">=</span> <span class="n">trace_clock_local</span><span class="p">;</span>
	<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">reader_lock_key</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>

	<span class="cm">/* need at least two pages */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_pages</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">nr_pages</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * In case of non-hotplug cpu, if the ring-buffer is allocated</span>
<span class="cm">	 * in early initcall, it will not be notified of secondary cpus.</span>
<span class="cm">	 * In that off case, we need to allocate for all possible cpus.</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
	<span class="n">get_online_cpus</span><span class="p">();</span>
	<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">,</span> <span class="n">cpu_online_mask</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">,</span> <span class="n">cpu_possible_mask</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">cpus</span> <span class="o">=</span> <span class="n">nr_cpu_ids</span><span class="p">;</span>

	<span class="n">bsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="n">nr_cpu_ids</span><span class="p">;</span>
	<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">ALIGN</span><span class="p">(</span><span class="n">bsize</span><span class="p">,</span> <span class="n">cache_line_size</span><span class="p">()),</span>
				  <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_free_cpumask</span><span class="p">;</span>

	<span class="n">for_each_buffer_cpu</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">rb_allocate_cpu_buffer</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu</span><span class="p">])</span>
			<span class="k">goto</span> <span class="n">fail_free_buffers</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
	<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">cpu_notify</span><span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">rb_cpu_notify</span><span class="p">;</span>
	<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">cpu_notify</span><span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">register_cpu_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">cpu_notify</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">put_online_cpus</span><span class="p">();</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">buffer</span><span class="p">;</span>

 <span class="nl">fail_free_buffers:</span>
	<span class="n">for_each_buffer_cpu</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu</span><span class="p">])</span>
			<span class="n">rb_free_cpu_buffer</span><span class="p">(</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">);</span>

 <span class="nl">fail_free_cpumask:</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">);</span>
	<span class="n">put_online_cpus</span><span class="p">();</span>

 <span class="nl">fail_free_buffer:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__ring_buffer_alloc</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_free - free a ring buffer.</span>
<span class="cm"> * @buffer: the buffer to free.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">ring_buffer_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">get_online_cpus</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
	<span class="n">unregister_cpu_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">cpu_notify</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">for_each_buffer_cpu</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span>
		<span class="n">rb_free_cpu_buffer</span><span class="p">(</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu</span><span class="p">]);</span>

	<span class="n">put_online_cpus</span><span class="p">();</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">);</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_free</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">ring_buffer_set_clock</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
			   <span class="n">u64</span> <span class="p">(</span><span class="o">*</span><span class="n">clock</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span>
<span class="p">{</span>
	<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">clock</span> <span class="o">=</span> <span class="n">clock</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">rb_reset_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">rb_page_entries</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">bpage</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">local_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bpage</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">RB_WRITE_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">rb_page_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">bpage</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">local_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bpage</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">RB_WRITE_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">rb_remove_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">tail_page</span><span class="p">,</span> <span class="o">*</span><span class="n">to_remove</span><span class="p">,</span> <span class="o">*</span><span class="n">next_page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">to_remove_page</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp_iter_page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">last_page</span><span class="p">,</span> <span class="o">*</span><span class="n">first_page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_removed</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">head_bit</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">page_entries</span><span class="p">;</span>

	<span class="n">head_bit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_lock</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">record_disabled</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * We don&#39;t race with the readers since we have acquired the reader</span>
<span class="cm">	 * lock. We also don&#39;t race with writers after disabling recording.</span>
<span class="cm">	 * This makes it easy to figure out the first and the last page to be</span>
<span class="cm">	 * removed from the list. We unlink all the pages in between including</span>
<span class="cm">	 * the first and last pages. This is done in a busy loop so that we</span>
<span class="cm">	 * lose the least number of traces.</span>
<span class="cm">	 * The pages are freed after we restart recording and unlock readers.</span>
<span class="cm">	 */</span>
	<span class="n">tail_page</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">tail_page</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * tail page might be on reader page, we remove the next page</span>
<span class="cm">	 * from the ring buffer</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">tail_page</span> <span class="o">==</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span><span class="p">)</span>
		<span class="n">tail_page</span> <span class="o">=</span> <span class="n">rb_list_head</span><span class="p">(</span><span class="n">tail_page</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
	<span class="n">to_remove</span> <span class="o">=</span> <span class="n">tail_page</span><span class="p">;</span>

	<span class="cm">/* start of pages to remove */</span>
	<span class="n">first_page</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">rb_list_head</span><span class="p">(</span><span class="n">to_remove</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">),</span>
				<span class="k">struct</span> <span class="n">buffer_page</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">nr_removed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">nr_removed</span> <span class="o">&lt;</span> <span class="n">nr_pages</span><span class="p">;</span> <span class="n">nr_removed</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">to_remove</span> <span class="o">=</span> <span class="n">rb_list_head</span><span class="p">(</span><span class="n">to_remove</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">head_bit</span> <span class="o">|=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">to_remove</span> <span class="o">&amp;</span> <span class="n">RB_PAGE_HEAD</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">next_page</span> <span class="o">=</span> <span class="n">rb_list_head</span><span class="p">(</span><span class="n">to_remove</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now we remove all pages between tail_page and next_page.</span>
<span class="cm">	 * Make sure that we have head_bit value preserved for the</span>
<span class="cm">	 * next page</span>
<span class="cm">	 */</span>
	<span class="n">tail_page</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">next_page</span> <span class="o">|</span>
						<span class="n">head_bit</span><span class="p">);</span>
	<span class="n">next_page</span> <span class="o">=</span> <span class="n">rb_list_head</span><span class="p">(</span><span class="n">next_page</span><span class="p">);</span>
	<span class="n">next_page</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">tail_page</span><span class="p">;</span>

	<span class="cm">/* make sure pages points to a valid page in the ring buffer */</span>
	<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">pages</span> <span class="o">=</span> <span class="n">next_page</span><span class="p">;</span>

	<span class="cm">/* update head page */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">head_bit</span><span class="p">)</span>
		<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">head_page</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">next_page</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">buffer_page</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * change read pointer to make sure any read iterators reset</span>
<span class="cm">	 * themselves</span>
<span class="cm">	 */</span>
	<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* pages are removed, resume tracing and then free the pages */</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">record_disabled</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_lock</span><span class="p">);</span>

	<span class="n">RB_WARN_ON</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">list_empty</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">));</span>

	<span class="cm">/* last buffer page to remove */</span>
	<span class="n">last_page</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">rb_list_head</span><span class="p">(</span><span class="n">to_remove</span><span class="p">),</span> <span class="k">struct</span> <span class="n">buffer_page</span><span class="p">,</span>
				<span class="n">list</span><span class="p">);</span>
	<span class="n">tmp_iter_page</span> <span class="o">=</span> <span class="n">first_page</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">to_remove_page</span> <span class="o">=</span> <span class="n">tmp_iter_page</span><span class="p">;</span>
		<span class="n">rb_inc_page</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp_iter_page</span><span class="p">);</span>

		<span class="cm">/* update the counters */</span>
		<span class="n">page_entries</span> <span class="o">=</span> <span class="n">rb_page_entries</span><span class="p">(</span><span class="n">to_remove_page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_entries</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If something was added to this page, it was full</span>
<span class="cm">			 * since it is not the tail page. So we deduct the</span>
<span class="cm">			 * bytes consumed in ring buffer from here.</span>
<span class="cm">			 * No need to update overruns, since this page is</span>
<span class="cm">			 * deleted from ring buffer and its entries are</span>
<span class="cm">			 * already accounted for.</span>
<span class="cm">			 */</span>
			<span class="n">local_sub</span><span class="p">(</span><span class="n">BUF_PAGE_SIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">entries_bytes</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * We have already removed references to this list item, just</span>
<span class="cm">		 * free up the buffer_page and its page</span>
<span class="cm">		 */</span>
		<span class="n">free_buffer_page</span><span class="p">(</span><span class="n">to_remove_page</span><span class="p">);</span>
		<span class="n">nr_removed</span><span class="o">--</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">to_remove_page</span> <span class="o">!=</span> <span class="n">last_page</span><span class="p">);</span>

	<span class="n">RB_WARN_ON</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">nr_removed</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">nr_removed</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">rb_insert_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pages</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">new_pages</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retries</span><span class="p">,</span> <span class="n">success</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * We are holding the reader lock, so the reader page won&#39;t be swapped</span>
<span class="cm">	 * in the ring buffer. Now we are racing with the writer trying to</span>
<span class="cm">	 * move head page and the tail page.</span>
<span class="cm">	 * We are going to adapt the reader page update process where:</span>
<span class="cm">	 * 1. We first splice the start and end of list of new pages between</span>
<span class="cm">	 *    the head page and its previous page.</span>
<span class="cm">	 * 2. We cmpxchg the prev_page-&gt;next to point from head page to the</span>
<span class="cm">	 *    start of new pages list.</span>
<span class="cm">	 * 3. Finally, we update the head-&gt;prev to the end of new list.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We will try this process 10 times, to make sure that we don&#39;t keep</span>
<span class="cm">	 * spinning.</span>
<span class="cm">	 */</span>
	<span class="n">retries</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">success</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">retries</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head_page</span><span class="p">,</span> <span class="o">*</span><span class="n">prev_page</span><span class="p">,</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">last_page</span><span class="p">,</span> <span class="o">*</span><span class="n">first_page</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head_page_with_bit</span><span class="p">;</span>

		<span class="n">head_page</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rb_set_head_page</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">;</span>
		<span class="n">prev_page</span> <span class="o">=</span> <span class="n">head_page</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>

		<span class="n">first_page</span> <span class="o">=</span> <span class="n">pages</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">last_page</span>  <span class="o">=</span> <span class="n">pages</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>

		<span class="n">head_page_with_bit</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="p">)</span>
				     <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">head_page</span> <span class="o">|</span> <span class="n">RB_PAGE_HEAD</span><span class="p">);</span>

		<span class="n">last_page</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head_page_with_bit</span><span class="p">;</span>
		<span class="n">first_page</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">prev_page</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="n">cmpxchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prev_page</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">head_page_with_bit</span><span class="p">,</span> <span class="n">first_page</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">head_page_with_bit</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * yay, we replaced the page pointer to our new list,</span>
<span class="cm">			 * now, we just have to update to head page&#39;s prev</span>
<span class="cm">			 * pointer to point to end of list</span>
<span class="cm">			 */</span>
			<span class="n">head_page</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">last_page</span><span class="p">;</span>
			<span class="n">success</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">success</span><span class="p">)</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we weren&#39;t successful in adding in new pages, warn and stop</span>
<span class="cm">	 * tracing</span>
<span class="cm">	 */</span>
	<span class="n">RB_WARN_ON</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="o">!</span><span class="n">success</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_lock</span><span class="p">);</span>

	<span class="cm">/* free pages if they weren&#39;t inserted */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">success</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">bpage</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">bpage</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">new_pages</span><span class="p">,</span>
					 <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bpage</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">free_buffer_page</span><span class="p">(</span><span class="n">bpage</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">success</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rb_update_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">success</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">nr_pages_to_update</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">success</span> <span class="o">=</span> <span class="n">rb_insert_pages</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">success</span> <span class="o">=</span> <span class="n">rb_remove_pages</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span>
					<span class="o">-</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">nr_pages_to_update</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">success</span><span class="p">)</span>
		<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">nr_pages</span> <span class="o">+=</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">nr_pages_to_update</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_pages_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span><span class="p">,</span> <span class="n">update_pages_work</span><span class="p">);</span>
	<span class="n">rb_update_pages</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>
	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">update_done</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_resize - resize the ring buffer</span>
<span class="cm"> * @buffer: the buffer to resize.</span>
<span class="cm"> * @size: the new size.</span>
<span class="cm"> *</span>
<span class="cm"> * Minimum size is 2 * BUF_PAGE_SIZE.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success and &lt; 0 on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ring_buffer_resize</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">cpu_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">nr_pages</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Always succeed at resizing a non-existent buffer:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">size</span><span class="p">;</span>

	<span class="cm">/* Make sure the requested buffer exists */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_id</span> <span class="o">!=</span> <span class="n">RING_BUFFER_ALL_CPUS</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">,</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">BUF_PAGE_SIZE</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">*=</span> <span class="n">BUF_PAGE_SIZE</span><span class="p">;</span>

	<span class="cm">/* we need a minimum of two pages */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">BUF_PAGE_SIZE</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">BUF_PAGE_SIZE</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">nr_pages</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">BUF_PAGE_SIZE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t succeed if resizing is disabled, as a reader might be</span>
<span class="cm">	 * manipulating the ring buffer and is expecting a sane state while</span>
<span class="cm">	 * this is true.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">resize_disabled</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="cm">/* prevent another thread from changing buffer sizes */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_id</span> <span class="o">==</span> <span class="n">RING_BUFFER_ALL_CPUS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* calculate the pages to update */</span>
		<span class="n">for_each_buffer_cpu</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cpu_buffer</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>

			<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">nr_pages_to_update</span> <span class="o">=</span> <span class="n">nr_pages</span> <span class="o">-</span>
							<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * nothing more to do for removing pages or no update</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">nr_pages_to_update</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * to add pages, make sure all new pages can be</span>
<span class="cm">			 * allocated without receiving ENOMEM</span>
<span class="cm">			 */</span>
			<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">new_pages</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">__rb_allocate_pages</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">nr_pages_to_update</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">new_pages</span><span class="p">,</span> <span class="n">cpu</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* not enough memory for new pages */</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">get_online_cpus</span><span class="p">();</span>
		<span class="cm">/*</span>
<span class="cm">		 * Fire off all the required work handlers</span>
<span class="cm">		 * We can&#39;t schedule on offline CPUs, but it&#39;s not necessary</span>
<span class="cm">		 * since we can change their buffer sizes without any race.</span>
<span class="cm">		 */</span>
		<span class="n">for_each_buffer_cpu</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cpu_buffer</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">nr_pages_to_update</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
				<span class="n">schedule_work_on</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">update_pages_work</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">rb_update_pages</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* wait for all the updates to complete */</span>
		<span class="n">for_each_buffer_cpu</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cpu_buffer</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">nr_pages_to_update</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
				<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">update_done</span><span class="p">);</span>
			<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">nr_pages_to_update</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">put_online_cpus</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cpu_buffer</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu_id</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nr_pages</span> <span class="o">==</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">nr_pages_to_update</span> <span class="o">=</span> <span class="n">nr_pages</span> <span class="o">-</span>
						<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">;</span>

		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">new_pages</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">nr_pages_to_update</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			<span class="n">__rb_allocate_pages</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">nr_pages_to_update</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">new_pages</span><span class="p">,</span> <span class="n">cpu_id</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">get_online_cpus</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">schedule_work_on</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">update_pages_work</span><span class="p">);</span>
			<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">update_done</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">rb_update_pages</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>

		<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">nr_pages_to_update</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">put_online_cpus</span><span class="p">();</span>
	<span class="p">}</span>

 <span class="nl">out:</span>
	<span class="cm">/*</span>
<span class="cm">	 * The ring buffer resize can happen with the ring buffer</span>
<span class="cm">	 * enabled, so that the update disturbs the tracing as little</span>
<span class="cm">	 * as possible. But if the buffer is disabled, we do not need</span>
<span class="cm">	 * to worry about that, and we can take the time to verify</span>
<span class="cm">	 * that the buffer is not corrupt.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">record_disabled</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">record_disabled</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Even though the buffer was disabled, we must make sure</span>
<span class="cm">		 * that it is truly disabled before calling rb_check_pages.</span>
<span class="cm">		 * There could have been a race between checking</span>
<span class="cm">		 * record_disable and incrementing it.</span>
<span class="cm">		 */</span>
		<span class="n">synchronize_sched</span><span class="p">();</span>
		<span class="n">for_each_buffer_cpu</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cpu_buffer</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
			<span class="n">rb_check_pages</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">record_disabled</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>

 <span class="nl">out_err:</span>
	<span class="n">for_each_buffer_cpu</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">bpage</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

		<span class="n">cpu_buffer</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
		<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">nr_pages_to_update</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">new_pages</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">bpage</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">new_pages</span><span class="p">,</span>
					<span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bpage</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">free_buffer_page</span><span class="p">(</span><span class="n">bpage</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_resize</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">ring_buffer_change_overwrite</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span>
		<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">RB_FL_OVERWRITE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RB_FL_OVERWRITE</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_change_overwrite</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">__rb_data_page_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_data_page</span> <span class="o">*</span><span class="n">bpage</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bpage</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">index</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">__rb_page_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">bpage</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bpage</span><span class="o">-&gt;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">index</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span>
<span class="nf">rb_reader_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__rb_page_index</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span><span class="p">,</span>
			       <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span>
<span class="nf">rb_iter_head_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__rb_page_index</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">head_page</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">rb_page_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">bpage</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">local_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bpage</span><span class="o">-&gt;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">commit</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Size is determined by what has been committed */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">rb_page_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">bpage</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rb_page_commit</span><span class="p">(</span><span class="n">bpage</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span>
<span class="nf">rb_commit_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rb_page_commit</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">commit_page</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span>
<span class="nf">rb_event_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">event</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">)</span> <span class="o">-</span> <span class="n">BUF_PAGE_HDR_SIZE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">rb_event_is_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">event</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">rb_event_index</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">addr</span> <span class="o">&amp;=</span> <span class="n">PAGE_MASK</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">commit_page</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">==</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span> <span class="o">&amp;&amp;</span>
		<span class="n">rb_commit_index</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">)</span> <span class="o">==</span> <span class="n">index</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">rb_set_commit_to_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_count</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We only race with interrupts and NMIs on this CPU.</span>
<span class="cm">	 * If we own the commit event, then we can commit</span>
<span class="cm">	 * all others that interrupted us, since the interruptions</span>
<span class="cm">	 * are in stack format (they finish before they come</span>
<span class="cm">	 * back to us). This allows us to do a simple loop to</span>
<span class="cm">	 * assign the commit to the tail.</span>
<span class="cm">	 */</span>
 <span class="nl">again:</span>
	<span class="n">max_count</span> <span class="o">=</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">nr_pages</span> <span class="o">*</span> <span class="mi">100</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">commit_page</span> <span class="o">!=</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">tail_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">RB_WARN_ON</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="o">!</span><span class="p">(</span><span class="o">--</span><span class="n">max_count</span><span class="p">)))</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">RB_WARN_ON</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span>
			       <span class="n">rb_is_reader_page</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">tail_page</span><span class="p">)))</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">local_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">commit_page</span><span class="o">-&gt;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">commit</span><span class="p">,</span>
			  <span class="n">rb_page_write</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">commit_page</span><span class="p">));</span>
		<span class="n">rb_inc_page</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">commit_page</span><span class="p">);</span>
		<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">write_stamp</span> <span class="o">=</span>
			<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">commit_page</span><span class="o">-&gt;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">time_stamp</span><span class="p">;</span>
		<span class="cm">/* add barrier to keep gcc from optimizing too much */</span>
		<span class="n">barrier</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">rb_commit_index</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">)</span> <span class="o">!=</span>
	       <span class="n">rb_page_write</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">commit_page</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">local_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">commit_page</span><span class="o">-&gt;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">commit</span><span class="p">,</span>
			  <span class="n">rb_page_write</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">commit_page</span><span class="p">));</span>
		<span class="n">RB_WARN_ON</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span>
			   <span class="n">local_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">commit_page</span><span class="o">-&gt;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">commit</span><span class="p">)</span> <span class="o">&amp;</span>
			   <span class="o">~</span><span class="n">RB_WRITE_MASK</span><span class="p">);</span>
		<span class="n">barrier</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/* again, keep gcc from optimizing */</span>
	<span class="n">barrier</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * If an interrupt came in just after the first while loop</span>
<span class="cm">	 * and pushed the tail page forward, we will be left with</span>
<span class="cm">	 * a dangling commit that will never go forward.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">commit_page</span> <span class="o">!=</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">tail_page</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rb_reset_reader_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">read_stamp</span> <span class="o">=</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span><span class="o">-&gt;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">time_stamp</span><span class="p">;</span>
	<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rb_inc_iter</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">cpu_buffer</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The iterator could be on the reader page (it starts there).</span>
<span class="cm">	 * But the head could have moved, since the reader was</span>
<span class="cm">	 * found. Check for this case and assign the iterator</span>
<span class="cm">	 * to the head page instead of next.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">head_page</span> <span class="o">==</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span><span class="p">)</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">head_page</span> <span class="o">=</span> <span class="n">rb_set_head_page</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">rb_inc_page</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">head_page</span><span class="p">);</span>

	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">read_stamp</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">head_page</span><span class="o">-&gt;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">time_stamp</span><span class="p">;</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Slow path, do not inline */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span>
<span class="nf">rb_add_time_stamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">u64</span> <span class="n">delta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">type_len</span> <span class="o">=</span> <span class="n">RINGBUF_TYPE_TIME_EXTEND</span><span class="p">;</span>

	<span class="cm">/* Not the first event on the page? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rb_event_index</span><span class="p">(</span><span class="n">event</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">time_delta</span> <span class="o">=</span> <span class="n">delta</span> <span class="o">&amp;</span> <span class="n">TS_MASK</span><span class="p">;</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta</span> <span class="o">&gt;&gt;</span> <span class="n">TS_SHIFT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* nope, just zero it */</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">time_delta</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">skip_time_extend</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_update_event - update event type and data</span>
<span class="cm"> * @event: the even to update</span>
<span class="cm"> * @type: the type of event</span>
<span class="cm"> * @length: the size of the event field in the ring buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Update the type and data fields of the event. The length</span>
<span class="cm"> * is the actual size that is written to the ring buffer,</span>
<span class="cm"> * and with this, we can determine what to place into the</span>
<span class="cm"> * data field.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">rb_update_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">length</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">add_timestamp</span><span class="p">,</span> <span class="n">u64</span> <span class="n">delta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Only a commit updates the timestamp */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">rb_event_is_commit</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">event</span><span class="p">)))</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we need to add a timestamp, then we</span>
<span class="cm">	 * add it to the start of the resevered space.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">add_timestamp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">event</span> <span class="o">=</span> <span class="n">rb_add_time_stamp</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
		<span class="n">length</span> <span class="o">-=</span> <span class="n">RB_LEN_TIME_EXTEND</span><span class="p">;</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">time_delta</span> <span class="o">=</span> <span class="n">delta</span><span class="p">;</span>
	<span class="n">length</span> <span class="o">-=</span> <span class="n">RB_EVNT_HDR_SIZE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">RB_MAX_SMALL_DATA</span> <span class="o">||</span> <span class="n">RB_FORCE_8BYTE_ALIGNMENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">type_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">type_len</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">RB_ALIGNMENT</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * rb_handle_head_page - writer hit the head page</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: +1 to retry page</span>
<span class="cm"> *           0 to continue</span>
<span class="cm"> *          -1 on error</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">rb_handle_head_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">tail_page</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">next_page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">new_head</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">entries</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">entries</span> <span class="o">=</span> <span class="n">rb_page_entries</span><span class="p">(</span><span class="n">next_page</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The hard part is here. We need to move the head</span>
<span class="cm">	 * forward, and protect against both readers on</span>
<span class="cm">	 * other CPUs and writers coming in via interrupts.</span>
<span class="cm">	 */</span>
	<span class="n">type</span> <span class="o">=</span> <span class="n">rb_head_page_set_update</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">next_page</span><span class="p">,</span> <span class="n">tail_page</span><span class="p">,</span>
				       <span class="n">RB_PAGE_HEAD</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * type can be one of four:</span>
<span class="cm">	 *  NORMAL - an interrupt already moved it for us</span>
<span class="cm">	 *  HEAD   - we are the first to get here.</span>
<span class="cm">	 *  UPDATE - we are the interrupt interrupting</span>
<span class="cm">	 *           a current move.</span>
<span class="cm">	 *  MOVED  - a reader on another CPU moved the next</span>
<span class="cm">	 *           pointer to its reader page. Give up</span>
<span class="cm">	 *           and try again.</span>
<span class="cm">	 */</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">RB_PAGE_HEAD</span>:
		<span class="cm">/*</span>
<span class="cm">		 * We changed the head to UPDATE, thus</span>
<span class="cm">		 * it is our responsibility to update</span>
<span class="cm">		 * the counters.</span>
<span class="cm">		 */</span>
		<span class="n">local_add</span><span class="p">(</span><span class="n">entries</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">overrun</span><span class="p">);</span>
		<span class="n">local_sub</span><span class="p">(</span><span class="n">BUF_PAGE_SIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">entries_bytes</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * The entries will be zeroed out when we move the</span>
<span class="cm">		 * tail page.</span>
<span class="cm">		 */</span>

		<span class="cm">/* still more to do */</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">RB_PAGE_UPDATE</span>:
		<span class="cm">/*</span>
<span class="cm">		 * This is an interrupt that interrupt the</span>
<span class="cm">		 * previous update. Still more to do.</span>
<span class="cm">		 */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RB_PAGE_NORMAL</span>:
		<span class="cm">/*</span>
<span class="cm">		 * An interrupt came in before the update</span>
<span class="cm">		 * and processed this for us.</span>
<span class="cm">		 * Nothing left to do.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RB_PAGE_MOVED</span>:
		<span class="cm">/*</span>
<span class="cm">		 * The reader is on another CPU and just did</span>
<span class="cm">		 * a swap with our next_page.</span>
<span class="cm">		 * Try again.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">RB_WARN_ON</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="cm">/* WTF??? */</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now that we are here, the old head pointer is</span>
<span class="cm">	 * set to UPDATE. This will keep the reader from</span>
<span class="cm">	 * swapping the head page with the reader page.</span>
<span class="cm">	 * The reader (on another CPU) will spin till</span>
<span class="cm">	 * we are finished.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We just need to protect against interrupts</span>
<span class="cm">	 * doing the job. We will set the next pointer</span>
<span class="cm">	 * to HEAD. After that, we set the old pointer</span>
<span class="cm">	 * to NORMAL, but only if it was HEAD before.</span>
<span class="cm">	 * otherwise we are an interrupt, and only</span>
<span class="cm">	 * want the outer most commit to reset it.</span>
<span class="cm">	 */</span>
	<span class="n">new_head</span> <span class="o">=</span> <span class="n">next_page</span><span class="p">;</span>
	<span class="n">rb_inc_page</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_head</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">rb_head_page_set_head</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">new_head</span><span class="p">,</span> <span class="n">next_page</span><span class="p">,</span>
				    <span class="n">RB_PAGE_NORMAL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Valid returns are:</span>
<span class="cm">	 *  HEAD   - an interrupt came in and already set it.</span>
<span class="cm">	 *  NORMAL - One of two things:</span>
<span class="cm">	 *            1) We really set it.</span>
<span class="cm">	 *            2) A bunch of interrupts came in and moved</span>
<span class="cm">	 *               the page forward again.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">RB_PAGE_HEAD</span>:
	<span class="k">case</span> <span class="n">RB_PAGE_NORMAL</span>:
		<span class="cm">/* OK */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">RB_WARN_ON</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * It is possible that an interrupt came in,</span>
<span class="cm">	 * set the head up, then more interrupts came in</span>
<span class="cm">	 * and moved it again. When we get back here,</span>
<span class="cm">	 * the page would have been set to NORMAL but we</span>
<span class="cm">	 * just set it back to HEAD.</span>
<span class="cm">	 *</span>
<span class="cm">	 * How do you detect this? Well, if that happened</span>
<span class="cm">	 * the tail page would have moved.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">RB_PAGE_NORMAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the tail had moved passed next, then we need</span>
<span class="cm">		 * to reset the pointer.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">tail_page</span> <span class="o">!=</span> <span class="n">tail_page</span> <span class="o">&amp;&amp;</span>
		    <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">tail_page</span> <span class="o">!=</span> <span class="n">next_page</span><span class="p">)</span>
			<span class="n">rb_head_page_set_normal</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">new_head</span><span class="p">,</span>
						<span class="n">next_page</span><span class="p">,</span>
						<span class="n">RB_PAGE_HEAD</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this was the outer most commit (the one that</span>
<span class="cm">	 * changed the original pointer from HEAD to UPDATE),</span>
<span class="cm">	 * then it is up to us to reset it to NORMAL.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">RB_PAGE_HEAD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">rb_head_page_set_normal</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">next_page</span><span class="p">,</span>
					      <span class="n">tail_page</span><span class="p">,</span>
					      <span class="n">RB_PAGE_UPDATE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">RB_WARN_ON</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span>
			       <span class="n">ret</span> <span class="o">!=</span> <span class="n">RB_PAGE_UPDATE</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">rb_calculate_event_length</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="n">event</span><span class="p">;</span> <span class="cm">/* Used only for sizeof array */</span>

	<span class="cm">/* zero length can cause confusions */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">length</span><span class="p">)</span>
		<span class="n">length</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">RB_MAX_SMALL_DATA</span> <span class="o">||</span> <span class="n">RB_FORCE_8BYTE_ALIGNMENT</span><span class="p">)</span>
		<span class="n">length</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="n">length</span> <span class="o">+=</span> <span class="n">RB_EVNT_HDR_SIZE</span><span class="p">;</span>
	<span class="n">length</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">RB_ARCH_ALIGNMENT</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">rb_reset_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">,</span>
	      <span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">tail_page</span><span class="p">,</span>
	      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tail</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Only the event that crossed the page boundary</span>
<span class="cm">	 * must fill the old tail_page with padding.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tail</span> <span class="o">&gt;=</span> <span class="n">BUF_PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the page was filled, then we still need</span>
<span class="cm">		 * to update the real_end. Reset it to zero</span>
<span class="cm">		 * and the reader will ignore it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tail</span> <span class="o">==</span> <span class="n">BUF_PAGE_SIZE</span><span class="p">)</span>
			<span class="n">tail_page</span><span class="o">-&gt;</span><span class="n">real_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">local_sub</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tail_page</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">__rb_page_index</span><span class="p">(</span><span class="n">tail_page</span><span class="p">,</span> <span class="n">tail</span><span class="p">);</span>
	<span class="n">kmemcheck_annotate_bitfield</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">bitfield</span><span class="p">);</span>

	<span class="cm">/* account for padding bytes */</span>
	<span class="n">local_add</span><span class="p">(</span><span class="n">BUF_PAGE_SIZE</span> <span class="o">-</span> <span class="n">tail</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">entries_bytes</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Save the original length to the meta data.</span>
<span class="cm">	 * This will be used by the reader to add lost event</span>
<span class="cm">	 * counter.</span>
<span class="cm">	 */</span>
	<span class="n">tail_page</span><span class="o">-&gt;</span><span class="n">real_end</span> <span class="o">=</span> <span class="n">tail</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this event is bigger than the minimum size, then</span>
<span class="cm">	 * we need to be careful that we don&#39;t subtract the</span>
<span class="cm">	 * write counter enough to allow another writer to slip</span>
<span class="cm">	 * in on this page.</span>
<span class="cm">	 * We put in a discarded commit instead, to make sure</span>
<span class="cm">	 * that this space is not used again.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If we are less than the minimum size, we don&#39;t need to</span>
<span class="cm">	 * worry about it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tail</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">BUF_PAGE_SIZE</span> <span class="o">-</span> <span class="n">RB_EVNT_MIN_SIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* No room for any events */</span>

		<span class="cm">/* Mark the rest of the page with padding */</span>
		<span class="n">rb_event_set_padding</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

		<span class="cm">/* Set the write back to the previous setting */</span>
		<span class="n">local_sub</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tail_page</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Put in a discarded event */</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">BUF_PAGE_SIZE</span> <span class="o">-</span> <span class="n">tail</span><span class="p">)</span> <span class="o">-</span> <span class="n">RB_EVNT_HDR_SIZE</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">type_len</span> <span class="o">=</span> <span class="n">RINGBUF_TYPE_PADDING</span><span class="p">;</span>
	<span class="cm">/* time delta must be non zero */</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">time_delta</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Set write to end of buffer */</span>
	<span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="n">tail</span> <span class="o">+</span> <span class="n">length</span><span class="p">)</span> <span class="o">-</span> <span class="n">BUF_PAGE_SIZE</span><span class="p">;</span>
	<span class="n">local_sub</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tail_page</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is the slow path, force gcc not to inline it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span>
<span class="nf">rb_move_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">,</span>
	     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">length</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tail</span><span class="p">,</span>
	     <span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">tail_page</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">commit_page</span> <span class="o">=</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">commit_page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">next_page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">next_page</span> <span class="o">=</span> <span class="n">tail_page</span><span class="p">;</span>

	<span class="n">rb_inc_page</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">next_page</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If for some reason, we had an interrupt storm that made</span>
<span class="cm">	 * it all the way around the buffer, bail, and warn</span>
<span class="cm">	 * about it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">next_page</span> <span class="o">==</span> <span class="n">commit_page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">local_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">commit_overrun</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_reset</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is where the fun begins!</span>
<span class="cm">	 *</span>
<span class="cm">	 * We are fighting against races between a reader that</span>
<span class="cm">	 * could be on another CPU trying to swap its reader</span>
<span class="cm">	 * page with the buffer head.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We are also fighting against interrupts coming in and</span>
<span class="cm">	 * moving the head or tail on us as well.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If the next page is the head page then we have filled</span>
<span class="cm">	 * the buffer, unless the commit page is still on the</span>
<span class="cm">	 * reader page.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rb_is_head_page</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">next_page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tail_page</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * If the commit is not on the reader page, then</span>
<span class="cm">		 * move the header page.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rb_is_reader_page</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">commit_page</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If we are not in overwrite mode,</span>
<span class="cm">			 * this is easy, just stop here.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RB_FL_OVERWRITE</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out_reset</span><span class="p">;</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">rb_handle_head_page</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span>
						  <span class="n">tail_page</span><span class="p">,</span>
						  <span class="n">next_page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_reset</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_again</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We need to be careful here too. The</span>
<span class="cm">			 * commit page could still be on the reader</span>
<span class="cm">			 * page. We could have a small buffer, and</span>
<span class="cm">			 * have filled up the buffer with events</span>
<span class="cm">			 * from interrupts and such, and wrapped.</span>
<span class="cm">			 *</span>
<span class="cm">			 * Note, if the tail page is also the on the</span>
<span class="cm">			 * reader_page, we let it move out.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">commit_page</span> <span class="o">!=</span>
				      <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">tail_page</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				     <span class="p">(</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">commit_page</span> <span class="o">==</span>
				      <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">local_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">commit_overrun</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_reset</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">rb_tail_page_update</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">tail_page</span><span class="p">,</span> <span class="n">next_page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Nested commits always have zero deltas, so</span>
<span class="cm">		 * just reread the time stamp</span>
<span class="cm">		 */</span>
		<span class="n">ts</span> <span class="o">=</span> <span class="n">rb_time_stamp</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
		<span class="n">next_page</span><span class="o">-&gt;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">time_stamp</span> <span class="o">=</span> <span class="n">ts</span><span class="p">;</span>
	<span class="p">}</span>

 <span class="nl">out_again:</span>

	<span class="n">rb_reset_tail</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">tail_page</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>

	<span class="cm">/* fail and let the caller try again */</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EAGAIN</span><span class="p">);</span>

 <span class="nl">out_reset:</span>
	<span class="cm">/* reset write */</span>
	<span class="n">rb_reset_tail</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">tail_page</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span>
<span class="nf">__rb_reserve_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">,</span>
		  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">length</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ts</span><span class="p">,</span>
		  <span class="n">u64</span> <span class="n">delta</span><span class="p">,</span> <span class="kt">int</span> <span class="n">add_timestamp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">tail_page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tail</span><span class="p">,</span> <span class="n">write</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the time delta since the last event is too big to</span>
<span class="cm">	 * hold in the time field of the event, then we append a</span>
<span class="cm">	 * TIME EXTEND event ahead of the data event.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">add_timestamp</span><span class="p">))</span>
		<span class="n">length</span> <span class="o">+=</span> <span class="n">RB_LEN_TIME_EXTEND</span><span class="p">;</span>

	<span class="n">tail_page</span> <span class="o">=</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">tail_page</span><span class="p">;</span>
	<span class="n">write</span> <span class="o">=</span> <span class="n">local_add_return</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tail_page</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">);</span>

	<span class="cm">/* set write to only the index of the write */</span>
	<span class="n">write</span> <span class="o">&amp;=</span> <span class="n">RB_WRITE_MASK</span><span class="p">;</span>
	<span class="n">tail</span> <span class="o">=</span> <span class="n">write</span> <span class="o">-</span> <span class="n">length</span><span class="p">;</span>

	<span class="cm">/* See if we shot pass the end of this buffer page */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">write</span> <span class="o">&gt;</span> <span class="n">BUF_PAGE_SIZE</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">rb_move_tail</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span>
				    <span class="n">tail_page</span><span class="p">,</span> <span class="n">ts</span><span class="p">);</span>

	<span class="cm">/* We reserved something on the buffer */</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">__rb_page_index</span><span class="p">(</span><span class="n">tail_page</span><span class="p">,</span> <span class="n">tail</span><span class="p">);</span>
	<span class="n">kmemcheck_annotate_bitfield</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">bitfield</span><span class="p">);</span>
	<span class="n">rb_update_event</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">add_timestamp</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>

	<span class="n">local_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tail_page</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is the first commit on the page, then update</span>
<span class="cm">	 * its timestamp.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tail</span><span class="p">)</span>
		<span class="n">tail_page</span><span class="o">-&gt;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">time_stamp</span> <span class="o">=</span> <span class="n">ts</span><span class="p">;</span>

	<span class="cm">/* account for these added bytes */</span>
	<span class="n">local_add</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">entries_bytes</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">event</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">rb_try_to_discard</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_index</span><span class="p">,</span> <span class="n">old_index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">bpage</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">new_index</span> <span class="o">=</span> <span class="n">rb_event_index</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">old_index</span> <span class="o">=</span> <span class="n">new_index</span> <span class="o">+</span> <span class="n">rb_event_ts_length</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">event</span><span class="p">;</span>
	<span class="n">addr</span> <span class="o">&amp;=</span> <span class="n">PAGE_MASK</span><span class="p">;</span>

	<span class="n">bpage</span> <span class="o">=</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">tail_page</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bpage</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">==</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span> <span class="o">&amp;&amp;</span> <span class="n">rb_page_write</span><span class="p">(</span><span class="n">bpage</span><span class="p">)</span> <span class="o">==</span> <span class="n">old_index</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">write_mask</span> <span class="o">=</span>
			<span class="n">local_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bpage</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">RB_WRITE_MASK</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">event_length</span> <span class="o">=</span> <span class="n">rb_event_length</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * This is on the tail page. It is possible that</span>
<span class="cm">		 * a write could come in and move the tail page</span>
<span class="cm">		 * and write to the next page. That is fine</span>
<span class="cm">		 * because we just shorten what is on this page.</span>
<span class="cm">		 */</span>
		<span class="n">old_index</span> <span class="o">+=</span> <span class="n">write_mask</span><span class="p">;</span>
		<span class="n">new_index</span> <span class="o">+=</span> <span class="n">write_mask</span><span class="p">;</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">local_cmpxchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bpage</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">,</span> <span class="n">old_index</span><span class="p">,</span> <span class="n">new_index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">old_index</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* update counters */</span>
			<span class="n">local_sub</span><span class="p">(</span><span class="n">event_length</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">entries_bytes</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* could not discard */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rb_start_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">local_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">committing</span><span class="p">);</span>
	<span class="n">local_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">commits</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rb_end_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">commits</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">RB_WARN_ON</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span>
		       <span class="o">!</span><span class="n">local_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">committing</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

 <span class="nl">again:</span>
	<span class="n">commits</span> <span class="o">=</span> <span class="n">local_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">commits</span><span class="p">);</span>
	<span class="cm">/* synchronize with interrupts */</span>
	<span class="n">barrier</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">local_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">committing</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">rb_set_commit_to_write</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>

	<span class="n">local_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">committing</span><span class="p">);</span>

	<span class="cm">/* synchronize with interrupts */</span>
	<span class="n">barrier</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Need to account for interrupts coming in between the</span>
<span class="cm">	 * updating of the commit page and the clearing of the</span>
<span class="cm">	 * committing counter.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">local_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">commits</span><span class="p">)</span> <span class="o">!=</span> <span class="n">commits</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">local_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">committing</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">local_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">committing</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span>
<span class="nf">rb_reserve_next_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ts</span><span class="p">,</span> <span class="n">delta</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_loops</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">add_timestamp</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">diff</span><span class="p">;</span>

	<span class="n">rb_start_commit</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_RING_BUFFER_ALLOW_SWAP</span>
	<span class="cm">/*</span>
<span class="cm">	 * Due to the ability to swap a cpu buffer from a buffer</span>
<span class="cm">	 * it is possible it was swapped before we committed.</span>
<span class="cm">	 * (committing stops a swap). We check for it here and</span>
<span class="cm">	 * if it happened, we have to fail the write.</span>
<span class="cm">	 */</span>
	<span class="n">barrier</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">)</span> <span class="o">!=</span> <span class="n">buffer</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">local_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">committing</span><span class="p">);</span>
		<span class="n">local_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">commits</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">length</span> <span class="o">=</span> <span class="n">rb_calculate_event_length</span><span class="p">(</span><span class="n">length</span><span class="p">);</span>
 <span class="nl">again:</span>
	<span class="n">add_timestamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">delta</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We allow for interrupts to reenter here and do a trace.</span>
<span class="cm">	 * If one does, it will cause this original code to loop</span>
<span class="cm">	 * back here. Even with heavy interrupts happening, this</span>
<span class="cm">	 * should only happen a few times in a row. If this happens</span>
<span class="cm">	 * 1000 times in a row, there must be either an interrupt</span>
<span class="cm">	 * storm or we have something buggy.</span>
<span class="cm">	 * Bail!</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">RB_WARN_ON</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="o">++</span><span class="n">nr_loops</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_fail</span><span class="p">;</span>

	<span class="n">ts</span> <span class="o">=</span> <span class="n">rb_time_stamp</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>
	<span class="n">diff</span> <span class="o">=</span> <span class="n">ts</span> <span class="o">-</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">write_stamp</span><span class="p">;</span>

	<span class="cm">/* make sure this diff is calculated here */</span>
	<span class="n">barrier</span><span class="p">();</span>

	<span class="cm">/* Did the write stamp get updated already? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ts</span> <span class="o">&gt;=</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">write_stamp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="n">diff</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">test_time_stamp</span><span class="p">(</span><span class="n">delta</span><span class="p">)))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">local_clock_stable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_HAVE_UNSTABLE_SCHED_CLOCK</span>
			<span class="n">local_clock_stable</span> <span class="o">=</span> <span class="n">sched_clock_stable</span><span class="p">;</span>
<span class="cp">#endif</span>
			<span class="n">WARN_ONCE</span><span class="p">(</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="mi">59</span><span class="p">),</span>
				  <span class="n">KERN_WARNING</span> <span class="s">&quot;Delta way too big! %llu ts=%llu write stamp = %llu</span><span class="se">\n</span><span class="s">%s&quot;</span><span class="p">,</span>
				  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">delta</span><span class="p">,</span>
				  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">ts</span><span class="p">,</span>
				  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">write_stamp</span><span class="p">,</span>
				  <span class="n">local_clock_stable</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span>
				  <span class="s">&quot;If you just came from a suspend/resume,</span><span class="se">\n</span><span class="s">&quot;</span>
				  <span class="s">&quot;please switch to the trace global clock:</span><span class="se">\n</span><span class="s">&quot;</span>
				  <span class="s">&quot;  echo global &gt; /sys/kernel/debug/tracing/trace_clock</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">add_timestamp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">__rb_reserve_next</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span>
				  <span class="n">delta</span><span class="p">,</span> <span class="n">add_timestamp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_fail</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">event</span><span class="p">;</span>

 <span class="nl">out_fail:</span>
	<span class="n">rb_end_commit</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_TRACING</span>

<span class="cp">#define TRACE_RECURSIVE_DEPTH 16</span>

<span class="cm">/* Keep this code out of the fast path cache */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">void</span> <span class="nf">trace_recursive_fail</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Disable all tracing before we do anything else */</span>
	<span class="n">tracing_off_permanent</span><span class="p">();</span>

	<span class="n">printk_once</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Tracing recursion: depth[%ld]:&quot;</span>
		    <span class="s">&quot;HC[%lu]:SC[%lu]:NMI[%lu]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">trace_recursion_buffer</span><span class="p">(),</span>
		    <span class="n">hardirq_count</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="n">HARDIRQ_SHIFT</span><span class="p">,</span>
		    <span class="n">softirq_count</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="n">SOFTIRQ_SHIFT</span><span class="p">,</span>
		    <span class="n">in_nmi</span><span class="p">());</span>

	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">trace_recursive_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_recursion_inc</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">trace_recursion_buffer</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">TRACE_RECURSIVE_DEPTH</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">trace_recursive_fail</span><span class="p">();</span>

	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">trace_recursive_unlock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">trace_recursion_buffer</span><span class="p">());</span>

	<span class="n">trace_recursion_dec</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="cp">#define trace_recursive_lock()		(0)</span>
<span class="cp">#define trace_recursive_unlock()	do { } while (0)</span>

<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_lock_reserve - reserve a part of the buffer</span>
<span class="cm"> * @buffer: the ring buffer to reserve from</span>
<span class="cm"> * @length: the length of the data to reserve (excluding event header)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a reseverd event on the ring buffer to copy directly to.</span>
<span class="cm"> * The user of this interface will need to get the body to write into</span>
<span class="cm"> * and can use the ring_buffer_event_data() interface.</span>
<span class="cm"> *</span>
<span class="cm"> * The length is the length of the data needed, not the event length</span>
<span class="cm"> * which also includes the event header.</span>
<span class="cm"> *</span>
<span class="cm"> * Must be paired with ring_buffer_unlock_commit, unless NULL is returned.</span>
<span class="cm"> * If NULL is returned, then nothing has been allocated or locked.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span>
<span class="nf">ring_buffer_lock_reserve</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ring_buffer_flags</span> <span class="o">!=</span> <span class="n">RB_BUFFERS_ON</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* If we are tracing schedule, we don&#39;t want to recurse */</span>
	<span class="n">preempt_disable_notrace</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">record_disabled</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_nocheck</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trace_recursive_lock</span><span class="p">())</span>
		<span class="k">goto</span> <span class="n">out_nocheck</span><span class="p">;</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="n">raw_smp_processor_id</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">cpu_buffer</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">record_disabled</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">BUF_MAX_DATA_SIZE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">rb_reserve_next_event</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">event</span><span class="p">;</span>

 <span class="nl">out:</span>
	<span class="n">trace_recursive_unlock</span><span class="p">();</span>

 <span class="nl">out_nocheck:</span>
	<span class="n">preempt_enable_notrace</span><span class="p">();</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_lock_reserve</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">rb_update_write_stamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">delta</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The event first in the commit queue updates the</span>
<span class="cm">	 * time stamp.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rb_event_is_commit</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">event</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * A commit event that is first on a page</span>
<span class="cm">		 * updates the write timestamp with the page stamp</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rb_event_index</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
			<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">write_stamp</span> <span class="o">=</span>
				<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">commit_page</span><span class="o">-&gt;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">time_stamp</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">type_len</span> <span class="o">==</span> <span class="n">RINGBUF_TYPE_TIME_EXTEND</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">delta</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="n">delta</span> <span class="o">&lt;&lt;=</span> <span class="n">TS_SHIFT</span><span class="p">;</span>
			<span class="n">delta</span> <span class="o">+=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">time_delta</span><span class="p">;</span>
			<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">write_stamp</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">write_stamp</span> <span class="o">+=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">time_delta</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rb_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">local_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">);</span>
	<span class="n">rb_update_write_stamp</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
	<span class="n">rb_end_commit</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_unlock_commit - commit a reserved</span>
<span class="cm"> * @buffer: The buffer to commit to</span>
<span class="cm"> * @event: The event pointer to commit.</span>
<span class="cm"> *</span>
<span class="cm"> * This commits the data to the ring buffer, and releases any locks held.</span>
<span class="cm"> *</span>
<span class="cm"> * Must be paired with ring_buffer_lock_reserve.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ring_buffer_unlock_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">raw_smp_processor_id</span><span class="p">();</span>

	<span class="n">cpu_buffer</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>

	<span class="n">rb_commit</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>

	<span class="n">trace_recursive_unlock</span><span class="p">();</span>

	<span class="n">preempt_enable_notrace</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_unlock_commit</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rb_event_discard</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">type_len</span> <span class="o">==</span> <span class="n">RINGBUF_TYPE_TIME_EXTEND</span><span class="p">)</span>
		<span class="n">event</span> <span class="o">=</span> <span class="n">skip_time_extend</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="cm">/* array[0] holds the actual length for the discarded event */</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">rb_event_data_length</span><span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="o">-</span> <span class="n">RB_EVNT_HDR_SIZE</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">type_len</span> <span class="o">=</span> <span class="n">RINGBUF_TYPE_PADDING</span><span class="p">;</span>
	<span class="cm">/* time delta must be non zero */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">time_delta</span><span class="p">)</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">time_delta</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Decrement the entries to the page that an event is on.</span>
<span class="cm"> * The event does not even need to exist, only the pointer</span>
<span class="cm"> * to the page it is on. This may only be called before the commit</span>
<span class="cm"> * takes place.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">rb_decrement_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">bpage</span> <span class="o">=</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">commit_page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">start</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">&amp;=</span> <span class="n">PAGE_MASK</span><span class="p">;</span>

	<span class="cm">/* Do the likely case first */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">bpage</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">==</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">local_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bpage</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Because the commit page may be on the reader page we</span>
<span class="cm">	 * start with the next page and check the end loop there.</span>
<span class="cm">	 */</span>
	<span class="n">rb_inc_page</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bpage</span><span class="p">);</span>
	<span class="n">start</span> <span class="o">=</span> <span class="n">bpage</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bpage</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">==</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">local_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bpage</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rb_inc_page</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bpage</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bpage</span> <span class="o">!=</span> <span class="n">start</span><span class="p">);</span>

	<span class="cm">/* commit not part of this buffer?? */</span>
	<span class="n">RB_WARN_ON</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_commit_discard - discard an event that has not been committed</span>
<span class="cm"> * @buffer: the ring buffer</span>
<span class="cm"> * @event: non committed event to discard</span>
<span class="cm"> *</span>
<span class="cm"> * Sometimes an event that is in the ring buffer needs to be ignored.</span>
<span class="cm"> * This function lets the user discard an event in the ring buffer</span>
<span class="cm"> * and then that event will not be read later.</span>
<span class="cm"> *</span>
<span class="cm"> * This function only works if it is called before the the item has been</span>
<span class="cm"> * committed. It will try to free the event from the ring buffer</span>
<span class="cm"> * if another event has not been added behind it.</span>
<span class="cm"> *</span>
<span class="cm"> * If another event has been added behind it, it will set the event</span>
<span class="cm"> * up as discarded, and perform the commit.</span>
<span class="cm"> *</span>
<span class="cm"> * If this function is called, do not call ring_buffer_unlock_commit on</span>
<span class="cm"> * the event.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ring_buffer_discard_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="cm">/* The event is discarded regardless */</span>
	<span class="n">rb_event_discard</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="n">cpu_buffer</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * This must only be called if the event has not been</span>
<span class="cm">	 * committed yet. Thus we can assume that preemption</span>
<span class="cm">	 * is still disabled.</span>
<span class="cm">	 */</span>
	<span class="n">RB_WARN_ON</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="o">!</span><span class="n">local_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">committing</span><span class="p">));</span>

	<span class="n">rb_decrement_entry</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rb_try_to_discard</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">event</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The commit is still visible by the reader, so we</span>
<span class="cm">	 * must still update the timestamp.</span>
<span class="cm">	 */</span>
	<span class="n">rb_update_write_stamp</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="n">rb_end_commit</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>

	<span class="n">trace_recursive_unlock</span><span class="p">();</span>

	<span class="n">preempt_enable_notrace</span><span class="p">();</span>

<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_discard_commit</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_write - write data to the buffer without reserving</span>
<span class="cm"> * @buffer: The ring buffer to write to.</span>
<span class="cm"> * @length: The length of the data being written (excluding the event header)</span>
<span class="cm"> * @data: The data to write to the buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * This is like ring_buffer_lock_reserve and ring_buffer_unlock_commit as</span>
<span class="cm"> * one function. If you already have the data to write to the buffer, it</span>
<span class="cm"> * may be easier to simply call this function.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, like ring_buffer_lock_reserve, the length is the length of the data</span>
<span class="cm"> * and not the length of the event which would hold the header.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ring_buffer_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">length</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">body</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ring_buffer_flags</span> <span class="o">!=</span> <span class="n">RB_BUFFERS_ON</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">preempt_disable_notrace</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">record_disabled</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="n">raw_smp_processor_id</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">cpu_buffer</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">record_disabled</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">BUF_MAX_DATA_SIZE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">rb_reserve_next_event</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">body</span> <span class="o">=</span> <span class="n">rb_event_data</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>

	<span class="n">rb_commit</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">out:</span>
	<span class="n">preempt_enable_notrace</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_write</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rb_per_cpu_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">reader</span> <span class="o">=</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">rb_set_head_page</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">commit</span> <span class="o">=</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">commit_page</span><span class="p">;</span>

	<span class="cm">/* In case of error, head will be NULL */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">head</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">reader</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">==</span> <span class="n">rb_page_commit</span><span class="p">(</span><span class="n">reader</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">commit</span> <span class="o">==</span> <span class="n">reader</span> <span class="o">||</span>
		 <span class="p">(</span><span class="n">commit</span> <span class="o">==</span> <span class="n">head</span> <span class="o">&amp;&amp;</span>
		  <span class="n">head</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">==</span> <span class="n">rb_page_commit</span><span class="p">(</span><span class="n">commit</span><span class="p">)));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_record_disable - stop all writes into the buffer</span>
<span class="cm"> * @buffer: The ring buffer to stop writes to.</span>
<span class="cm"> *</span>
<span class="cm"> * This prevents all writes to the buffer. Any attempt to write</span>
<span class="cm"> * to the buffer after this will fail and return NULL.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller should call synchronize_sched() after this.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ring_buffer_record_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">record_disabled</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_record_disable</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_record_enable - enable writes to the buffer</span>
<span class="cm"> * @buffer: The ring buffer to enable writes</span>
<span class="cm"> *</span>
<span class="cm"> * Note, multiple disables will need the same number of enables</span>
<span class="cm"> * to truly enable the writing (much like preempt_disable).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ring_buffer_record_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">record_disabled</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_record_enable</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_record_off - stop all writes into the buffer</span>
<span class="cm"> * @buffer: The ring buffer to stop writes to.</span>
<span class="cm"> *</span>
<span class="cm"> * This prevents all writes to the buffer. Any attempt to write</span>
<span class="cm"> * to the buffer after this will fail and return NULL.</span>
<span class="cm"> *</span>
<span class="cm"> * This is different than ring_buffer_record_disable() as</span>
<span class="cm"> * it works like an on/off switch, where as the disable() verison</span>
<span class="cm"> * must be paired with a enable().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ring_buffer_record_off</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">new_rd</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">rd</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">record_disabled</span><span class="p">);</span>
		<span class="n">new_rd</span> <span class="o">=</span> <span class="n">rd</span> <span class="o">|</span> <span class="n">RB_BUFFER_OFF</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">atomic_cmpxchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">record_disabled</span><span class="p">,</span> <span class="n">rd</span><span class="p">,</span> <span class="n">new_rd</span><span class="p">)</span> <span class="o">!=</span> <span class="n">rd</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_record_off</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_record_on - restart writes into the buffer</span>
<span class="cm"> * @buffer: The ring buffer to start writes to.</span>
<span class="cm"> *</span>
<span class="cm"> * This enables all writes to the buffer that was disabled by</span>
<span class="cm"> * ring_buffer_record_off().</span>
<span class="cm"> *</span>
<span class="cm"> * This is different than ring_buffer_record_enable() as</span>
<span class="cm"> * it works like an on/off switch, where as the enable() verison</span>
<span class="cm"> * must be paired with a disable().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ring_buffer_record_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">new_rd</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">rd</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">record_disabled</span><span class="p">);</span>
		<span class="n">new_rd</span> <span class="o">=</span> <span class="n">rd</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">RB_BUFFER_OFF</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">atomic_cmpxchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">record_disabled</span><span class="p">,</span> <span class="n">rd</span><span class="p">,</span> <span class="n">new_rd</span><span class="p">)</span> <span class="o">!=</span> <span class="n">rd</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_record_on</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_record_is_on - return true if the ring buffer can write</span>
<span class="cm"> * @buffer: The ring buffer to see if write is enabled</span>
<span class="cm"> *</span>
<span class="cm"> * Returns true if the ring buffer is in a state that it accepts writes.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ring_buffer_record_is_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">record_disabled</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_record_disable_cpu - stop all writes into the cpu_buffer</span>
<span class="cm"> * @buffer: The ring buffer to stop writes to.</span>
<span class="cm"> * @cpu: The CPU buffer to stop</span>
<span class="cm"> *</span>
<span class="cm"> * This prevents all writes to the buffer. Any attempt to write</span>
<span class="cm"> * to the buffer after this will fail and return NULL.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller should call synchronize_sched() after this.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ring_buffer_record_disable_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cpu_buffer</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">record_disabled</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_record_disable_cpu</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_record_enable_cpu - enable writes to the buffer</span>
<span class="cm"> * @buffer: The ring buffer to enable writes</span>
<span class="cm"> * @cpu: The CPU to enable.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, multiple disables will need the same number of enables</span>
<span class="cm"> * to truly enable the writing (much like preempt_disable).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ring_buffer_record_enable_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cpu_buffer</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">record_disabled</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_record_enable_cpu</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The total entries in the ring buffer is the running counter</span>
<span class="cm"> * of entries entered into the ring buffer, minus the sum of</span>
<span class="cm"> * the entries read from the ring buffer and the number of</span>
<span class="cm"> * entries that were overwritten.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">rb_num_of_entries</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">local_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">)</span> <span class="o">-</span>
		<span class="p">(</span><span class="n">local_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">overrun</span><span class="p">)</span> <span class="o">+</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_oldest_event_ts - get the oldest event timestamp from the buffer</span>
<span class="cm"> * @buffer: The ring buffer</span>
<span class="cm"> * @cpu: The per CPU buffer to read from.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">ring_buffer_oldest_event_ts</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">bpage</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cpu_buffer</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * if the tail is on reader_page, oldest time stamp is on the reader</span>
<span class="cm">	 * page</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">tail_page</span> <span class="o">==</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span><span class="p">)</span>
		<span class="n">bpage</span> <span class="o">=</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">bpage</span> <span class="o">=</span> <span class="n">rb_set_head_page</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">bpage</span><span class="o">-&gt;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">time_stamp</span><span class="p">;</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_oldest_event_ts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_bytes_cpu - get the number of bytes consumed in a cpu buffer</span>
<span class="cm"> * @buffer: The ring buffer</span>
<span class="cm"> * @cpu: The per CPU buffer to read from.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">ring_buffer_bytes_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cpu_buffer</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">local_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">entries_bytes</span><span class="p">)</span> <span class="o">-</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">read_bytes</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_bytes_cpu</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_entries_cpu - get the number of entries in a cpu buffer</span>
<span class="cm"> * @buffer: The ring buffer</span>
<span class="cm"> * @cpu: The per CPU buffer to get the entries from.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">ring_buffer_entries_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cpu_buffer</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>

	<span class="k">return</span> <span class="n">rb_num_of_entries</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_entries_cpu</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_overrun_cpu - get the number of overruns in a cpu_buffer</span>
<span class="cm"> * @buffer: The ring buffer</span>
<span class="cm"> * @cpu: The per CPU buffer to get the number of overruns from</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">ring_buffer_overrun_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cpu_buffer</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">local_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">overrun</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_overrun_cpu</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_commit_overrun_cpu - get the number of overruns caused by commits</span>
<span class="cm"> * @buffer: The ring buffer</span>
<span class="cm"> * @cpu: The per CPU buffer to get the number of overruns from</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">ring_buffer_commit_overrun_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cpu_buffer</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">local_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">commit_overrun</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_commit_overrun_cpu</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_entries - get the number of entries in a buffer</span>
<span class="cm"> * @buffer: The ring buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the total number of entries in the ring buffer</span>
<span class="cm"> * (all CPU entries)</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">ring_buffer_entries</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">entries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="cm">/* if you care about this being correct, lock the buffer */</span>
	<span class="n">for_each_buffer_cpu</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpu_buffer</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
		<span class="n">entries</span> <span class="o">+=</span> <span class="n">rb_num_of_entries</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">entries</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_entries</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_overruns - get the number of overruns in buffer</span>
<span class="cm"> * @buffer: The ring buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the total number of overruns in the ring buffer</span>
<span class="cm"> * (all CPU entries)</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">ring_buffer_overruns</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">overruns</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="cm">/* if you care about this being correct, lock the buffer */</span>
	<span class="n">for_each_buffer_cpu</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpu_buffer</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
		<span class="n">overruns</span> <span class="o">+=</span> <span class="n">local_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">overrun</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">overruns</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_overruns</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rb_iter_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">cpu_buffer</span><span class="p">;</span>

	<span class="cm">/* Iterator usage is expected to have record disabled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">head_page</span> <span class="o">=</span> <span class="n">rb_set_head_page</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">head_page</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">head_page</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">head_page</span> <span class="o">=</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span><span class="p">;</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">)</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">read_stamp</span> <span class="o">=</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">read_stamp</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">read_stamp</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">head_page</span><span class="o">-&gt;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">time_stamp</span><span class="p">;</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">cache_reader_page</span> <span class="o">=</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span><span class="p">;</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">cache_read</span> <span class="o">=</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_iter_reset - reset an iterator</span>
<span class="cm"> * @iter: The iterator to reset</span>
<span class="cm"> *</span>
<span class="cm"> * Resets the iterator, so that it will start from the beginning</span>
<span class="cm"> * again.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ring_buffer_iter_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iter</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cpu_buffer</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">cpu_buffer</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">rb_iter_reset</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_iter_reset</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_iter_empty - check if an iterator has no more to read</span>
<span class="cm"> * @iter: The iterator to check</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ring_buffer_iter_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">;</span>

	<span class="n">cpu_buffer</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">cpu_buffer</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">head_page</span> <span class="o">==</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">commit_page</span> <span class="o">&amp;&amp;</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">==</span> <span class="n">rb_commit_index</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_iter_empty</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">rb_update_read_stamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">delta</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">type_len</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">RINGBUF_TYPE_PADDING</span>:
		<span class="k">return</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">RINGBUF_TYPE_TIME_EXTEND</span>:
		<span class="n">delta</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">delta</span> <span class="o">&lt;&lt;=</span> <span class="n">TS_SHIFT</span><span class="p">;</span>
		<span class="n">delta</span> <span class="o">+=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">time_delta</span><span class="p">;</span>
		<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">read_stamp</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">RINGBUF_TYPE_TIME_STAMP</span>:
		<span class="cm">/* FIXME: not implemented */</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">RINGBUF_TYPE_DATA</span>:
		<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">read_stamp</span> <span class="o">+=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">time_delta</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">rb_update_iter_read_stamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">delta</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">type_len</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">RINGBUF_TYPE_PADDING</span>:
		<span class="k">return</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">RINGBUF_TYPE_TIME_EXTEND</span>:
		<span class="n">delta</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">delta</span> <span class="o">&lt;&lt;=</span> <span class="n">TS_SHIFT</span><span class="p">;</span>
		<span class="n">delta</span> <span class="o">+=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">time_delta</span><span class="p">;</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">read_stamp</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">RINGBUF_TYPE_TIME_STAMP</span>:
		<span class="cm">/* FIXME: not implemented */</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">RINGBUF_TYPE_DATA</span>:
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">read_stamp</span> <span class="o">+=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">time_delta</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span>
<span class="nf">rb_get_reader_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">reader</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">overwrite</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_loops</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">arch_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

 <span class="nl">again:</span>
	<span class="cm">/*</span>
<span class="cm">	 * This should normally only loop twice. But because the</span>
<span class="cm">	 * start of the reader inserts an empty page, it causes</span>
<span class="cm">	 * a case where we will loop three times. There should be no</span>
<span class="cm">	 * reason to loop four times (that I know of).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">RB_WARN_ON</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="o">++</span><span class="n">nr_loops</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">reader</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">reader</span> <span class="o">=</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span><span class="p">;</span>

	<span class="cm">/* If there&#39;s more to read, return this page */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">&lt;</span> <span class="n">rb_page_size</span><span class="p">(</span><span class="n">reader</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Never should we have an index greater than the size */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">RB_WARN_ON</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span>
		       <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">&gt;</span> <span class="n">rb_page_size</span><span class="p">(</span><span class="n">reader</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* check if we caught up to the tail */</span>
	<span class="n">reader</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">commit_page</span> <span class="o">==</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reset the reader page to size zero.</span>
<span class="cm">	 */</span>
	<span class="n">local_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">local_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">local_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span><span class="o">-&gt;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">commit</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span><span class="o">-&gt;</span><span class="n">real_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">spin:</span>
	<span class="cm">/*</span>
<span class="cm">	 * Splice the empty reader page into the list around the head.</span>
<span class="cm">	 */</span>
	<span class="n">reader</span> <span class="o">=</span> <span class="n">rb_set_head_page</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>
	<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">rb_list_head</span><span class="p">(</span><span class="n">reader</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>
	<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">reader</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">prev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * cpu_buffer-&gt;pages just needs to point to the buffer, it</span>
<span class="cm">	 *  has no specific buffer page to point to. Lets move it out</span>
<span class="cm">	 *  of our way so we don&#39;t accidentally swap it.</span>
<span class="cm">	 */</span>
	<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">pages</span> <span class="o">=</span> <span class="n">reader</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">prev</span><span class="p">;</span>

	<span class="cm">/* The reader page will be pointing to the new head */</span>
	<span class="n">rb_set_list_to_head</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We want to make sure we read the overruns after we set up our</span>
<span class="cm">	 * pointers to the next object. The writer side does a</span>
<span class="cm">	 * cmpxchg to cross pages which acts as the mb on the writer</span>
<span class="cm">	 * side. Note, the reader will constantly fail the swap</span>
<span class="cm">	 * while the writer is updating the pointers, so this</span>
<span class="cm">	 * guarantees that the overwrite recorded here is the one we</span>
<span class="cm">	 * want to compare with the last_overrun.</span>
<span class="cm">	 */</span>
	<span class="n">smp_mb</span><span class="p">();</span>
	<span class="n">overwrite</span> <span class="o">=</span> <span class="n">local_read</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">overrun</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Here&#39;s the tricky part.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We need to move the pointer past the header page.</span>
<span class="cm">	 * But we can only do that if a writer is not currently</span>
<span class="cm">	 * moving it. The page before the header page has the</span>
<span class="cm">	 * flag bit &#39;1&#39; set if it is pointing to the page we want.</span>
<span class="cm">	 * but if the writer is in the process of moving it</span>
<span class="cm">	 * than it will be &#39;2&#39; or already moved &#39;0&#39;.</span>
<span class="cm">	 */</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">rb_head_page_replace</span><span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we did not convert it, then we must try again.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">spin</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Yeah! We succeeded in replacing the page.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Now make the new head point back to the reader page.</span>
<span class="cm">	 */</span>
	<span class="n">rb_list_head</span><span class="p">(</span><span class="n">reader</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">next</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">;</span>
	<span class="n">rb_inc_page</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">head_page</span><span class="p">);</span>

	<span class="cm">/* Finally update the reader page to the new head */</span>
	<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span> <span class="o">=</span> <span class="n">reader</span><span class="p">;</span>
	<span class="n">rb_reset_reader_page</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">overwrite</span> <span class="o">!=</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">last_overrun</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">lost_events</span> <span class="o">=</span> <span class="n">overwrite</span> <span class="o">-</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">last_overrun</span><span class="p">;</span>
		<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">last_overrun</span> <span class="o">=</span> <span class="n">overwrite</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>

 <span class="nl">out:</span>
	<span class="n">arch_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">reader</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rb_advance_reader</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">reader</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">length</span><span class="p">;</span>

	<span class="n">reader</span> <span class="o">=</span> <span class="n">rb_get_reader_page</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>

	<span class="cm">/* This function should not be called when buffer is empty */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">RB_WARN_ON</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="o">!</span><span class="n">reader</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">rb_reader_event</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">type_len</span> <span class="o">&lt;=</span> <span class="n">RINGBUF_TYPE_DATA_TYPE_LEN_MAX</span><span class="p">)</span>
		<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">read</span><span class="o">++</span><span class="p">;</span>

	<span class="n">rb_update_read_stamp</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>

	<span class="n">length</span> <span class="o">=</span> <span class="n">rb_event_length</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rb_advance_iter</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">length</span><span class="p">;</span>

	<span class="n">cpu_buffer</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">cpu_buffer</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if we are at the end of the buffer.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">&gt;=</span> <span class="n">rb_page_size</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">head_page</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* discarded commits can make the page empty */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">head_page</span> <span class="o">==</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">commit_page</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">rb_inc_iter</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">rb_iter_head_event</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>

	<span class="n">length</span> <span class="o">=</span> <span class="n">rb_event_length</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This should not be called to advance the header if we are</span>
<span class="cm">	 * at the tail of the buffer.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">RB_WARN_ON</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span>
		       <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">head_page</span> <span class="o">==</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">commit_page</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		       <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">+</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="n">rb_commit_index</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">))))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">rb_update_iter_read_stamp</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>

	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>

	<span class="cm">/* check for end of page padding */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">&gt;=</span> <span class="n">rb_page_size</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">head_page</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">head_page</span> <span class="o">!=</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">commit_page</span><span class="p">))</span>
		<span class="n">rb_advance_iter</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rb_lost_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">lost_events</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span>
<span class="nf">rb_buffer_peek</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">ts</span><span class="p">,</span>
	       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">lost_events</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">reader</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_loops</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">again:</span>
	<span class="cm">/*</span>
<span class="cm">	 * We repeat when a time extend is encountered.</span>
<span class="cm">	 * Since the time extend is always attached to a data event,</span>
<span class="cm">	 * we should never loop more than once.</span>
<span class="cm">	 * (We never hit the following condition more than twice).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">RB_WARN_ON</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="o">++</span><span class="n">nr_loops</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">reader</span> <span class="o">=</span> <span class="n">rb_get_reader_page</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reader</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">rb_reader_event</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">type_len</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">RINGBUF_TYPE_PADDING</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">rb_null_event</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
			<span class="n">RB_WARN_ON</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Because the writer could be discarding every</span>
<span class="cm">		 * event it creates (which would probably be bad)</span>
<span class="cm">		 * if we were to go back to &quot;again&quot; then we may never</span>
<span class="cm">		 * catch up, and will trigger the warn on, or lock</span>
<span class="cm">		 * the box. Return the padding, and we will release</span>
<span class="cm">		 * the current locks, and try again.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="n">event</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">RINGBUF_TYPE_TIME_EXTEND</span>:
		<span class="cm">/* Internal data, OK to advance */</span>
		<span class="n">rb_advance_reader</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">RINGBUF_TYPE_TIME_STAMP</span>:
		<span class="cm">/* FIXME: not implemented */</span>
		<span class="n">rb_advance_reader</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">RINGBUF_TYPE_DATA</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">ts</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">ts</span> <span class="o">=</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">read_stamp</span> <span class="o">+</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">time_delta</span><span class="p">;</span>
			<span class="n">ring_buffer_normalize_time_stamp</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span>
							 <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">ts</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lost_events</span><span class="p">)</span>
			<span class="o">*</span><span class="n">lost_events</span> <span class="o">=</span> <span class="n">rb_lost_events</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">event</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_peek</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span>
<span class="nf">rb_iter_peek</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">ts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_loops</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cpu_buffer</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">cpu_buffer</span><span class="p">;</span>
	<span class="n">buffer</span> <span class="o">=</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if someone performed a consuming read to</span>
<span class="cm">	 * the buffer. A consuming read invalidates the iterator</span>
<span class="cm">	 * and we need to reset the iterator in this case.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">cache_read</span> <span class="o">!=</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">||</span>
		     <span class="n">iter</span><span class="o">-&gt;</span><span class="n">cache_reader_page</span> <span class="o">!=</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span><span class="p">))</span>
		<span class="n">rb_iter_reset</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>

 <span class="nl">again:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ring_buffer_iter_empty</span><span class="p">(</span><span class="n">iter</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We repeat when a time extend is encountered.</span>
<span class="cm">	 * Since the time extend is always attached to a data event,</span>
<span class="cm">	 * we should never loop more than once.</span>
<span class="cm">	 * (We never hit the following condition more than twice).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">RB_WARN_ON</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="o">++</span><span class="n">nr_loops</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rb_per_cpu_empty</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">&gt;=</span> <span class="n">local_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">head_page</span><span class="o">-&gt;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">commit</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rb_inc_iter</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">rb_iter_head_event</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">type_len</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">RINGBUF_TYPE_PADDING</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">rb_null_event</span><span class="p">(</span><span class="n">event</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rb_inc_iter</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rb_advance_iter</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">event</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">RINGBUF_TYPE_TIME_EXTEND</span>:
		<span class="cm">/* Internal data, OK to advance */</span>
		<span class="n">rb_advance_iter</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">RINGBUF_TYPE_TIME_STAMP</span>:
		<span class="cm">/* FIXME: not implemented */</span>
		<span class="n">rb_advance_iter</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">RINGBUF_TYPE_DATA</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">ts</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">ts</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">read_stamp</span> <span class="o">+</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">time_delta</span><span class="p">;</span>
			<span class="n">ring_buffer_normalize_time_stamp</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span>
							 <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">ts</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">event</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_iter_peek</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">rb_ok_to_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * If an NMI die dumps out the content of the ring buffer</span>
<span class="cm">	 * do not grab locks. We also permanently disable the ring</span>
<span class="cm">	 * buffer too. A one time deal is all you get from reading</span>
<span class="cm">	 * the ring buffer from an NMI.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">in_nmi</span><span class="p">()))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">tracing_off_permanent</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_peek - peek at the next event to be read</span>
<span class="cm"> * @buffer: The ring buffer to read</span>
<span class="cm"> * @cpu: The cpu to peak at</span>
<span class="cm"> * @ts: The timestamp counter of this event.</span>
<span class="cm"> * @lost_events: a variable to store if events were lost (may be NULL)</span>
<span class="cm"> *</span>
<span class="cm"> * This will return the event that will be read next, but does</span>
<span class="cm"> * not consume the data.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span>
<span class="nf">ring_buffer_peek</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">ts</span><span class="p">,</span>
		 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">lost_events</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dolock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dolock</span> <span class="o">=</span> <span class="n">rb_ok_to_lock</span><span class="p">();</span>
 <span class="nl">again:</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dolock</span><span class="p">)</span>
		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_lock</span><span class="p">);</span>
	<span class="n">event</span> <span class="o">=</span> <span class="n">rb_buffer_peek</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">lost_events</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">&amp;&amp;</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">type_len</span> <span class="o">==</span> <span class="n">RINGBUF_TYPE_PADDING</span><span class="p">)</span>
		<span class="n">rb_advance_reader</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dolock</span><span class="p">)</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_lock</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">&amp;&amp;</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">type_len</span> <span class="o">==</span> <span class="n">RINGBUF_TYPE_PADDING</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">event</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_iter_peek - peek at the next event to be read</span>
<span class="cm"> * @iter: The ring buffer iterator</span>
<span class="cm"> * @ts: The timestamp counter of this event.</span>
<span class="cm"> *</span>
<span class="cm"> * This will return the event that will be read next, but does</span>
<span class="cm"> * not increment the iterator.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span>
<span class="nf">ring_buffer_iter_peek</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">ts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">cpu_buffer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

 <span class="nl">again:</span>
	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">event</span> <span class="o">=</span> <span class="n">rb_iter_peek</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">ts</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">&amp;&amp;</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">type_len</span> <span class="o">==</span> <span class="n">RINGBUF_TYPE_PADDING</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">event</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_consume - return an event and consume it</span>
<span class="cm"> * @buffer: The ring buffer to get the next event from</span>
<span class="cm"> * @cpu: the cpu to read the buffer from</span>
<span class="cm"> * @ts: a variable to store the timestamp (may be NULL)</span>
<span class="cm"> * @lost_events: a variable to store if events were lost (may be NULL)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the next event in the ring buffer, and that event is consumed.</span>
<span class="cm"> * Meaning, that sequential reads will keep returning a different event,</span>
<span class="cm"> * and eventually empty the ring buffer if the producer is slower.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span>
<span class="nf">ring_buffer_consume</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">ts</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">lost_events</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dolock</span><span class="p">;</span>

	<span class="n">dolock</span> <span class="o">=</span> <span class="n">rb_ok_to_lock</span><span class="p">();</span>

 <span class="nl">again:</span>
	<span class="cm">/* might be called in atomic */</span>
	<span class="n">preempt_disable</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">cpu_buffer</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dolock</span><span class="p">)</span>
		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_lock</span><span class="p">);</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">rb_buffer_peek</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">lost_events</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">lost_events</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rb_advance_reader</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dolock</span><span class="p">)</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_lock</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

 <span class="nl">out:</span>
	<span class="n">preempt_enable</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">&amp;&amp;</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">type_len</span> <span class="o">==</span> <span class="n">RINGBUF_TYPE_PADDING</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">event</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_consume</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_read_prepare - Prepare for a non consuming read of the buffer</span>
<span class="cm"> * @buffer: The ring buffer to read from</span>
<span class="cm"> * @cpu: The cpu buffer to iterate over</span>
<span class="cm"> *</span>
<span class="cm"> * This performs the initial preparations necessary to iterate</span>
<span class="cm"> * through the buffer.  Memory is allocated, buffer recording</span>
<span class="cm"> * is disabled, and the iterator pointer is returned to the caller.</span>
<span class="cm"> *</span>
<span class="cm"> * Disabling buffer recordng prevents the reading from being</span>
<span class="cm"> * corrupted. This is not a consuming read, so a producer is not</span>
<span class="cm"> * expected.</span>
<span class="cm"> *</span>
<span class="cm"> * After a sequence of ring_buffer_read_prepare calls, the user is</span>
<span class="cm"> * expected to make at least one call to ring_buffer_prepare_sync.</span>
<span class="cm"> * Afterwards, ring_buffer_read_start is invoked to get things going</span>
<span class="cm"> * for real.</span>
<span class="cm"> *</span>
<span class="cm"> * This overall must be paired with ring_buffer_finish.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ring_buffer_iter</span> <span class="o">*</span>
<span class="nf">ring_buffer_read_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring_buffer_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">iter</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iter</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">cpu_buffer</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>

	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">cpu_buffer</span> <span class="o">=</span> <span class="n">cpu_buffer</span><span class="p">;</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">resize_disabled</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">record_disabled</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">iter</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_read_prepare</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_read_prepare_sync - Synchronize a set of prepare calls</span>
<span class="cm"> *</span>
<span class="cm"> * All previously invoked ring_buffer_read_prepare calls to prepare</span>
<span class="cm"> * iterators will be synchronized.  Afterwards, read_buffer_read_start</span>
<span class="cm"> * calls on those iterators are allowed.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">ring_buffer_read_prepare_sync</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">synchronize_sched</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_read_prepare_sync</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_read_start - start a non consuming read of the buffer</span>
<span class="cm"> * @iter: The iterator returned by ring_buffer_read_prepare</span>
<span class="cm"> *</span>
<span class="cm"> * This finalizes the startup of an iteration through the buffer.</span>
<span class="cm"> * The iterator comes from a call to ring_buffer_read_prepare and</span>
<span class="cm"> * an intervening ring_buffer_read_prepare_sync must have been</span>
<span class="cm"> * performed.</span>
<span class="cm"> *</span>
<span class="cm"> * Must be paired with ring_buffer_finish.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">ring_buffer_read_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iter</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cpu_buffer</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">cpu_buffer</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">arch_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">rb_iter_reset</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
	<span class="n">arch_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_read_start</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_finish - finish reading the iterator of the buffer</span>
<span class="cm"> * @iter: The iterator retrieved by ring_buffer_start</span>
<span class="cm"> *</span>
<span class="cm"> * This re-enables the recording to the buffer, and frees the</span>
<span class="cm"> * iterator.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">ring_buffer_read_finish</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">cpu_buffer</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ring buffer is disabled from recording, here&#39;s a good place</span>
<span class="cm">	 * to check the integrity of the ring buffer. </span>
<span class="cm">	 */</span>
	<span class="n">rb_check_pages</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>

	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">record_disabled</span><span class="p">);</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">resize_disabled</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_read_finish</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_read - read the next item in the ring buffer by the iterator</span>
<span class="cm"> * @iter: The ring buffer iterator</span>
<span class="cm"> * @ts: The time stamp of the event read.</span>
<span class="cm"> *</span>
<span class="cm"> * This reads the next event in the ring buffer and increments the iterator.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span>
<span class="nf">ring_buffer_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">ts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">cpu_buffer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
 <span class="nl">again:</span>
	<span class="n">event</span> <span class="o">=</span> <span class="n">rb_iter_peek</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">ts</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">type_len</span> <span class="o">==</span> <span class="n">RINGBUF_TYPE_PADDING</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>

	<span class="n">rb_advance_iter</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">event</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_read</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_size - return the size of the ring buffer (in bytes)</span>
<span class="cm"> * @buffer: The ring buffer.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">ring_buffer_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Earlier, this method returned</span>
<span class="cm">	 *	BUF_PAGE_SIZE * buffer-&gt;nr_pages</span>
<span class="cm">	 * Since the nr_pages field is now removed, we have converted this to</span>
<span class="cm">	 * return the per cpu buffer value.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">BUF_PAGE_SIZE</span> <span class="o">*</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_size</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">rb_reset_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rb_head_page_deactivate</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>

	<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">head_page</span>
		<span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_page</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="n">local_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">head_page</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">local_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">head_page</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">local_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">head_page</span><span class="o">-&gt;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">commit</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">head_page</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">tail_page</span> <span class="o">=</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">head_page</span><span class="p">;</span>
	<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">commit_page</span> <span class="o">=</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">head_page</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">new_pages</span><span class="p">);</span>
	<span class="n">local_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">local_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">local_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span><span class="o">-&gt;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">commit</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">local_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">commit_overrun</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">local_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">entries_bytes</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">local_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">overrun</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">local_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">local_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">committing</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">local_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">commits</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">read_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">write_stamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">read_stamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">lost_events</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">last_overrun</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rb_head_page_activate</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_reset_cpu - reset a ring buffer per CPU buffer</span>
<span class="cm"> * @buffer: The ring buffer to reset a per cpu buffer of</span>
<span class="cm"> * @cpu: The CPU buffer to be reset</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ring_buffer_reset_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">resize_disabled</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">record_disabled</span><span class="p">);</span>

	<span class="cm">/* Make sure all commits have finished */</span>
	<span class="n">synchronize_sched</span><span class="p">();</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">RB_WARN_ON</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">,</span> <span class="n">local_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">committing</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">arch_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">rb_reset_cpu</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>

	<span class="n">arch_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

 <span class="nl">out:</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">record_disabled</span><span class="p">);</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">resize_disabled</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_reset_cpu</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_reset - reset a ring buffer</span>
<span class="cm"> * @buffer: The ring buffer to reset all cpu buffers</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ring_buffer_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_buffer_cpu</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span>
		<span class="n">ring_buffer_reset_cpu</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_reset</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rind_buffer_empty - is the ring buffer empty?</span>
<span class="cm"> * @buffer: The ring buffer to test</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ring_buffer_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dolock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">dolock</span> <span class="o">=</span> <span class="n">rb_ok_to_lock</span><span class="p">();</span>

	<span class="cm">/* yes this is racy, but if you don&#39;t like the race, lock the buffer */</span>
	<span class="n">for_each_buffer_cpu</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpu_buffer</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
		<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dolock</span><span class="p">)</span>
			<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_lock</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">rb_per_cpu_empty</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dolock</span><span class="p">)</span>
			<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_lock</span><span class="p">);</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_empty</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_empty_cpu - is a cpu buffer of a ring buffer empty?</span>
<span class="cm"> * @buffer: The ring buffer</span>
<span class="cm"> * @cpu: The CPU buffer to test</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ring_buffer_empty_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dolock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">dolock</span> <span class="o">=</span> <span class="n">rb_ok_to_lock</span><span class="p">();</span>

	<span class="n">cpu_buffer</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dolock</span><span class="p">)</span>
		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">rb_per_cpu_empty</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dolock</span><span class="p">)</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_lock</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_empty_cpu</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_RING_BUFFER_ALLOW_SWAP</span>
<span class="cm">/**</span>
<span class="cm"> * ring_buffer_swap_cpu - swap a CPU buffer between two ring buffers</span>
<span class="cm"> * @buffer_a: One buffer to swap with</span>
<span class="cm"> * @buffer_b: The other buffer to swap with</span>
<span class="cm"> *</span>
<span class="cm"> * This function is useful for tracers that want to take a &quot;snapshot&quot;</span>
<span class="cm"> * of a CPU buffer and has another back up buffer lying around.</span>
<span class="cm"> * it is expected that the tracer handles the cpu buffer not being</span>
<span class="cm"> * used at the moment.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ring_buffer_swap_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer_a</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer_b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer_a</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer_b</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">buffer_a</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">buffer_b</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">cpu_buffer_a</span> <span class="o">=</span> <span class="n">buffer_a</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
	<span class="n">cpu_buffer_b</span> <span class="o">=</span> <span class="n">buffer_b</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>

	<span class="cm">/* At least make sure the two buffers are somewhat the same */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_buffer_a</span><span class="o">-&gt;</span><span class="n">nr_pages</span> <span class="o">!=</span> <span class="n">cpu_buffer_b</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ring_buffer_flags</span> <span class="o">!=</span> <span class="n">RB_BUFFERS_ON</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer_a</span><span class="o">-&gt;</span><span class="n">record_disabled</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer_b</span><span class="o">-&gt;</span><span class="n">record_disabled</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer_a</span><span class="o">-&gt;</span><span class="n">record_disabled</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer_b</span><span class="o">-&gt;</span><span class="n">record_disabled</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We can&#39;t do a synchronize_sched here because this</span>
<span class="cm">	 * function can be called in atomic context.</span>
<span class="cm">	 * Normally this will be called from the same CPU as cpu.</span>
<span class="cm">	 * If not it&#39;s up to the caller to protect this.</span>
<span class="cm">	 */</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer_a</span><span class="o">-&gt;</span><span class="n">record_disabled</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer_b</span><span class="o">-&gt;</span><span class="n">record_disabled</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">local_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer_a</span><span class="o">-&gt;</span><span class="n">committing</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_dec</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">local_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer_b</span><span class="o">-&gt;</span><span class="n">committing</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_dec</span><span class="p">;</span>

	<span class="n">buffer_a</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_buffer_b</span><span class="p">;</span>
	<span class="n">buffer_b</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_buffer_a</span><span class="p">;</span>

	<span class="n">cpu_buffer_b</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">buffer_a</span><span class="p">;</span>
	<span class="n">cpu_buffer_a</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">buffer_b</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_dec:</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer_a</span><span class="o">-&gt;</span><span class="n">record_disabled</span><span class="p">);</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer_b</span><span class="o">-&gt;</span><span class="n">record_disabled</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_swap_cpu</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_RING_BUFFER_ALLOW_SWAP */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_alloc_read_page - allocate a page to read from buffer</span>
<span class="cm"> * @buffer: the buffer to allocate for.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is used in conjunction with ring_buffer_read_page.</span>
<span class="cm"> * When reading a full page from the ring buffer, these functions</span>
<span class="cm"> * can be used to speed up the process. The calling function should</span>
<span class="cm"> * allocate a few pages first with this function. Then when it</span>
<span class="cm"> * needs to get pages from the ring buffer, it passes the result</span>
<span class="cm"> * of this function into ring_buffer_read_page, which will swap</span>
<span class="cm"> * the page that was allocated, with the read page of the buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *  The page allocated, or NULL on error.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">ring_buffer_alloc_read_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_data_page</span> <span class="o">*</span><span class="n">bpage</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_pages_node</span><span class="p">(</span><span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">),</span>
				<span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_NORETRY</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">bpage</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">rb_init_page</span><span class="p">(</span><span class="n">bpage</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">bpage</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_alloc_read_page</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_free_read_page - free an allocated read page</span>
<span class="cm"> * @buffer: the buffer the page was allocate for</span>
<span class="cm"> * @data: the page to free</span>
<span class="cm"> *</span>
<span class="cm"> * Free a page allocated from ring_buffer_alloc_read_page.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ring_buffer_free_read_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_free_read_page</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ring_buffer_read_page - extract a page from the ring buffer</span>
<span class="cm"> * @buffer: buffer to extract from</span>
<span class="cm"> * @data_page: the page to use allocated from ring_buffer_alloc_read_page</span>
<span class="cm"> * @len: amount to extract</span>
<span class="cm"> * @cpu: the cpu of the buffer to extract</span>
<span class="cm"> * @full: should the extraction only happen when the page is full.</span>
<span class="cm"> *</span>
<span class="cm"> * This function will pull out a page from the ring buffer and consume it.</span>
<span class="cm"> * @data_page must be the address of the variable that was returned</span>
<span class="cm"> * from ring_buffer_alloc_read_page. This is because the page might be used</span>
<span class="cm"> * to swap with a page in the ring buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * for example:</span>
<span class="cm"> *	rpage = ring_buffer_alloc_read_page(buffer);</span>
<span class="cm"> *	if (!rpage)</span>
<span class="cm"> *		return error;</span>
<span class="cm"> *	ret = ring_buffer_read_page(buffer, &amp;rpage, len, cpu, 0);</span>
<span class="cm"> *	if (ret &gt;= 0)</span>
<span class="cm"> *		process_page(rpage, ret);</span>
<span class="cm"> *</span>
<span class="cm"> * When @full is set, the function will not return true unless</span>
<span class="cm"> * the writer is off the reader page.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: it is up to the calling functions to handle sleeps and wakeups.</span>
<span class="cm"> *  The ring buffer can be used anywhere in the kernel and can not</span>
<span class="cm"> *  blindly call wake_up. The layer that uses the ring buffer must be</span>
<span class="cm"> *  responsible for that.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *  &gt;=0 if data has been transferred, returns the offset of consumed data.</span>
<span class="cm"> *  &lt;0 if no data has been transferred.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ring_buffer_read_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
			  <span class="kt">void</span> <span class="o">**</span><span class="n">data_page</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">full</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_per_cpu</span> <span class="o">*</span><span class="n">cpu_buffer</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_data_page</span> <span class="o">*</span><span class="n">bpage</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_page</span> <span class="o">*</span><span class="n">reader</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">missed_events</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">commit</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">read</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">save_timestamp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If len is not big enough to hold the page header, then</span>
<span class="cm">	 * we can not copy anything.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">BUF_PAGE_HDR_SIZE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">-=</span> <span class="n">BUF_PAGE_HDR_SIZE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data_page</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">bpage</span> <span class="o">=</span> <span class="o">*</span><span class="n">data_page</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bpage</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">reader</span> <span class="o">=</span> <span class="n">rb_get_reader_page</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reader</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">rb_reader_event</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>

	<span class="n">read</span> <span class="o">=</span> <span class="n">reader</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">;</span>
	<span class="n">commit</span> <span class="o">=</span> <span class="n">rb_page_commit</span><span class="p">(</span><span class="n">reader</span><span class="p">);</span>

	<span class="cm">/* Check if any events were dropped */</span>
	<span class="n">missed_events</span> <span class="o">=</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">lost_events</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this page has been partially read or</span>
<span class="cm">	 * if len is not big enough to read the rest of the page or</span>
<span class="cm">	 * a writer is still on the page, then</span>
<span class="cm">	 * we must copy the data from the page to the buffer.</span>
<span class="cm">	 * Otherwise, we can simply swap the page with the one passed in.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">read</span> <span class="o">||</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">commit</span> <span class="o">-</span> <span class="n">read</span><span class="p">))</span> <span class="o">||</span>
	    <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span> <span class="o">==</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">commit_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">buffer_data_page</span> <span class="o">*</span><span class="n">rpage</span> <span class="o">=</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_page</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rpos</span> <span class="o">=</span> <span class="n">read</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">full</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">commit</span> <span class="o">-</span> <span class="n">read</span><span class="p">))</span>
			<span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="n">commit</span> <span class="o">-</span> <span class="n">read</span><span class="p">);</span>

		<span class="cm">/* Always keep the time extend and data together */</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">rb_event_ts_length</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

		<span class="cm">/* save the current timestamp, since the user will need it */</span>
		<span class="n">save_timestamp</span> <span class="o">=</span> <span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">read_stamp</span><span class="p">;</span>

		<span class="cm">/* Need to copy one event at a time */</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="cm">/* We need the size of one event, because</span>
<span class="cm">			 * rb_advance_reader only advances by one event,</span>
<span class="cm">			 * whereas rb_event_ts_length may include the size of</span>
<span class="cm">			 * one or two events.</span>
<span class="cm">			 * We have already ensured there&#39;s enough space if this</span>
<span class="cm">			 * is a time extend. */</span>
			<span class="n">size</span> <span class="o">=</span> <span class="n">rb_event_length</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">bpage</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">rpage</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">rpos</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

			<span class="n">len</span> <span class="o">-=</span> <span class="n">size</span><span class="p">;</span>

			<span class="n">rb_advance_reader</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>
			<span class="n">rpos</span> <span class="o">=</span> <span class="n">reader</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">;</span>
			<span class="n">pos</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">rpos</span> <span class="o">&gt;=</span> <span class="n">commit</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">event</span> <span class="o">=</span> <span class="n">rb_reader_event</span><span class="p">(</span><span class="n">cpu_buffer</span><span class="p">);</span>
			<span class="cm">/* Always keep the time extend and data together */</span>
			<span class="n">size</span> <span class="o">=</span> <span class="n">rb_event_ts_length</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">);</span>

		<span class="cm">/* update bpage */</span>
		<span class="n">local_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bpage</span><span class="o">-&gt;</span><span class="n">commit</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
		<span class="n">bpage</span><span class="o">-&gt;</span><span class="n">time_stamp</span> <span class="o">=</span> <span class="n">save_timestamp</span><span class="p">;</span>

		<span class="cm">/* we copied everything to the beginning */</span>
		<span class="n">read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* update the entry counter */</span>
		<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">+=</span> <span class="n">rb_page_entries</span><span class="p">(</span><span class="n">reader</span><span class="p">);</span>
		<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">read_bytes</span> <span class="o">+=</span> <span class="n">BUF_PAGE_SIZE</span><span class="p">;</span>

		<span class="cm">/* swap the pages */</span>
		<span class="n">rb_init_page</span><span class="p">(</span><span class="n">bpage</span><span class="p">);</span>
		<span class="n">bpage</span> <span class="o">=</span> <span class="n">reader</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">;</span>
		<span class="n">reader</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="o">*</span><span class="n">data_page</span><span class="p">;</span>
		<span class="n">local_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reader</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">local_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reader</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">reader</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="o">*</span><span class="n">data_page</span> <span class="o">=</span> <span class="n">bpage</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Use the real_end for the data size,</span>
<span class="cm">		 * This gives us a chance to store the lost events</span>
<span class="cm">		 * on the page.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reader</span><span class="o">-&gt;</span><span class="n">real_end</span><span class="p">)</span>
			<span class="n">local_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bpage</span><span class="o">-&gt;</span><span class="n">commit</span><span class="p">,</span> <span class="n">reader</span><span class="o">-&gt;</span><span class="n">real_end</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">read</span><span class="p">;</span>

	<span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">lost_events</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">commit</span> <span class="o">=</span> <span class="n">local_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bpage</span><span class="o">-&gt;</span><span class="n">commit</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Set a flag in the commit field if we lost events</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">missed_events</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If there is room at the end of the page to save the</span>
<span class="cm">		 * missed events, then record it there.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">BUF_PAGE_SIZE</span> <span class="o">-</span> <span class="n">commit</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">missed_events</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bpage</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">commit</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">missed_events</span><span class="p">,</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="n">missed_events</span><span class="p">));</span>
			<span class="n">local_add</span><span class="p">(</span><span class="n">RB_MISSED_STORED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bpage</span><span class="o">-&gt;</span><span class="n">commit</span><span class="p">);</span>
			<span class="n">commit</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">missed_events</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">local_add</span><span class="p">(</span><span class="n">RB_MISSED_EVENTS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bpage</span><span class="o">-&gt;</span><span class="n">commit</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * This page may be off to user land. Zero it out here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">commit</span> <span class="o">&lt;</span> <span class="n">BUF_PAGE_SIZE</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bpage</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">commit</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">BUF_PAGE_SIZE</span> <span class="o">-</span> <span class="n">commit</span><span class="p">);</span>

 <span class="nl">out_unlock:</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_buffer</span><span class="o">-&gt;</span><span class="n">reader_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ring_buffer_read_page</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rb_cpu_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ring_buffer</span><span class="p">,</span> <span class="n">cpu_notify</span><span class="p">);</span>
	<span class="kt">long</span> <span class="n">cpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">hcpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu_i</span><span class="p">,</span> <span class="n">nr_pages_same</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_pages</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_UP_PREPARE</span>:
	<span class="k">case</span> <span class="n">CPU_UP_PREPARE_FROZEN</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>

		<span class="n">nr_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">nr_pages_same</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* check if all cpu sizes are same */</span>
		<span class="n">for_each_buffer_cpu</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">cpu_i</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* fill in the size from first enabled cpu */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nr_pages</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">nr_pages</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu_i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nr_pages</span> <span class="o">!=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu_i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">nr_pages_same</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* allocate minimum pages, user can later expand it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nr_pages_same</span><span class="p">)</span>
			<span class="n">nr_pages</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">rb_allocate_cpu_buffer</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">[</span><span class="n">cpu</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;failed to allocate ring buffer on CPU %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">cpu</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">smp_wmb</span><span class="p">();</span>
		<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CPU_DOWN_PREPARE</span>:
	<span class="k">case</span> <span class="n">CPU_DOWN_PREPARE_FROZEN</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Do nothing.</span>
<span class="cm">		 *  If we were to free the buffer, then the user would</span>
<span class="cm">		 *  lose any trace that was in the buffer.</span>
<span class="cm">		 */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
