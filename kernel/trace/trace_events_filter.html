<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › trace › trace_events_filter.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>trace_events_filter.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * trace_events_filter - generic event filtering</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2009 Tom Zanussi &lt;tzanussi@gmail.com&gt;</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/perf_event.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &quot;trace.h&quot;</span>
<span class="cp">#include &quot;trace_output.h&quot;</span>

<span class="cp">#define DEFAULT_SYS_FILTER_MESSAGE					\</span>
<span class="cp">	&quot;### global filter ###\n&quot;					\</span>
<span class="cp">	&quot;# Use this to set filters for multiple events.\n&quot;		\</span>
<span class="cp">	&quot;# Only events with the given fields will be affected.\n&quot;	\</span>
<span class="cp">	&quot;# If no events are modified, an error message will be displayed here&quot;</span>

<span class="k">enum</span> <span class="n">filter_op_ids</span>
<span class="p">{</span>
	<span class="n">OP_OR</span><span class="p">,</span>
	<span class="n">OP_AND</span><span class="p">,</span>
	<span class="n">OP_GLOB</span><span class="p">,</span>
	<span class="n">OP_NE</span><span class="p">,</span>
	<span class="n">OP_EQ</span><span class="p">,</span>
	<span class="n">OP_LT</span><span class="p">,</span>
	<span class="n">OP_LE</span><span class="p">,</span>
	<span class="n">OP_GT</span><span class="p">,</span>
	<span class="n">OP_GE</span><span class="p">,</span>
	<span class="n">OP_NONE</span><span class="p">,</span>
	<span class="n">OP_OPEN_PAREN</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">filter_op</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">precedence</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">filter_op</span> <span class="n">filter_ops</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">OP_OR</span><span class="p">,</span>	<span class="s">&quot;||&quot;</span><span class="p">,</span>		<span class="mi">1</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">OP_AND</span><span class="p">,</span>	<span class="s">&quot;&amp;&amp;&quot;</span><span class="p">,</span>		<span class="mi">2</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">OP_GLOB</span><span class="p">,</span>	<span class="s">&quot;~&quot;</span><span class="p">,</span>		<span class="mi">4</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">OP_NE</span><span class="p">,</span>	<span class="s">&quot;!=&quot;</span><span class="p">,</span>		<span class="mi">4</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">OP_EQ</span><span class="p">,</span>	<span class="s">&quot;==&quot;</span><span class="p">,</span>		<span class="mi">4</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">OP_LT</span><span class="p">,</span>	<span class="s">&quot;&lt;&quot;</span><span class="p">,</span>		<span class="mi">5</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">OP_LE</span><span class="p">,</span>	<span class="s">&quot;&lt;=&quot;</span><span class="p">,</span>		<span class="mi">5</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">OP_GT</span><span class="p">,</span>	<span class="s">&quot;&gt;&quot;</span><span class="p">,</span>		<span class="mi">5</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">OP_GE</span><span class="p">,</span>	<span class="s">&quot;&gt;=&quot;</span><span class="p">,</span>		<span class="mi">5</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">OP_NONE</span><span class="p">,</span>	<span class="s">&quot;OP_NONE&quot;</span><span class="p">,</span>	<span class="mi">0</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">OP_OPEN_PAREN</span><span class="p">,</span> <span class="s">&quot;(&quot;</span><span class="p">,</span>		<span class="mi">0</span> <span class="p">},</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">FILT_ERR_NONE</span><span class="p">,</span>
	<span class="n">FILT_ERR_INVALID_OP</span><span class="p">,</span>
	<span class="n">FILT_ERR_UNBALANCED_PAREN</span><span class="p">,</span>
	<span class="n">FILT_ERR_TOO_MANY_OPERANDS</span><span class="p">,</span>
	<span class="n">FILT_ERR_OPERAND_TOO_LONG</span><span class="p">,</span>
	<span class="n">FILT_ERR_FIELD_NOT_FOUND</span><span class="p">,</span>
	<span class="n">FILT_ERR_ILLEGAL_FIELD_OP</span><span class="p">,</span>
	<span class="n">FILT_ERR_ILLEGAL_INTVAL</span><span class="p">,</span>
	<span class="n">FILT_ERR_BAD_SUBSYS_FILTER</span><span class="p">,</span>
	<span class="n">FILT_ERR_TOO_MANY_PREDS</span><span class="p">,</span>
	<span class="n">FILT_ERR_MISSING_FIELD</span><span class="p">,</span>
	<span class="n">FILT_ERR_INVALID_FILTER</span><span class="p">,</span>
	<span class="n">FILT_ERR_IP_FIELD_ONLY</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">err_text</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;No error&quot;</span><span class="p">,</span>
	<span class="s">&quot;Invalid operator&quot;</span><span class="p">,</span>
	<span class="s">&quot;Unbalanced parens&quot;</span><span class="p">,</span>
	<span class="s">&quot;Too many operands&quot;</span><span class="p">,</span>
	<span class="s">&quot;Operand too long&quot;</span><span class="p">,</span>
	<span class="s">&quot;Field not found&quot;</span><span class="p">,</span>
	<span class="s">&quot;Illegal operation for field type&quot;</span><span class="p">,</span>
	<span class="s">&quot;Illegal integer value&quot;</span><span class="p">,</span>
	<span class="s">&quot;Couldn&#39;t find or set field in one of a subsystem&#39;s events&quot;</span><span class="p">,</span>
	<span class="s">&quot;Too many terms in predicate expression&quot;</span><span class="p">,</span>
	<span class="s">&quot;Missing field name and/or value&quot;</span><span class="p">,</span>
	<span class="s">&quot;Meaningless filter expression&quot;</span><span class="p">,</span>
	<span class="s">&quot;Only &#39;ip&#39; field is supported for function trace&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">opstack_op</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">op</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">postfix_elt</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">op</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">operand</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">filter_parse_state</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">filter_op</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">opstack</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">postfix</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lasterr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lasterr_pos</span><span class="p">;</span>

	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tail</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">infix</span><span class="p">;</span>

	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">string</span><span class="p">[</span><span class="n">MAX_FILTER_STR_VAL</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tail</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">operand</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pred_stack</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">filter_pred</span>	<span class="o">**</span><span class="n">preds</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">index</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define DEFINE_COMPARISON_PRED(type)					\</span>
<span class="cp">static int filter_pred_##type(struct filter_pred *pred, void *event)	\</span>
<span class="cp">{									\</span>
<span class="cp">	type *addr = (type *)(event + pred-&gt;offset);			\</span>
<span class="cp">	type val = (type)pred-&gt;val;					\</span>
<span class="cp">	int match = 0;							\</span>
<span class="cp">									\</span>
<span class="cp">	switch (pred-&gt;op) {						\</span>
<span class="cp">	case OP_LT:							\</span>
<span class="cp">		match = (*addr &lt; val);					\</span>
<span class="cp">		break;							\</span>
<span class="cp">	case OP_LE:							\</span>
<span class="cp">		match = (*addr &lt;= val);					\</span>
<span class="cp">		break;							\</span>
<span class="cp">	case OP_GT:							\</span>
<span class="cp">		match = (*addr &gt; val);					\</span>
<span class="cp">		break;							\</span>
<span class="cp">	case OP_GE:							\</span>
<span class="cp">		match = (*addr &gt;= val);					\</span>
<span class="cp">		break;							\</span>
<span class="cp">	default:							\</span>
<span class="cp">		break;							\</span>
<span class="cp">	}								\</span>
<span class="cp">									\</span>
<span class="cp">	return match;							\</span>
<span class="cp">}</span>

<span class="cp">#define DEFINE_EQUALITY_PRED(size)					\</span>
<span class="cp">static int filter_pred_##size(struct filter_pred *pred, void *event)	\</span>
<span class="cp">{									\</span>
<span class="cp">	u##size *addr = (u##size *)(event + pred-&gt;offset);		\</span>
<span class="cp">	u##size val = (u##size)pred-&gt;val;				\</span>
<span class="cp">	int match;							\</span>
<span class="cp">									\</span>
<span class="cp">	match = (val == *addr) ^ pred-&gt;not;				\</span>
<span class="cp">									\</span>
<span class="cp">	return match;							\</span>
<span class="cp">}</span>

<span class="n">DEFINE_COMPARISON_PRED</span><span class="p">(</span><span class="n">s64</span><span class="p">);</span>
<span class="n">DEFINE_COMPARISON_PRED</span><span class="p">(</span><span class="n">u64</span><span class="p">);</span>
<span class="n">DEFINE_COMPARISON_PRED</span><span class="p">(</span><span class="n">s32</span><span class="p">);</span>
<span class="n">DEFINE_COMPARISON_PRED</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>
<span class="n">DEFINE_COMPARISON_PRED</span><span class="p">(</span><span class="n">s16</span><span class="p">);</span>
<span class="n">DEFINE_COMPARISON_PRED</span><span class="p">(</span><span class="n">u16</span><span class="p">);</span>
<span class="n">DEFINE_COMPARISON_PRED</span><span class="p">(</span><span class="n">s8</span><span class="p">);</span>
<span class="n">DEFINE_COMPARISON_PRED</span><span class="p">(</span><span class="n">u8</span><span class="p">);</span>

<span class="n">DEFINE_EQUALITY_PRED</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span>
<span class="n">DEFINE_EQUALITY_PRED</span><span class="p">(</span><span class="mi">32</span><span class="p">);</span>
<span class="n">DEFINE_EQUALITY_PRED</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
<span class="n">DEFINE_EQUALITY_PRED</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>

<span class="cm">/* Filter predicate for fixed sized arrays of characters */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">filter_pred_string</span><span class="p">(</span><span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">pred</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">event</span> <span class="o">+</span> <span class="n">pred</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">cmp</span><span class="p">,</span> <span class="n">match</span><span class="p">;</span>

	<span class="n">cmp</span> <span class="o">=</span> <span class="n">pred</span><span class="o">-&gt;</span><span class="n">regex</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">regex</span><span class="p">,</span> <span class="n">pred</span><span class="o">-&gt;</span><span class="n">regex</span><span class="p">.</span><span class="n">field_len</span><span class="p">);</span>

	<span class="n">match</span> <span class="o">=</span> <span class="n">cmp</span> <span class="o">^</span> <span class="n">pred</span><span class="o">-&gt;</span><span class="n">not</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">match</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Filter predicate for char * pointers */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">filter_pred_pchar</span><span class="p">(</span><span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">pred</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">**</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="p">)(</span><span class="n">event</span> <span class="o">+</span> <span class="n">pred</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">cmp</span><span class="p">,</span> <span class="n">match</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* including tailing &#39;\0&#39; */</span>

	<span class="n">cmp</span> <span class="o">=</span> <span class="n">pred</span><span class="o">-&gt;</span><span class="n">regex</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">regex</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">match</span> <span class="o">=</span> <span class="n">cmp</span> <span class="o">^</span> <span class="n">pred</span><span class="o">-&gt;</span><span class="n">not</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">match</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Filter predicate for dynamic sized arrays of characters.</span>
<span class="cm"> * These are implemented through a list of strings at the end</span>
<span class="cm"> * of the entry.</span>
<span class="cm"> * Also each of these strings have a field in the entry which</span>
<span class="cm"> * contains its offset from the beginning of the entry.</span>
<span class="cm"> * We have then first to get this field, dereference it</span>
<span class="cm"> * and add it to the address of the entry, and at last we have</span>
<span class="cm"> * the address of the string.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">filter_pred_strloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">pred</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">str_item</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)(</span><span class="n">event</span> <span class="o">+</span> <span class="n">pred</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">str_loc</span> <span class="o">=</span> <span class="n">str_item</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">str_len</span> <span class="o">=</span> <span class="n">str_item</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">event</span> <span class="o">+</span> <span class="n">str_loc</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">cmp</span><span class="p">,</span> <span class="n">match</span><span class="p">;</span>

	<span class="n">cmp</span> <span class="o">=</span> <span class="n">pred</span><span class="o">-&gt;</span><span class="n">regex</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">regex</span><span class="p">,</span> <span class="n">str_len</span><span class="p">);</span>

	<span class="n">match</span> <span class="o">=</span> <span class="n">cmp</span> <span class="o">^</span> <span class="n">pred</span><span class="o">-&gt;</span><span class="n">not</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">match</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">filter_pred_none</span><span class="p">(</span><span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">pred</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * regex_match_foo - Basic regex callbacks</span>
<span class="cm"> *</span>
<span class="cm"> * @str: the string to be searched</span>
<span class="cm"> * @r:   the regex structure containing the pattern string</span>
<span class="cm"> * @len: the length of the string to be searched (including &#39;\0&#39;)</span>
<span class="cm"> *</span>
<span class="cm"> * Note:</span>
<span class="cm"> * - @str might not be NULL-terminated if it&#39;s of type DYN_STRING</span>
<span class="cm"> *   or STATIC_STRING</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">regex_match_full</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="k">struct</span> <span class="n">regex</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">pattern</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">regex_match_front</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="k">struct</span> <span class="n">regex</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">pattern</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">regex_match_middle</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="k">struct</span> <span class="n">regex</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strnstr</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">pattern</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">regex_match_end</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="k">struct</span> <span class="n">regex</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">strlen</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strlen</span> <span class="o">&gt;=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&amp;&amp;</span>
	    <span class="n">memcmp</span><span class="p">(</span><span class="n">str</span> <span class="o">+</span> <span class="n">strlen</span> <span class="o">-</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">pattern</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * filter_parse_regex - parse a basic regex</span>
<span class="cm"> * @buff:   the raw regex</span>
<span class="cm"> * @len:    length of the regex</span>
<span class="cm"> * @search: will point to the beginning of the string to compare</span>
<span class="cm"> * @not:    tell whether the match will have to be inverted</span>
<span class="cm"> *</span>
<span class="cm"> * This passes in a buffer containing a regex and this function will</span>
<span class="cm"> * set search to point to the search part of the buffer and</span>
<span class="cm"> * return the type of search it is (see enum above).</span>
<span class="cm"> * This does modify buff.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns enum type.</span>
<span class="cm"> *  search returns the pointer to use for comparison.</span>
<span class="cm"> *  not returns 1 if buff started with a &#39;!&#39;</span>
<span class="cm"> *     0 otherwise.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">regex_type</span> <span class="nf">filter_parse_regex</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">search</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">not</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">type</span> <span class="o">=</span> <span class="n">MATCH_FULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;!&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">not</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">buff</span><span class="o">++</span><span class="p">;</span>
		<span class="n">len</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="o">*</span><span class="n">not</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="o">*</span><span class="n">search</span> <span class="o">=</span> <span class="n">buff</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;*&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">search</span> <span class="o">=</span> <span class="n">buff</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">type</span> <span class="o">=</span> <span class="n">MATCH_END_ONLY</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">MATCH_END_ONLY</span><span class="p">)</span>
					<span class="n">type</span> <span class="o">=</span> <span class="n">MATCH_MIDDLE_ONLY</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">type</span> <span class="o">=</span> <span class="n">MATCH_FRONT_ONLY</span><span class="p">;</span>
				<span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">type</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">filter_build_regex</span><span class="p">(</span><span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">regex</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">regex</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">search</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">regex_type</span> <span class="n">type</span> <span class="o">=</span> <span class="n">MATCH_FULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">not</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">==</span> <span class="n">OP_GLOB</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">filter_parse_regex</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">pattern</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">search</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">not</span><span class="p">);</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">search</span><span class="p">);</span>
		<span class="n">memmove</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">pattern</span><span class="p">,</span> <span class="n">search</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">len</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MATCH_FULL</span>:
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">match</span> <span class="o">=</span> <span class="n">regex_match_full</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MATCH_FRONT_ONLY</span>:
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">match</span> <span class="o">=</span> <span class="n">regex_match_front</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MATCH_MIDDLE_ONLY</span>:
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">match</span> <span class="o">=</span> <span class="n">regex_match_middle</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MATCH_END_ONLY</span>:
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">match</span> <span class="o">=</span> <span class="n">regex_match_end</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pred</span><span class="o">-&gt;</span><span class="n">not</span> <span class="o">^=</span> <span class="n">not</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">move_type</span> <span class="p">{</span>
	<span class="n">MOVE_DOWN</span><span class="p">,</span>
	<span class="n">MOVE_UP_FROM_LEFT</span><span class="p">,</span>
	<span class="n">MOVE_UP_FROM_RIGHT</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span>
<span class="nf">get_pred_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">pred</span><span class="p">,</span> <span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">preds</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="k">enum</span> <span class="n">move_type</span> <span class="o">*</span><span class="n">move</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">&amp;</span> <span class="n">FILTER_PRED_IS_RIGHT</span><span class="p">)</span>
		<span class="o">*</span><span class="n">move</span> <span class="o">=</span> <span class="n">MOVE_UP_FROM_RIGHT</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">move</span> <span class="o">=</span> <span class="n">MOVE_UP_FROM_LEFT</span><span class="p">;</span>
	<span class="n">pred</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">preds</span><span class="p">[</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">FILTER_PRED_IS_RIGHT</span><span class="p">];</span>

	<span class="k">return</span> <span class="n">pred</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">walk_return</span> <span class="p">{</span>
	<span class="n">WALK_PRED_ABORT</span><span class="p">,</span>
	<span class="n">WALK_PRED_PARENT</span><span class="p">,</span>
	<span class="n">WALK_PRED_DEFAULT</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">filter_pred_walkcb_t</span><span class="p">)</span> <span class="p">(</span><span class="k">enum</span> <span class="n">move_type</span> <span class="n">move</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">pred</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">walk_pred_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">preds</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			  <span class="n">filter_pred_walkcb_t</span> <span class="n">cb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">pred</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">move_type</span> <span class="n">move</span> <span class="o">=</span> <span class="n">MOVE_DOWN</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span>  <span class="p">(</span><span class="o">!</span><span class="n">preds</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">cb</span><span class="p">(</span><span class="n">move</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">WALK_PRED_ABORT</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">WALK_PRED_PARENT</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">get_parent</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">move</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">MOVE_DOWN</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="n">FILTER_PRED_INVALID</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pred</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">preds</span><span class="p">[</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">];</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">goto</span> <span class="n">get_parent</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">MOVE_UP_FROM_LEFT</span>:
			<span class="n">pred</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">preds</span><span class="p">[</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">];</span>
			<span class="n">move</span> <span class="o">=</span> <span class="n">MOVE_DOWN</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">MOVE_UP_FROM_RIGHT</span>:
 <span class="nl">get_parent:</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pred</span> <span class="o">==</span> <span class="n">root</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">pred</span> <span class="o">=</span> <span class="n">get_pred_parent</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">preds</span><span class="p">,</span>
					       <span class="n">pred</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span>
					       <span class="o">&amp;</span><span class="n">move</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">);</span>

	<span class="cm">/* We are fine. */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * A series of AND or ORs where found together. Instead of</span>
<span class="cm"> * climbing up and down the tree branches, an array of the</span>
<span class="cm"> * ops were made in order of checks. We can just move across</span>
<span class="cm"> * the array and short circuit if needed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">process_ops</span><span class="p">(</span><span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">preds</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">rec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">pred</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">match</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Micro-optimization: We set type to true if op</span>
<span class="cm">	 * is an OR and false otherwise (AND). Then we</span>
<span class="cm">	 * just need to test if the match is equal to</span>
<span class="cm">	 * the type, and if it is, we can short circuit the</span>
<span class="cm">	 * rest of the checks:</span>
<span class="cm">	 *</span>
<span class="cm">	 * if ((match &amp;&amp; op-&gt;op == OP_OR) ||</span>
<span class="cm">	 *     (!match &amp;&amp; op-&gt;op == OP_AND))</span>
<span class="cm">	 *	  return match;</span>
<span class="cm">	 */</span>
	<span class="n">type</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">==</span> <span class="n">OP_OR</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pred</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">preds</span><span class="p">[</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">fn</span><span class="p">))</span>
			<span class="n">match</span> <span class="o">=</span> <span class="n">pred</span><span class="o">-&gt;</span><span class="n">fn</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">rec</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!!</span><span class="n">match</span> <span class="o">==</span> <span class="n">type</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">match</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">match</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">filter_match_preds_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">preds</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">match</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">rec</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">filter_match_preds_cb</span><span class="p">(</span><span class="k">enum</span> <span class="n">move_type</span> <span class="n">move</span><span class="p">,</span> <span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">pred</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">filter_match_preds_data</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">move</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MOVE_DOWN</span>:
		<span class="cm">/* only AND and OR have children */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="n">FILTER_PRED_INVALID</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* If ops is set, then it was folded. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">WALK_PRED_DEFAULT</span><span class="p">;</span>
			<span class="cm">/* We can treat folded ops as a leaf node */</span>
			<span class="n">d</span><span class="o">-&gt;</span><span class="n">match</span> <span class="o">=</span> <span class="n">process_ops</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">preds</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">rec</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">fn</span><span class="p">))</span>
				<span class="n">d</span><span class="o">-&gt;</span><span class="n">match</span> <span class="o">=</span> <span class="n">pred</span><span class="o">-&gt;</span><span class="n">fn</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">rec</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="n">WALK_PRED_PARENT</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MOVE_UP_FROM_LEFT</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Check for short circuits.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Optimization: !!match == (pred-&gt;op == OP_OR)</span>
<span class="cm">		 *   is the same as:</span>
<span class="cm">		 * if ((match &amp;&amp; pred-&gt;op == OP_OR) ||</span>
<span class="cm">		 *     (!match &amp;&amp; pred-&gt;op == OP_AND))</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!!</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">match</span> <span class="o">==</span> <span class="p">(</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">==</span> <span class="n">OP_OR</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">WALK_PRED_PARENT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MOVE_UP_FROM_RIGHT</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">WALK_PRED_DEFAULT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* return 1 if event matches, 0 otherwise (discard) */</span>
<span class="kt">int</span> <span class="nf">filter_match_preds</span><span class="p">(</span><span class="k">struct</span> <span class="n">event_filter</span> <span class="o">*</span><span class="n">filter</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">rec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">preds</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">filter_match_preds_data</span> <span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
		<span class="cm">/* match is currently meaningless */</span>
		<span class="p">.</span><span class="n">match</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">rec</span>   <span class="o">=</span> <span class="n">rec</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="kt">int</span> <span class="n">n_preds</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* no filter is considered a match */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">filter</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">n_preds</span> <span class="o">=</span> <span class="n">filter</span><span class="o">-&gt;</span><span class="n">n_preds</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n_preds</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * n_preds, root and filter-&gt;preds are protect with preemption disabled.</span>
<span class="cm">	 */</span>
	<span class="n">root</span> <span class="o">=</span> <span class="n">rcu_dereference_sched</span><span class="p">(</span><span class="n">filter</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">data</span><span class="p">.</span><span class="n">preds</span> <span class="o">=</span> <span class="n">preds</span> <span class="o">=</span> <span class="n">rcu_dereference_sched</span><span class="p">(</span><span class="n">filter</span><span class="o">-&gt;</span><span class="n">preds</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">walk_pred_tree</span><span class="p">(</span><span class="n">preds</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">filter_match_preds_cb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">data</span><span class="p">.</span><span class="n">match</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">filter_match_preds</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">parse_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">filter_parse_state</span> <span class="o">*</span><span class="n">ps</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ps</span><span class="o">-&gt;</span><span class="n">lasterr</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">ps</span><span class="o">-&gt;</span><span class="n">lasterr_pos</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">remove_filter_string</span><span class="p">(</span><span class="k">struct</span> <span class="n">event_filter</span> <span class="o">*</span><span class="n">filter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">filter</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">filter</span><span class="o">-&gt;</span><span class="n">filter_string</span><span class="p">);</span>
	<span class="n">filter</span><span class="o">-&gt;</span><span class="n">filter_string</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">replace_filter_string</span><span class="p">(</span><span class="k">struct</span> <span class="n">event_filter</span> <span class="o">*</span><span class="n">filter</span><span class="p">,</span>
				 <span class="kt">char</span> <span class="o">*</span><span class="n">filter_string</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">filter</span><span class="o">-&gt;</span><span class="n">filter_string</span><span class="p">);</span>
	<span class="n">filter</span><span class="o">-&gt;</span><span class="n">filter_string</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">filter_string</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">filter</span><span class="o">-&gt;</span><span class="n">filter_string</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">append_filter_string</span><span class="p">(</span><span class="k">struct</span> <span class="n">event_filter</span> <span class="o">*</span><span class="n">filter</span><span class="p">,</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">newlen</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">new_filter_string</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">filter</span><span class="o">-&gt;</span><span class="n">filter_string</span><span class="p">);</span>
	<span class="n">newlen</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">filter</span><span class="o">-&gt;</span><span class="n">filter_string</span><span class="p">)</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">string</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">new_filter_string</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">newlen</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_filter_string</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">strcpy</span><span class="p">(</span><span class="n">new_filter_string</span><span class="p">,</span> <span class="n">filter</span><span class="o">-&gt;</span><span class="n">filter_string</span><span class="p">);</span>
	<span class="n">strcat</span><span class="p">(</span><span class="n">new_filter_string</span><span class="p">,</span> <span class="n">string</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">filter</span><span class="o">-&gt;</span><span class="n">filter_string</span><span class="p">);</span>
	<span class="n">filter</span><span class="o">-&gt;</span><span class="n">filter_string</span> <span class="o">=</span> <span class="n">new_filter_string</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">append_filter_err</span><span class="p">(</span><span class="k">struct</span> <span class="n">filter_parse_state</span> <span class="o">*</span><span class="n">ps</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">event_filter</span> <span class="o">*</span><span class="n">filter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">ps</span><span class="o">-&gt;</span><span class="n">lasterr_pos</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="o">*</span><span class="n">pbuf</span><span class="p">;</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_TEMPORARY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">append_filter_string</span><span class="p">(</span><span class="n">filter</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">128</span><span class="p">)</span>
		<span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;^&#39;</span><span class="p">;</span>
	<span class="n">pbuf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">pbuf</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">parse_error: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err_text</span><span class="p">[</span><span class="n">ps</span><span class="o">-&gt;</span><span class="n">lasterr</span><span class="p">]);</span>
	<span class="n">append_filter_string</span><span class="p">(</span><span class="n">filter</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">print_event_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span><span class="p">,</span> <span class="k">struct</span> <span class="n">trace_seq</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">event_filter</span> <span class="o">*</span><span class="n">filter</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event_mutex</span><span class="p">);</span>
	<span class="n">filter</span> <span class="o">=</span> <span class="n">call</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">filter</span> <span class="o">&amp;&amp;</span> <span class="n">filter</span><span class="o">-&gt;</span><span class="n">filter_string</span><span class="p">)</span>
		<span class="n">trace_seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">filter</span><span class="o">-&gt;</span><span class="n">filter_string</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">trace_seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;none</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">print_subsystem_event_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">event_subsystem</span> <span class="o">*</span><span class="n">system</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">trace_seq</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">event_filter</span> <span class="o">*</span><span class="n">filter</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event_mutex</span><span class="p">);</span>
	<span class="n">filter</span> <span class="o">=</span> <span class="n">system</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">filter</span> <span class="o">&amp;&amp;</span> <span class="n">filter</span><span class="o">-&gt;</span><span class="n">filter_string</span><span class="p">)</span>
		<span class="n">trace_seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">filter</span><span class="o">-&gt;</span><span class="n">filter_string</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">trace_seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">DEFAULT_SYS_FILTER_MESSAGE</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ftrace_event_field</span> <span class="o">*</span>
<span class="nf">__find_event_field</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_event_field</span> <span class="o">*</span><span class="n">field</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">field</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">field</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ftrace_event_field</span> <span class="o">*</span>
<span class="nf">find_event_field</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_event_field</span> <span class="o">*</span><span class="n">field</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>

	<span class="n">field</span> <span class="o">=</span> <span class="n">__find_event_field</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_common_fields</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">field</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">field</span><span class="p">;</span>

	<span class="n">head</span> <span class="o">=</span> <span class="n">trace_get_fields</span><span class="p">(</span><span class="n">call</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">__find_event_field</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__alloc_pred_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">pred_stack</span> <span class="o">*</span><span class="n">stack</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n_preds</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">stack</span><span class="o">-&gt;</span><span class="n">preds</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">n_preds</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">stack</span><span class="o">-&gt;</span><span class="n">preds</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stack</span><span class="o">-&gt;</span><span class="n">preds</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">stack</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">n_preds</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__free_pred_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">pred_stack</span> <span class="o">*</span><span class="n">stack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">stack</span><span class="o">-&gt;</span><span class="n">preds</span><span class="p">);</span>
	<span class="n">stack</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__push_pred_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">pred_stack</span> <span class="o">*</span><span class="n">stack</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">stack</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>

	<span class="n">stack</span><span class="o">-&gt;</span><span class="n">preds</span><span class="p">[</span><span class="o">--</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">pred</span><span class="p">;</span>
	<span class="n">stack</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span>
<span class="nf">__pop_pred_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">pred_stack</span> <span class="o">*</span><span class="n">stack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">pred</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">stack</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>

	<span class="n">pred</span> <span class="o">=</span> <span class="n">stack</span><span class="o">-&gt;</span><span class="n">preds</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pred</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">stack</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">pred</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">filter_set_pred</span><span class="p">(</span><span class="k">struct</span> <span class="n">event_filter</span> <span class="o">*</span><span class="n">filter</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">pred_stack</span> <span class="o">*</span><span class="n">stack</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">filter</span><span class="o">-&gt;</span><span class="n">preds</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>

	<span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="o">*</span><span class="n">src</span><span class="p">;</span>
	<span class="n">dest</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">==</span> <span class="n">OP_OR</span> <span class="o">||</span> <span class="n">dest</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">==</span> <span class="n">OP_AND</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">right</span> <span class="o">=</span> <span class="n">__pop_pred_stack</span><span class="p">(</span><span class="n">stack</span><span class="p">);</span>
		<span class="n">left</span> <span class="o">=</span> <span class="n">__pop_pred_stack</span><span class="p">(</span><span class="n">stack</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">left</span> <span class="o">||</span> <span class="o">!</span><span class="n">right</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If both children can be folded</span>
<span class="cm">		 * and they are the same op as this op or a leaf,</span>
<span class="cm">		 * then this op can be folded.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&amp;</span> <span class="n">FILTER_PRED_FOLD</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">==</span> <span class="n">dest</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">||</span>
		     <span class="n">left</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="n">FILTER_PRED_INVALID</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">right</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&amp;</span> <span class="n">FILTER_PRED_FOLD</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">==</span> <span class="n">dest</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">||</span>
		     <span class="n">right</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="n">FILTER_PRED_INVALID</span><span class="p">))</span>
			<span class="n">dest</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">|=</span> <span class="n">FILTER_PRED_FOLD</span><span class="p">;</span>

		<span class="n">dest</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">FILTER_PRED_FOLD</span><span class="p">;</span>
		<span class="n">dest</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">FILTER_PRED_FOLD</span><span class="p">;</span>
		<span class="n">left</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">dest</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">FILTER_PRED_FOLD</span><span class="p">;</span>
		<span class="n">right</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">dest</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">|</span> <span class="n">FILTER_PRED_IS_RIGHT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Make dest-&gt;left invalid to be used as a quick</span>
<span class="cm">		 * way to know this is a leaf node.</span>
<span class="cm">		 */</span>
		<span class="n">dest</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">FILTER_PRED_INVALID</span><span class="p">;</span>

		<span class="cm">/* All leafs allow folding the parent ops. */</span>
		<span class="n">dest</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">|=</span> <span class="n">FILTER_PRED_FOLD</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">__push_pred_stack</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">dest</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__free_preds</span><span class="p">(</span><span class="k">struct</span> <span class="n">event_filter</span> <span class="o">*</span><span class="n">filter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">filter</span><span class="o">-&gt;</span><span class="n">preds</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">filter</span><span class="o">-&gt;</span><span class="n">preds</span><span class="p">);</span>
		<span class="n">filter</span><span class="o">-&gt;</span><span class="n">preds</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">filter</span><span class="o">-&gt;</span><span class="n">a_preds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">filter</span><span class="o">-&gt;</span><span class="n">n_preds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">filter_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">call</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TRACE_EVENT_FL_FILTERED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__free_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">event_filter</span> <span class="o">*</span><span class="n">filter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">filter</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">__free_preds</span><span class="p">(</span><span class="n">filter</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">filter</span><span class="o">-&gt;</span><span class="n">filter_string</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">filter</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called when destroying the ftrace_event_call.</span>
<span class="cm"> * The call is being freed, so we do not need to worry about</span>
<span class="cm"> * the call being currently used. This is for module code removing</span>
<span class="cm"> * the tracepoints from within it.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">destroy_preds</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__free_filter</span><span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">);</span>
	<span class="n">call</span><span class="o">-&gt;</span><span class="n">filter</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">event_filter</span> <span class="o">*</span><span class="nf">__alloc_filter</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">event_filter</span> <span class="o">*</span><span class="n">filter</span><span class="p">;</span>

	<span class="n">filter</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">filter</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">filter</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__alloc_preds</span><span class="p">(</span><span class="k">struct</span> <span class="n">event_filter</span> <span class="o">*</span><span class="n">filter</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n_preds</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">pred</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">filter</span><span class="o">-&gt;</span><span class="n">preds</span><span class="p">)</span>
		<span class="n">__free_preds</span><span class="p">(</span><span class="n">filter</span><span class="p">);</span>

	<span class="n">filter</span><span class="o">-&gt;</span><span class="n">preds</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">n_preds</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">filter</span><span class="o">-&gt;</span><span class="n">preds</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">filter</span><span class="o">-&gt;</span><span class="n">preds</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">filter</span><span class="o">-&gt;</span><span class="n">a_preds</span> <span class="o">=</span> <span class="n">n_preds</span><span class="p">;</span>
	<span class="n">filter</span><span class="o">-&gt;</span><span class="n">n_preds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_preds</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pred</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">filter</span><span class="o">-&gt;</span><span class="n">preds</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">pred</span><span class="o">-&gt;</span><span class="n">fn</span> <span class="o">=</span> <span class="n">filter_pred_none</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">filter_free_subsystem_preds</span><span class="p">(</span><span class="k">struct</span> <span class="n">event_subsystem</span> <span class="o">*</span><span class="n">system</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ftrace_events</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">system</span><span class="p">,</span> <span class="n">system</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">filter_disable</span><span class="p">(</span><span class="n">call</span><span class="p">);</span>
		<span class="n">remove_filter_string</span><span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">filter_free_subsystem_filters</span><span class="p">(</span><span class="k">struct</span> <span class="n">event_subsystem</span> <span class="o">*</span><span class="n">system</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ftrace_events</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">system</span><span class="p">,</span> <span class="n">system</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">__free_filter</span><span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">);</span>
		<span class="n">call</span><span class="o">-&gt;</span><span class="n">filter</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">filter_add_pred</span><span class="p">(</span><span class="k">struct</span> <span class="n">filter_parse_state</span> <span class="o">*</span><span class="n">ps</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">event_filter</span> <span class="o">*</span><span class="n">filter</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">pred</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">pred_stack</span> <span class="o">*</span><span class="n">stack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">filter</span><span class="o">-&gt;</span><span class="n">n_preds</span> <span class="o">==</span> <span class="n">filter</span><span class="o">-&gt;</span><span class="n">a_preds</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">parse_error</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">FILT_ERR_TOO_MANY_PREDS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">filter_set_pred</span><span class="p">(</span><span class="n">filter</span><span class="p">,</span> <span class="n">filter</span><span class="o">-&gt;</span><span class="n">n_preds</span><span class="p">,</span> <span class="n">stack</span><span class="p">,</span> <span class="n">pred</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">filter</span><span class="o">-&gt;</span><span class="n">n_preds</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">filter_assign_type</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="s">&quot;__data_loc&quot;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">strstr</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="s">&quot;char&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">FILTER_DYN_STRING</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strchr</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="sc">&#39;[&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">strstr</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="s">&quot;char&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">FILTER_STATIC_STRING</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">FILTER_OTHER</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">is_function_field</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_event_field</span> <span class="o">*</span><span class="n">field</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">filter_type</span> <span class="o">==</span> <span class="n">FILTER_TRACE_FN</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">is_string_field</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_event_field</span> <span class="o">*</span><span class="n">field</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">filter_type</span> <span class="o">==</span> <span class="n">FILTER_DYN_STRING</span> <span class="o">||</span>
	       <span class="n">field</span><span class="o">-&gt;</span><span class="n">filter_type</span> <span class="o">==</span> <span class="n">FILTER_STATIC_STRING</span> <span class="o">||</span>
	       <span class="n">field</span><span class="o">-&gt;</span><span class="n">filter_type</span> <span class="o">==</span> <span class="n">FILTER_PTR_STRING</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_legal_op</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_event_field</span> <span class="o">*</span><span class="n">field</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_string_field</span><span class="p">(</span><span class="n">field</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">op</span> <span class="o">!=</span> <span class="n">OP_EQ</span> <span class="o">&amp;&amp;</span> <span class="n">op</span> <span class="o">!=</span> <span class="n">OP_NE</span> <span class="o">&amp;&amp;</span> <span class="n">op</span> <span class="o">!=</span> <span class="n">OP_GLOB</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_string_field</span><span class="p">(</span><span class="n">field</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">op</span> <span class="o">==</span> <span class="n">OP_GLOB</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">filter_pred_fn_t</span> <span class="nf">select_comparison_fn</span><span class="p">(</span><span class="kt">int</span> <span class="n">op</span><span class="p">,</span> <span class="kt">int</span> <span class="n">field_size</span><span class="p">,</span>
					     <span class="kt">int</span> <span class="n">field_is_signed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">filter_pred_fn_t</span> <span class="n">fn</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">field_size</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">8</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="n">OP_EQ</span> <span class="o">||</span> <span class="n">op</span> <span class="o">==</span> <span class="n">OP_NE</span><span class="p">)</span>
			<span class="n">fn</span> <span class="o">=</span> <span class="n">filter_pred_64</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">field_is_signed</span><span class="p">)</span>
			<span class="n">fn</span> <span class="o">=</span> <span class="n">filter_pred_s64</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">fn</span> <span class="o">=</span> <span class="n">filter_pred_u64</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="n">OP_EQ</span> <span class="o">||</span> <span class="n">op</span> <span class="o">==</span> <span class="n">OP_NE</span><span class="p">)</span>
			<span class="n">fn</span> <span class="o">=</span> <span class="n">filter_pred_32</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">field_is_signed</span><span class="p">)</span>
			<span class="n">fn</span> <span class="o">=</span> <span class="n">filter_pred_s32</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">fn</span> <span class="o">=</span> <span class="n">filter_pred_u32</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="n">OP_EQ</span> <span class="o">||</span> <span class="n">op</span> <span class="o">==</span> <span class="n">OP_NE</span><span class="p">)</span>
			<span class="n">fn</span> <span class="o">=</span> <span class="n">filter_pred_16</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">field_is_signed</span><span class="p">)</span>
			<span class="n">fn</span> <span class="o">=</span> <span class="n">filter_pred_s16</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">fn</span> <span class="o">=</span> <span class="n">filter_pred_u16</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="n">OP_EQ</span> <span class="o">||</span> <span class="n">op</span> <span class="o">==</span> <span class="n">OP_NE</span><span class="p">)</span>
			<span class="n">fn</span> <span class="o">=</span> <span class="n">filter_pred_8</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">field_is_signed</span><span class="p">)</span>
			<span class="n">fn</span> <span class="o">=</span> <span class="n">filter_pred_s8</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">fn</span> <span class="o">=</span> <span class="n">filter_pred_u8</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">fn</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_pred</span><span class="p">(</span><span class="k">struct</span> <span class="n">filter_parse_state</span> <span class="o">*</span><span class="n">ps</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">ftrace_event_field</span> <span class="o">*</span><span class="n">field</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">pred</span><span class="p">)</span>

<span class="p">{</span>
	<span class="n">filter_pred_fn_t</span> <span class="n">fn</span> <span class="o">=</span> <span class="n">filter_pred_none</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">pred</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_legal_op</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">pred</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">parse_error</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">FILT_ERR_ILLEGAL_FIELD_OP</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_string_field</span><span class="p">(</span><span class="n">field</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">filter_build_regex</span><span class="p">(</span><span class="n">pred</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">field</span><span class="o">-&gt;</span><span class="n">filter_type</span> <span class="o">==</span> <span class="n">FILTER_STATIC_STRING</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fn</span> <span class="o">=</span> <span class="n">filter_pred_string</span><span class="p">;</span>
			<span class="n">pred</span><span class="o">-&gt;</span><span class="n">regex</span><span class="p">.</span><span class="n">field_len</span> <span class="o">=</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">field</span><span class="o">-&gt;</span><span class="n">filter_type</span> <span class="o">==</span> <span class="n">FILTER_DYN_STRING</span><span class="p">)</span>
			<span class="n">fn</span> <span class="o">=</span> <span class="n">filter_pred_strloc</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">fn</span> <span class="o">=</span> <span class="n">filter_pred_pchar</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_function_field</span><span class="p">(</span><span class="n">field</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">field</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;ip&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">parse_error</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">FILT_ERR_IP_FIELD_ONLY</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">field</span><span class="o">-&gt;</span><span class="n">is_signed</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">strict_strtoll</span><span class="p">(</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">regex</span><span class="p">.</span><span class="n">pattern</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">strict_strtoull</span><span class="p">(</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">regex</span><span class="p">.</span><span class="n">pattern</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">parse_error</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">FILT_ERR_ILLEGAL_INTVAL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pred</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>

		<span class="n">fn</span> <span class="o">=</span> <span class="n">select_comparison_fn</span><span class="p">(</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">,</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
					  <span class="n">field</span><span class="o">-&gt;</span><span class="n">is_signed</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fn</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">parse_error</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">FILT_ERR_INVALID_OP</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">==</span> <span class="n">OP_NE</span><span class="p">)</span>
		<span class="n">pred</span><span class="o">-&gt;</span><span class="n">not</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">pred</span><span class="o">-&gt;</span><span class="n">fn</span> <span class="o">=</span> <span class="n">fn</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">parse_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">filter_parse_state</span> <span class="o">*</span><span class="n">ps</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">filter_op</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span>
		       <span class="kt">char</span> <span class="o">*</span><span class="n">infix_string</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="sc">&#39;\0&#39;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ps</span><span class="p">));</span>

	<span class="n">ps</span><span class="o">-&gt;</span><span class="n">infix</span><span class="p">.</span><span class="n">string</span> <span class="o">=</span> <span class="n">infix_string</span><span class="p">;</span>
	<span class="n">ps</span><span class="o">-&gt;</span><span class="n">infix</span><span class="p">.</span><span class="n">cnt</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">infix_string</span><span class="p">);</span>
	<span class="n">ps</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="n">ops</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ps</span><span class="o">-&gt;</span><span class="n">opstack</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ps</span><span class="o">-&gt;</span><span class="n">postfix</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">char</span> <span class="nf">infix_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">filter_parse_state</span> <span class="o">*</span><span class="n">ps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ps</span><span class="o">-&gt;</span><span class="n">infix</span><span class="p">.</span><span class="n">cnt</span><span class="o">--</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ps</span><span class="o">-&gt;</span><span class="n">infix</span><span class="p">.</span><span class="n">string</span><span class="p">[</span><span class="n">ps</span><span class="o">-&gt;</span><span class="n">infix</span><span class="p">.</span><span class="n">tail</span><span class="o">++</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">char</span> <span class="nf">infix_peek</span><span class="p">(</span><span class="k">struct</span> <span class="n">filter_parse_state</span> <span class="o">*</span><span class="n">ps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ps</span><span class="o">-&gt;</span><span class="n">infix</span><span class="p">.</span><span class="n">tail</span> <span class="o">==</span> <span class="n">strlen</span><span class="p">(</span><span class="n">ps</span><span class="o">-&gt;</span><span class="n">infix</span><span class="p">.</span><span class="n">string</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ps</span><span class="o">-&gt;</span><span class="n">infix</span><span class="p">.</span><span class="n">string</span><span class="p">[</span><span class="n">ps</span><span class="o">-&gt;</span><span class="n">infix</span><span class="p">.</span><span class="n">tail</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">infix_advance</span><span class="p">(</span><span class="k">struct</span> <span class="n">filter_parse_state</span> <span class="o">*</span><span class="n">ps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ps</span><span class="o">-&gt;</span><span class="n">infix</span><span class="p">.</span><span class="n">cnt</span><span class="o">--</span><span class="p">;</span>
	<span class="n">ps</span><span class="o">-&gt;</span><span class="n">infix</span><span class="p">.</span><span class="n">tail</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_precedence_lower</span><span class="p">(</span><span class="k">struct</span> <span class="n">filter_parse_state</span> <span class="o">*</span><span class="n">ps</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ps</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">precedence</span> <span class="o">&lt;</span> <span class="n">ps</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">precedence</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_op_char</span><span class="p">(</span><span class="k">struct</span> <span class="n">filter_parse_state</span> <span class="o">*</span><span class="n">ps</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">ps</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">string</span><span class="p">,</span> <span class="s">&quot;OP_NONE&quot;</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ps</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">string</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">infix_get_op</span><span class="p">(</span><span class="k">struct</span> <span class="n">filter_parse_state</span> <span class="o">*</span><span class="n">ps</span><span class="p">,</span> <span class="kt">char</span> <span class="n">firstc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">nextc</span> <span class="o">=</span> <span class="n">infix_peek</span><span class="p">(</span><span class="n">ps</span><span class="p">);</span>
	<span class="kt">char</span> <span class="n">opstr</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">opstr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">firstc</span><span class="p">;</span>
	<span class="n">opstr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nextc</span><span class="p">;</span>
	<span class="n">opstr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">ps</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">string</span><span class="p">,</span> <span class="s">&quot;OP_NONE&quot;</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">opstr</span><span class="p">,</span> <span class="n">ps</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">string</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">infix_advance</span><span class="p">(</span><span class="n">ps</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ps</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">id</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">opstr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">ps</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">string</span><span class="p">,</span> <span class="s">&quot;OP_NONE&quot;</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">opstr</span><span class="p">,</span> <span class="n">ps</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">string</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">ps</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">id</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">OP_NONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clear_operand_string</span><span class="p">(</span><span class="k">struct</span> <span class="n">filter_parse_state</span> <span class="o">*</span><span class="n">ps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ps</span><span class="o">-&gt;</span><span class="n">operand</span><span class="p">.</span><span class="n">string</span><span class="p">,</span> <span class="sc">&#39;\0&#39;</span><span class="p">,</span> <span class="n">MAX_FILTER_STR_VAL</span><span class="p">);</span>
	<span class="n">ps</span><span class="o">-&gt;</span><span class="n">operand</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">append_operand_char</span><span class="p">(</span><span class="k">struct</span> <span class="n">filter_parse_state</span> <span class="o">*</span><span class="n">ps</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ps</span><span class="o">-&gt;</span><span class="n">operand</span><span class="p">.</span><span class="n">tail</span> <span class="o">==</span> <span class="n">MAX_FILTER_STR_VAL</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ps</span><span class="o">-&gt;</span><span class="n">operand</span><span class="p">.</span><span class="n">string</span><span class="p">[</span><span class="n">ps</span><span class="o">-&gt;</span><span class="n">operand</span><span class="p">.</span><span class="n">tail</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">filter_opstack_push</span><span class="p">(</span><span class="k">struct</span> <span class="n">filter_parse_state</span> <span class="o">*</span><span class="n">ps</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">opstack_op</span> <span class="o">*</span><span class="n">opstack_op</span><span class="p">;</span>

	<span class="n">opstack_op</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">opstack_op</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">opstack_op</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">opstack_op</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">opstack_op</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ps</span><span class="o">-&gt;</span><span class="n">opstack</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">filter_opstack_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">filter_parse_state</span> <span class="o">*</span><span class="n">ps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ps</span><span class="o">-&gt;</span><span class="n">opstack</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">filter_opstack_top</span><span class="p">(</span><span class="k">struct</span> <span class="n">filter_parse_state</span> <span class="o">*</span><span class="n">ps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">opstack_op</span> <span class="o">*</span><span class="n">opstack_op</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">filter_opstack_empty</span><span class="p">(</span><span class="n">ps</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">OP_NONE</span><span class="p">;</span>

	<span class="n">opstack_op</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ps</span><span class="o">-&gt;</span><span class="n">opstack</span><span class="p">,</span> <span class="k">struct</span> <span class="n">opstack_op</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">opstack_op</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">filter_opstack_pop</span><span class="p">(</span><span class="k">struct</span> <span class="n">filter_parse_state</span> <span class="o">*</span><span class="n">ps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">opstack_op</span> <span class="o">*</span><span class="n">opstack_op</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">op</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">filter_opstack_empty</span><span class="p">(</span><span class="n">ps</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">OP_NONE</span><span class="p">;</span>

	<span class="n">opstack_op</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ps</span><span class="o">-&gt;</span><span class="n">opstack</span><span class="p">,</span> <span class="k">struct</span> <span class="n">opstack_op</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="n">op</span> <span class="o">=</span> <span class="n">opstack_op</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">;</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">opstack_op</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">opstack_op</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">op</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">filter_opstack_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">filter_parse_state</span> <span class="o">*</span><span class="n">ps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">filter_opstack_empty</span><span class="p">(</span><span class="n">ps</span><span class="p">))</span>
		<span class="n">filter_opstack_pop</span><span class="p">(</span><span class="n">ps</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">curr_operand</span><span class="p">(</span><span class="k">struct</span> <span class="n">filter_parse_state</span> <span class="o">*</span><span class="n">ps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ps</span><span class="o">-&gt;</span><span class="n">operand</span><span class="p">.</span><span class="n">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">postfix_append_operand</span><span class="p">(</span><span class="k">struct</span> <span class="n">filter_parse_state</span> <span class="o">*</span><span class="n">ps</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">operand</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">postfix_elt</span> <span class="o">*</span><span class="n">elt</span><span class="p">;</span>

	<span class="n">elt</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">elt</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elt</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">elt</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">=</span> <span class="n">OP_NONE</span><span class="p">;</span>
	<span class="n">elt</span><span class="o">-&gt;</span><span class="n">operand</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elt</span><span class="o">-&gt;</span><span class="n">operand</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">elt</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">elt</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ps</span><span class="o">-&gt;</span><span class="n">postfix</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">postfix_append_op</span><span class="p">(</span><span class="k">struct</span> <span class="n">filter_parse_state</span> <span class="o">*</span><span class="n">ps</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">postfix_elt</span> <span class="o">*</span><span class="n">elt</span><span class="p">;</span>

	<span class="n">elt</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">elt</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elt</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">elt</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span>
	<span class="n">elt</span><span class="o">-&gt;</span><span class="n">operand</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">elt</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ps</span><span class="o">-&gt;</span><span class="n">postfix</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">postfix_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">filter_parse_state</span> <span class="o">*</span><span class="n">ps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">postfix_elt</span> <span class="o">*</span><span class="n">elt</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ps</span><span class="o">-&gt;</span><span class="n">postfix</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">elt</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ps</span><span class="o">-&gt;</span><span class="n">postfix</span><span class="p">,</span> <span class="k">struct</span> <span class="n">postfix_elt</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">elt</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">elt</span><span class="o">-&gt;</span><span class="n">operand</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">elt</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">filter_parse</span><span class="p">(</span><span class="k">struct</span> <span class="n">filter_parse_state</span> <span class="o">*</span><span class="n">ps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">in_string</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">op</span><span class="p">,</span> <span class="n">top_op</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">ch</span> <span class="o">=</span> <span class="n">infix_next</span><span class="p">(</span><span class="n">ps</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">&#39;&quot;&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">in_string</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">in_string</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">parse_operand</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">isspace</span><span class="p">(</span><span class="n">ch</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_op_char</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">ch</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">op</span> <span class="o">=</span> <span class="n">infix_get_op</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">ch</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="n">OP_NONE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">parse_error</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">FILT_ERR_INVALID_OP</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">curr_operand</span><span class="p">(</span><span class="n">ps</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">postfix_append_operand</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">curr_operand</span><span class="p">(</span><span class="n">ps</span><span class="p">));</span>
				<span class="n">clear_operand_string</span><span class="p">(</span><span class="n">ps</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">filter_opstack_empty</span><span class="p">(</span><span class="n">ps</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">top_op</span> <span class="o">=</span> <span class="n">filter_opstack_top</span><span class="p">(</span><span class="n">ps</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_precedence_lower</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">top_op</span><span class="p">,</span> <span class="n">op</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">top_op</span> <span class="o">=</span> <span class="n">filter_opstack_pop</span><span class="p">(</span><span class="n">ps</span><span class="p">);</span>
					<span class="n">postfix_append_op</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">top_op</span><span class="p">);</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">filter_opstack_push</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">&#39;(&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">filter_opstack_push</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">OP_OPEN_PAREN</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">&#39;)&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">curr_operand</span><span class="p">(</span><span class="n">ps</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">postfix_append_operand</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">curr_operand</span><span class="p">(</span><span class="n">ps</span><span class="p">));</span>
				<span class="n">clear_operand_string</span><span class="p">(</span><span class="n">ps</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">top_op</span> <span class="o">=</span> <span class="n">filter_opstack_pop</span><span class="p">(</span><span class="n">ps</span><span class="p">);</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">top_op</span> <span class="o">!=</span> <span class="n">OP_NONE</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">top_op</span> <span class="o">==</span> <span class="n">OP_OPEN_PAREN</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="n">postfix_append_op</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">top_op</span><span class="p">);</span>
				<span class="n">top_op</span> <span class="o">=</span> <span class="n">filter_opstack_pop</span><span class="p">(</span><span class="n">ps</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">top_op</span> <span class="o">==</span> <span class="n">OP_NONE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">parse_error</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">FILT_ERR_UNBALANCED_PAREN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
<span class="nl">parse_operand:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">append_operand_char</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">ch</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">parse_error</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">FILT_ERR_OPERAND_TOO_LONG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">curr_operand</span><span class="p">(</span><span class="n">ps</span><span class="p">)))</span>
		<span class="n">postfix_append_operand</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">curr_operand</span><span class="p">(</span><span class="n">ps</span><span class="p">));</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">filter_opstack_empty</span><span class="p">(</span><span class="n">ps</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">top_op</span> <span class="o">=</span> <span class="n">filter_opstack_pop</span><span class="p">(</span><span class="n">ps</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">top_op</span> <span class="o">==</span> <span class="n">OP_NONE</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">top_op</span> <span class="o">==</span> <span class="n">OP_OPEN_PAREN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">parse_error</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">FILT_ERR_UNBALANCED_PAREN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">postfix_append_op</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">top_op</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="nf">create_pred</span><span class="p">(</span><span class="k">struct</span> <span class="n">filter_parse_state</span> <span class="o">*</span><span class="n">ps</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">op</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">operand1</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">operand2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_event_field</span> <span class="o">*</span><span class="n">field</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">filter_pred</span> <span class="n">pred</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pred</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pred</span><span class="p">));</span>
	<span class="n">pred</span><span class="p">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="n">OP_AND</span> <span class="o">||</span> <span class="n">op</span> <span class="o">==</span> <span class="n">OP_OR</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">pred</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">operand1</span> <span class="o">||</span> <span class="o">!</span><span class="n">operand2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parse_error</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">FILT_ERR_MISSING_FIELD</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">field</span> <span class="o">=</span> <span class="n">find_event_field</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="n">operand1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">field</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parse_error</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">FILT_ERR_FIELD_NOT_FOUND</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">strcpy</span><span class="p">(</span><span class="n">pred</span><span class="p">.</span><span class="n">regex</span><span class="p">.</span><span class="n">pattern</span><span class="p">,</span> <span class="n">operand2</span><span class="p">);</span>
	<span class="n">pred</span><span class="p">.</span><span class="n">regex</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">pred</span><span class="p">.</span><span class="n">regex</span><span class="p">.</span><span class="n">pattern</span><span class="p">);</span>
	<span class="n">pred</span><span class="p">.</span><span class="n">field</span> <span class="o">=</span> <span class="n">field</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">init_pred</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pred</span><span class="p">)</span> <span class="o">?</span> <span class="nb">NULL</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">pred</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_preds</span><span class="p">(</span><span class="k">struct</span> <span class="n">filter_parse_state</span> <span class="o">*</span><span class="n">ps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n_normal_preds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n_logical_preds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">postfix_elt</span> <span class="o">*</span><span class="n">elt</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">elt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ps</span><span class="o">-&gt;</span><span class="n">postfix</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">elt</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">==</span> <span class="n">OP_NONE</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">elt</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">==</span> <span class="n">OP_AND</span> <span class="o">||</span> <span class="n">elt</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">==</span> <span class="n">OP_OR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">n_logical_preds</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">n_normal_preds</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n_normal_preds</span> <span class="o">||</span> <span class="n">n_logical_preds</span> <span class="o">&gt;=</span> <span class="n">n_normal_preds</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parse_error</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">FILT_ERR_INVALID_FILTER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">count_preds</span><span class="p">(</span><span class="k">struct</span> <span class="n">filter_parse_state</span> <span class="o">*</span><span class="n">ps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">postfix_elt</span> <span class="o">*</span><span class="n">elt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n_preds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">elt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ps</span><span class="o">-&gt;</span><span class="n">postfix</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">elt</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">==</span> <span class="n">OP_NONE</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">n_preds</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">n_preds</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">check_pred_data</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_pred_tree_cb</span><span class="p">(</span><span class="k">enum</span> <span class="n">move_type</span> <span class="n">move</span><span class="p">,</span> <span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">pred</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">check_pred_data</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span> <span class="o">&gt;</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">WALK_PRED_ABORT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">WALK_PRED_DEFAULT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The tree is walked at filtering of an event. If the tree is not correctly</span>
<span class="cm"> * built, it may cause an infinite loop. Check here that the tree does</span>
<span class="cm"> * indeed terminate.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_pred_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">event_filter</span> <span class="o">*</span><span class="n">filter</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">check_pred_data</span> <span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The max that we can hit a node is three times.</span>
<span class="cm">		 * Once going down, once coming up from left, and</span>
<span class="cm">		 * once coming up from right. This is more than enough</span>
<span class="cm">		 * since leafs are only hit a single time.</span>
<span class="cm">		 */</span>
		<span class="p">.</span><span class="n">max</span>   <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">filter</span><span class="o">-&gt;</span><span class="n">n_preds</span><span class="p">,</span>
		<span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="k">return</span> <span class="n">walk_pred_tree</span><span class="p">(</span><span class="n">filter</span><span class="o">-&gt;</span><span class="n">preds</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span>
			      <span class="n">check_pred_tree_cb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">count_leafs_cb</span><span class="p">(</span><span class="k">enum</span> <span class="n">move_type</span> <span class="n">move</span><span class="p">,</span> <span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">pred</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">move</span> <span class="o">==</span> <span class="n">MOVE_DOWN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="n">FILTER_PRED_INVALID</span><span class="p">))</span>
		<span class="p">(</span><span class="o">*</span><span class="n">count</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">WALK_PRED_DEFAULT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">count_leafs</span><span class="p">(</span><span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">preds</span><span class="p">,</span> <span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">walk_pred_tree</span><span class="p">(</span><span class="n">preds</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">count_leafs_cb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">fold_pred_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">children</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fold_pred_cb</span><span class="p">(</span><span class="k">enum</span> <span class="n">move_type</span> <span class="n">move</span><span class="p">,</span> <span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">pred</span><span class="p">,</span>
			<span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fold_pred_data</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">move</span> <span class="o">!=</span> <span class="n">MOVE_DOWN</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">WALK_PRED_DEFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="n">FILTER_PRED_INVALID</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">WALK_PRED_DEFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">WALK_PRED_ABORT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pred</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FILTER_PRED_FOLD</span><span class="p">;</span>
	<span class="n">root</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">[</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">pred</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">WALK_PRED_DEFAULT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fold_pred</span><span class="p">(</span><span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">preds</span><span class="p">,</span> <span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fold_pred_data</span> <span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">root</span>  <span class="o">=</span> <span class="n">root</span><span class="p">,</span>
		<span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="kt">int</span> <span class="n">children</span><span class="p">;</span>

	<span class="cm">/* No need to keep the fold flag */</span>
	<span class="n">root</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FILTER_PRED_FOLD</span><span class="p">;</span>

	<span class="cm">/* If the root is a leaf then do nothing */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="n">FILTER_PRED_INVALID</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* count the children */</span>
	<span class="n">children</span> <span class="o">=</span> <span class="n">count_leafs</span><span class="p">(</span><span class="n">preds</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">preds</span><span class="p">[</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">]);</span>
	<span class="n">children</span> <span class="o">+=</span> <span class="n">count_leafs</span><span class="p">(</span><span class="n">preds</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">preds</span><span class="p">[</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">]);</span>

	<span class="n">root</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">children</span><span class="p">;</span>
	<span class="n">data</span><span class="p">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">children</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">walk_pred_tree</span><span class="p">(</span><span class="n">preds</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">fold_pred_cb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fold_pred_tree_cb</span><span class="p">(</span><span class="k">enum</span> <span class="n">move_type</span> <span class="n">move</span><span class="p">,</span> <span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">pred</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">preds</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">move</span> <span class="o">!=</span> <span class="n">MOVE_DOWN</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">WALK_PRED_DEFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&amp;</span> <span class="n">FILTER_PRED_FOLD</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">WALK_PRED_DEFAULT</span><span class="p">;</span>

	<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="n">fold_pred</span><span class="p">(</span><span class="n">preds</span><span class="p">,</span> <span class="n">pred</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">WALK_PRED_ABORT</span><span class="p">;</span>

	<span class="cm">/* eveyrhing below is folded, continue with parent */</span>
	<span class="k">return</span> <span class="n">WALK_PRED_PARENT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * To optimize the processing of the ops, if we have several &quot;ors&quot; or</span>
<span class="cm"> * &quot;ands&quot; together, we can put them in an array and process them all</span>
<span class="cm"> * together speeding up the filter logic.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fold_pred_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">event_filter</span> <span class="o">*</span><span class="n">filter</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">walk_pred_tree</span><span class="p">(</span><span class="n">filter</span><span class="o">-&gt;</span><span class="n">preds</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">fold_pred_tree_cb</span><span class="p">,</span>
			      <span class="n">filter</span><span class="o">-&gt;</span><span class="n">preds</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">replace_preds</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">event_filter</span> <span class="o">*</span><span class="n">filter</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">filter_parse_state</span> <span class="o">*</span><span class="n">ps</span><span class="p">,</span>
			 <span class="kt">char</span> <span class="o">*</span><span class="n">filter_string</span><span class="p">,</span>
			 <span class="n">bool</span> <span class="n">dry_run</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">operand1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">operand2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">pred</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">postfix_elt</span> <span class="o">*</span><span class="n">elt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pred_stack</span> <span class="n">stack</span> <span class="o">=</span> <span class="p">{</span> <span class="p">};</span> <span class="cm">/* init to NULL */</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n_preds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">n_preds</span> <span class="o">=</span> <span class="n">count_preds</span><span class="p">(</span><span class="n">ps</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n_preds</span> <span class="o">&gt;=</span> <span class="n">MAX_FILTER_PRED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parse_error</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">FILT_ERR_TOO_MANY_PREDS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">check_preds</span><span class="p">(</span><span class="n">ps</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dry_run</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">__alloc_pred_stack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stack</span><span class="p">,</span> <span class="n">n_preds</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">__alloc_preds</span><span class="p">(</span><span class="n">filter</span><span class="p">,</span> <span class="n">n_preds</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">n_preds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">elt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ps</span><span class="o">-&gt;</span><span class="n">postfix</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">elt</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">==</span> <span class="n">OP_NONE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">operand1</span><span class="p">)</span>
				<span class="n">operand1</span> <span class="o">=</span> <span class="n">elt</span><span class="o">-&gt;</span><span class="n">operand</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">operand2</span><span class="p">)</span>
				<span class="n">operand2</span> <span class="o">=</span> <span class="n">elt</span><span class="o">-&gt;</span><span class="n">operand</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">parse_error</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">FILT_ERR_TOO_MANY_OPERANDS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">n_preds</span><span class="o">++</span> <span class="o">==</span> <span class="n">MAX_FILTER_PRED</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">parse_error</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">FILT_ERR_TOO_MANY_PREDS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pred</span> <span class="o">=</span> <span class="n">create_pred</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">call</span><span class="p">,</span> <span class="n">elt</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">,</span> <span class="n">operand1</span><span class="p">,</span> <span class="n">operand2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pred</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dry_run</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">filter_add_pred</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">filter</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stack</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">operand1</span> <span class="o">=</span> <span class="n">operand2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dry_run</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We should have one item left on the stack */</span>
		<span class="n">pred</span> <span class="o">=</span> <span class="n">__pop_pred_stack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stack</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pred</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="cm">/* This item is where we start from in matching */</span>
		<span class="n">root</span> <span class="o">=</span> <span class="n">pred</span><span class="p">;</span>
		<span class="cm">/* Make sure the stack is empty */</span>
		<span class="n">pred</span> <span class="o">=</span> <span class="n">__pop_pred_stack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stack</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">pred</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="n">filter</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">check_pred_tree</span><span class="p">(</span><span class="n">filter</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

		<span class="cm">/* Optimize the tree */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">fold_pred_tree</span><span class="p">(</span><span class="n">filter</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

		<span class="cm">/* We don&#39;t set root until we know it works */</span>
		<span class="n">barrier</span><span class="p">();</span>
		<span class="n">filter</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="n">__free_pred_stack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stack</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">filter_list</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">event_filter</span>	<span class="o">*</span><span class="n">filter</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">replace_system_preds</span><span class="p">(</span><span class="k">struct</span> <span class="n">event_subsystem</span> <span class="o">*</span><span class="n">system</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">filter_parse_state</span> <span class="o">*</span><span class="n">ps</span><span class="p">,</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">filter_string</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">filter_list</span> <span class="o">*</span><span class="n">filter_item</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">filter_list</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">filter_list</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">fail</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ftrace_events</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">system</span><span class="p">,</span> <span class="n">system</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Try to see if the filter can be applied</span>
<span class="cm">		 *  (filter arg is ignored on dry_run)</span>
<span class="cm">		 */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">replace_preds</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">ps</span><span class="p">,</span> <span class="n">filter_string</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="n">call</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">TRACE_EVENT_FL_NO_SET_FILTER</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">call</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TRACE_EVENT_FL_NO_SET_FILTER</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ftrace_events</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">event_filter</span> <span class="o">*</span><span class="n">filter</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">system</span><span class="p">,</span> <span class="n">system</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TRACE_EVENT_FL_NO_SET_FILTER</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">filter_item</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">filter_item</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">filter_item</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail_mem</span><span class="p">;</span>

		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">filter_item</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">filter_list</span><span class="p">);</span>

		<span class="n">filter_item</span><span class="o">-&gt;</span><span class="n">filter</span> <span class="o">=</span> <span class="n">__alloc_filter</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">filter_item</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail_mem</span><span class="p">;</span>
		<span class="n">filter</span> <span class="o">=</span> <span class="n">filter_item</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">;</span>

		<span class="cm">/* Can only fail on no memory */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">replace_filter_string</span><span class="p">(</span><span class="n">filter</span><span class="p">,</span> <span class="n">filter_string</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail_mem</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">replace_preds</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="n">filter</span><span class="p">,</span> <span class="n">ps</span><span class="p">,</span> <span class="n">filter_string</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">filter_disable</span><span class="p">(</span><span class="n">call</span><span class="p">);</span>
			<span class="n">parse_error</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">FILT_ERR_BAD_SUBSYS_FILTER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">append_filter_err</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">filter</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">call</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">TRACE_EVENT_FL_FILTERED</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Regardless of if this returned an error, we still</span>
<span class="cm">		 * replace the filter for the call.</span>
<span class="cm">		 */</span>
		<span class="n">filter</span> <span class="o">=</span> <span class="n">call</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">;</span>
		<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">,</span> <span class="n">filter_item</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">);</span>
		<span class="n">filter_item</span><span class="o">-&gt;</span><span class="n">filter</span> <span class="o">=</span> <span class="n">filter</span><span class="p">;</span>

		<span class="n">fail</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fail</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The calls can still be using the old filters.</span>
<span class="cm">	 * Do a synchronize_sched() to ensure all calls are</span>
<span class="cm">	 * done with them before we free them.</span>
<span class="cm">	 */</span>
	<span class="n">synchronize_sched</span><span class="p">();</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">filter_item</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">filter_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__free_filter</span><span class="p">(</span><span class="n">filter_item</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">filter_item</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">filter_item</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">fail:</span>
	<span class="cm">/* No call succeeded */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">filter_item</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">filter_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">filter_item</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">filter_item</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">parse_error</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">FILT_ERR_BAD_SUBSYS_FILTER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
 <span class="nl">fail_mem:</span>
	<span class="cm">/* If any call succeeded, we still need to sync */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fail</span><span class="p">)</span>
		<span class="n">synchronize_sched</span><span class="p">();</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">filter_item</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">filter_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__free_filter</span><span class="p">(</span><span class="n">filter_item</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">filter_item</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">filter_item</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">create_filter_start</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">filter_str</span><span class="p">,</span> <span class="n">bool</span> <span class="n">set_str</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">filter_parse_state</span> <span class="o">**</span><span class="n">psp</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">event_filter</span> <span class="o">**</span><span class="n">filterp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">event_filter</span> <span class="o">*</span><span class="n">filter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">filter_parse_state</span> <span class="o">*</span><span class="n">ps</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">*</span><span class="n">psp</span> <span class="o">||</span> <span class="o">*</span><span class="n">filterp</span><span class="p">);</span>

	<span class="cm">/* allocate everything, and if any fails, free all and fail */</span>
	<span class="n">filter</span> <span class="o">=</span> <span class="n">__alloc_filter</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">filter</span> <span class="o">&amp;&amp;</span> <span class="n">set_str</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">replace_filter_string</span><span class="p">(</span><span class="n">filter</span><span class="p">,</span> <span class="n">filter_str</span><span class="p">);</span>

	<span class="n">ps</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ps</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">filter</span> <span class="o">||</span> <span class="o">!</span><span class="n">ps</span> <span class="o">||</span> <span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ps</span><span class="p">);</span>
		<span class="n">__free_filter</span><span class="p">(</span><span class="n">filter</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* we&#39;re committed to creating a new filter */</span>
	<span class="o">*</span><span class="n">filterp</span> <span class="o">=</span> <span class="n">filter</span><span class="p">;</span>
	<span class="o">*</span><span class="n">psp</span> <span class="o">=</span> <span class="n">ps</span><span class="p">;</span>

	<span class="n">parse_init</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">filter_ops</span><span class="p">,</span> <span class="n">filter_str</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">filter_parse</span><span class="p">(</span><span class="n">ps</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">set_str</span><span class="p">)</span>
		<span class="n">append_filter_err</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">filter</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">create_filter_finish</span><span class="p">(</span><span class="k">struct</span> <span class="n">filter_parse_state</span> <span class="o">*</span><span class="n">ps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ps</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">filter_opstack_clear</span><span class="p">(</span><span class="n">ps</span><span class="p">);</span>
		<span class="n">postfix_clear</span><span class="p">(</span><span class="n">ps</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ps</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * create_filter - create a filter for a ftrace_event_call</span>
<span class="cm"> * @call: ftrace_event_call to create a filter for</span>
<span class="cm"> * @filter_str: filter string</span>
<span class="cm"> * @set_str: remember @filter_str and enable detailed error in filter</span>
<span class="cm"> * @filterp: out param for created filter (always updated on return)</span>
<span class="cm"> *</span>
<span class="cm"> * Creates a filter for @call with @filter_str.  If @set_str is %true,</span>
<span class="cm"> * @filter_str is copied and recorded in the new filter.</span>
<span class="cm"> *</span>
<span class="cm"> * On success, returns 0 and *@filterp points to the new filter.  On</span>
<span class="cm"> * failure, returns -errno and *@filterp may point to %NULL or to a new</span>
<span class="cm"> * filter.  In the latter case, the returned filter contains error</span>
<span class="cm"> * information if @set_str is %true and the caller is responsible for</span>
<span class="cm"> * freeing it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">create_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span><span class="p">,</span>
			 <span class="kt">char</span> <span class="o">*</span><span class="n">filter_str</span><span class="p">,</span> <span class="n">bool</span> <span class="n">set_str</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">event_filter</span> <span class="o">**</span><span class="n">filterp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">event_filter</span> <span class="o">*</span><span class="n">filter</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">filter_parse_state</span> <span class="o">*</span><span class="n">ps</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">create_filter_start</span><span class="p">(</span><span class="n">filter_str</span><span class="p">,</span> <span class="n">set_str</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ps</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">filter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">replace_preds</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="n">filter</span><span class="p">,</span> <span class="n">ps</span><span class="p">,</span> <span class="n">filter_str</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">set_str</span><span class="p">)</span>
			<span class="n">append_filter_err</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">filter</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">create_filter_finish</span><span class="p">(</span><span class="n">ps</span><span class="p">);</span>

	<span class="o">*</span><span class="n">filterp</span> <span class="o">=</span> <span class="n">filter</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * create_system_filter - create a filter for an event_subsystem</span>
<span class="cm"> * @system: event_subsystem to create a filter for</span>
<span class="cm"> * @filter_str: filter string</span>
<span class="cm"> * @filterp: out param for created filter (always updated on return)</span>
<span class="cm"> *</span>
<span class="cm"> * Identical to create_filter() except that it creates a subsystem filter</span>
<span class="cm"> * and always remembers @filter_str.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">create_system_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">event_subsystem</span> <span class="o">*</span><span class="n">system</span><span class="p">,</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">filter_str</span><span class="p">,</span> <span class="k">struct</span> <span class="n">event_filter</span> <span class="o">**</span><span class="n">filterp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">event_filter</span> <span class="o">*</span><span class="n">filter</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">filter_parse_state</span> <span class="o">*</span><span class="n">ps</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">create_filter_start</span><span class="p">(</span><span class="n">filter_str</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ps</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">filter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">replace_system_preds</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="n">ps</span><span class="p">,</span> <span class="n">filter_str</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* System filters just show a default message */</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">filter</span><span class="o">-&gt;</span><span class="n">filter_string</span><span class="p">);</span>
			<span class="n">filter</span><span class="o">-&gt;</span><span class="n">filter_string</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">append_filter_err</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">filter</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">create_filter_finish</span><span class="p">(</span><span class="n">ps</span><span class="p">);</span>

	<span class="o">*</span><span class="n">filterp</span> <span class="o">=</span> <span class="n">filter</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">apply_event_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filter_string</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">event_filter</span> <span class="o">*</span><span class="n">filter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">strstrip</span><span class="p">(</span><span class="n">filter_string</span><span class="p">),</span> <span class="s">&quot;0&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">filter_disable</span><span class="p">(</span><span class="n">call</span><span class="p">);</span>
		<span class="n">filter</span> <span class="o">=</span> <span class="n">call</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">filter</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="n">RCU_INIT_POINTER</span><span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="cm">/* Make sure the filter is not being used */</span>
		<span class="n">synchronize_sched</span><span class="p">();</span>
		<span class="n">__free_filter</span><span class="p">(</span><span class="n">filter</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">create_filter</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="n">filter_string</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">filter</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Always swap the call filter with the new filter</span>
<span class="cm">	 * even if there was an error. If there was an error</span>
<span class="cm">	 * in the filter, we disable the filter and show the error</span>
<span class="cm">	 * string</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">filter</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">event_filter</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">call</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
			<span class="n">call</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">TRACE_EVENT_FL_FILTERED</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">filter_disable</span><span class="p">(</span><span class="n">call</span><span class="p">);</span>

		<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">,</span> <span class="n">filter</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Make sure the call is done with the filter */</span>
			<span class="n">synchronize_sched</span><span class="p">();</span>
			<span class="n">__free_filter</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">apply_subsystem_event_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">event_subsystem</span> <span class="o">*</span><span class="n">system</span><span class="p">,</span>
				 <span class="kt">char</span> <span class="o">*</span><span class="n">filter_string</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">event_filter</span> <span class="o">*</span><span class="n">filter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event_mutex</span><span class="p">);</span>

	<span class="cm">/* Make sure the system still has events */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">system</span><span class="o">-&gt;</span><span class="n">nr_events</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">strstrip</span><span class="p">(</span><span class="n">filter_string</span><span class="p">),</span> <span class="s">&quot;0&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">filter_free_subsystem_preds</span><span class="p">(</span><span class="n">system</span><span class="p">);</span>
		<span class="n">remove_filter_string</span><span class="p">(</span><span class="n">system</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">);</span>
		<span class="n">filter</span> <span class="o">=</span> <span class="n">system</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">;</span>
		<span class="n">system</span><span class="o">-&gt;</span><span class="n">filter</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="cm">/* Ensure all filters are no longer used */</span>
		<span class="n">synchronize_sched</span><span class="p">();</span>
		<span class="n">filter_free_subsystem_filters</span><span class="p">(</span><span class="n">system</span><span class="p">);</span>
		<span class="n">__free_filter</span><span class="p">(</span><span class="n">filter</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">create_system_filter</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="n">filter_string</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">filter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">filter</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * No event actually uses the system filter</span>
<span class="cm">		 * we can free it without synchronize_sched().</span>
<span class="cm">		 */</span>
		<span class="n">__free_filter</span><span class="p">(</span><span class="n">system</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">);</span>
		<span class="n">system</span><span class="o">-&gt;</span><span class="n">filter</span> <span class="o">=</span> <span class="n">filter</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PERF_EVENTS</span>

<span class="kt">void</span> <span class="nf">ftrace_profile_free_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">event_filter</span> <span class="o">*</span><span class="n">filter</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">;</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">filter</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">__free_filter</span><span class="p">(</span><span class="n">filter</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">function_filter_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">first_filter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">first_notrace</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_FUNCTION_TRACER</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">**</span>
<span class="nf">ftrace_function_filter_re</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span> <span class="o">**</span><span class="n">re</span><span class="p">;</span>

	<span class="n">str</span> <span class="o">=</span> <span class="n">kstrndup</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">str</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The argv_split function takes white space</span>
<span class="cm">	 * as a separator, so convert &#39;,&#39; into spaces.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">sep</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="sc">&#39;,&#39;</span><span class="p">)))</span>
		<span class="o">*</span><span class="n">sep</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>

	<span class="n">re</span> <span class="o">=</span> <span class="n">argv_split</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">re</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ftrace_function_set_regexp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span> <span class="kt">int</span> <span class="n">filter</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">reset</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">re</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">filter</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ftrace_set_filter</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">re</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">reset</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ftrace_set_notrace</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">re</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">reset</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__ftrace_function_set_filter</span><span class="p">(</span><span class="kt">int</span> <span class="n">filter</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">function_filter_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">re_cnt</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">reset</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">**</span><span class="n">re</span><span class="p">;</span>

	<span class="n">reset</span> <span class="o">=</span> <span class="n">filter</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">first_filter</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">first_notrace</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The &#39;ip&#39; field could have multiple filters set, separated</span>
<span class="cm">	 * either by space or comma. We first cut the filter and apply</span>
<span class="cm">	 * all pieces separatelly.</span>
<span class="cm">	 */</span>
	<span class="n">re</span> <span class="o">=</span> <span class="n">ftrace_function_filter_re</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">re_cnt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">re</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">re_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ftrace_function_set_regexp</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">,</span> <span class="n">filter</span><span class="p">,</span> <span class="o">*</span><span class="n">reset</span><span class="p">,</span>
						 <span class="n">re</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">strlen</span><span class="p">(</span><span class="n">re</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">reset</span><span class="p">)</span>
			<span class="o">*</span><span class="n">reset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">argv_free</span><span class="p">(</span><span class="n">re</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ftrace_function_check_pred</span><span class="p">(</span><span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">pred</span><span class="p">,</span> <span class="kt">int</span> <span class="n">leaf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_event_field</span> <span class="o">*</span><span class="n">field</span> <span class="o">=</span> <span class="n">pred</span><span class="o">-&gt;</span><span class="n">field</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">leaf</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Check the leaf predicate for function trace, verify:</span>
<span class="cm">		 *  - only &#39;==&#39; and &#39;!=&#39; is used</span>
<span class="cm">		 *  - the &#39;ip&#39; field is used</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">!=</span> <span class="n">OP_EQ</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">!=</span> <span class="n">OP_NE</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">field</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;ip&quot;</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Check the non leaf predicate for function trace, verify:</span>
<span class="cm">		 *  - only &#39;||&#39; is used</span>
<span class="cm">		*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">!=</span> <span class="n">OP_OR</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ftrace_function_set_filter_cb</span><span class="p">(</span><span class="k">enum</span> <span class="n">move_type</span> <span class="n">move</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">pred</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Checking the node is valid for function trace. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">move</span> <span class="o">!=</span> <span class="n">MOVE_DOWN</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="n">FILTER_PRED_INVALID</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="n">ftrace_function_check_pred</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="n">ftrace_function_check_pred</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">WALK_PRED_ABORT</span><span class="p">;</span>

		<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="n">__ftrace_function_set_filter</span><span class="p">(</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">==</span> <span class="n">OP_EQ</span><span class="p">,</span>
						    <span class="n">pred</span><span class="o">-&gt;</span><span class="n">regex</span><span class="p">.</span><span class="n">pattern</span><span class="p">,</span>
						    <span class="n">pred</span><span class="o">-&gt;</span><span class="n">regex</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
						    <span class="n">data</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">err</span><span class="p">)</span> <span class="o">?</span> <span class="n">WALK_PRED_ABORT</span> <span class="o">:</span> <span class="n">WALK_PRED_DEFAULT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ftrace_function_set_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">event_filter</span> <span class="o">*</span><span class="n">filter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">function_filter_data</span> <span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">first_filter</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">first_notrace</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">ops</span>           <span class="o">=</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">ftrace_ops</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="k">return</span> <span class="n">walk_pred_tree</span><span class="p">(</span><span class="n">filter</span><span class="o">-&gt;</span><span class="n">preds</span><span class="p">,</span> <span class="n">filter</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">,</span>
			      <span class="n">ftrace_function_set_filter_cb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ftrace_function_set_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">event_filter</span> <span class="o">*</span><span class="n">filter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_FUNCTION_TRACER */</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">ftrace_profile_set_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">event_id</span><span class="p">,</span>
			      <span class="kt">char</span> <span class="o">*</span><span class="n">filter_str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">event_filter</span> <span class="o">*</span><span class="n">filter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event_mutex</span><span class="p">);</span>

	<span class="n">call</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">tp_event</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">call</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">create_filter</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="n">filter_str</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">filter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_filter</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ftrace_event_is_function</span><span class="p">(</span><span class="n">call</span><span class="p">))</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ftrace_function_set_filter</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">filter</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">filter</span> <span class="o">=</span> <span class="n">filter</span><span class="p">;</span>

<span class="nl">free_filter:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">||</span> <span class="n">ftrace_event_is_function</span><span class="p">(</span><span class="n">call</span><span class="p">))</span>
		<span class="n">__free_filter</span><span class="p">(</span><span class="n">filter</span><span class="p">);</span>

<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_PERF_EVENTS */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_FTRACE_STARTUP_TEST</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/tracepoint.h&gt;</span>

<span class="cp">#define CREATE_TRACE_POINTS</span>
<span class="cp">#include &quot;trace_events_filter_test.h&quot;</span>

<span class="cp">#define DATA_REC(m, va, vb, vc, vd, ve, vf, vg, vh, nvisit) \</span>
<span class="cp">{ \</span>
<span class="cp">	.filter = FILTER, \</span>
<span class="cp">	.rec    = { .a = va, .b = vb, .c = vc, .d = vd, \</span>
<span class="cp">		    .e = ve, .f = vf, .g = vg, .h = vh }, \</span>
<span class="cp">	.match  = m, \</span>
<span class="cp">	.not_visited = nvisit, \</span>
<span class="cp">}</span>
<span class="cp">#define YES 1</span>
<span class="cp">#define NO  0</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">test_filter_data_t</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">filter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_raw_ftrace_test_filter</span> <span class="n">rec</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">match</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">not_visited</span><span class="p">;</span>
<span class="p">}</span> <span class="n">test_filter_data</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="cp">#define FILTER &quot;a == 1 &amp;&amp; b == 1 &amp;&amp; c == 1 &amp;&amp; d == 1 &amp;&amp; &quot; \</span>
<span class="cp">	       &quot;e == 1 &amp;&amp; f == 1 &amp;&amp; g == 1 &amp;&amp; h == 1&quot;</span>
	<span class="n">DATA_REC</span><span class="p">(</span><span class="n">YES</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">),</span>
	<span class="n">DATA_REC</span><span class="p">(</span><span class="n">NO</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;bcdefgh&quot;</span><span class="p">),</span>
	<span class="n">DATA_REC</span><span class="p">(</span><span class="n">NO</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">),</span>
<span class="cp">#undef FILTER</span>
<span class="cp">#define FILTER &quot;a == 1 || b == 1 || c == 1 || d == 1 || &quot; \</span>
<span class="cp">	       &quot;e == 1 || f == 1 || g == 1 || h == 1&quot;</span>
	<span class="n">DATA_REC</span><span class="p">(</span><span class="n">NO</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">),</span>
	<span class="n">DATA_REC</span><span class="p">(</span><span class="n">YES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">),</span>
	<span class="n">DATA_REC</span><span class="p">(</span><span class="n">YES</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;bcdefgh&quot;</span><span class="p">),</span>
<span class="cp">#undef FILTER</span>
<span class="cp">#define FILTER &quot;(a == 1 || b == 1) &amp;&amp; (c == 1 || d == 1) &amp;&amp; &quot; \</span>
<span class="cp">	       &quot;(e == 1 || f == 1) &amp;&amp; (g == 1 || h == 1)&quot;</span>
	<span class="n">DATA_REC</span><span class="p">(</span><span class="n">NO</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;dfh&quot;</span><span class="p">),</span>
	<span class="n">DATA_REC</span><span class="p">(</span><span class="n">YES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">),</span>
	<span class="n">DATA_REC</span><span class="p">(</span><span class="n">YES</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;bd&quot;</span><span class="p">),</span>
	<span class="n">DATA_REC</span><span class="p">(</span><span class="n">NO</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;bd&quot;</span><span class="p">),</span>
<span class="cp">#undef FILTER</span>
<span class="cp">#define FILTER &quot;(a == 1 &amp;&amp; b == 1) || (c == 1 &amp;&amp; d == 1) || &quot; \</span>
<span class="cp">	       &quot;(e == 1 &amp;&amp; f == 1) || (g == 1 &amp;&amp; h == 1)&quot;</span>
	<span class="n">DATA_REC</span><span class="p">(</span><span class="n">YES</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;efgh&quot;</span><span class="p">),</span>
	<span class="n">DATA_REC</span><span class="p">(</span><span class="n">YES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">),</span>
	<span class="n">DATA_REC</span><span class="p">(</span><span class="n">NO</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">),</span>
<span class="cp">#undef FILTER</span>
<span class="cp">#define FILTER &quot;(a == 1 &amp;&amp; b == 1) &amp;&amp; (c == 1 &amp;&amp; d == 1) &amp;&amp; &quot; \</span>
<span class="cp">	       &quot;(e == 1 &amp;&amp; f == 1) || (g == 1 &amp;&amp; h == 1)&quot;</span>
	<span class="n">DATA_REC</span><span class="p">(</span><span class="n">YES</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;gh&quot;</span><span class="p">),</span>
	<span class="n">DATA_REC</span><span class="p">(</span><span class="n">NO</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">),</span>
	<span class="n">DATA_REC</span><span class="p">(</span><span class="n">YES</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">),</span>
<span class="cp">#undef FILTER</span>
<span class="cp">#define FILTER &quot;((a == 1 || b == 1) || (c == 1 || d == 1) || &quot; \</span>
<span class="cp">	       &quot;(e == 1 || f == 1)) &amp;&amp; (g == 1 || h == 1)&quot;</span>
	<span class="n">DATA_REC</span><span class="p">(</span><span class="n">YES</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;bcdef&quot;</span><span class="p">),</span>
	<span class="n">DATA_REC</span><span class="p">(</span><span class="n">NO</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">),</span>
	<span class="n">DATA_REC</span><span class="p">(</span><span class="n">YES</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;h&quot;</span><span class="p">),</span>
<span class="cp">#undef FILTER</span>
<span class="cp">#define FILTER &quot;((((((((a == 1) &amp;&amp; (b == 1)) || (c == 1)) &amp;&amp; (d == 1)) || &quot; \</span>
<span class="cp">	       &quot;(e == 1)) &amp;&amp; (f == 1)) || (g == 1)) &amp;&amp; (h == 1))&quot;</span>
	<span class="n">DATA_REC</span><span class="p">(</span><span class="n">YES</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;ceg&quot;</span><span class="p">),</span>
	<span class="n">DATA_REC</span><span class="p">(</span><span class="n">NO</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">),</span>
	<span class="n">DATA_REC</span><span class="p">(</span><span class="n">NO</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">),</span>
<span class="cp">#undef FILTER</span>
<span class="cp">#define FILTER &quot;((((((((a == 1) || (b == 1)) &amp;&amp; (c == 1)) || (d == 1)) &amp;&amp; &quot; \</span>
<span class="cp">	       &quot;(e == 1)) || (f == 1)) &amp;&amp; (g == 1)) || (h == 1))&quot;</span>
	<span class="n">DATA_REC</span><span class="p">(</span><span class="n">YES</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;bdfh&quot;</span><span class="p">),</span>
	<span class="n">DATA_REC</span><span class="p">(</span><span class="n">YES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">),</span>
	<span class="n">DATA_REC</span><span class="p">(</span><span class="n">YES</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;bdfh&quot;</span><span class="p">),</span>
<span class="p">};</span>

<span class="cp">#undef DATA_REC</span>
<span class="cp">#undef FILTER</span>
<span class="cp">#undef YES</span>
<span class="cp">#undef NO</span>

<span class="cp">#define DATA_CNT (sizeof(test_filter_data)/sizeof(struct test_filter_data_t))</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">test_pred_visited</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">test_pred_visited_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">pred</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_event_field</span> <span class="o">*</span><span class="n">field</span> <span class="o">=</span> <span class="n">pred</span><span class="o">-&gt;</span><span class="n">field</span><span class="p">;</span>

	<span class="n">test_pred_visited</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">pred visited %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">test_walk_pred_cb</span><span class="p">(</span><span class="k">enum</span> <span class="n">move_type</span> <span class="n">move</span><span class="p">,</span> <span class="k">struct</span> <span class="n">filter_pred</span> <span class="o">*</span><span class="n">pred</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">fields</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">move</span> <span class="o">==</span> <span class="n">MOVE_DOWN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="n">FILTER_PRED_INVALID</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ftrace_event_field</span> <span class="o">*</span><span class="n">field</span> <span class="o">=</span> <span class="n">pred</span><span class="o">-&gt;</span><span class="n">field</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">field</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;all leafs should have field defined&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">WALK_PRED_DEFAULT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strchr</span><span class="p">(</span><span class="n">fields</span><span class="p">,</span> <span class="o">*</span><span class="n">field</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">WALK_PRED_DEFAULT</span><span class="p">;</span>

		<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">fn</span><span class="p">);</span>
		<span class="n">pred</span><span class="o">-&gt;</span><span class="n">fn</span> <span class="o">=</span> <span class="n">test_pred_visited_fn</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">WALK_PRED_DEFAULT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">ftrace_test_event_filter</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Testing ftrace filter: &quot;</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">DATA_CNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">event_filter</span> <span class="o">*</span><span class="n">filter</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">test_filter_data_t</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">test_filter_data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">create_filter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event_ftrace_test_filter</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">,</span>
				    <span class="nb">false</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">filter</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			       <span class="s">&quot;Failed to get filter for &#39;%s&#39;, err %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">d</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
			<span class="n">__free_filter</span><span class="p">(</span><span class="n">filter</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * The preemption disabling is not really needed for self</span>
<span class="cm">		 * tests, but the rcu dereference will complain without it.</span>
<span class="cm">		 */</span>
		<span class="n">preempt_disable</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">not_visited</span><span class="p">)</span>
			<span class="n">walk_pred_tree</span><span class="p">(</span><span class="n">filter</span><span class="o">-&gt;</span><span class="n">preds</span><span class="p">,</span> <span class="n">filter</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">,</span>
				       <span class="n">test_walk_pred_cb</span><span class="p">,</span>
				       <span class="n">d</span><span class="o">-&gt;</span><span class="n">not_visited</span><span class="p">);</span>

		<span class="n">test_pred_visited</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">filter_match_preds</span><span class="p">(</span><span class="n">filter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">rec</span><span class="p">);</span>
		<span class="n">preempt_enable</span><span class="p">();</span>

		<span class="n">__free_filter</span><span class="p">(</span><span class="n">filter</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">test_pred_visited</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			       <span class="s">&quot;Failed, unwanted pred visited for filter %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">d</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			       <span class="s">&quot;Failed to match filter &#39;%s&#39;, expected %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">d</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">DATA_CNT</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;OK</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">late_initcall</span><span class="p">(</span><span class="n">ftrace_test_event_filter</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_FTRACE_STARTUP_TEST */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
