<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › trace › ftrace.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ftrace.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Infrastructure for profiling code inserted by &#39;gcc -pg&#39;.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2007-2008 Steven Rostedt &lt;srostedt@redhat.com&gt;</span>
<span class="cm"> * Copyright (C) 2004-2008 Ingo Molnar &lt;mingo@redhat.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Originally ported from the -rt patch by:</span>
<span class="cm"> *   Copyright (C) 2007 Arnaldo Carvalho de Melo &lt;acme@redhat.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Based on code in the latency_tracer, that is:</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 2004-2006 Ingo Molnar</span>
<span class="cm"> *  Copyright (C) 2004 William Lee Irwin III</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/stop_machine.h&gt;</span>
<span class="cp">#include &lt;linux/clocksource.h&gt;</span>
<span class="cp">#include &lt;linux/kallsyms.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/suspend.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/hardirq.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/bsearch.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/ftrace.h&gt;</span>
<span class="cp">#include &lt;linux/sysctl.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/sort.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/hash.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>

<span class="cp">#include &lt;trace/events/sched.h&gt;</span>

<span class="cp">#include &lt;asm/setup.h&gt;</span>

<span class="cp">#include &quot;trace_output.h&quot;</span>
<span class="cp">#include &quot;trace_stat.h&quot;</span>

<span class="cp">#define FTRACE_WARN_ON(cond)			\</span>
<span class="cp">	({					\</span>
<span class="cp">		int ___r = cond;		\</span>
<span class="cp">		if (WARN_ON(___r))		\</span>
<span class="cp">			ftrace_kill();		\</span>
<span class="cp">		___r;				\</span>
<span class="cp">	})</span>

<span class="cp">#define FTRACE_WARN_ON_ONCE(cond)		\</span>
<span class="cp">	({					\</span>
<span class="cp">		int ___r = cond;		\</span>
<span class="cp">		if (WARN_ON_ONCE(___r))		\</span>
<span class="cp">			ftrace_kill();		\</span>
<span class="cp">		___r;				\</span>
<span class="cp">	})</span>

<span class="cm">/* hash bits for specific function selection */</span>
<span class="cp">#define FTRACE_HASH_BITS 7</span>
<span class="cp">#define FTRACE_FUNC_HASHSIZE (1 &lt;&lt; FTRACE_HASH_BITS)</span>
<span class="cp">#define FTRACE_HASH_DEFAULT_BITS 10</span>
<span class="cp">#define FTRACE_HASH_MAX_BITS 12</span>

<span class="cp">#define FL_GLOBAL_CONTROL_MASK (FTRACE_OPS_FL_GLOBAL | FTRACE_OPS_FL_CONTROL)</span>

<span class="cm">/* ftrace_enabled is a method to turn ftrace on or off */</span>
<span class="kt">int</span> <span class="n">ftrace_enabled</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">last_ftrace_enabled</span><span class="p">;</span>

<span class="cm">/* Quick disabling of function tracer. */</span>
<span class="kt">int</span> <span class="n">function_trace_stop</span><span class="p">;</span>

<span class="cm">/* List for set_ftrace_pid&#39;s pids. */</span>
<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">ftrace_pids</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">ftrace_pid</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * ftrace_disabled is set when an anomaly is discovered.</span>
<span class="cm"> * ftrace_disabled is much stronger than ftrace_enabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ftrace_disabled</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">ftrace_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="n">ftrace_list_end</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">func</span>		<span class="o">=</span> <span class="n">ftrace_stub</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ftrace_global_list</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ftrace_list_end</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ftrace_control_list</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ftrace_list_end</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ftrace_ops_list</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ftrace_list_end</span><span class="p">;</span>
<span class="n">ftrace_func_t</span> <span class="n">ftrace_trace_function</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="n">ftrace_stub</span><span class="p">;</span>
<span class="k">static</span> <span class="n">ftrace_func_t</span> <span class="n">__ftrace_trace_function_delay</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="n">ftrace_stub</span><span class="p">;</span>
<span class="n">ftrace_func_t</span> <span class="n">__ftrace_trace_function</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="n">ftrace_stub</span><span class="p">;</span>
<span class="n">ftrace_func_t</span> <span class="n">ftrace_pid_function</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="n">ftrace_stub</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="n">global_ops</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="n">control_ops</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="n">ftrace_ops_list_func</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">parent_ip</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Traverse the ftrace_global_list, invoking all entries.  The reason that we</span>
<span class="cm"> * can use rcu_dereference_raw() is that elements removed from this list</span>
<span class="cm"> * are simply leaked, so there is no need to interact with a grace-period</span>
<span class="cm"> * mechanism.  The rcu_dereference_raw() calls are needed to handle</span>
<span class="cm"> * concurrent insertions into the ftrace_global_list.</span>
<span class="cm"> *</span>
<span class="cm"> * Silly Alpha and silly pointer-speculation compiler optimizations!</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ftrace_global_list_func</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">parent_ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">trace_recursion_test</span><span class="p">(</span><span class="n">TRACE_GLOBAL_BIT</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">trace_recursion_set</span><span class="p">(</span><span class="n">TRACE_GLOBAL_BIT</span><span class="p">);</span>
	<span class="n">op</span> <span class="o">=</span> <span class="n">rcu_dereference_raw</span><span class="p">(</span><span class="n">ftrace_global_list</span><span class="p">);</span> <span class="cm">/*see above*/</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">op</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">ftrace_list_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">op</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">parent_ip</span><span class="p">);</span>
		<span class="n">op</span> <span class="o">=</span> <span class="n">rcu_dereference_raw</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span> <span class="cm">/*see above*/</span>
	<span class="p">};</span>
	<span class="n">trace_recursion_clear</span><span class="p">(</span><span class="n">TRACE_GLOBAL_BIT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ftrace_pid_func</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">parent_ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_tsk_trace_trace</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ftrace_pid_function</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">parent_ip</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_ftrace_pid_function</span><span class="p">(</span><span class="n">ftrace_func_t</span> <span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* do not set ftrace_pid_function to itself! */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">func</span> <span class="o">!=</span> <span class="n">ftrace_pid_func</span><span class="p">)</span>
		<span class="n">ftrace_pid_function</span> <span class="o">=</span> <span class="n">func</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * clear_ftrace_function - reset the ftrace function</span>
<span class="cm"> *</span>
<span class="cm"> * This NULLs the ftrace function and in essence stops</span>
<span class="cm"> * tracing.  There may be lag</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">clear_ftrace_function</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ftrace_trace_function</span> <span class="o">=</span> <span class="n">ftrace_stub</span><span class="p">;</span>
	<span class="n">__ftrace_trace_function</span> <span class="o">=</span> <span class="n">ftrace_stub</span><span class="p">;</span>
	<span class="n">__ftrace_trace_function_delay</span> <span class="o">=</span> <span class="n">ftrace_stub</span><span class="p">;</span>
	<span class="n">ftrace_pid_function</span> <span class="o">=</span> <span class="n">ftrace_stub</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifndef CONFIG_HAVE_FUNCTION_TRACE_MCOUNT_TEST</span>
<span class="cm">/*</span>
<span class="cm"> * For those archs that do not test ftrace_trace_stop in their</span>
<span class="cm"> * mcount call site, we need to do it from C.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ftrace_test_stop_func</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">parent_ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">function_trace_stop</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">__ftrace_trace_function</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">parent_ip</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">control_ops_disable_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="o">*</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">disabled</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">control_ops_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">disabled</span><span class="p">;</span>

	<span class="n">disabled</span> <span class="o">=</span> <span class="n">alloc_percpu</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">disabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">ops</span><span class="o">-&gt;</span><span class="n">disabled</span> <span class="o">=</span> <span class="n">disabled</span><span class="p">;</span>
	<span class="n">control_ops_disable_all</span><span class="p">(</span><span class="n">ops</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">control_ops_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_percpu</span><span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">disabled</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_global_ops</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ftrace_func_t</span> <span class="n">func</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there&#39;s only one function registered, then call that</span>
<span class="cm">	 * function directly. Otherwise, we need to iterate over the</span>
<span class="cm">	 * registered callers.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ftrace_global_list</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">ftrace_list_end</span> <span class="o">||</span>
	    <span class="n">ftrace_global_list</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">ftrace_list_end</span><span class="p">)</span>
		<span class="n">func</span> <span class="o">=</span> <span class="n">ftrace_global_list</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">func</span> <span class="o">=</span> <span class="n">ftrace_global_list_func</span><span class="p">;</span>

	<span class="cm">/* If we filter on pids, update to use the pid function */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_pids</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">set_ftrace_pid_function</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
		<span class="n">func</span> <span class="o">=</span> <span class="n">ftrace_pid_func</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">global_ops</span><span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_ftrace_function</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ftrace_func_t</span> <span class="n">func</span><span class="p">;</span>

	<span class="n">update_global_ops</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we are at the end of the list and this ops is</span>
<span class="cm">	 * not dynamic, then have the mcount trampoline call</span>
<span class="cm">	 * the function directly</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ftrace_ops_list</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">ftrace_list_end</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">ftrace_ops_list</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">ftrace_list_end</span> <span class="o">&amp;&amp;</span>
	     <span class="o">!</span><span class="p">(</span><span class="n">ftrace_ops_list</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FTRACE_OPS_FL_DYNAMIC</span><span class="p">)))</span>
		<span class="n">func</span> <span class="o">=</span> <span class="n">ftrace_ops_list</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">func</span> <span class="o">=</span> <span class="n">ftrace_ops_list_func</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_HAVE_FUNCTION_TRACE_MCOUNT_TEST</span>
	<span class="n">ftrace_trace_function</span> <span class="o">=</span> <span class="n">func</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="cp">#ifdef CONFIG_DYNAMIC_FTRACE</span>
	<span class="cm">/* do not update till all functions have been modified */</span>
	<span class="n">__ftrace_trace_function_delay</span> <span class="o">=</span> <span class="n">func</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">__ftrace_trace_function</span> <span class="o">=</span> <span class="n">func</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">ftrace_trace_function</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">func</span> <span class="o">==</span> <span class="n">ftrace_stub</span><span class="p">)</span> <span class="o">?</span> <span class="n">func</span> <span class="o">:</span> <span class="n">ftrace_test_stop_func</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_ftrace_ops</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">**</span><span class="n">list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ops</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="o">*</span><span class="n">list</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We are entering ops into the list but another</span>
<span class="cm">	 * CPU might be walking that list. We need to make sure</span>
<span class="cm">	 * the ops-&gt;next pointer is valid before another CPU sees</span>
<span class="cm">	 * the ops pointer included into the list.</span>
<span class="cm">	 */</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="n">ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">remove_ftrace_ops</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">**</span><span class="n">list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">**</span><span class="n">p</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we are removing the last function, then simply point</span>
<span class="cm">	 * to the ftrace_stub.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">list</span> <span class="o">==</span> <span class="n">ops</span> <span class="o">&amp;&amp;</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">ftrace_list_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ftrace_list_end</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span> <span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">ftrace_list_end</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="n">ops</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="n">ops</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_ftrace_list_ops</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">**</span><span class="n">list</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">main_ops</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">first</span> <span class="o">=</span> <span class="o">*</span><span class="n">list</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">ftrace_list_end</span><span class="p">;</span>
	<span class="n">add_ftrace_ops</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span>
		<span class="n">add_ftrace_ops</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_ops_list</span><span class="p">,</span> <span class="n">main_ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">remove_ftrace_list_ops</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">**</span><span class="n">list</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">main_ops</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">remove_ftrace_ops</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">list</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">ftrace_list_end</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">remove_ftrace_ops</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_ops_list</span><span class="p">,</span> <span class="n">main_ops</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__register_ftrace_function</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ftrace_disabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">FTRACE_WARN_ON</span><span class="p">(</span><span class="n">ops</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">global_ops</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FTRACE_OPS_FL_ENABLED</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="cm">/* We don&#39;t support both control and global flags set. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FL_GLOBAL_CONTROL_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">FL_GLOBAL_CONTROL_MASK</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">core_kernel_data</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ops</span><span class="p">))</span>
		<span class="n">ops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">FTRACE_OPS_FL_DYNAMIC</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FTRACE_OPS_FL_GLOBAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">add_ftrace_list_ops</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_global_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">global_ops</span><span class="p">,</span> <span class="n">ops</span><span class="p">);</span>
		<span class="n">ops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">FTRACE_OPS_FL_ENABLED</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FTRACE_OPS_FL_CONTROL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">control_ops_alloc</span><span class="p">(</span><span class="n">ops</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">add_ftrace_list_ops</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_control_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">control_ops</span><span class="p">,</span> <span class="n">ops</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">add_ftrace_ops</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_ops_list</span><span class="p">,</span> <span class="n">ops</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ftrace_enabled</span><span class="p">)</span>
		<span class="n">update_ftrace_function</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__unregister_ftrace_function</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ftrace_disabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FTRACE_OPS_FL_ENABLED</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">FTRACE_WARN_ON</span><span class="p">(</span><span class="n">ops</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">global_ops</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FTRACE_OPS_FL_GLOBAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">remove_ftrace_list_ops</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_global_list</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">global_ops</span><span class="p">,</span> <span class="n">ops</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">ops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FTRACE_OPS_FL_ENABLED</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FTRACE_OPS_FL_CONTROL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">remove_ftrace_list_ops</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_control_list</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">control_ops</span><span class="p">,</span> <span class="n">ops</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The ftrace_ops is now removed from the list,</span>
<span class="cm">			 * so there&#39;ll be no new users. We must ensure</span>
<span class="cm">			 * all current users are done before we free</span>
<span class="cm">			 * the control data.</span>
<span class="cm">			 */</span>
			<span class="n">synchronize_sched</span><span class="p">();</span>
			<span class="n">control_ops_free</span><span class="p">(</span><span class="n">ops</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">remove_ftrace_ops</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_ops_list</span><span class="p">,</span> <span class="n">ops</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ftrace_enabled</span><span class="p">)</span>
		<span class="n">update_ftrace_function</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Dynamic ops may be freed, we must make sure that all</span>
<span class="cm">	 * callers are done before leaving this function.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FTRACE_OPS_FL_DYNAMIC</span><span class="p">)</span>
		<span class="n">synchronize_sched</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ftrace_update_pid_func</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Only do something if we are tracing something */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ftrace_trace_function</span> <span class="o">==</span> <span class="n">ftrace_stub</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">update_ftrace_function</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_FUNCTION_PROFILER</span>
<span class="k">struct</span> <span class="n">ftrace_profile</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span>		<span class="n">node</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>			<span class="n">ip</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>			<span class="n">counter</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span>		<span class="n">time</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span>		<span class="n">time_squared</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ftrace_profile_page</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_profile_page</span>	<span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>			<span class="n">index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_profile</span>		<span class="n">records</span><span class="p">[];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ftrace_profile_stat</span> <span class="p">{</span>
	<span class="n">atomic_t</span>			<span class="n">disabled</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span>		<span class="o">*</span><span class="n">hash</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_profile_page</span>	<span class="o">*</span><span class="n">pages</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_profile_page</span>	<span class="o">*</span><span class="n">start</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tracer_stat</span>		<span class="n">stat</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define PROFILE_RECORDS_SIZE						\</span>
<span class="cp">	(PAGE_SIZE - offsetof(struct ftrace_profile_page, records))</span>

<span class="cp">#define PROFILES_PER_PAGE					\</span>
<span class="cp">	(PROFILE_RECORDS_SIZE / sizeof(struct ftrace_profile))</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">ftrace_profile_bits</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ftrace_profile_enabled</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cm">/* ftrace_profile_lock - synchronize the enable and disable of the profiler */</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">ftrace_profile_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_profile_stat</span><span class="p">,</span> <span class="n">ftrace_profile_stats</span><span class="p">);</span>

<span class="cp">#define FTRACE_PROFILE_HASH_SIZE 1024 </span><span class="cm">/* must be power of 2 */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">function_stat_next</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_profile</span> <span class="o">*</span><span class="n">rec</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_profile_page</span> <span class="o">*</span><span class="n">pg</span><span class="p">;</span>

	<span class="n">pg</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_profile_page</span> <span class="o">*</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">rec</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">);</span>

 <span class="nl">again:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">rec</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">rec</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pg</span><span class="o">-&gt;</span><span class="n">records</span><span class="p">[</span><span class="n">pg</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">pg</span> <span class="o">=</span> <span class="n">pg</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pg</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">rec</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pg</span><span class="o">-&gt;</span><span class="n">records</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rec</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rec</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">function_stat_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">tracer_stat</span> <span class="o">*</span><span class="n">trace</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_profile_stat</span> <span class="o">*</span><span class="n">stat</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ftrace_profile_stat</span><span class="p">,</span> <span class="n">stat</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stat</span> <span class="o">||</span> <span class="o">!</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">function_stat_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">start</span><span class="o">-&gt;</span><span class="n">records</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span>
<span class="cm">/* function graph compares on total time */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">function_stat_cmp</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p1</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_profile</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_profile</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">p2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">time</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">time</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cm">/* not function graph compares against hits */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">function_stat_cmp</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p1</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_profile</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_profile</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">p2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">counter</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">counter</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">function_stat_headers</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;  Function                               &quot;</span>
		   <span class="s">&quot;Hit    Time            Avg             s^2</span><span class="se">\n</span><span class="s">&quot;</span>
		      <span class="s">&quot;  --------                               &quot;</span>
		   <span class="s">&quot;---    ----            ---             ---</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;  Function                               Hit</span><span class="se">\n</span><span class="s">&quot;</span>
		      <span class="s">&quot;  --------                               ---</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">function_stat_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_profile</span> <span class="o">*</span><span class="n">rec</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="n">KSYM_SYMBOL_LEN</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">trace_seq</span> <span class="n">s</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">avg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">stddev</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_profile_lock</span><span class="p">);</span>

	<span class="cm">/* we raced with function_profile_reset() */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rec</span><span class="o">-&gt;</span><span class="n">counter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kallsyms_lookup</span><span class="p">(</span><span class="n">rec</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;  %-30.30s  %10lu&quot;</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">rec</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;    &quot;</span><span class="p">);</span>
	<span class="n">avg</span> <span class="o">=</span> <span class="n">rec</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">;</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">avg</span><span class="p">,</span> <span class="n">rec</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">);</span>

	<span class="cm">/* Sample standard deviation (s^2) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rec</span><span class="o">-&gt;</span><span class="n">counter</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">stddev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">stddev</span> <span class="o">=</span> <span class="n">rec</span><span class="o">-&gt;</span><span class="n">time_squared</span> <span class="o">-</span> <span class="n">rec</span><span class="o">-&gt;</span><span class="n">counter</span> <span class="o">*</span> <span class="n">avg</span> <span class="o">*</span> <span class="n">avg</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Divide only 1000 for ns^2 -&gt; us^2 conversion.</span>
<span class="cm">		 * trace_print_graph_duration will divide 1000 again.</span>
<span class="cm">		 */</span>
		<span class="n">do_div</span><span class="p">(</span><span class="n">stddev</span><span class="p">,</span> <span class="p">(</span><span class="n">rec</span><span class="o">-&gt;</span><span class="n">counter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">trace_seq_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
	<span class="n">trace_print_graph_duration</span><span class="p">(</span><span class="n">rec</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
	<span class="n">trace_seq_puts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;    &quot;</span><span class="p">);</span>
	<span class="n">trace_print_graph_duration</span><span class="p">(</span><span class="n">avg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
	<span class="n">trace_seq_puts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;    &quot;</span><span class="p">);</span>
	<span class="n">trace_print_graph_duration</span><span class="p">(</span><span class="n">stddev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
	<span class="n">trace_print_seq</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">seq_putc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_profile_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ftrace_profile_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_profile_stat</span> <span class="o">*</span><span class="n">stat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_profile_page</span> <span class="o">*</span><span class="n">pg</span><span class="p">;</span>

	<span class="n">pg</span> <span class="o">=</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">pages</span> <span class="o">=</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">pg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">pg</span><span class="o">-&gt;</span><span class="n">records</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PROFILE_RECORDS_SIZE</span><span class="p">);</span>
		<span class="n">pg</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pg</span> <span class="o">=</span> <span class="n">pg</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	       <span class="n">FTRACE_PROFILE_HASH_SIZE</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_head</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ftrace_profile_pages_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_profile_stat</span> <span class="o">*</span><span class="n">stat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_profile_page</span> <span class="o">*</span><span class="n">pg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">functions</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pages</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* If we already allocated, do nothing */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">stat</span><span class="o">-&gt;</span><span class="n">pages</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">get_zeroed_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_DYNAMIC_FTRACE</span>
	<span class="n">functions</span> <span class="o">=</span> <span class="n">ftrace_update_tot_cnt</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="cm">/*</span>
<span class="cm">	 * We do not know the number of functions that exist because</span>
<span class="cm">	 * dynamic tracing is what counts them. With past experience</span>
<span class="cm">	 * we have around 20K functions. That should be more than enough.</span>
<span class="cm">	 * It is highly unlikely we will execute every function in</span>
<span class="cm">	 * the kernel.</span>
<span class="cm">	 */</span>
	<span class="n">functions</span> <span class="o">=</span> <span class="mi">20000</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">pg</span> <span class="o">=</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">;</span>

	<span class="n">pages</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">functions</span><span class="p">,</span> <span class="n">PROFILES_PER_PAGE</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pg</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">get_zeroed_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pg</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="n">pg</span> <span class="o">=</span> <span class="n">pg</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">out_free:</span>
	<span class="n">pg</span> <span class="o">=</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">pg</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">pg</span><span class="p">;</span>

		<span class="n">pg</span> <span class="o">=</span> <span class="n">pg</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">free_page</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">);</span>
	<span class="n">stat</span><span class="o">-&gt;</span><span class="n">pages</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">stat</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ftrace_profile_init_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_profile_stat</span> <span class="o">*</span><span class="n">stat</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">stat</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">ftrace_profile_stats</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If the profile is already created, simply reset it */</span>
		<span class="n">ftrace_profile_reset</span><span class="p">(</span><span class="n">stat</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We are profiling all functions, but usually only a few thousand</span>
<span class="cm">	 * functions are hit. We&#39;ll make a hash of 1024 items.</span>
<span class="cm">	 */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">FTRACE_PROFILE_HASH_SIZE</span><span class="p">;</span>

	<span class="n">stat</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_head</span><span class="p">)</span> <span class="o">*</span> <span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ftrace_profile_bits</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">size</span><span class="o">--</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(;</span> <span class="n">size</span><span class="p">;</span> <span class="n">size</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">ftrace_profile_bits</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Preallocate the function profiling pages */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ftrace_profile_pages_init</span><span class="p">(</span><span class="n">stat</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">);</span>
		<span class="n">stat</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ftrace_profile_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ftrace_profile_init_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* interrupts must be disabled */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ftrace_profile</span> <span class="o">*</span>
<span class="nf">ftrace_find_profiled_func</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_profile_stat</span> <span class="o">*</span><span class="n">stat</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_profile</span> <span class="o">*</span><span class="n">rec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">hhd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">key</span><span class="p">;</span>

	<span class="n">key</span> <span class="o">=</span> <span class="n">hash_long</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">ftrace_profile_bits</span><span class="p">);</span>
	<span class="n">hhd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">[</span><span class="n">key</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hlist_empty</span><span class="p">(</span><span class="n">hhd</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">hlist_for_each_entry_rcu</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">hhd</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rec</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">==</span> <span class="n">ip</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rec</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ftrace_add_profile</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_profile_stat</span> <span class="o">*</span><span class="n">stat</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ftrace_profile</span> <span class="o">*</span><span class="n">rec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">key</span><span class="p">;</span>

	<span class="n">key</span> <span class="o">=</span> <span class="n">hash_long</span><span class="p">(</span><span class="n">rec</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span> <span class="n">ftrace_profile_bits</span><span class="p">);</span>
	<span class="n">hlist_add_head_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rec</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The memory is already allocated, this simply finds a new record to use.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ftrace_profile</span> <span class="o">*</span>
<span class="nf">ftrace_profile_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_profile_stat</span> <span class="o">*</span><span class="n">stat</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_profile</span> <span class="o">*</span><span class="n">rec</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* prevent recursion (from NMIs) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">disabled</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Try to find the function again since an NMI</span>
<span class="cm">	 * could have added it</span>
<span class="cm">	 */</span>
	<span class="n">rec</span> <span class="o">=</span> <span class="n">ftrace_find_profiled_func</span><span class="p">(</span><span class="n">stat</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rec</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">pages</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">==</span> <span class="n">PROFILES_PER_PAGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">pages</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">stat</span><span class="o">-&gt;</span><span class="n">pages</span> <span class="o">=</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">pages</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rec</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">pages</span><span class="o">-&gt;</span><span class="n">records</span><span class="p">[</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">pages</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">];</span>
	<span class="n">rec</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">=</span> <span class="n">ip</span><span class="p">;</span>
	<span class="n">ftrace_add_profile</span><span class="p">(</span><span class="n">stat</span><span class="p">,</span> <span class="n">rec</span><span class="p">);</span>

 <span class="nl">out:</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">disabled</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rec</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">function_profile_call</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">parent_ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_profile_stat</span> <span class="o">*</span><span class="n">stat</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_profile</span> <span class="o">*</span><span class="n">rec</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ftrace_profile_enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">stat</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">ftrace_profile_stats</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">||</span> <span class="o">!</span><span class="n">ftrace_profile_enabled</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">rec</span> <span class="o">=</span> <span class="n">ftrace_find_profiled_func</span><span class="p">(</span><span class="n">stat</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rec</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rec</span> <span class="o">=</span> <span class="n">ftrace_profile_alloc</span><span class="p">(</span><span class="n">stat</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rec</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rec</span><span class="o">-&gt;</span><span class="n">counter</span><span class="o">++</span><span class="p">;</span>
 <span class="nl">out:</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">profile_graph_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_graph_ent</span> <span class="o">*</span><span class="n">trace</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">function_profile_call</span><span class="p">(</span><span class="n">trace</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">profile_graph_return</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_graph_ret</span> <span class="o">*</span><span class="n">trace</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_profile_stat</span> <span class="o">*</span><span class="n">stat</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">calltime</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_profile</span> <span class="o">*</span><span class="n">rec</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">stat</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">ftrace_profile_stats</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">||</span> <span class="o">!</span><span class="n">ftrace_profile_enabled</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* If the calltime was zero&#39;d ignore it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trace</span><span class="o">-&gt;</span><span class="n">calltime</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">calltime</span> <span class="o">=</span> <span class="n">trace</span><span class="o">-&gt;</span><span class="n">rettime</span> <span class="o">-</span> <span class="n">trace</span><span class="o">-&gt;</span><span class="n">calltime</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">trace_flags</span> <span class="o">&amp;</span> <span class="n">TRACE_ITER_GRAPH_TIME</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

		<span class="n">index</span> <span class="o">=</span> <span class="n">trace</span><span class="o">-&gt;</span><span class="n">depth</span><span class="p">;</span>

		<span class="cm">/* Append this call time to the parent time to subtract */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">index</span><span class="p">)</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">ret_stack</span><span class="p">[</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">subtime</span> <span class="o">+=</span> <span class="n">calltime</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">ret_stack</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">subtime</span> <span class="o">&lt;</span> <span class="n">calltime</span><span class="p">)</span>
			<span class="n">calltime</span> <span class="o">-=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">ret_stack</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">subtime</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">calltime</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rec</span> <span class="o">=</span> <span class="n">ftrace_find_profiled_func</span><span class="p">(</span><span class="n">stat</span><span class="p">,</span> <span class="n">trace</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rec</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rec</span><span class="o">-&gt;</span><span class="n">time</span> <span class="o">+=</span> <span class="n">calltime</span><span class="p">;</span>
		<span class="n">rec</span><span class="o">-&gt;</span><span class="n">time_squared</span> <span class="o">+=</span> <span class="n">calltime</span> <span class="o">*</span> <span class="n">calltime</span><span class="p">;</span>
	<span class="p">}</span>

 <span class="nl">out:</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">register_ftrace_profiler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">register_ftrace_graph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">profile_graph_return</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">profile_graph_entry</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unregister_ftrace_profiler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">unregister_ftrace_graph</span><span class="p">();</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="n">ftrace_profile_ops</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">func</span>		<span class="o">=</span> <span class="n">function_profile_call</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">register_ftrace_profiler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">register_ftrace_function</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_profile_ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unregister_ftrace_profiler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">unregister_ftrace_function</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_profile_ops</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_FUNCTION_GRAPH_TRACER */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">ftrace_profile_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
		     <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">kstrtoul_from_user</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="o">!!</span><span class="n">val</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_profile_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ftrace_profile_enabled</span> <span class="o">^</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">ftrace_profile_init</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cnt</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">register_ftrace_profiler</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cnt</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ftrace_profile_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ftrace_profile_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * unregister_ftrace_profiler calls stop_machine</span>
<span class="cm">			 * so this acts like an synchronize_sched.</span>
<span class="cm">			 */</span>
			<span class="n">unregister_ftrace_profiler</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
 <span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_profile_lock</span><span class="p">);</span>

	<span class="o">*</span><span class="n">ppos</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">ftrace_profile_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
		     <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>		<span class="cm">/* big enough to hold a number */</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ftrace_profile_enabled</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ftrace_profile_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">tracing_open_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">ftrace_profile_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">ftrace_profile_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">default_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* used to initialize the real stat files */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tracer_stat</span> <span class="n">function_stats</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;functions&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stat_start</span>	<span class="o">=</span> <span class="n">function_stat_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stat_next</span>	<span class="o">=</span> <span class="n">function_stat_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stat_cmp</span>	<span class="o">=</span> <span class="n">function_stat_cmp</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stat_headers</span>	<span class="o">=</span> <span class="n">function_stat_headers</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stat_show</span>	<span class="o">=</span> <span class="n">function_stat_show</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">void</span> <span class="nf">ftrace_profile_debugfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d_tracer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_profile_stat</span> <span class="o">*</span><span class="n">stat</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">stat</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">ftrace_profile_stats</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

		<span class="cm">/* allocate enough for function name + cpu number */</span>
		<span class="n">name</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The files created are permanent, if something happens</span>
<span class="cm">			 * we still do not free memory.</span>
<span class="cm">			 */</span>
			<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span>
			     <span class="s">&quot;Could not allocate stat file for cpu %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">cpu</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">stat</span><span class="o">-&gt;</span><span class="n">stat</span> <span class="o">=</span> <span class="n">function_stats</span><span class="p">;</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="s">&quot;function%d&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">stat</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">register_stat_tracer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span>
			     <span class="s">&quot;Could not register function stat for cpu %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">cpu</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="s">&quot;function_profile_enabled&quot;</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span>
				    <span class="n">d_tracer</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ftrace_profile_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">)</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Could not create debugfs &quot;</span>
			   <span class="s">&quot;&#39;function_profile_enabled&#39; entry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_FUNCTION_PROFILER */</span><span class="cp"></span>
<span class="k">static</span> <span class="n">__init</span> <span class="kt">void</span> <span class="nf">ftrace_profile_debugfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d_tracer</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_FUNCTION_PROFILER */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span> <span class="k">const</span> <span class="n">ftrace_swapper_pid</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">init_struct_pid</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_DYNAMIC_FTRACE</span>

<span class="cp">#ifndef CONFIG_FTRACE_MCOUNT_RECORD</span>
<span class="cp"># error Dynamic ftrace depends on MCOUNT_RECORD</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">hlist_head</span> <span class="n">ftrace_func_hash</span><span class="p">[</span><span class="n">FTRACE_FUNC_HASHSIZE</span><span class="p">]</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ftrace_func_probe</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span>	<span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_probe_ops</span>	<span class="o">*</span><span class="n">ops</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ip</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rcu_head</span>		<span class="n">rcu</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ftrace_func_entry</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">hlist</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ftrace_hash</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">size_bits</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span>	<span class="o">*</span><span class="n">buckets</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rcu_head</span>		<span class="n">rcu</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * We make these constant because no one should touch them,</span>
<span class="cm"> * but they are used as the default &quot;empty hash&quot;, to avoid allocating</span>
<span class="cm"> * it all the time. These are in a read only section such that if</span>
<span class="cm"> * anyone does try to modify it, it will cause an exception.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">hlist_head</span> <span class="n">empty_buckets</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ftrace_hash</span> <span class="n">empty_hash</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">buckets</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="p">)</span><span class="n">empty_buckets</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#define EMPTY_HASH	((struct ftrace_hash *)&amp;empty_hash)</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="n">global_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">func</span>			<span class="o">=</span> <span class="n">ftrace_stub</span><span class="p">,</span>
	<span class="p">.</span><span class="n">notrace_hash</span>		<span class="o">=</span> <span class="n">EMPTY_HASH</span><span class="p">,</span>
	<span class="p">.</span><span class="n">filter_hash</span>		<span class="o">=</span> <span class="n">EMPTY_HASH</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">ftrace_regex_lock</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">ftrace_page</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_page</span>	<span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dyn_ftrace</span>	<span class="o">*</span><span class="n">records</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">index</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">size</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ftrace_page</span> <span class="o">*</span><span class="n">ftrace_new_pgs</span><span class="p">;</span>

<span class="cp">#define ENTRY_SIZE sizeof(struct dyn_ftrace)</span>
<span class="cp">#define ENTRIES_PER_PAGE (PAGE_SIZE / ENTRY_SIZE)</span>

<span class="cm">/* estimate from running different kernels */</span>
<span class="cp">#define NR_TO_INIT		10000</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ftrace_page</span>	<span class="o">*</span><span class="n">ftrace_pages_start</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ftrace_page</span>	<span class="o">*</span><span class="n">ftrace_pages</span><span class="p">;</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">ftrace_hash_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_hash</span> <span class="o">*</span><span class="n">hash</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">hash</span> <span class="o">||</span> <span class="o">!</span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ftrace_func_entry</span> <span class="o">*</span>
<span class="nf">ftrace_lookup_ip</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_hash</span> <span class="o">*</span><span class="n">hash</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_func_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">hhd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ftrace_hash_empty</span><span class="p">(</span><span class="n">hash</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">size_bits</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">key</span> <span class="o">=</span> <span class="n">hash_long</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">hash</span><span class="o">-&gt;</span><span class="n">size_bits</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">key</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">hhd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">buckets</span><span class="p">[</span><span class="n">key</span><span class="p">];</span>

	<span class="n">hlist_for_each_entry_rcu</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">hhd</span><span class="p">,</span> <span class="n">hlist</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">==</span> <span class="n">ip</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">entry</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__add_hash_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_hash</span> <span class="o">*</span><span class="n">hash</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ftrace_func_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">hhd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">key</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">size_bits</span><span class="p">)</span>
		<span class="n">key</span> <span class="o">=</span> <span class="n">hash_long</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span> <span class="n">hash</span><span class="o">-&gt;</span><span class="n">size_bits</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">key</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">hhd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">buckets</span><span class="p">[</span><span class="n">key</span><span class="p">];</span>
	<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">,</span> <span class="n">hhd</span><span class="p">);</span>
	<span class="n">hash</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">add_hash_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_hash</span> <span class="o">*</span><span class="n">hash</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_func_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">=</span> <span class="n">ip</span><span class="p">;</span>
	<span class="n">__add_hash_entry</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">free_hash_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_hash</span> <span class="o">*</span><span class="n">hash</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">ftrace_func_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="n">hash</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">remove_hash_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_hash</span> <span class="o">*</span><span class="n">hash</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">ftrace_func_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">);</span>
	<span class="n">hash</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ftrace_hash_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_hash</span> <span class="o">*</span><span class="n">hash</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">hhd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="o">*</span><span class="n">tn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_func_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">hash</span><span class="o">-&gt;</span><span class="n">size_bits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hhd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">buckets</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">hlist_for_each_entry_safe</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">tn</span><span class="p">,</span> <span class="n">hhd</span><span class="p">,</span> <span class="n">hlist</span><span class="p">)</span>
			<span class="n">free_hash_entry</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">FTRACE_WARN_ON</span><span class="p">(</span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_ftrace_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_hash</span> <span class="o">*</span><span class="n">hash</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hash</span> <span class="o">||</span> <span class="n">hash</span> <span class="o">==</span> <span class="n">EMPTY_HASH</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">ftrace_hash_clear</span><span class="p">(</span><span class="n">hash</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">buckets</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">hash</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__free_ftrace_hash_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">rcu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_hash</span> <span class="o">*</span><span class="n">hash</span><span class="p">;</span>

	<span class="n">hash</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">rcu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ftrace_hash</span><span class="p">,</span> <span class="n">rcu</span><span class="p">);</span>
	<span class="n">free_ftrace_hash</span><span class="p">(</span><span class="n">hash</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_ftrace_hash_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_hash</span> <span class="o">*</span><span class="n">hash</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hash</span> <span class="o">||</span> <span class="n">hash</span> <span class="o">==</span> <span class="n">EMPTY_HASH</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">call_rcu_sched</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">rcu</span><span class="p">,</span> <span class="n">__free_ftrace_hash_rcu</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ftrace_free_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_ftrace_hash</span><span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">filter_hash</span><span class="p">);</span>
	<span class="n">free_ftrace_hash</span><span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">notrace_hash</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ftrace_hash</span> <span class="o">*</span><span class="nf">alloc_ftrace_hash</span><span class="p">(</span><span class="kt">int</span> <span class="n">size_bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_hash</span> <span class="o">*</span><span class="n">hash</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">hash</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hash</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hash</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">size_bits</span><span class="p">;</span>
	<span class="n">hash</span><span class="o">-&gt;</span><span class="n">buckets</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">buckets</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">buckets</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">hash</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hash</span><span class="o">-&gt;</span><span class="n">size_bits</span> <span class="o">=</span> <span class="n">size_bits</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">hash</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ftrace_hash</span> <span class="o">*</span>
<span class="nf">alloc_and_copy_ftrace_hash</span><span class="p">(</span><span class="kt">int</span> <span class="n">size_bits</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ftrace_hash</span> <span class="o">*</span><span class="n">hash</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_func_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_hash</span> <span class="o">*</span><span class="n">new_hash</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">tp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">new_hash</span> <span class="o">=</span> <span class="n">alloc_ftrace_hash</span><span class="p">(</span><span class="n">size_bits</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_hash</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Empty hash? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ftrace_hash_empty</span><span class="p">(</span><span class="n">hash</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">new_hash</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">hash</span><span class="o">-&gt;</span><span class="n">size_bits</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">buckets</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">hlist</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">add_hash_entry</span><span class="p">(</span><span class="n">new_hash</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">free_hash</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">FTRACE_WARN_ON</span><span class="p">(</span><span class="n">new_hash</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">!=</span> <span class="n">hash</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">new_hash</span><span class="p">;</span>

 <span class="nl">free_hash:</span>
	<span class="n">free_ftrace_hash</span><span class="p">(</span><span class="n">new_hash</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="n">ftrace_hash_rec_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span> <span class="kt">int</span> <span class="n">filter_hash</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="n">ftrace_hash_rec_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span> <span class="kt">int</span> <span class="n">filter_hash</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ftrace_hash_move</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">ftrace_hash</span> <span class="o">**</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ftrace_hash</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_func_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="o">*</span><span class="n">tn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">hhd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_hash</span> <span class="o">*</span><span class="n">old_hash</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_hash</span> <span class="o">*</span><span class="n">new_hash</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">key</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Remove the current set, update the hash and add</span>
<span class="cm">	 * them back.</span>
<span class="cm">	 */</span>
	<span class="n">ftrace_hash_rec_disable</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">enable</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the new source is empty, just free dst and assign it</span>
<span class="cm">	 * the empty_hash.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_ftrace_hash_rcu</span><span class="p">(</span><span class="o">*</span><span class="n">dst</span><span class="p">);</span>
		<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="n">EMPTY_HASH</span><span class="p">);</span>
		<span class="cm">/* still need to update the function records */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make the hash size about 1/2 the # found</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">size</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">size</span><span class="p">;</span> <span class="n">size</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">bits</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t allocate too much */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">&gt;</span> <span class="n">FTRACE_HASH_MAX_BITS</span><span class="p">)</span>
		<span class="n">bits</span> <span class="o">=</span> <span class="n">FTRACE_HASH_MAX_BITS</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">new_hash</span> <span class="o">=</span> <span class="n">alloc_ftrace_hash</span><span class="p">(</span><span class="n">bits</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_hash</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">size_bits</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hhd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">buckets</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">hlist_for_each_entry_safe</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">tn</span><span class="p">,</span> <span class="n">hhd</span><span class="p">,</span> <span class="n">hlist</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">key</span> <span class="o">=</span> <span class="n">hash_long</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span> <span class="n">bits</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">key</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">remove_hash_entry</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
			<span class="n">__add_hash_entry</span><span class="p">(</span><span class="n">new_hash</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">old_hash</span> <span class="o">=</span> <span class="o">*</span><span class="n">dst</span><span class="p">;</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="n">new_hash</span><span class="p">);</span>
	<span class="n">free_ftrace_hash_rcu</span><span class="p">(</span><span class="n">old_hash</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">out:</span>
	<span class="cm">/*</span>
<span class="cm">	 * Enable regardless of ret:</span>
<span class="cm">	 *  On success, we enable the new hash.</span>
<span class="cm">	 *  On failure, we re-enable the original hash.</span>
<span class="cm">	 */</span>
	<span class="n">ftrace_hash_rec_enable</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">enable</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Test the hashes for this ops to see if we want to call</span>
<span class="cm"> * the ops-&gt;func or not.</span>
<span class="cm"> *</span>
<span class="cm"> * It&#39;s a match if the ip is in the ops-&gt;filter_hash or</span>
<span class="cm"> * the filter_hash does not exist or is empty,</span>
<span class="cm"> *  AND</span>
<span class="cm"> * the ip is not in the ops-&gt;notrace_hash.</span>
<span class="cm"> *</span>
<span class="cm"> * This needs to be called with preemption disabled as</span>
<span class="cm"> * the hashes are freed with call_rcu_sched().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ftrace_ops_test</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_hash</span> <span class="o">*</span><span class="n">filter_hash</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_hash</span> <span class="o">*</span><span class="n">notrace_hash</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">filter_hash</span> <span class="o">=</span> <span class="n">rcu_dereference_raw</span><span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">filter_hash</span><span class="p">);</span>
	<span class="n">notrace_hash</span> <span class="o">=</span> <span class="n">rcu_dereference_raw</span><span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">notrace_hash</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ftrace_hash_empty</span><span class="p">(</span><span class="n">filter_hash</span><span class="p">)</span> <span class="o">||</span>
	     <span class="n">ftrace_lookup_ip</span><span class="p">(</span><span class="n">filter_hash</span><span class="p">,</span> <span class="n">ip</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">ftrace_hash_empty</span><span class="p">(</span><span class="n">notrace_hash</span><span class="p">)</span> <span class="o">||</span>
	     <span class="o">!</span><span class="n">ftrace_lookup_ip</span><span class="p">(</span><span class="n">notrace_hash</span><span class="p">,</span> <span class="n">ip</span><span class="p">)))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is a double for. Do not use &#39;break&#39; to break out of the loop,</span>
<span class="cm"> * you must use a goto.</span>
<span class="cm"> */</span>
<span class="cp">#define do_for_each_ftrace_rec(pg, rec)					\</span>
<span class="cp">	for (pg = ftrace_pages_start; pg; pg = pg-&gt;next) {		\</span>
<span class="cp">		int _____i;						\</span>
<span class="cp">		for (_____i = 0; _____i &lt; pg-&gt;index; _____i++) {	\</span>
<span class="cp">			rec = &amp;pg-&gt;records[_____i];</span>

<span class="cp">#define while_for_each_ftrace_rec()		\</span>
<span class="cp">		}				\</span>
<span class="cp">	}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">ftrace_cmp_recs</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dyn_ftrace</span> <span class="o">*</span><span class="n">key</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dyn_ftrace</span> <span class="o">*</span><span class="n">rec</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&lt;</span> <span class="n">rec</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">&gt;=</span> <span class="n">rec</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">+</span> <span class="n">MCOUNT_INSN_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">ftrace_location_range</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_page</span> <span class="o">*</span><span class="n">pg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dyn_ftrace</span> <span class="o">*</span><span class="n">rec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dyn_ftrace</span> <span class="n">key</span><span class="p">;</span>

	<span class="n">key</span><span class="p">.</span><span class="n">ip</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>	<span class="cm">/* overload flags, as it is unsigned long */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pg</span> <span class="o">=</span> <span class="n">ftrace_pages_start</span><span class="p">;</span> <span class="n">pg</span><span class="p">;</span> <span class="n">pg</span> <span class="o">=</span> <span class="n">pg</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">pg</span><span class="o">-&gt;</span><span class="n">records</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">ip</span> <span class="o">||</span>
		    <span class="n">start</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">pg</span><span class="o">-&gt;</span><span class="n">records</span><span class="p">[</span><span class="n">pg</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">ip</span> <span class="o">+</span> <span class="n">MCOUNT_INSN_SIZE</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">rec</span> <span class="o">=</span> <span class="n">bsearch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">pg</span><span class="o">-&gt;</span><span class="n">records</span><span class="p">,</span> <span class="n">pg</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span>
			      <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dyn_ftrace</span><span class="p">),</span>
			      <span class="n">ftrace_cmp_recs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rec</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rec</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ftrace_location - return true if the ip giving is a traced location</span>
<span class="cm"> * @ip: the instruction pointer to check</span>
<span class="cm"> *</span>
<span class="cm"> * Returns rec-&gt;ip if @ip given is a pointer to a ftrace location.</span>
<span class="cm"> * That is, the instruction that is either a NOP or call to</span>
<span class="cm"> * the function tracer. It checks the ftrace internal tables to</span>
<span class="cm"> * determine if the address belongs or not.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">ftrace_location</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ftrace_location_range</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ftrace_text_reserved - return true if range contains an ftrace location</span>
<span class="cm"> * @start: start of range to search</span>
<span class="cm"> * @end: end of range to search (inclusive). @end points to the last byte to check.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 if @start and @end contains a ftrace location.</span>
<span class="cm"> * That is, the instruction that is either a NOP or call to</span>
<span class="cm"> * the function tracer. It checks the ftrace internal tables to</span>
<span class="cm"> * determine if the address belongs or not.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ftrace_text_reserved</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ftrace_location_range</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">start</span><span class="p">,</span>
				    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">end</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">!!</span><span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__ftrace_hash_rec_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">filter_hash</span><span class="p">,</span>
				     <span class="n">bool</span> <span class="n">inc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_hash</span> <span class="o">*</span><span class="n">hash</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_hash</span> <span class="o">*</span><span class="n">other_hash</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_page</span> <span class="o">*</span><span class="n">pg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dyn_ftrace</span> <span class="o">*</span><span class="n">rec</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">all</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Only update if the ops has been registered */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FTRACE_OPS_FL_ENABLED</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * In the filter_hash case:</span>
<span class="cm">	 *   If the count is zero, we update all records.</span>
<span class="cm">	 *   Otherwise we just update the items in the hash.</span>
<span class="cm">	 *</span>
<span class="cm">	 * In the notrace_hash case:</span>
<span class="cm">	 *   We enable the update in the hash.</span>
<span class="cm">	 *   As disabling notrace means enabling the tracing,</span>
<span class="cm">	 *   and enabling notrace means disabling, the inc variable</span>
<span class="cm">	 *   gets inversed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">filter_hash</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hash</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">filter_hash</span><span class="p">;</span>
		<span class="n">other_hash</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">notrace_hash</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ftrace_hash_empty</span><span class="p">(</span><span class="n">hash</span><span class="p">))</span>
			<span class="n">all</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">inc</span> <span class="o">=</span> <span class="o">!</span><span class="n">inc</span><span class="p">;</span>
		<span class="n">hash</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">notrace_hash</span><span class="p">;</span>
		<span class="n">other_hash</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">filter_hash</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the notrace hash has no items,</span>
<span class="cm">		 * then there&#39;s nothing to do.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ftrace_hash_empty</span><span class="p">(</span><span class="n">hash</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">do_for_each_ftrace_rec</span><span class="p">(</span><span class="n">pg</span><span class="p">,</span> <span class="n">rec</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">in_other_hash</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">in_hash</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">match</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">all</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Only the filter_hash affects all records.</span>
<span class="cm">			 * Update if the record is not in the notrace hash.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">other_hash</span> <span class="o">||</span> <span class="o">!</span><span class="n">ftrace_lookup_ip</span><span class="p">(</span><span class="n">other_hash</span><span class="p">,</span> <span class="n">rec</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">))</span>
				<span class="n">match</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">in_hash</span> <span class="o">=</span> <span class="o">!!</span><span class="n">ftrace_lookup_ip</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">rec</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span>
			<span class="n">in_other_hash</span> <span class="o">=</span> <span class="o">!!</span><span class="n">ftrace_lookup_ip</span><span class="p">(</span><span class="n">other_hash</span><span class="p">,</span> <span class="n">rec</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 *</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">filter_hash</span> <span class="o">&amp;&amp;</span> <span class="n">in_hash</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">in_other_hash</span><span class="p">)</span>
				<span class="n">match</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">filter_hash</span> <span class="o">&amp;&amp;</span> <span class="n">in_hash</span> <span class="o">&amp;&amp;</span>
				 <span class="p">(</span><span class="n">in_other_hash</span> <span class="o">||</span> <span class="n">ftrace_hash_empty</span><span class="p">(</span><span class="n">other_hash</span><span class="p">)))</span>
				<span class="n">match</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">match</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">inc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rec</span><span class="o">-&gt;</span><span class="n">flags</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">FTRACE_WARN_ON</span><span class="p">((</span><span class="n">rec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">FTRACE_FL_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">FTRACE_REF_MAX</span><span class="p">))</span>
				<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">FTRACE_WARN_ON</span><span class="p">((</span><span class="n">rec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">FTRACE_FL_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="n">rec</span><span class="o">-&gt;</span><span class="n">flags</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="cm">/* Shortcut, if we handled all records, we are done. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">all</span> <span class="o">&amp;&amp;</span> <span class="n">count</span> <span class="o">==</span> <span class="n">hash</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">while_for_each_ftrace_rec</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ftrace_hash_rec_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">filter_hash</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__ftrace_hash_rec_update</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">filter_hash</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ftrace_hash_rec_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">filter_hash</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__ftrace_hash_rec_update</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">filter_hash</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_ip_ins</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MCOUNT_INSN_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;%s%02x&quot;</span><span class="p">,</span> <span class="n">i</span> <span class="o">?</span> <span class="s">&quot;:&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ftrace_bug - report and shutdown function tracer</span>
<span class="cm"> * @failed: The failed type (EFAULT, EINVAL, EPERM)</span>
<span class="cm"> * @ip: The address that failed</span>
<span class="cm"> *</span>
<span class="cm"> * The arch code that enables or disables the function tracing</span>
<span class="cm"> * can call ftrace_bug() when it has detected a problem in</span>
<span class="cm"> * modifying the code. @failed should be one of either:</span>
<span class="cm"> * EFAULT - if the problem happens on reading the @ip address</span>
<span class="cm"> * EINVAL - if what is read at @ip is not what was expected</span>
<span class="cm"> * EPERM - if the problem happens on writting to the @ip address</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ftrace_bug</span><span class="p">(</span><span class="kt">int</span> <span class="n">failed</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">failed</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EFAULT</span>:
		<span class="n">FTRACE_WARN_ON_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;ftrace faulted on modifying &quot;</span><span class="p">);</span>
		<span class="n">print_ip_sym</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EINVAL</span>:
		<span class="n">FTRACE_WARN_ON_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;ftrace failed to modify &quot;</span><span class="p">);</span>
		<span class="n">print_ip_sym</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
		<span class="n">print_ip_ins</span><span class="p">(</span><span class="s">&quot; actual: &quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">ip</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EPERM</span>:
		<span class="n">FTRACE_WARN_ON_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;ftrace faulted on writing &quot;</span><span class="p">);</span>
		<span class="n">print_ip_sym</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">FTRACE_WARN_ON_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;ftrace faulted on unknown error &quot;</span><span class="p">);</span>
		<span class="n">print_ip_sym</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ftrace_check_record</span><span class="p">(</span><span class="k">struct</span> <span class="n">dyn_ftrace</span> <span class="o">*</span><span class="n">rec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">update</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flag</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we are updating calls:</span>
<span class="cm">	 *</span>
<span class="cm">	 *   If the record has a ref count, then we need to enable it</span>
<span class="cm">	 *   because someone is using it.</span>
<span class="cm">	 *</span>
<span class="cm">	 *   Otherwise we make sure its disabled.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If we are disabling calls, then disable all records that</span>
<span class="cm">	 * are enabled.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">FTRACE_FL_MASK</span><span class="p">))</span>
		<span class="n">flag</span> <span class="o">=</span> <span class="n">FTRACE_FL_ENABLED</span><span class="p">;</span>

	<span class="cm">/* If the state of this record hasn&#39;t changed, then do nothing */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FTRACE_FL_ENABLED</span><span class="p">)</span> <span class="o">==</span> <span class="n">flag</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">FTRACE_UPDATE_IGNORE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">update</span><span class="p">)</span>
			<span class="n">rec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">FTRACE_FL_ENABLED</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">FTRACE_UPDATE_MAKE_CALL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">update</span><span class="p">)</span>
		<span class="n">rec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FTRACE_FL_ENABLED</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">FTRACE_UPDATE_MAKE_NOP</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ftrace_update_record, set a record that now is tracing or not</span>
<span class="cm"> * @rec: the record to update</span>
<span class="cm"> * @enable: set to 1 if the record is tracing, zero to force disable</span>
<span class="cm"> *</span>
<span class="cm"> * The records that represent all functions that can be traced need</span>
<span class="cm"> * to be updated when tracing has been enabled.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ftrace_update_record</span><span class="p">(</span><span class="k">struct</span> <span class="n">dyn_ftrace</span> <span class="o">*</span><span class="n">rec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ftrace_check_record</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">enable</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ftrace_test_record, check if the record has been enabled or not</span>
<span class="cm"> * @rec: the record to test</span>
<span class="cm"> * @enable: set to 1 to check if enabled, 0 if it is disabled</span>
<span class="cm"> *</span>
<span class="cm"> * The arch code may need to test if a record is already set to</span>
<span class="cm"> * tracing to determine how to modify the function code that it</span>
<span class="cm"> * represents.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ftrace_test_record</span><span class="p">(</span><span class="k">struct</span> <span class="n">dyn_ftrace</span> <span class="o">*</span><span class="n">rec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ftrace_check_record</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">enable</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">__ftrace_replace_code</span><span class="p">(</span><span class="k">struct</span> <span class="n">dyn_ftrace</span> <span class="o">*</span><span class="n">rec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ftrace_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ftrace_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">FTRACE_ADDR</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ftrace_update_record</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">enable</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FTRACE_UPDATE_IGNORE</span>:
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FTRACE_UPDATE_MAKE_CALL</span>:
		<span class="k">return</span> <span class="n">ftrace_make_call</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">ftrace_addr</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">FTRACE_UPDATE_MAKE_NOP</span>:
		<span class="k">return</span> <span class="n">ftrace_make_nop</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">ftrace_addr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* unknow ftrace bug */</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__weak</span> <span class="nf">ftrace_replace_code</span><span class="p">(</span><span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dyn_ftrace</span> <span class="o">*</span><span class="n">rec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_page</span> <span class="o">*</span><span class="n">pg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">failed</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ftrace_disabled</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">do_for_each_ftrace_rec</span><span class="p">(</span><span class="n">pg</span><span class="p">,</span> <span class="n">rec</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">failed</span> <span class="o">=</span> <span class="n">__ftrace_replace_code</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">enable</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">failed</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ftrace_bug</span><span class="p">(</span><span class="n">failed</span><span class="p">,</span> <span class="n">rec</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span>
			<span class="cm">/* Stop processing */</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="n">while_for_each_ftrace_rec</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">ftrace_rec_iter</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_page</span>	<span class="o">*</span><span class="n">pg</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">index</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * ftrace_rec_iter_start, start up iterating over traced functions</span>
<span class="cm"> *</span>
<span class="cm"> * Returns an iterator handle that is used to iterate over all</span>
<span class="cm"> * the records that represent address locations where functions</span>
<span class="cm"> * are traced.</span>
<span class="cm"> *</span>
<span class="cm"> * May return NULL if no records are available.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ftrace_rec_iter</span> <span class="o">*</span><span class="nf">ftrace_rec_iter_start</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * We only use a single iterator.</span>
<span class="cm">	 * Protected by the ftrace_lock mutex.</span>
<span class="cm">	 */</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">ftrace_rec_iter</span> <span class="n">ftrace_rec_iter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_rec_iter</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ftrace_rec_iter</span><span class="p">;</span>

	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">pg</span> <span class="o">=</span> <span class="n">ftrace_pages_start</span><span class="p">;</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Could have empty pages */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">pg</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">pg</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">)</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">pg</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">pg</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">pg</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">iter</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ftrace_rec_iter_next, get the next record to process.</span>
<span class="cm"> * @iter: The handle to the iterator.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the next iterator after the given iterator @iter.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ftrace_rec_iter</span> <span class="o">*</span><span class="nf">ftrace_rec_iter_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_rec_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">pg</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">pg</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">pg</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Could have empty pages */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">pg</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">pg</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">)</span>
			<span class="n">iter</span><span class="o">-&gt;</span><span class="n">pg</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">pg</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">pg</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">iter</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ftrace_rec_iter_record, get the record at the iterator location</span>
<span class="cm"> * @iter: The current iterator location</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the record that the current @iter is at.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dyn_ftrace</span> <span class="o">*</span><span class="nf">ftrace_rec_iter_record</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_rec_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">pg</span><span class="o">-&gt;</span><span class="n">records</span><span class="p">[</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ftrace_code_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dyn_ftrace</span> <span class="o">*</span><span class="n">rec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ip</span> <span class="o">=</span> <span class="n">rec</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ftrace_disabled</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ftrace_make_nop</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">MCOUNT_ADDR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ftrace_bug</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * archs can override this function if they must do something</span>
<span class="cm"> * before the modifying code is performed.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__weak</span> <span class="nf">ftrace_arch_code_modify_prepare</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * archs can override this function if they must do something</span>
<span class="cm"> * after the modifying code is performed.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__weak</span> <span class="nf">ftrace_arch_code_modify_post_process</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ftrace_modify_all_code</span><span class="p">(</span><span class="kt">int</span> <span class="n">command</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">command</span> <span class="o">&amp;</span> <span class="n">FTRACE_UPDATE_CALLS</span><span class="p">)</span>
		<span class="n">ftrace_replace_code</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">command</span> <span class="o">&amp;</span> <span class="n">FTRACE_DISABLE_CALLS</span><span class="p">)</span>
		<span class="n">ftrace_replace_code</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">command</span> <span class="o">&amp;</span> <span class="n">FTRACE_UPDATE_TRACE_FUNC</span><span class="p">)</span>
		<span class="n">ftrace_update_ftrace_func</span><span class="p">(</span><span class="n">ftrace_trace_function</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">command</span> <span class="o">&amp;</span> <span class="n">FTRACE_START_FUNC_RET</span><span class="p">)</span>
		<span class="n">ftrace_enable_ftrace_graph_caller</span><span class="p">();</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">command</span> <span class="o">&amp;</span> <span class="n">FTRACE_STOP_FUNC_RET</span><span class="p">)</span>
		<span class="n">ftrace_disable_ftrace_graph_caller</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__ftrace_modify_code</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">command</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">ftrace_modify_all_code</span><span class="p">(</span><span class="o">*</span><span class="n">command</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ftrace_run_stop_machine, go back to the stop machine method</span>
<span class="cm"> * @command: The command to tell ftrace what to do</span>
<span class="cm"> *</span>
<span class="cm"> * If an arch needs to fall back to the stop machine method, the</span>
<span class="cm"> * it can call this function.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ftrace_run_stop_machine</span><span class="p">(</span><span class="kt">int</span> <span class="n">command</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">stop_machine</span><span class="p">(</span><span class="n">__ftrace_modify_code</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">command</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * arch_ftrace_update_code, modify the code to trace or not trace</span>
<span class="cm"> * @command: The command that needs to be done</span>
<span class="cm"> *</span>
<span class="cm"> * Archs can override this function if it does not need to</span>
<span class="cm"> * run stop_machine() to modify code.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__weak</span> <span class="nf">arch_ftrace_update_code</span><span class="p">(</span><span class="kt">int</span> <span class="n">command</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ftrace_run_stop_machine</span><span class="p">(</span><span class="n">command</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ftrace_run_update_code</span><span class="p">(</span><span class="kt">int</span> <span class="n">command</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ftrace_arch_code_modify_prepare</span><span class="p">();</span>
	<span class="n">FTRACE_WARN_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Do not call function tracer while we update the code.</span>
<span class="cm">	 * We are in stop machine.</span>
<span class="cm">	 */</span>
	<span class="n">function_trace_stop</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * By default we use stop_machine() to modify the code.</span>
<span class="cm">	 * But archs can do what ever they want as long as it</span>
<span class="cm">	 * is safe. The stop_machine() is the safest, but also</span>
<span class="cm">	 * produces the most overhead.</span>
<span class="cm">	 */</span>
	<span class="n">arch_ftrace_update_code</span><span class="p">(</span><span class="n">command</span><span class="p">);</span>

<span class="cp">#ifndef CONFIG_HAVE_FUNCTION_TRACE_MCOUNT_TEST</span>
	<span class="cm">/*</span>
<span class="cm">	 * For archs that call ftrace_test_stop_func(), we must</span>
<span class="cm">	 * wait till after we update all the function callers</span>
<span class="cm">	 * before we update the callback. This keeps different</span>
<span class="cm">	 * ops that record different functions from corrupting</span>
<span class="cm">	 * each other.</span>
<span class="cm">	 */</span>
	<span class="n">__ftrace_trace_function</span> <span class="o">=</span> <span class="n">__ftrace_trace_function_delay</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">function_trace_stop</span><span class="o">--</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ftrace_arch_code_modify_post_process</span><span class="p">();</span>
	<span class="n">FTRACE_WARN_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">ftrace_func_t</span> <span class="n">saved_ftrace_func</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ftrace_start_up</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">global_start_up</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ftrace_startup_enable</span><span class="p">(</span><span class="kt">int</span> <span class="n">command</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">saved_ftrace_func</span> <span class="o">!=</span> <span class="n">ftrace_trace_function</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">saved_ftrace_func</span> <span class="o">=</span> <span class="n">ftrace_trace_function</span><span class="p">;</span>
		<span class="n">command</span> <span class="o">|=</span> <span class="n">FTRACE_UPDATE_TRACE_FUNC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">command</span> <span class="o">||</span> <span class="o">!</span><span class="n">ftrace_enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ftrace_run_update_code</span><span class="p">(</span><span class="n">command</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ftrace_startup</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span> <span class="kt">int</span> <span class="n">command</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">hash_enable</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ftrace_disabled</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">ftrace_start_up</span><span class="o">++</span><span class="p">;</span>
	<span class="n">command</span> <span class="o">|=</span> <span class="n">FTRACE_UPDATE_CALLS</span><span class="p">;</span>

	<span class="cm">/* ops marked global share the filter hashes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FTRACE_OPS_FL_GLOBAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">global_ops</span><span class="p">;</span>
		<span class="cm">/* Don&#39;t update hash if global is already set */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">global_start_up</span><span class="p">)</span>
			<span class="n">hash_enable</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">global_start_up</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">FTRACE_OPS_FL_ENABLED</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hash_enable</span><span class="p">)</span>
		<span class="n">ftrace_hash_rec_enable</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">ftrace_startup_enable</span><span class="p">(</span><span class="n">command</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ftrace_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span> <span class="kt">int</span> <span class="n">command</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">hash_disable</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ftrace_disabled</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ftrace_start_up</span><span class="o">--</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Just warn in case of unbalance, no need to kill ftrace, it&#39;s not</span>
<span class="cm">	 * critical but the ftrace_call callers may be never nopped again after</span>
<span class="cm">	 * further ftrace uses.</span>
<span class="cm">	 */</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">ftrace_start_up</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FTRACE_OPS_FL_GLOBAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">global_ops</span><span class="p">;</span>
		<span class="n">global_start_up</span><span class="o">--</span><span class="p">;</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">global_start_up</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/* Don&#39;t update hash if global still has users */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">global_start_up</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">ftrace_start_up</span><span class="p">);</span>
			<span class="n">hash_disable</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hash_disable</span><span class="p">)</span>
		<span class="n">ftrace_hash_rec_disable</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ops</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">global_ops</span> <span class="o">||</span> <span class="o">!</span><span class="n">global_start_up</span><span class="p">)</span>
		<span class="n">ops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FTRACE_OPS_FL_ENABLED</span><span class="p">;</span>

	<span class="n">command</span> <span class="o">|=</span> <span class="n">FTRACE_UPDATE_CALLS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">saved_ftrace_func</span> <span class="o">!=</span> <span class="n">ftrace_trace_function</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">saved_ftrace_func</span> <span class="o">=</span> <span class="n">ftrace_trace_function</span><span class="p">;</span>
		<span class="n">command</span> <span class="o">|=</span> <span class="n">FTRACE_UPDATE_TRACE_FUNC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">command</span> <span class="o">||</span> <span class="o">!</span><span class="n">ftrace_enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ftrace_run_update_code</span><span class="p">(</span><span class="n">command</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ftrace_startup_sysctl</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ftrace_disabled</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Force update next time */</span>
	<span class="n">saved_ftrace_func</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/* ftrace_start_up is true if we want ftrace running */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ftrace_start_up</span><span class="p">)</span>
		<span class="n">ftrace_run_update_code</span><span class="p">(</span><span class="n">FTRACE_UPDATE_CALLS</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ftrace_shutdown_sysctl</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ftrace_disabled</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* ftrace_start_up is true if ftrace is running */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ftrace_start_up</span><span class="p">)</span>
		<span class="n">ftrace_run_update_code</span><span class="p">(</span><span class="n">FTRACE_DISABLE_CALLS</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">cycle_t</span>		<span class="n">ftrace_update_time</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">ftrace_update_cnt</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ftrace_update_tot_cnt</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ops_traces_mod</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_hash</span> <span class="o">*</span><span class="n">hash</span><span class="p">;</span>

	<span class="n">hash</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">filter_hash</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ftrace_hash_empty</span><span class="p">(</span><span class="n">hash</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ftrace_update_code</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_page</span> <span class="o">*</span><span class="n">pg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dyn_ftrace</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">cycle_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ref</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * When adding a module, we need to check if tracers are</span>
<span class="cm">	 * currently enabled and if they are set to trace all functions.</span>
<span class="cm">	 * If they are, we need to enable the module functions as well</span>
<span class="cm">	 * as update the reference counts for those function records.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mod</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">ops</span> <span class="o">=</span> <span class="n">ftrace_ops_list</span><span class="p">;</span>
		     <span class="n">ops</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">ftrace_list_end</span><span class="p">;</span> <span class="n">ops</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FTRACE_OPS_FL_ENABLED</span> <span class="o">&amp;&amp;</span>
			    <span class="n">ops_traces_mod</span><span class="p">(</span><span class="n">ops</span><span class="p">))</span>
				<span class="n">ref</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">ftrace_now</span><span class="p">(</span><span class="n">raw_smp_processor_id</span><span class="p">());</span>
	<span class="n">ftrace_update_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pg</span> <span class="o">=</span> <span class="n">ftrace_new_pgs</span><span class="p">;</span> <span class="n">pg</span><span class="p">;</span> <span class="n">pg</span> <span class="o">=</span> <span class="n">pg</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pg</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* If something went wrong, bail without enabling anything */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ftrace_disabled</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pg</span><span class="o">-&gt;</span><span class="n">records</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">ref</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Do the initial record conversion from mcount jump</span>
<span class="cm">			 * to the NOP instructions.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ftrace_code_disable</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">ftrace_update_cnt</span><span class="o">++</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * If the tracing is enabled, go ahead and enable the record.</span>
<span class="cm">			 *</span>
<span class="cm">			 * The reason not to enable the record immediatelly is the</span>
<span class="cm">			 * inherent check of ftrace_make_nop/ftrace_make_call for</span>
<span class="cm">			 * correct previous instructions.  Making first the NOP</span>
<span class="cm">			 * conversion puts the module to the correct state, thus</span>
<span class="cm">			 * passing the ftrace_make_call check.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ftrace_start_up</span> <span class="o">&amp;&amp;</span> <span class="n">ref</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">failed</span> <span class="o">=</span> <span class="n">__ftrace_replace_code</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">failed</span><span class="p">)</span>
					<span class="n">ftrace_bug</span><span class="p">(</span><span class="n">failed</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ftrace_new_pgs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">stop</span> <span class="o">=</span> <span class="n">ftrace_now</span><span class="p">(</span><span class="n">raw_smp_processor_id</span><span class="p">());</span>
	<span class="n">ftrace_update_time</span> <span class="o">=</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">ftrace_update_tot_cnt</span> <span class="o">+=</span> <span class="n">ftrace_update_cnt</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ftrace_allocate_records</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_page</span> <span class="o">*</span><span class="n">pg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">order</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">order</span> <span class="o">=</span> <span class="n">get_count_order</span><span class="p">(</span><span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">ENTRIES_PER_PAGE</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * We want to fill as much as possible. No more than a page</span>
<span class="cm">	 * may be empty.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">PAGE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">)</span> <span class="o">/</span> <span class="n">ENTRY_SIZE</span> <span class="o">&gt;=</span> <span class="n">count</span> <span class="o">+</span> <span class="n">ENTRIES_PER_PAGE</span><span class="p">)</span>
		<span class="n">order</span><span class="o">--</span><span class="p">;</span>

 <span class="nl">again:</span>
	<span class="n">pg</span><span class="o">-&gt;</span><span class="n">records</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_ZERO</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pg</span><span class="o">-&gt;</span><span class="n">records</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* if we can&#39;t allocate this size, try something smaller */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">order</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">order</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cnt</span> <span class="o">=</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">)</span> <span class="o">/</span> <span class="n">ENTRY_SIZE</span><span class="p">;</span>
	<span class="n">pg</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="n">count</span><span class="p">)</span>
		<span class="n">cnt</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ftrace_page</span> <span class="o">*</span>
<span class="nf">ftrace_allocate_pages</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_to_init</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_page</span> <span class="o">*</span><span class="n">start_pg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_page</span> <span class="o">*</span><span class="n">pg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">order</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">num_to_init</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">start_pg</span> <span class="o">=</span> <span class="n">pg</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pg</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pg</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Try to allocate as much as possible in one continues</span>
<span class="cm">	 * location that fills in all of the space. We want to</span>
<span class="cm">	 * waste as little space as possible.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">cnt</span> <span class="o">=</span> <span class="n">ftrace_allocate_records</span><span class="p">(</span><span class="n">pg</span><span class="p">,</span> <span class="n">num_to_init</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">free_pages</span><span class="p">;</span>

		<span class="n">num_to_init</span> <span class="o">-=</span> <span class="n">cnt</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">num_to_init</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">pg</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pg</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pg</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">free_pages</span><span class="p">;</span>

		<span class="n">pg</span> <span class="o">=</span> <span class="n">pg</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">start_pg</span><span class="p">;</span>

 <span class="nl">free_pages:</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">start_pg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">order</span> <span class="o">=</span> <span class="n">get_count_order</span><span class="p">(</span><span class="n">pg</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">/</span> <span class="n">ENTRIES_PER_PAGE</span><span class="p">);</span>
		<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">pg</span><span class="o">-&gt;</span><span class="n">records</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
		<span class="n">start_pg</span> <span class="o">=</span> <span class="n">pg</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pg</span><span class="p">);</span>
		<span class="n">pg</span> <span class="o">=</span> <span class="n">start_pg</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;ftrace: FAILED to allocate memory for functions</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ftrace_dyn_table_alloc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_to_init</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">num_to_init</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;ftrace: No functions to be traced?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cnt</span> <span class="o">=</span> <span class="n">num_to_init</span> <span class="o">/</span> <span class="n">ENTRIES_PER_PAGE</span><span class="p">;</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;ftrace: allocating %ld entries in %d pages</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">num_to_init</span><span class="p">,</span> <span class="n">cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define FTRACE_BUFF_MAX (KSYM_SYMBOL_LEN+4) </span><span class="cm">/* room for wildcards */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">ftrace_iterator</span> <span class="p">{</span>
	<span class="n">loff_t</span>				<span class="n">pos</span><span class="p">;</span>
	<span class="n">loff_t</span>				<span class="n">func_pos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_page</span>		<span class="o">*</span><span class="n">pg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dyn_ftrace</span>		<span class="o">*</span><span class="n">func</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_func_probe</span>	<span class="o">*</span><span class="n">probe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">trace_parser</span>		<span class="n">parser</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_hash</span>		<span class="o">*</span><span class="n">hash</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_ops</span>		<span class="o">*</span><span class="n">ops</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="n">hidx</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="n">idx</span><span class="p">;</span>
	<span class="kt">unsigned</span>			<span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">t_hash_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_iterator</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">hnd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">hhd</span><span class="p">;</span>

	<span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">=</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">)</span>
		<span class="n">hnd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">probe</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>
 <span class="nl">retry:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">hidx</span> <span class="o">&gt;=</span> <span class="n">FTRACE_FUNC_HASHSIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">hhd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ftrace_func_hash</span><span class="p">[</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">hidx</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hlist_empty</span><span class="p">(</span><span class="n">hhd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">hidx</span><span class="o">++</span><span class="p">;</span>
		<span class="n">hnd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hnd</span><span class="p">)</span>
		<span class="n">hnd</span> <span class="o">=</span> <span class="n">hhd</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">hnd</span> <span class="o">=</span> <span class="n">hnd</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hnd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iter</span><span class="o">-&gt;</span><span class="n">hidx</span><span class="o">++</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">hnd</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">probe</span> <span class="o">=</span> <span class="n">hlist_entry</span><span class="p">(</span><span class="n">hnd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ftrace_func_probe</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">iter</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">t_hash_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_iterator</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">l</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FTRACE_ITER_DO_HASH</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">func_pos</span> <span class="o">&gt;</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">hidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">l</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="o">*</span><span class="n">pos</span> <span class="o">-</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">func_pos</span><span class="p">);</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">t_hash_next</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Only set this if we have an item */</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">FTRACE_ITER_HASH</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">iter</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">t_hash_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ftrace_iterator</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_func_probe</span> <span class="o">*</span><span class="n">rec</span><span class="p">;</span>

	<span class="n">rec</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">rec</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rec</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">print</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rec</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">print</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">rec</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span> <span class="n">rec</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">,</span> <span class="n">rec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%ps:%ps&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">rec</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">rec</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;:%p&quot;</span><span class="p">,</span> <span class="n">rec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
	<span class="n">seq_putc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">t_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_iterator</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dyn_ftrace</span> <span class="o">*</span><span class="n">rec</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ftrace_disabled</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FTRACE_ITER_HASH</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">t_hash_next</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>

	<span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">func_pos</span> <span class="o">=</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FTRACE_ITER_PRINTALL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">t_hash_start</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>

 <span class="nl">retry:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">pg</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">pg</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iter</span><span class="o">-&gt;</span><span class="n">pg</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">pg</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="n">iter</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rec</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">pg</span><span class="o">-&gt;</span><span class="n">records</span><span class="p">[</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">idx</span><span class="o">++</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FTRACE_ITER_FILTER</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="o">!</span><span class="p">(</span><span class="n">ftrace_lookup_ip</span><span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">filter_hash</span><span class="p">,</span> <span class="n">rec</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">)))</span> <span class="o">||</span>

		    <span class="p">((</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FTRACE_ITER_NOTRACE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="o">!</span><span class="n">ftrace_lookup_ip</span><span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">notrace_hash</span><span class="p">,</span> <span class="n">rec</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">))</span> <span class="o">||</span>

		    <span class="p">((</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FTRACE_ITER_ENABLED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="o">!</span><span class="p">(</span><span class="n">rec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">FTRACE_FL_MASK</span><span class="p">)))</span> <span class="p">{</span>

			<span class="n">rec</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rec</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">t_hash_start</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>

	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">func</span> <span class="o">=</span> <span class="n">rec</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">iter</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">reset_iter_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_iterator</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">func_pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">FTRACE_ITER_PRINTALL</span> <span class="o">&amp;</span> <span class="n">FTRACE_ITER_HASH</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">t_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_iterator</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">l</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ftrace_disabled</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If an lseek was done, then reset and start from beginning.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">)</span>
		<span class="n">reset_iter_read</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * For set_ftrace_filter reading, if we have the filter</span>
<span class="cm">	 * off, we can short cut and just print out that all</span>
<span class="cm">	 * functions are enabled.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FTRACE_ITER_FILTER</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ftrace_hash_empty</span><span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">filter_hash</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pos</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">t_hash_start</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">FTRACE_ITER_PRINTALL</span><span class="p">;</span>
		<span class="cm">/* reset in case of seek/pread */</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FTRACE_ITER_HASH</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">iter</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FTRACE_ITER_HASH</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">t_hash_start</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Unfortunately, we need to restart at ftrace_pages_start</span>
<span class="cm">	 * every time we let go of the ftrace_mutex. This is because</span>
<span class="cm">	 * those pointers can change without the lock.</span>
<span class="cm">	 */</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">pg</span> <span class="o">=</span> <span class="n">ftrace_pages_start</span><span class="p">;</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">l</span> <span class="o">&lt;=</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">t_next</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">t_hash_start</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">iter</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">t_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">t_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_iterator</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dyn_ftrace</span> <span class="o">*</span><span class="n">rec</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FTRACE_ITER_HASH</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">t_hash_show</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">iter</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FTRACE_ITER_PRINTALL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;#### all functions enabled ####</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rec</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rec</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%ps&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">rec</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FTRACE_ITER_ENABLED</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; (%ld)&quot;</span><span class="p">,</span>
			   <span class="n">rec</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">FTRACE_FL_MASK</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">show_ftrace_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">t_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">t_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span> <span class="o">=</span> <span class="n">t_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span> <span class="o">=</span> <span class="n">t_show</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ftrace_avail_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_iterator</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ftrace_disabled</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">iter</span> <span class="o">=</span> <span class="n">__seq_open_private</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">show_ftrace_seq_ops</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">pg</span> <span class="o">=</span> <span class="n">ftrace_pages_start</span><span class="p">;</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">global_ops</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">iter</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ftrace_enabled_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_iterator</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ftrace_disabled</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">iter</span> <span class="o">=</span> <span class="n">__seq_open_private</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">show_ftrace_seq_ops</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">pg</span> <span class="o">=</span> <span class="n">ftrace_pages_start</span><span class="p">;</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">FTRACE_ITER_ENABLED</span><span class="p">;</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">global_ops</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">iter</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ftrace_filter_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_hash</span> <span class="o">*</span><span class="n">hash</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>
	<span class="n">ftrace_hash_clear</span><span class="p">(</span><span class="n">hash</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ftrace_regex_open - initialize function tracer filter files</span>
<span class="cm"> * @ops: The ftrace_ops that hold the hash filters</span>
<span class="cm"> * @flag: The type of filter to process</span>
<span class="cm"> * @inode: The inode, usually passed in to your open routine</span>
<span class="cm"> * @file: The file, usually passed in to your open routine</span>
<span class="cm"> *</span>
<span class="cm"> * ftrace_regex_open() initializes the filter files for the</span>
<span class="cm"> * @ops. Depending on @flag it may process the filter hash or</span>
<span class="cm"> * the notrace hash of @ops. With this called from the open</span>
<span class="cm"> * routine, you can use ftrace_filter_write() for the write</span>
<span class="cm"> * routine if @flag has FTRACE_ITER_FILTER set, or</span>
<span class="cm"> * ftrace_notrace_write() if @flag has FTRACE_ITER_NOTRACE set.</span>
<span class="cm"> * ftrace_regex_lseek() should be used as the lseek routine, and</span>
<span class="cm"> * release must call ftrace_regex_release().</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">ftrace_regex_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_iterator</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_hash</span> <span class="o">*</span><span class="n">hash</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ftrace_disabled</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">iter</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iter</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trace_parser_get_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">parser</span><span class="p">,</span> <span class="n">FTRACE_BUFF_MAX</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">FTRACE_ITER_NOTRACE</span><span class="p">)</span>
		<span class="n">hash</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">notrace_hash</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">hash</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">filter_hash</span><span class="p">;</span>

	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="n">ops</span><span class="p">;</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flag</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">=</span> <span class="n">alloc_and_copy_ftrace_hash</span><span class="p">(</span><span class="n">FTRACE_HASH_DEFAULT_BITS</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">trace_parser_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">parser</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_regex_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_TRUNC</span><span class="p">))</span>
		<span class="n">ftrace_filter_reset</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_READ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">pg</span> <span class="o">=</span> <span class="n">ftrace_pages_start</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">show_ftrace_seq_ops</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
			<span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">iter</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Failed */</span>
			<span class="n">free_ftrace_hash</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">);</span>
			<span class="n">trace_parser_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">parser</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">iter</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_regex_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ftrace_filter_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ftrace_regex_open</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global_ops</span><span class="p">,</span>
			<span class="n">FTRACE_ITER_FILTER</span> <span class="o">|</span> <span class="n">FTRACE_ITER_DO_HASH</span><span class="p">,</span>
			<span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ftrace_notrace_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ftrace_regex_open</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global_ops</span><span class="p">,</span> <span class="n">FTRACE_ITER_NOTRACE</span><span class="p">,</span>
				 <span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">loff_t</span>
<span class="nf">ftrace_regex_lseek</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">origin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">loff_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_READ</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">origin</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ftrace_match</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">regex</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">matched</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slen</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MATCH_FULL</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">regex</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">matched</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MATCH_FRONT_ONLY</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">regex</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">matched</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MATCH_MIDDLE_ONLY</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">regex</span><span class="p">))</span>
			<span class="n">matched</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MATCH_END_ONLY</span>:
		<span class="n">slen</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slen</span> <span class="o">&gt;=</span> <span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">memcmp</span><span class="p">(</span><span class="n">str</span> <span class="o">+</span> <span class="n">slen</span> <span class="o">-</span> <span class="n">len</span><span class="p">,</span> <span class="n">regex</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">matched</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">matched</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">enter_record</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_hash</span> <span class="o">*</span><span class="n">hash</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dyn_ftrace</span> <span class="o">*</span><span class="n">rec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">not</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_func_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">ftrace_lookup_ip</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">rec</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">not</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Do nothing if it doesn&#39;t exist */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">free_hash_entry</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Do nothing if it exists */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">add_hash_entry</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">rec</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ftrace_match_record</span><span class="p">(</span><span class="k">struct</span> <span class="n">dyn_ftrace</span> <span class="o">*</span><span class="n">rec</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span>
		    <span class="kt">char</span> <span class="o">*</span><span class="n">regex</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="n">KSYM_SYMBOL_LEN</span><span class="p">];</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">modname</span><span class="p">;</span>

	<span class="n">kallsyms_lookup</span><span class="p">(</span><span class="n">rec</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">modname</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mod</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* module lookup requires matching the module */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">modname</span> <span class="o">||</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">modname</span><span class="p">,</span> <span class="n">mod</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* blank search means to match all funcs in the mod */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ftrace_match</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">regex</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">match_records</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_hash</span> <span class="o">*</span><span class="n">hash</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span>
	      <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="kt">int</span> <span class="n">not</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">search_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_page</span> <span class="o">*</span><span class="n">pg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dyn_ftrace</span> <span class="o">*</span><span class="n">rec</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span> <span class="o">=</span> <span class="n">MATCH_FULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">search</span> <span class="o">=</span> <span class="n">buff</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">filter_parse_regex</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">search</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">not</span><span class="p">);</span>
		<span class="n">search_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">search</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ftrace_disabled</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">do_for_each_ftrace_rec</span><span class="p">(</span><span class="n">pg</span><span class="p">,</span> <span class="n">rec</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ftrace_match_record</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span> <span class="n">search</span><span class="p">,</span> <span class="n">search_len</span><span class="p">,</span> <span class="n">type</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">enter_record</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">not</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">found</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="n">while_for_each_ftrace_rec</span><span class="p">();</span>
 <span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">found</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ftrace_match_records</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_hash</span> <span class="o">*</span><span class="n">hash</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">match_records</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ftrace_match_module_records</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_hash</span> <span class="o">*</span><span class="n">hash</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">not</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* blank or &#39;*&#39; mean the same */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="s">&quot;*&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">buff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* handle the case of &#39;dont filter this module&#39; */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="s">&quot;!&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="s">&quot;!*&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">not</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">match_records</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buff</span><span class="p">),</span> <span class="n">mod</span><span class="p">,</span> <span class="n">not</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We register the module command as a template to show others how</span>
<span class="cm"> * to register the a command as well.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ftrace_mod_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_hash</span> <span class="o">*</span><span class="n">hash</span><span class="p">,</span>
		    <span class="kt">char</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">param</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">mod</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * cmd == &#39;mod&#39; because we only registered this func</span>
<span class="cm">	 * for the &#39;mod&#39; ftrace_func_command.</span>
<span class="cm">	 * But if you register one func with multiple commands,</span>
<span class="cm">	 * you can tell which command was used by the cmd</span>
<span class="cm">	 * parameter.</span>
<span class="cm">	 */</span>

	<span class="cm">/* we must have a module name */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">param</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mod</span> <span class="o">=</span> <span class="n">strsep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">param</span><span class="p">,</span> <span class="s">&quot;:&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strlen</span><span class="p">(</span><span class="n">mod</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ftrace_match_module_records</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">mod</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ftrace_func_command</span> <span class="n">ftrace_mod_cmd</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>			<span class="o">=</span> <span class="s">&quot;mod&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">func</span>			<span class="o">=</span> <span class="n">ftrace_mod_callback</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ftrace_mod_cmd_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">register_ftrace_command</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_mod_cmd</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">device_initcall</span><span class="p">(</span><span class="n">ftrace_mod_cmd_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">function_trace_probe_call</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">parent_ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_func_probe</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">hhd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">key</span><span class="p">;</span>

	<span class="n">key</span> <span class="o">=</span> <span class="n">hash_long</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">FTRACE_HASH_BITS</span><span class="p">);</span>

	<span class="n">hhd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ftrace_func_hash</span><span class="p">[</span><span class="n">key</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hlist_empty</span><span class="p">(</span><span class="n">hhd</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Disable preemption for these calls to prevent a RCU grace</span>
<span class="cm">	 * period. This syncs the hash iteration and freeing of items</span>
<span class="cm">	 * on the hash. rcu_read_lock is too dangerous here.</span>
<span class="cm">	 */</span>
	<span class="n">preempt_disable_notrace</span><span class="p">();</span>
	<span class="n">hlist_for_each_entry_rcu</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">hhd</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">==</span> <span class="n">ip</span><span class="p">)</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">parent_ip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">preempt_enable_notrace</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="n">trace_probe_ops</span> <span class="n">__read_mostly</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="p">.</span><span class="n">func</span>		<span class="o">=</span> <span class="n">function_trace_probe_call</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">ftrace_probe_registered</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__enable_ftrace_function_probe</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ftrace_probe_registered</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">FTRACE_FUNC_HASHSIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">hhd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ftrace_func_hash</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hhd</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Nothing registered? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">FTRACE_FUNC_HASHSIZE</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__register_ftrace_function</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_probe_ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ftrace_startup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_probe_ops</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">ftrace_probe_registered</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__disable_ftrace_function_probe</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ftrace_probe_registered</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">FTRACE_FUNC_HASHSIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">hhd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ftrace_func_hash</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hhd</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* no more funcs left */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__unregister_ftrace_function</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_probe_ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ftrace_shutdown</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_probe_ops</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">ftrace_probe_registered</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">ftrace_free_entry_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">rhp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_func_probe</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">rhp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ftrace_func_probe</span><span class="p">,</span> <span class="n">rcu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">)</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">int</span>
<span class="nf">register_ftrace_function_probe</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">glob</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ftrace_probe_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span>
			      <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_func_probe</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_page</span> <span class="o">*</span><span class="n">pg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dyn_ftrace</span> <span class="o">*</span><span class="n">rec</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">not</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">key</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">search</span><span class="p">;</span>

	<span class="n">type</span> <span class="o">=</span> <span class="n">filter_parse_regex</span><span class="p">(</span><span class="n">glob</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">glob</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">search</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">not</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">search</span><span class="p">);</span>

	<span class="cm">/* we do not support &#39;!&#39; for function probes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">not</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ftrace_disabled</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">do_for_each_ftrace_rec</span><span class="p">(</span><span class="n">pg</span><span class="p">,</span> <span class="n">rec</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ftrace_match_record</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">search</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">type</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">entry</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* If we did not process any, then return error */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="p">)</span>
				<span class="n">count</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">count</span><span class="o">++</span><span class="p">;</span>

		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * The caller might want to do something special</span>
<span class="cm">		 * for each function we find. We call the callback</span>
<span class="cm">		 * to give the caller an opportunity to do so.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">(</span><span class="n">rec</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* caller does not like this func */</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="n">ops</span><span class="p">;</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">=</span> <span class="n">rec</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">;</span>

		<span class="n">key</span> <span class="o">=</span> <span class="n">hash_long</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span> <span class="n">FTRACE_HASH_BITS</span><span class="p">);</span>
		<span class="n">hlist_add_head_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ftrace_func_hash</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span>

	<span class="p">}</span> <span class="n">while_for_each_ftrace_rec</span><span class="p">();</span>
	<span class="n">__enable_ftrace_function_probe</span><span class="p">();</span>

 <span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">PROBE_TEST_FUNC</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">PROBE_TEST_DATA</span>		<span class="o">=</span> <span class="mi">2</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">__unregister_ftrace_function_probe</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">glob</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ftrace_probe_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span>
				  <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_func_probe</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="n">KSYM_SYMBOL_LEN</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">type</span> <span class="o">=</span> <span class="n">MATCH_FULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">search</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">glob</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">glob</span><span class="p">,</span> <span class="s">&quot;*&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">strlen</span><span class="p">(</span><span class="n">glob</span><span class="p">)))</span>
		<span class="n">glob</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">glob</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">not</span><span class="p">;</span>

		<span class="n">type</span> <span class="o">=</span> <span class="n">filter_parse_regex</span><span class="p">(</span><span class="n">glob</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">glob</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">search</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">not</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">search</span><span class="p">);</span>

		<span class="cm">/* we do not support &#39;!&#39; for function probes */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">not</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">FTRACE_FUNC_HASHSIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">hhd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ftrace_func_hash</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">hlist_for_each_entry_safe</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">hhd</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* break up if statements for readability */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PROBE_TEST_FUNC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">!=</span> <span class="n">ops</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PROBE_TEST_DATA</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">!=</span> <span class="n">data</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/* do this last, since it is the most expensive */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">glob</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kallsyms_lookup</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
						<span class="nb">NULL</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ftrace_match</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">glob</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">type</span><span class="p">))</span>
					<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
			<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rcu</span><span class="p">,</span> <span class="n">ftrace_free_entry_rcu</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">__disable_ftrace_function_probe</span><span class="p">();</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">unregister_ftrace_function_probe</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">glob</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ftrace_probe_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span>
				<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__unregister_ftrace_function_probe</span><span class="p">(</span><span class="n">glob</span><span class="p">,</span> <span class="n">ops</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span>
					  <span class="n">PROBE_TEST_FUNC</span> <span class="o">|</span> <span class="n">PROBE_TEST_DATA</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">unregister_ftrace_function_probe_func</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">glob</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ftrace_probe_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__unregister_ftrace_function_probe</span><span class="p">(</span><span class="n">glob</span><span class="p">,</span> <span class="n">ops</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">PROBE_TEST_FUNC</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">unregister_ftrace_function_probe_all</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">glob</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__unregister_ftrace_function_probe</span><span class="p">(</span><span class="n">glob</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">ftrace_commands</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">ftrace_cmd_mutex</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">register_ftrace_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_func_command</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_func_command</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_cmd_mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ftrace_commands</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ftrace_commands</span><span class="p">);</span>
 <span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_cmd_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">unregister_ftrace_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_func_command</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_func_command</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_cmd_mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ftrace_commands</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
 <span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_cmd_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ftrace_process_regex</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_hash</span> <span class="o">*</span><span class="n">hash</span><span class="p">,</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">command</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">buff</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_func_command</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">func</span> <span class="o">=</span> <span class="n">strsep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next</span><span class="p">,</span> <span class="s">&quot;:&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ftrace_match_records</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* command found */</span>

	<span class="n">command</span> <span class="o">=</span> <span class="n">strsep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next</span><span class="p">,</span> <span class="s">&quot;:&quot;</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_cmd_mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ftrace_commands</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">command</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">enable</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
 <span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_cmd_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">ftrace_regex_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
		   <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_iterator</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">trace_parser</span> <span class="o">*</span><span class="n">parser</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">,</span> <span class="n">read</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cnt</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_regex_lock</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ftrace_disabled</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_READ</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
		<span class="n">iter</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">iter</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">parser</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">parser</span><span class="p">;</span>
	<span class="n">read</span> <span class="o">=</span> <span class="n">trace_get_user</span><span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">read</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">trace_parser_loaded</span><span class="p">(</span><span class="n">parser</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">trace_parser_cont</span><span class="p">(</span><span class="n">parser</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ftrace_process_regex</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">,</span> <span class="n">parser</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span>
					   <span class="n">parser</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">,</span> <span class="n">enable</span><span class="p">);</span>
		<span class="n">trace_parser_clear</span><span class="p">(</span><span class="n">parser</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">read</span><span class="p">;</span>
<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_regex_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">ssize_t</span>
<span class="nf">ftrace_filter_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
		    <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ftrace_regex_write</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">ssize_t</span>
<span class="nf">ftrace_notrace_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
		     <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ftrace_regex_write</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ftrace_set_regex</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
		 <span class="kt">int</span> <span class="n">reset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_hash</span> <span class="o">**</span><span class="n">orig_hash</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_hash</span> <span class="o">*</span><span class="n">hash</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* All global ops uses the global ops filters */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FTRACE_OPS_FL_GLOBAL</span><span class="p">)</span>
		<span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">global_ops</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ftrace_disabled</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span>
		<span class="n">orig_hash</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">filter_hash</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">orig_hash</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">notrace_hash</span><span class="p">;</span>

	<span class="n">hash</span> <span class="o">=</span> <span class="n">alloc_and_copy_ftrace_hash</span><span class="p">(</span><span class="n">FTRACE_HASH_DEFAULT_BITS</span><span class="p">,</span> <span class="o">*</span><span class="n">orig_hash</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hash</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_regex_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reset</span><span class="p">)</span>
		<span class="n">ftrace_filter_reset</span><span class="p">(</span><span class="n">hash</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ftrace_match_records</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_regex_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ftrace_hash_move</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">enable</span><span class="p">,</span> <span class="n">orig_hash</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FTRACE_OPS_FL_ENABLED</span>
	    <span class="o">&amp;&amp;</span> <span class="n">ftrace_enabled</span><span class="p">)</span>
		<span class="n">ftrace_run_update_code</span><span class="p">(</span><span class="n">FTRACE_UPDATE_CALLS</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>

 <span class="nl">out_regex_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_regex_lock</span><span class="p">);</span>

	<span class="n">free_ftrace_hash</span><span class="p">(</span><span class="n">hash</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ftrace_set_filter - set a function to filter on in ftrace</span>
<span class="cm"> * @ops - the ops to set the filter with</span>
<span class="cm"> * @buf - the string that holds the function filter text.</span>
<span class="cm"> * @len - the length of the string.</span>
<span class="cm"> * @reset - non zero to reset all filters before applying this filter.</span>
<span class="cm"> *</span>
<span class="cm"> * Filters denote which functions should be enabled when tracing is enabled.</span>
<span class="cm"> * If @buf is NULL and reset is set, all functions will be enabled for tracing.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ftrace_set_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ftrace_set_regex</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">reset</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ftrace_set_filter</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ftrace_set_notrace - set a function to not trace in ftrace</span>
<span class="cm"> * @ops - the ops to set the notrace filter with</span>
<span class="cm"> * @buf - the string that holds the function notrace text.</span>
<span class="cm"> * @len - the length of the string.</span>
<span class="cm"> * @reset - non zero to reset all filters before applying this filter.</span>
<span class="cm"> *</span>
<span class="cm"> * Notrace Filters denote which functions should not be enabled when tracing</span>
<span class="cm"> * is enabled. If @buf is NULL and reset is set, all functions will be enabled</span>
<span class="cm"> * for tracing.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ftrace_set_notrace</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ftrace_set_regex</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">reset</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ftrace_set_notrace</span><span class="p">);</span>
<span class="cm">/**</span>
<span class="cm"> * ftrace_set_filter - set a function to filter on in ftrace</span>
<span class="cm"> * @ops - the ops to set the filter with</span>
<span class="cm"> * @buf - the string that holds the function filter text.</span>
<span class="cm"> * @len - the length of the string.</span>
<span class="cm"> * @reset - non zero to reset all filters before applying this filter.</span>
<span class="cm"> *</span>
<span class="cm"> * Filters denote which functions should be enabled when tracing is enabled.</span>
<span class="cm"> * If @buf is NULL and reset is set, all functions will be enabled for tracing.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ftrace_set_global_filter</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ftrace_set_regex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global_ops</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">reset</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ftrace_set_global_filter</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ftrace_set_notrace - set a function to not trace in ftrace</span>
<span class="cm"> * @ops - the ops to set the notrace filter with</span>
<span class="cm"> * @buf - the string that holds the function notrace text.</span>
<span class="cm"> * @len - the length of the string.</span>
<span class="cm"> * @reset - non zero to reset all filters before applying this filter.</span>
<span class="cm"> *</span>
<span class="cm"> * Notrace Filters denote which functions should not be enabled when tracing</span>
<span class="cm"> * is enabled. If @buf is NULL and reset is set, all functions will be enabled</span>
<span class="cm"> * for tracing.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ftrace_set_global_notrace</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ftrace_set_regex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global_ops</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">reset</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ftrace_set_global_notrace</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * command line interface to allow users to set filters on boot up.</span>
<span class="cm"> */</span>
<span class="cp">#define FTRACE_FILTER_SIZE		COMMAND_LINE_SIZE</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">ftrace_notrace_buf</span><span class="p">[</span><span class="n">FTRACE_FILTER_SIZE</span><span class="p">]</span> <span class="n">__initdata</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">ftrace_filter_buf</span><span class="p">[</span><span class="n">FTRACE_FILTER_SIZE</span><span class="p">]</span> <span class="n">__initdata</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">set_ftrace_notrace</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="n">ftrace_notrace_buf</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">FTRACE_FILTER_SIZE</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;ftrace_notrace=&quot;</span><span class="p">,</span> <span class="n">set_ftrace_notrace</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">set_ftrace_filter</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="n">ftrace_filter_buf</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">FTRACE_FILTER_SIZE</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;ftrace_filter=&quot;</span><span class="p">,</span> <span class="n">set_ftrace_filter</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">ftrace_graph_buf</span><span class="p">[</span><span class="n">FTRACE_FILTER_SIZE</span><span class="p">]</span> <span class="n">__initdata</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ftrace_set_func</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">array</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">idx</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">set_graph_function</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">ftrace_graph_buf</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">FTRACE_FILTER_SIZE</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;ftrace_graph_filter=&quot;</span><span class="p">,</span> <span class="n">set_graph_function</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">set_ftrace_early_graph</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">func</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">func</span> <span class="o">=</span> <span class="n">strsep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;,&quot;</span><span class="p">);</span>
		<span class="cm">/* we allow only one expression at a time */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ftrace_set_func</span><span class="p">(</span><span class="n">ftrace_graph_funcs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ftrace_graph_count</span><span class="p">,</span>
				      <span class="n">func</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;ftrace: function %s not &quot;</span>
					  <span class="s">&quot;traceable</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_FUNCTION_GRAPH_TRACER */</span><span class="cp"></span>

<span class="kt">void</span> <span class="n">__init</span>
<span class="nf">ftrace_set_early_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">func</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">func</span> <span class="o">=</span> <span class="n">strsep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;,&quot;</span><span class="p">);</span>
		<span class="n">ftrace_set_regex</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">func</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">enable</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">set_ftrace_early_filters</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ftrace_filter_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">ftrace_set_early_filter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global_ops</span><span class="p">,</span> <span class="n">ftrace_filter_buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ftrace_notrace_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">ftrace_set_early_filter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global_ops</span><span class="p">,</span> <span class="n">ftrace_notrace_buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ftrace_graph_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">set_ftrace_early_graph</span><span class="p">(</span><span class="n">ftrace_graph_buf</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_FUNCTION_GRAPH_TRACER */</span><span class="cp"></span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ftrace_regex_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="p">)</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_iterator</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_hash</span> <span class="o">**</span><span class="n">orig_hash</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">trace_parser</span> <span class="o">*</span><span class="n">parser</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">filter_hash</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_regex_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_READ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iter</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

		<span class="n">seq_release</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">iter</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">parser</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">parser</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trace_parser_loaded</span><span class="p">(</span><span class="n">parser</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">parser</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="n">parser</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ftrace_match_records</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">,</span> <span class="n">parser</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">parser</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">trace_parser_put</span><span class="p">(</span><span class="n">parser</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">filter_hash</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FTRACE_ITER_FILTER</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">filter_hash</span><span class="p">)</span>
			<span class="n">orig_hash</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">filter_hash</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">orig_hash</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">notrace_hash</span><span class="p">;</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ftrace_hash_move</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">,</span> <span class="n">filter_hash</span><span class="p">,</span>
				       <span class="n">orig_hash</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FTRACE_OPS_FL_ENABLED</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="n">ftrace_enabled</span><span class="p">)</span>
			<span class="n">ftrace_run_update_code</span><span class="p">(</span><span class="n">FTRACE_UPDATE_CALLS</span><span class="p">);</span>

		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">free_ftrace_hash</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_regex_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ftrace_avail_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">ftrace_avail_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">seq_release_private</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ftrace_enabled_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">ftrace_enabled_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">seq_release_private</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ftrace_filter_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">ftrace_filter_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">ftrace_filter_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">ftrace_regex_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">ftrace_regex_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ftrace_notrace_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">ftrace_notrace_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">ftrace_notrace_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">ftrace_regex_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">ftrace_regex_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span>

<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">graph_lock</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ftrace_graph_count</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">ftrace_graph_filter_enabled</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ftrace_graph_funcs</span><span class="p">[</span><span class="n">FTRACE_GRAPH_MAX_FUNCS</span><span class="p">]</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">__g_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pos</span> <span class="o">&gt;=</span> <span class="n">ftrace_graph_count</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">ftrace_graph_funcs</span><span class="p">[</span><span class="o">*</span><span class="n">pos</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">g_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">__g_next</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">g_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph_lock</span><span class="p">);</span>

	<span class="cm">/* Nothing, tell g_show to print all functions are enabled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ftrace_graph_filter_enabled</span> <span class="o">&amp;&amp;</span> <span class="o">!*</span><span class="n">pos</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">__g_next</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">g_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">g_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptr</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">==</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;#### all functions enabled ####</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%ps</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">*</span><span class="n">ptr</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">ftrace_graph_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">g_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">g_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span> <span class="o">=</span> <span class="n">g_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span> <span class="o">=</span> <span class="n">g_show</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ftrace_graph_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ftrace_disabled</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_TRUNC</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ftrace_graph_filter_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ftrace_graph_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">ftrace_graph_funcs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ftrace_graph_funcs</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_READ</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ftrace_graph_seq_ops</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ftrace_graph_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_READ</span><span class="p">)</span>
		<span class="n">seq_release</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ftrace_set_func</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">array</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">idx</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dyn_ftrace</span> <span class="o">*</span><span class="n">rec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_page</span> <span class="o">*</span><span class="n">pg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">search_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fail</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="n">not</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">search</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">exists</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* decode regex */</span>
	<span class="n">type</span> <span class="o">=</span> <span class="n">filter_parse_regex</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">search</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">not</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">not</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">FTRACE_GRAPH_MAX_FUNCS</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">search_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">search</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ftrace_disabled</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">do_for_each_ftrace_rec</span><span class="p">(</span><span class="n">pg</span><span class="p">,</span> <span class="n">rec</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ftrace_match_record</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">search</span><span class="p">,</span> <span class="n">search_len</span><span class="p">,</span> <span class="n">type</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* if it is in the array */</span>
			<span class="n">exists</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">idx</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">rec</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">exists</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">not</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">fail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">exists</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">array</span><span class="p">[(</span><span class="o">*</span><span class="n">idx</span><span class="p">)</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">rec</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">FTRACE_GRAPH_MAX_FUNCS</span><span class="p">)</span>
						<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">exists</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="o">--</span><span class="p">(</span><span class="o">*</span><span class="n">idx</span><span class="p">)];</span>
					<span class="n">array</span><span class="p">[</span><span class="o">*</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">fail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="n">while_for_each_ftrace_rec</span><span class="p">();</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fail</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ftrace_graph_filter_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">ftrace_graph_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
		   <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trace_parser</span> <span class="n">parser</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">read</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cnt</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trace_parser_get_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parser</span><span class="p">,</span> <span class="n">FTRACE_BUFF_MAX</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">read</span> <span class="o">=</span> <span class="n">trace_get_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parser</span><span class="p">,</span> <span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">read</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">trace_parser_loaded</span><span class="p">((</span><span class="o">&amp;</span><span class="n">parser</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">parser</span><span class="p">.</span><span class="n">buffer</span><span class="p">[</span><span class="n">parser</span><span class="p">.</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* we allow only one expression at a time */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ftrace_set_func</span><span class="p">(</span><span class="n">ftrace_graph_funcs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ftrace_graph_count</span><span class="p">,</span>
					<span class="n">parser</span><span class="p">.</span><span class="n">buffer</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">read</span><span class="p">;</span>

<span class="nl">out_free:</span>
	<span class="n">trace_parser_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parser</span><span class="p">);</span>
<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ftrace_graph_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">ftrace_graph_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">ftrace_graph_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">ftrace_graph_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_FUNCTION_GRAPH_TRACER */</span><span class="cp"></span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">ftrace_init_dyn_debugfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d_tracer</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">trace_create_file</span><span class="p">(</span><span class="s">&quot;available_filter_functions&quot;</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span>
			<span class="n">d_tracer</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ftrace_avail_fops</span><span class="p">);</span>

	<span class="n">trace_create_file</span><span class="p">(</span><span class="s">&quot;enabled_functions&quot;</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span>
			<span class="n">d_tracer</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ftrace_enabled_fops</span><span class="p">);</span>

	<span class="n">trace_create_file</span><span class="p">(</span><span class="s">&quot;set_ftrace_filter&quot;</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">d_tracer</span><span class="p">,</span>
			<span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ftrace_filter_fops</span><span class="p">);</span>

	<span class="n">trace_create_file</span><span class="p">(</span><span class="s">&quot;set_ftrace_notrace&quot;</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">d_tracer</span><span class="p">,</span>
				    <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ftrace_notrace_fops</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span>
	<span class="n">trace_create_file</span><span class="p">(</span><span class="s">&quot;set_graph_function&quot;</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">d_tracer</span><span class="p">,</span>
				    <span class="nb">NULL</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">ftrace_graph_fops</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_FUNCTION_GRAPH_TRACER */</span><span class="cp"></span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ftrace_cmp_ips</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ipa</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ipb</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ipa</span> <span class="o">&gt;</span> <span class="o">*</span><span class="n">ipb</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ipa</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">ipb</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ftrace_swap_ips</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ipa</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ipb</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">t</span><span class="p">;</span>

	<span class="n">t</span> <span class="o">=</span> <span class="o">*</span><span class="n">ipa</span><span class="p">;</span>
	<span class="o">*</span><span class="n">ipa</span> <span class="o">=</span> <span class="o">*</span><span class="n">ipb</span><span class="p">;</span>
	<span class="o">*</span><span class="n">ipb</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ftrace_process_locs</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_page</span> <span class="o">*</span><span class="n">start_pg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_page</span> <span class="o">*</span><span class="n">pg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dyn_ftrace</span> <span class="o">*</span><span class="n">rec</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Shut up gcc */</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">count</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sort</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">start</span><span class="p">),</span>
	     <span class="n">ftrace_cmp_ips</span><span class="p">,</span> <span class="n">ftrace_swap_ips</span><span class="p">);</span>

	<span class="n">start_pg</span> <span class="o">=</span> <span class="n">ftrace_allocate_pages</span><span class="p">(</span><span class="n">count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">start_pg</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Core and each module needs their own pages, as</span>
<span class="cm">	 * modules will free them when they are removed.</span>
<span class="cm">	 * Force a new page to be allocated for modules.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mod</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">ftrace_pages</span> <span class="o">||</span> <span class="n">ftrace_pages_start</span><span class="p">);</span>
		<span class="cm">/* First initialization */</span>
		<span class="n">ftrace_pages</span> <span class="o">=</span> <span class="n">ftrace_pages_start</span> <span class="o">=</span> <span class="n">start_pg</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ftrace_pages</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">ftrace_pages</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Hmm, we have free pages? */</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">ftrace_pages</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
				<span class="n">ftrace_pages</span> <span class="o">=</span> <span class="n">ftrace_pages</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ftrace_pages</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">start_pg</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">pg</span> <span class="o">=</span> <span class="n">start_pg</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">ftrace_call_adjust</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Some architecture linkers will pad between</span>
<span class="cm">		 * the different mcount_loc sections of different</span>
<span class="cm">		 * object files to satisfy alignments.</span>
<span class="cm">		 * Skip any NULL pointers.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addr</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pg</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">==</span> <span class="n">pg</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* We should have allocated enough */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pg</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">pg</span> <span class="o">=</span> <span class="n">pg</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">rec</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pg</span><span class="o">-&gt;</span><span class="n">records</span><span class="p">[</span><span class="n">pg</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">];</span>
		<span class="n">rec</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We should have used all pages */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">pg</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>

	<span class="cm">/* Assign the last page to ftrace_pages */</span>
	<span class="n">ftrace_pages</span> <span class="o">=</span> <span class="n">pg</span><span class="p">;</span>

	<span class="cm">/* These new locations need to be initialized */</span>
	<span class="n">ftrace_new_pgs</span> <span class="o">=</span> <span class="n">start_pg</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We only need to disable interrupts on start up</span>
<span class="cm">	 * because we are modifying code that an interrupt</span>
<span class="cm">	 * may execute, and the modification is not atomic.</span>
<span class="cm">	 * But for modules, nothing runs the code we modify</span>
<span class="cm">	 * until we are finished with it, and there&#39;s no</span>
<span class="cm">	 * reason to cause large interrupt latencies while we do it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mod</span><span class="p">)</span>
		<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">ftrace_update_code</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mod</span><span class="p">)</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_MODULES</span>

<span class="cp">#define next_to_ftrace_page(p) container_of(p, struct ftrace_page, next)</span>

<span class="kt">void</span> <span class="nf">ftrace_release_mod</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dyn_ftrace</span> <span class="o">*</span><span class="n">rec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_page</span> <span class="o">**</span><span class="n">last_pg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_page</span> <span class="o">*</span><span class="n">pg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">order</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ftrace_disabled</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Each module has its own ftrace_pages, remove</span>
<span class="cm">	 * them from the list.</span>
<span class="cm">	 */</span>
	<span class="n">last_pg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ftrace_pages_start</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">pg</span> <span class="o">=</span> <span class="n">ftrace_pages_start</span><span class="p">;</span> <span class="n">pg</span><span class="p">;</span> <span class="n">pg</span> <span class="o">=</span> <span class="o">*</span><span class="n">last_pg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rec</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pg</span><span class="o">-&gt;</span><span class="n">records</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">within_module_core</span><span class="p">(</span><span class="n">rec</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span> <span class="n">mod</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * As core pages are first, the first</span>
<span class="cm">			 * page should never be a module page.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">pg</span> <span class="o">==</span> <span class="n">ftrace_pages_start</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

			<span class="cm">/* Check if we are deleting the last page */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pg</span> <span class="o">==</span> <span class="n">ftrace_pages</span><span class="p">)</span>
				<span class="n">ftrace_pages</span> <span class="o">=</span> <span class="n">next_to_ftrace_page</span><span class="p">(</span><span class="n">last_pg</span><span class="p">);</span>

			<span class="o">*</span><span class="n">last_pg</span> <span class="o">=</span> <span class="n">pg</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="n">order</span> <span class="o">=</span> <span class="n">get_count_order</span><span class="p">(</span><span class="n">pg</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">/</span> <span class="n">ENTRIES_PER_PAGE</span><span class="p">);</span>
			<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">pg</span><span class="o">-&gt;</span><span class="n">records</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">pg</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">last_pg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pg</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
 <span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ftrace_init_module</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ftrace_disabled</span> <span class="o">||</span> <span class="n">start</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">ftrace_process_locs</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ftrace_module_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MODULE_STATE_COMING</span>:
		<span class="n">ftrace_init_module</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">ftrace_callsites</span><span class="p">,</span>
				   <span class="n">mod</span><span class="o">-&gt;</span><span class="n">ftrace_callsites</span> <span class="o">+</span>
				   <span class="n">mod</span><span class="o">-&gt;</span><span class="n">num_ftrace_callsites</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MODULE_STATE_GOING</span>:
		<span class="n">ftrace_release_mod</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ftrace_module_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MODULES */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">ftrace_module_nb</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">ftrace_module_notify</span><span class="p">,</span>
	<span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__start_mcount_loc</span><span class="p">[];</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__stop_mcount_loc</span><span class="p">[];</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">ftrace_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Keep the ftrace pointer to the stub */</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ftrace_stub</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">ftrace_dyn_arch_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* ftrace_dyn_arch_init places the return code in addr */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>

	<span class="n">count</span> <span class="o">=</span> <span class="n">__stop_mcount_loc</span> <span class="o">-</span> <span class="n">__start_mcount_loc</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ftrace_dyn_table_alloc</span><span class="p">(</span><span class="n">count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>

	<span class="n">last_ftrace_enabled</span> <span class="o">=</span> <span class="n">ftrace_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ftrace_process_locs</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span>
				  <span class="n">__start_mcount_loc</span><span class="p">,</span>
				  <span class="n">__stop_mcount_loc</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">register_module_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_module_nb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Failed to register trace ftrace module notifier</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">set_ftrace_early_filters</span><span class="p">();</span>

	<span class="k">return</span><span class="p">;</span>
 <span class="nl">failed:</span>
	<span class="n">ftrace_disabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="n">global_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">func</span>			<span class="o">=</span> <span class="n">ftrace_stub</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ftrace_nodyn_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ftrace_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">device_initcall</span><span class="p">(</span><span class="n">ftrace_nodyn_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ftrace_init_dyn_debugfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d_tracer</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ftrace_startup_enable</span><span class="p">(</span><span class="kt">int</span> <span class="n">command</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cm">/* Keep as macros so we do not need to define the commands */</span>
<span class="cp"># define ftrace_startup(ops, command)			\</span>
<span class="cp">	({						\</span>
<span class="cp">		(ops)-&gt;flags |= FTRACE_OPS_FL_ENABLED;	\</span>
<span class="cp">		0;					\</span>
<span class="cp">	})</span>
<span class="cp"># define ftrace_shutdown(ops, command)	do { } while (0)</span>
<span class="cp"># define ftrace_startup_sysctl()	do { } while (0)</span>
<span class="cp"># define ftrace_shutdown_sysctl()	do { } while (0)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">ftrace_ops_test</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_DYNAMIC_FTRACE */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ftrace_ops_control_func</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">parent_ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">trace_recursion_test</span><span class="p">(</span><span class="n">TRACE_CONTROL_BIT</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some of the ops may be dynamically allocated,</span>
<span class="cm">	 * they must be freed after a synchronize_sched().</span>
<span class="cm">	 */</span>
	<span class="n">preempt_disable_notrace</span><span class="p">();</span>
	<span class="n">trace_recursion_set</span><span class="p">(</span><span class="n">TRACE_CONTROL_BIT</span><span class="p">);</span>
	<span class="n">op</span> <span class="o">=</span> <span class="n">rcu_dereference_raw</span><span class="p">(</span><span class="n">ftrace_control_list</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">op</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">ftrace_list_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ftrace_function_local_disabled</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ftrace_ops_test</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">ip</span><span class="p">))</span>
			<span class="n">op</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">parent_ip</span><span class="p">);</span>

		<span class="n">op</span> <span class="o">=</span> <span class="n">rcu_dereference_raw</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
	<span class="p">};</span>
	<span class="n">trace_recursion_clear</span><span class="p">(</span><span class="n">TRACE_CONTROL_BIT</span><span class="p">);</span>
	<span class="n">preempt_enable_notrace</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="n">control_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">ftrace_ops_control_func</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ftrace_ops_list_func</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">parent_ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">trace_recursion_test</span><span class="p">(</span><span class="n">TRACE_INTERNAL_BIT</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">trace_recursion_set</span><span class="p">(</span><span class="n">TRACE_INTERNAL_BIT</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Some of the ops may be dynamically allocated,</span>
<span class="cm">	 * they must be freed after a synchronize_sched().</span>
<span class="cm">	 */</span>
	<span class="n">preempt_disable_notrace</span><span class="p">();</span>
	<span class="n">op</span> <span class="o">=</span> <span class="n">rcu_dereference_raw</span><span class="p">(</span><span class="n">ftrace_ops_list</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">op</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">ftrace_list_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ftrace_ops_test</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">ip</span><span class="p">))</span>
			<span class="n">op</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">parent_ip</span><span class="p">);</span>
		<span class="n">op</span> <span class="o">=</span> <span class="n">rcu_dereference_raw</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
	<span class="p">};</span>
	<span class="n">preempt_enable_notrace</span><span class="p">();</span>
	<span class="n">trace_recursion_clear</span><span class="p">(</span><span class="n">TRACE_INTERNAL_BIT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">clear_ftrace_swapper</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">get_online_cpus</span><span class="p">();</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">idle_task</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="n">clear_tsk_trace_trace</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">put_online_cpus</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_ftrace_swapper</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">get_online_cpus</span><span class="p">();</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">idle_task</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="n">set_tsk_trace_trace</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">put_online_cpus</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">clear_ftrace_pid</span><span class="p">(</span><span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">do_each_pid_task</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">PIDTYPE_PID</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clear_tsk_trace_trace</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span> <span class="n">while_each_pid_task</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">PIDTYPE_PID</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="n">put_pid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_ftrace_pid</span><span class="p">(</span><span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">do_each_pid_task</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">PIDTYPE_PID</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_tsk_trace_trace</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span> <span class="n">while_each_pid_task</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">PIDTYPE_PID</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">clear_ftrace_pid_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="n">ftrace_swapper_pid</span><span class="p">)</span>
		<span class="n">clear_ftrace_swapper</span><span class="p">();</span>
	<span class="k">else</span>
		<span class="n">clear_ftrace_pid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_ftrace_pid_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="n">ftrace_swapper_pid</span><span class="p">)</span>
		<span class="n">set_ftrace_swapper</span><span class="p">();</span>
	<span class="k">else</span>
		<span class="n">set_ftrace_pid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ftrace_pid_add</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_pid</span> <span class="o">*</span><span class="n">fpid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="n">pid</span> <span class="o">=</span> <span class="n">ftrace_swapper_pid</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">pid</span> <span class="o">=</span> <span class="n">find_get_pid</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pid</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">fpid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ftrace_pids</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fpid</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">==</span> <span class="n">pid</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">fpid</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">fpid</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fpid</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fpid</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ftrace_pids</span><span class="p">);</span>
	<span class="n">fpid</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="n">pid</span><span class="p">;</span>

	<span class="n">set_ftrace_pid_task</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>

	<span class="n">ftrace_update_pid_func</span><span class="p">();</span>
	<span class="n">ftrace_startup_enable</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_put:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">!=</span> <span class="n">ftrace_swapper_pid</span><span class="p">)</span>
		<span class="n">put_pid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ftrace_pid_reset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_pid</span> <span class="o">*</span><span class="n">fpid</span><span class="p">,</span> <span class="o">*</span><span class="n">safe</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">fpid</span><span class="p">,</span> <span class="n">safe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ftrace_pids</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fpid</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>

		<span class="n">clear_ftrace_pid_task</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>

		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fpid</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">fpid</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ftrace_update_pid_func</span><span class="p">();</span>
	<span class="n">ftrace_startup_enable</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">fpid_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_pids</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!*</span><span class="n">pos</span><span class="p">))</span>
		<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">seq_list_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_pids</span><span class="p">,</span> <span class="o">*</span><span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">fpid_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">seq_list_next</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ftrace_pids</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fpid_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fpid_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ftrace_pid</span> <span class="o">*</span><span class="n">fpid</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ftrace_pid</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;no pid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fpid</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">==</span> <span class="n">ftrace_swapper_pid</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;swapper tasks</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pid_vnr</span><span class="p">(</span><span class="n">fpid</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">ftrace_pid_sops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">fpid_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">fpid_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span> <span class="o">=</span> <span class="n">fpid_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span> <span class="o">=</span> <span class="n">fpid_show</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ftrace_pid_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_TRUNC</span><span class="p">))</span>
		<span class="n">ftrace_pid_reset</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_READ</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ftrace_pid_sops</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">ftrace_pid_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
		   <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">64</span><span class="p">],</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">buf</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allow &quot;echo &gt; set_ftrace_pid&quot; or &quot;echo -n &#39;&#39; &gt; set_ftrace_pid&quot;</span>
<span class="cm">	 * to clean the filter quietly.</span>
<span class="cm">	 */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">strstrip</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">strict_strtol</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ftrace_pid_add</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ftrace_pid_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_READ</span><span class="p">)</span>
		<span class="n">seq_release</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ftrace_pid_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">ftrace_pid_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">ftrace_pid_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">ftrace_pid_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">ftrace_init_debugfs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d_tracer</span><span class="p">;</span>

	<span class="n">d_tracer</span> <span class="o">=</span> <span class="n">tracing_init_dentry</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d_tracer</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ftrace_init_dyn_debugfs</span><span class="p">(</span><span class="n">d_tracer</span><span class="p">);</span>

	<span class="n">trace_create_file</span><span class="p">(</span><span class="s">&quot;set_ftrace_pid&quot;</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">d_tracer</span><span class="p">,</span>
			    <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ftrace_pid_fops</span><span class="p">);</span>

	<span class="n">ftrace_profile_debugfs</span><span class="p">(</span><span class="n">d_tracer</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">fs_initcall</span><span class="p">(</span><span class="n">ftrace_init_debugfs</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ftrace_kill - kill ftrace</span>
<span class="cm"> *</span>
<span class="cm"> * This function should be used by panic code. It stops ftrace</span>
<span class="cm"> * but in a not so nice way. If you need to simply kill ftrace</span>
<span class="cm"> * from a non-atomic section, use ftrace_kill.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ftrace_kill</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ftrace_disabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ftrace_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">clear_ftrace_function</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Test if ftrace is dead or not.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ftrace_is_dead</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ftrace_disabled</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * register_ftrace_function - register a function for profiling</span>
<span class="cm"> * @ops - ops structure that holds the function for profiling.</span>
<span class="cm"> *</span>
<span class="cm"> * Register a function to be called by all functions in the</span>
<span class="cm"> * kernel.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: @ops-&gt;func and all the functions it calls must be labeled</span>
<span class="cm"> *       with &quot;notrace&quot;, otherwise it will go into a</span>
<span class="cm"> *       recursive loop.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">register_ftrace_function</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ftrace_disabled</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__register_ftrace_function</span><span class="p">(</span><span class="n">ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ftrace_startup</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>


 <span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">register_ftrace_function</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * unregister_ftrace_function - unregister a function for profiling.</span>
<span class="cm"> * @ops - ops structure that holds the function to unregister</span>
<span class="cm"> *</span>
<span class="cm"> * Unregister a function that was added to be called by ftrace profiling.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">unregister_ftrace_function</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__unregister_ftrace_function</span><span class="p">(</span><span class="n">ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ftrace_shutdown</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">unregister_ftrace_function</span><span class="p">);</span>

<span class="kt">int</span>
<span class="nf">ftrace_enable_sysctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
		     <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">lenp</span><span class="p">,</span>
		     <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ftrace_disabled</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">proc_dointvec</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">lenp</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">||</span> <span class="o">!</span><span class="n">write</span> <span class="o">||</span> <span class="p">(</span><span class="n">last_ftrace_enabled</span> <span class="o">==</span> <span class="o">!!</span><span class="n">ftrace_enabled</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">last_ftrace_enabled</span> <span class="o">=</span> <span class="o">!!</span><span class="n">ftrace_enabled</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ftrace_enabled</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">ftrace_startup_sysctl</span><span class="p">();</span>

		<span class="cm">/* we are starting ftrace again */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ftrace_ops_list</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">ftrace_list_end</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ftrace_ops_list</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">ftrace_list_end</span><span class="p">)</span>
				<span class="n">ftrace_trace_function</span> <span class="o">=</span> <span class="n">ftrace_ops_list</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">ftrace_trace_function</span> <span class="o">=</span> <span class="n">ftrace_ops_list_func</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* stopping ftrace calls (just send to ftrace_stub) */</span>
		<span class="n">ftrace_trace_function</span> <span class="o">=</span> <span class="n">ftrace_stub</span><span class="p">;</span>

		<span class="n">ftrace_shutdown_sysctl</span><span class="p">();</span>
	<span class="p">}</span>

 <span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">ftrace_graph_active</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">ftrace_suspend_notifier</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">ftrace_graph_entry_stub</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_graph_ent</span> <span class="o">*</span><span class="n">trace</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* The callbacks that hook a function */</span>
<span class="n">trace_func_graph_ret_t</span> <span class="n">ftrace_graph_return</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">trace_func_graph_ret_t</span><span class="p">)</span><span class="n">ftrace_stub</span><span class="p">;</span>
<span class="n">trace_func_graph_ent_t</span> <span class="n">ftrace_graph_entry</span> <span class="o">=</span> <span class="n">ftrace_graph_entry_stub</span><span class="p">;</span>

<span class="cm">/* Try to assign a return stack array on FTRACE_RETSTACK_ALLOC_SIZE tasks. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">alloc_retstack_tasklist</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ret_stack</span> <span class="o">**</span><span class="n">ret_stack_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">FTRACE_RETSTACK_ALLOC_SIZE</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">g</span><span class="p">,</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">FTRACE_RETSTACK_ALLOC_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_stack_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">FTRACE_RETFUNC_DEPTH</span>
					<span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ret_stack</span><span class="p">),</span>
					<span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret_stack_list</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">end</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">free</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">read_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">do_each_thread</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">ret_stack</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">tracing_graph_pause</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">trace_overrun</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">t</span><span class="o">-&gt;</span><span class="n">curr_ret_stack</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="cm">/* Make sure the tasks see the -1 first: */</span>
			<span class="n">smp_wmb</span><span class="p">();</span>
			<span class="n">t</span><span class="o">-&gt;</span><span class="n">ret_stack</span> <span class="o">=</span> <span class="n">ret_stack_list</span><span class="p">[</span><span class="n">start</span><span class="o">++</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="n">while_each_thread</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>

<span class="nl">unlock:</span>
	<span class="n">read_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="nl">free:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ret_stack_list</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ftrace_graph_probe_sched_switch</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ignore</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">timestamp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Does the user want to count the time a function was asleep.</span>
<span class="cm">	 * If so, do not update the time stamps.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trace_flags</span> <span class="o">&amp;</span> <span class="n">TRACE_ITER_SLEEP_TIME</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">timestamp</span> <span class="o">=</span> <span class="n">trace_clock_local</span><span class="p">();</span>

	<span class="n">prev</span><span class="o">-&gt;</span><span class="n">ftrace_timestamp</span> <span class="o">=</span> <span class="n">timestamp</span><span class="p">;</span>

	<span class="cm">/* only process tasks that we timestamped */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">ftrace_timestamp</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Update all the counters in next to make up for the</span>
<span class="cm">	 * time next was sleeping.</span>
<span class="cm">	 */</span>
	<span class="n">timestamp</span> <span class="o">-=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">ftrace_timestamp</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">curr_ret_stack</span><span class="p">;</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span><span class="o">--</span><span class="p">)</span>
		<span class="n">next</span><span class="o">-&gt;</span><span class="n">ret_stack</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">calltime</span> <span class="o">+=</span> <span class="n">timestamp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Allocate a return stack for each task */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">start_graph_tracing</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_ret_stack</span> <span class="o">**</span><span class="n">ret_stack_list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">ret_stack_list</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">FTRACE_RETSTACK_ALLOC_SIZE</span> <span class="o">*</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ret_stack</span> <span class="o">*</span><span class="p">),</span>
				<span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret_stack_list</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* The cpu_boot init_task-&gt;ret_stack will never be freed */</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">idle_task</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ret_stack</span><span class="p">)</span>
			<span class="n">ftrace_graph_init_idle_task</span><span class="p">(</span><span class="n">idle_task</span><span class="p">(</span><span class="n">cpu</span><span class="p">),</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">alloc_retstack_tasklist</span><span class="p">(</span><span class="n">ret_stack_list</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">register_trace_sched_switch</span><span class="p">(</span><span class="n">ftrace_graph_probe_sched_switch</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;ftrace_graph: Couldn&#39;t activate tracepoint&quot;</span>
				<span class="s">&quot; probe to kernel_sched_switch</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">ret_stack_list</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Hibernation protection.</span>
<span class="cm"> * The state of the current task is too much unstable during</span>
<span class="cm"> * suspend/restore to disk. We want to protect against that.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ftrace_suspend_notifier_call</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">bl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">state</span><span class="p">,</span>
							<span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PM_HIBERNATION_PREPARE</span>:
		<span class="n">pause_graph_tracing</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PM_POST_HIBERNATION</span>:
		<span class="n">unpause_graph_tracing</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">register_ftrace_graph</span><span class="p">(</span><span class="n">trace_func_graph_ret_t</span> <span class="n">retfunc</span><span class="p">,</span>
			<span class="n">trace_func_graph_ent_t</span> <span class="n">entryfunc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>

	<span class="cm">/* we currently allow only one tracer registered at a time */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ftrace_graph_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ftrace_suspend_notifier</span><span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">ftrace_suspend_notifier_call</span><span class="p">;</span>
	<span class="n">register_pm_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_suspend_notifier</span><span class="p">);</span>

	<span class="n">ftrace_graph_active</span><span class="o">++</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">start_graph_tracing</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ftrace_graph_active</span><span class="o">--</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ftrace_graph_return</span> <span class="o">=</span> <span class="n">retfunc</span><span class="p">;</span>
	<span class="n">ftrace_graph_entry</span> <span class="o">=</span> <span class="n">entryfunc</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ftrace_startup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global_ops</span><span class="p">,</span> <span class="n">FTRACE_START_FUNC_RET</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">unregister_ftrace_graph</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ftrace_graph_active</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ftrace_graph_active</span><span class="o">--</span><span class="p">;</span>
	<span class="n">ftrace_graph_return</span> <span class="o">=</span> <span class="p">(</span><span class="n">trace_func_graph_ret_t</span><span class="p">)</span><span class="n">ftrace_stub</span><span class="p">;</span>
	<span class="n">ftrace_graph_entry</span> <span class="o">=</span> <span class="n">ftrace_graph_entry_stub</span><span class="p">;</span>
	<span class="n">ftrace_shutdown</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global_ops</span><span class="p">,</span> <span class="n">FTRACE_STOP_FUNC_RET</span><span class="p">);</span>
	<span class="n">unregister_pm_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_suspend_notifier</span><span class="p">);</span>
	<span class="n">unregister_trace_sched_switch</span><span class="p">(</span><span class="n">ftrace_graph_probe_sched_switch</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

 <span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ret_stack</span> <span class="o">*</span><span class="p">,</span> <span class="n">idle_ret_stack</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">graph_init_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ftrace_ret_stack</span> <span class="o">*</span><span class="n">ret_stack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">tracing_graph_pause</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">trace_overrun</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">ftrace_timestamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* make curr_ret_stack visible before we add the ret_stack */</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">ret_stack</span> <span class="o">=</span> <span class="n">ret_stack</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate a return stack for the idle task. May be the first</span>
<span class="cm"> * time through, or it may be done by CPU hotplug online.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ftrace_graph_init_idle_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">curr_ret_stack</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * The idle task has no parent, it either has its own</span>
<span class="cm">	 * stack or no stack at all.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">ret_stack</span><span class="p">)</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">ret_stack</span> <span class="o">!=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">idle_ret_stack</span><span class="p">,</span> <span class="n">cpu</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ftrace_graph_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ftrace_ret_stack</span> <span class="o">*</span><span class="n">ret_stack</span><span class="p">;</span>

		<span class="n">ret_stack</span> <span class="o">=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">idle_ret_stack</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret_stack</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret_stack</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">FTRACE_RETFUNC_DEPTH</span>
					    <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ret_stack</span><span class="p">),</span>
					    <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret_stack</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="n">per_cpu</span><span class="p">(</span><span class="n">idle_ret_stack</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="n">ret_stack</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">graph_init_task</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ret_stack</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Allocate a return stack for newly created task */</span>
<span class="kt">void</span> <span class="nf">ftrace_graph_init_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Make sure we do not use the parent ret_stack */</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">ret_stack</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">curr_ret_stack</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ftrace_graph_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ftrace_ret_stack</span> <span class="o">*</span><span class="n">ret_stack</span><span class="p">;</span>

		<span class="n">ret_stack</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">FTRACE_RETFUNC_DEPTH</span>
				<span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ret_stack</span><span class="p">),</span>
				<span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret_stack</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">graph_init_task</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ret_stack</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ftrace_graph_exit_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_ret_stack</span>	<span class="o">*</span><span class="n">ret_stack</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">ret_stack</span><span class="p">;</span>

	<span class="n">t</span><span class="o">-&gt;</span><span class="n">ret_stack</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/* NULL must become visible to IRQs before we free it: */</span>
	<span class="n">barrier</span><span class="p">();</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">ret_stack</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ftrace_graph_stop</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ftrace_stop</span><span class="p">();</span>
<span class="p">}</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
