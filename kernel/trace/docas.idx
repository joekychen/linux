f | Makefile | g | 2.1K |  | Linus Torvalds | torvalds@linux-foundation.org | 1337884774 |  | Merge branch 'perf-uprobes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip  Pull user-space probe instrumentation from Ingo Molnar:  "The uprobes code originates from SystemTap and has been used for years   in Fedora and RHEL kernels.  This version is much rewritten, reviews   from PeterZ, Oleg and myself shaped the end result.    This tree includes uprobes support in 'perf probe' - but SystemTap   (and other tools) can take advantage of user probe points as well.    Sample usage of uprobes via perf, for example to profile malloc()   calls without modifying user-space binaries.    First boot a new kernel with CONFIG_UPROBE_EVENT=y enabled.    If you don't know which function you want to probe you can pick one   from 'perf top' or can get a list all functions that can be probed   within libc (binaries can be specified as well):  	$ perf probe -F -x /lib/libc.so.6    To probe libc's malloc():  	$ perf probe -x /lib64/libc.so.6 malloc 	Added new event: 	probe_libc:malloc    (on 0x7eac0)    You can now use it in all perf tools, such as:  	perf record -e probe_libc:malloc -aR sleep 1    Make use of it to create a call graph (as the flat profile is going to   look very boring):  	$ perf record -e probe_libc:malloc -gR make 	[ perf record: Woken up 173 times to write data ] 	[ perf record: Captured and wrote 44.190 MB perf.data (~1930712  	$ perf report || less  	  32.03%            git  libc-2.15.so   [.] malloc 	                    || 	                    --- malloc  	  29.49%            cc1  libc-2.15.so   [.] malloc 	                    || 	                    --- malloc 	                       || 	                       ||--0.95%-- 0x208eb1000000000 	                       || 	                       ||--0.63%-- htab_traverse_noresize  	  11.04%             as  libc-2.15.so   [.] malloc 	                     || 	                     --- malloc 	                        ||  	   7.15%             ld  libc-2.15.so   [.] malloc 	                     || 	                     --- malloc 	                        ||  	   5.07%             sh  libc-2.15.so   [.] malloc 	                     || 	                     --- malloc 	                        || 	   4.99%  python-config  libc-2.15.so   [.] malloc 	          || 	          --- malloc 	             || 	   4.54%           make  libc-2.15.so   [.] malloc 	                   || 	                   --- malloc 	                      || 	                      ||--7.34%-- glob 	                      ||          || 	                      ||          ||--93.18%-- 0x41588f 	                      ||          || 	                      ||           --6.82%-- glob 	                      ||                     0x41588f  	   ...    Or:  	$ perf report -g flat || less  	# Overhead        Command  Shared Object      Symbol 	# ........  .............  .............  .......... 	# 	  32.03%            git  libc-2.15.so   [.] malloc 	          27.19% 	              malloc  	  29.49%            cc1  libc-2.15.so   [.] malloc 	          24.77% 	              malloc  	  11.04%             as  libc-2.15.so   [.] malloc 	          11.02% 	              malloc  	   7.15%             ld  libc-2.15.so   [.] malloc 	           6.57% 	              malloc  	 ...    The core uprobes design is fairly straightforward: uprobes probe   points register themselves at (inode:offset) addresses of   libraries/binaries, after which all existing (or new) vmas that map   that address will have a software breakpoint injected at that address.   vmas are COW-ed to preserve original content.  The probe points are   kept in an rbtree.    If user-space executes the probed inode:offset instruction address   then an event is generated which can be recovered from the regular   perf event channels and mmap-ed ring-buffer.    Multiple probes at the same address are supported, they create a   dynamic callback list of event consumers.    The basic model is further complicated by the XOL speedup: the   original instruction that is probed is copied (in an architecture   specific fashion) and executed out of line when the probe triggers.   The XOL area is a single vma per process, with a fixed number of   entries (which limits probe execution parallelism).    The API: uprobes are installed/removed via   /sys/kernel/debug/tracing/uprobe_events, the API is integrated to   align with the kprobes interface as much as possible, but is separate   to it.    Injecting a probe point is privileged operation, which can be relaxed   by setting perf_paranoid to -1.    You can use multiple probes as well and mix them with kprobes and   regular PMU events or tracepoints, when instrumenting a task."  Fix up trivial conflicts in mm/memory.c due to previous cleanup of unmap_single_vma().  * 'perf-uprobes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (21 commits)   perf probe: Detect probe target when m/x options are absent   perf probe: Provide perf interface for uprobes   tracing: Fix kconfig warning due to a typo   tracing: Provide trace events interface for uprobes   tracing: Extract out common code for kprobes/uprobes trace events   tracing: Modify is_delete, is_return from int to bool   uprobes/core: Decrement uprobe count before the pages are unmapped   uprobes/core: Make background page replacement logic account for rss_stat counters   uprobes/core: Optimize probe hits with the help of a counter   uprobes/core: Allocate XOL slots for uprobes use   uprobes/core: Handle breakpoint and singlestep exceptions   uprobes/core: Rename bkpt to swbp   uprobes/core: Make order of function parameters consistent across functions   uprobes/core: Make macro names consistent   uprobes: Update copyright notices   uprobes/core: Move insn to arch specific structure   uprobes/core: Remove uprobe_opcode_sz   uprobes/core: Make instruction tables volatile   uprobes: Move to kernel/events/   uprobes/core: Clean up, refactor and improve the code   ...
f | trace_syscalls.c | s | 16K | 574 | Jiri Olsa | jolsa@redhat.com | 1329840505 |  | ftrace, perf: Add add/del tracepoint perf registration actions  Adding TRACE_REG_PERF_ADD and TRACE_REG_PERF_DEL to handle perf event schedule in/out actions.  The add action is invoked for when the perf event is scheduled in, while the del action is invoked when the event is scheduled out.  Link: http://lkml.kernel.org/r/1329317514-8131-4-git-send-email-jolsa@redhat.com  Acked-by: Frederic Weisbecker <fweisbec@gmail.com> Signed-off-by: Jiri Olsa <jolsa@redhat.com> Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
f | trace_output.h | s | 1.6K | 41 | Steven Rostedt | srostedt@redhat.com | 1273861232 |  | tracing: Allow events to share their print functions  Multiple events may use the same method to print their data. Instead of having all events have a pointer to their print funtions, the trace_event structure now points to a trace_event_functions structure that will hold the way to print ouf the event.  The event itself is now passed to the print function to let the print function know what kind of event it should print.  This opens the door to consolidating the way several events print their output.     text	   data	    bss	    dec	    hex	filename 4913961	1088356	 861512	6863829	 68bbd5	vmlinux.orig 4900382	1048964	 861512	6810858	 67ecea	vmlinux.init 4900446	1049028	 861512	6810986	 67ed6a	vmlinux.preprint  This change slightly increases the size but is needed for the next change.  v3: Fix the branch tracer events to handle this change.  v2: Fix the new function graph tracer event calls to handle this change.  Acked-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com> Acked-by: Masami Hiramatsu <mhiramat@redhat.com> Acked-by: Frederic Weisbecker <fweisbec@gmail.com> Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
f | trace_events_filter_test.h | s | 1.0K | 39 | Jiri Olsa | jolsa@redhat.com | 1313778959 |  | tracing/filter: Add startup tests for events filter  Adding automated tests running as late_initcall. Tests are compiled in with CONFIG_FTRACE_STARTUP_TEST option.  Adding test event "ftrace_test_filter" used to simulate filter processing during event occurance.  String filters are compiled and tested against several test events with different values.  Also testing that evaluation of explicit predicates is ommited due to the lazy filter evaluation.  Signed-off-by: Jiri Olsa <jolsa@redhat.com> Link: http://lkml.kernel.org/r/1313072754-4620-11-git-send-email-jolsa@redhat.com Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
f | trace.h | s | 24K | 727 | Linus Torvalds | torvalds@linux-foundation.org | 1337884774 |  | Merge branch 'perf-uprobes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip  Pull user-space probe instrumentation from Ingo Molnar:  "The uprobes code originates from SystemTap and has been used for years   in Fedora and RHEL kernels.  This version is much rewritten, reviews   from PeterZ, Oleg and myself shaped the end result.    This tree includes uprobes support in 'perf probe' - but SystemTap   (and other tools) can take advantage of user probe points as well.    Sample usage of uprobes via perf, for example to profile malloc()   calls without modifying user-space binaries.    First boot a new kernel with CONFIG_UPROBE_EVENT=y enabled.    If you don't know which function you want to probe you can pick one   from 'perf top' or can get a list all functions that can be probed   within libc (binaries can be specified as well):  	$ perf probe -F -x /lib/libc.so.6    To probe libc's malloc():  	$ perf probe -x /lib64/libc.so.6 malloc 	Added new event: 	probe_libc:malloc    (on 0x7eac0)    You can now use it in all perf tools, such as:  	perf record -e probe_libc:malloc -aR sleep 1    Make use of it to create a call graph (as the flat profile is going to   look very boring):  	$ perf record -e probe_libc:malloc -gR make 	[ perf record: Woken up 173 times to write data ] 	[ perf record: Captured and wrote 44.190 MB perf.data (~1930712  	$ perf report || less  	  32.03%            git  libc-2.15.so   [.] malloc 	                    || 	                    --- malloc  	  29.49%            cc1  libc-2.15.so   [.] malloc 	                    || 	                    --- malloc 	                       || 	                       ||--0.95%-- 0x208eb1000000000 	                       || 	                       ||--0.63%-- htab_traverse_noresize  	  11.04%             as  libc-2.15.so   [.] malloc 	                     || 	                     --- malloc 	                        ||  	   7.15%             ld  libc-2.15.so   [.] malloc 	                     || 	                     --- malloc 	                        ||  	   5.07%             sh  libc-2.15.so   [.] malloc 	                     || 	                     --- malloc 	                        || 	   4.99%  python-config  libc-2.15.so   [.] malloc 	          || 	          --- malloc 	             || 	   4.54%           make  libc-2.15.so   [.] malloc 	                   || 	                   --- malloc 	                      || 	                      ||--7.34%-- glob 	                      ||          || 	                      ||          ||--93.18%-- 0x41588f 	                      ||          || 	                      ||           --6.82%-- glob 	                      ||                     0x41588f  	   ...    Or:  	$ perf report -g flat || less  	# Overhead        Command  Shared Object      Symbol 	# ........  .............  .............  .......... 	# 	  32.03%            git  libc-2.15.so   [.] malloc 	          27.19% 	              malloc  	  29.49%            cc1  libc-2.15.so   [.] malloc 	          24.77% 	              malloc  	  11.04%             as  libc-2.15.so   [.] malloc 	          11.02% 	              malloc  	   7.15%             ld  libc-2.15.so   [.] malloc 	           6.57% 	              malloc  	 ...    The core uprobes design is fairly straightforward: uprobes probe   points register themselves at (inode:offset) addresses of   libraries/binaries, after which all existing (or new) vmas that map   that address will have a software breakpoint injected at that address.   vmas are COW-ed to preserve original content.  The probe points are   kept in an rbtree.    If user-space executes the probed inode:offset instruction address   then an event is generated which can be recovered from the regular   perf event channels and mmap-ed ring-buffer.    Multiple probes at the same address are supported, they create a   dynamic callback list of event consumers.    The basic model is further complicated by the XOL speedup: the   original instruction that is probed is copied (in an architecture   specific fashion) and executed out of line when the probe triggers.   The XOL area is a single vma per process, with a fixed number of   entries (which limits probe execution parallelism).    The API: uprobes are installed/removed via   /sys/kernel/debug/tracing/uprobe_events, the API is integrated to   align with the kprobes interface as much as possible, but is separate   to it.    Injecting a probe point is privileged operation, which can be relaxed   by setting perf_paranoid to -1.    You can use multiple probes as well and mix them with kprobes and   regular PMU events or tracepoints, when instrumenting a task."  Fix up trivial conflicts in mm/memory.c due to previous cleanup of unmap_single_vma().  * 'perf-uprobes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (21 commits)   perf probe: Detect probe target when m/x options are absent   perf probe: Provide perf interface for uprobes   tracing: Fix kconfig warning due to a typo   tracing: Provide trace events interface for uprobes   tracing: Extract out common code for kprobes/uprobes trace events   tracing: Modify is_delete, is_return from int to bool   uprobes/core: Decrement uprobe count before the pages are unmapped   uprobes/core: Make background page replacement logic account for rss_stat counters   uprobes/core: Optimize probe hits with the help of a counter   uprobes/core: Allocate XOL slots for uprobes use   uprobes/core: Handle breakpoint and singlestep exceptions   uprobes/core: Rename bkpt to swbp   uprobes/core: Make order of function parameters consistent across functions   uprobes/core: Make macro names consistent   uprobes: Update copyright notices   uprobes/core: Move insn to arch specific structure   uprobes/core: Remove uprobe_opcode_sz   uprobes/core: Make instruction tables volatile   uprobes: Move to kernel/events/   uprobes/core: Clean up, refactor and improve the code   ...
f | trace_export.c | s | 5.3K | 166 | Steven Rostedt | srostedt@redhat.com | 1336679743 |  | tracing: Do not enable function event with enable  With the adding of function tracing event to perf, it caused a side effect that produces the following warning when enabling all events in ftrace:   # echo 1 > /sys/kernel/debug/tracing/events/enable  [console] event trace: Could not enable event function  This is because when enabling all events via the debugfs system it ignores events that do not have a ->reg() function assigned. This was to skip over the ftrace internal events (as they are not TRACE_EVENTs). But as the ftrace function event now has a ->reg() function attached to it for use with perf, it is no longer ignored.  Worse yet, this ->reg() function is being called when it should not be. It returns an error and causes the above warning to be printed.  By adding a new event_call flag (TRACE_EVENT_FL_IGNORE_ENABLE) and have all ftrace internel event structures have it set, setting the events/enable will no longe try to incorrectly enable the function event and does not warn.  Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
f | trace_sched_wakeup.c | s | 14K | 521 | Jiri Olsa | jolsa@redhat.com | 1320691715 |  | tracing/latency: Fix header output for latency tracers  In case the the graph tracer (CONFIG_FUNCTION_GRAPH_TRACER) or even the function tracer (CONFIG_FUNCTION_TRACER) are not set, the latency tracers do not display proper latency header.  The involved/fixed latency tracers are:         wakeup_rt         wakeup         preemptirqsoff         preemptoff         irqsoff  The patch adds proper handling of tracer configuration options for latency tracers, and displaying correct header info accordingly.  * The current output (for wakeup tracer) with both graph and function   tracers disabled is:    # tracer: wakeup   #     <idle>-0       0d.h5    1us+:      0:120:R   + [000]     7:  0:R watchdog/0     <idle>-0       0d.h5    3us+: ttwu_do_activate.clone.1 <-try_to_wake_up     ...  * The fixed output is:    # tracer: wakeup   #   # wakeup latency trace v1.1.5 on 3.1.0-tip+   # --------------------------------------------------------------------   # latency: 55 us, #4/4, CPU#0 || (M:preempt VP:0, KP:0, SP:0 HP:0 #P:2)   #    -----------------   #    || task: migration/0-6 (uid:0 nice:0 policy:1 rt_prio:99)   #    -----------------   #   #                  _------=> CPU#   #                 / _-----=> irqs-off   #                || / _----=> need-resched   #                |||| / _---=> hardirq/softirq   #                |||||| / _--=> preempt-depth   #                |||||||| /     delay   #  cmd     pid   |||||||||| time  ||   caller   #     \   /      ||||||||||  \    ||   /        cat-1129    0d..4    1us :   1129:120:R   + [000]     6:  0:R migration/0        cat-1129    0d..4    2us+: ttwu_do_activate.clone.1 <-try_to_wake_up  * The current output (for wakeup tracer) with only function   tracer enabled is:    # tracer: wakeup   #        cat-1140    0d..4    1us+:   1140:120:R   + [000]     6:  0:R migration/0        cat-1140    0d..4    2us : ttwu_do_activate.clone.1 <-try_to_wake_up  * The fixed output is:   # tracer: wakeup   #   # wakeup latency trace v1.1.5 on 3.1.0-tip+   # --------------------------------------------------------------------   # latency: 207 us, #109/109, CPU#1 || (M:preempt VP:0, KP:0, SP:0 HP:0 #P:2)   #    -----------------   #    || task: watchdog/1-12 (uid:0 nice:0 policy:1 rt_prio:99)   #    -----------------   #   #                  _------=> CPU#   #                 / _-----=> irqs-off   #                || / _----=> need-resched   #                |||| / _---=> hardirq/softirq   #                |||||| / _--=> preempt-depth   #                |||||||| /     delay   #  cmd     pid   |||||||||| time  ||   caller   #     \   /      ||||||||||  \    ||   /     <idle>-0       1d.h5    1us+:      0:120:R   + [001]    12:  0:R watchdog/1     <idle>-0       1d.h5    3us : ttwu_do_activate.clone.1 <-try_to_wake_up  Link: http://lkml.kernel.org/r/20111107150849.GE1807@m.brq.redhat.com  Cc: Frederic Weisbecker <fweisbec@gmail.com> Cc: Ingo Molnar <mingo@redhat.com> Signed-off-by: Jiri Olsa <jolsa@redhat.com> Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
f | trace_stat.c | s | 8.2K | 315 | Tejun Heo | tj@kernel.org | 1269954152 |  | include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h  percpu.h is included by sched.h and module.h and thus ends up being included when building most .c files.  percpu.h includes slab.h which in turn includes gfp.h making everything defined by the two files universally available and complicating inclusion dependencies.  percpu.h -> slab.h dependency is about to be removed.  Prepare for this change by updating users of gfp and slab facilities include those headers directly instead of assuming availability.  As this conversion needs to touch large number of source files, the following script is used as the basis of conversion.    http://userweb.kernel.org/~tj/misc/slabh-sweep.py  The script does the followings.  * Scan files for gfp and slab usages and update includes such that   only the necessary includes are there.  ie. if only gfp is used,   gfp.h, if slab is used, slab.h.  * When the script inserts a new include, it looks at the include   blocks and try to put the new include such that its order conforms   to its surrounding.  It's put in the include block which contains   core kernel includes, in the same order that the rest are ordered -   alphabetical, Christmas tree, rev-Xmas-tree or at the end if there   doesn't seem to be any matching order.  * If the script can't find a place to put a new include (mostly   because the file doesn't have fitting include block), it prints out   an error message indicating which .h file needs to be added to the   file.  The conversion was done in the following steps.  1. The initial automatic conversion of all .c files updated slightly    over 4000 files, deleting around 700 includes and adding ~480 gfp.h    and ~3000 slab.h inclusions.  The script emitted errors for ~400    files.  2. Each error was manually checked.  Some didn't need the inclusion,    some needed manual addition while adding it to implementation .h or    embedding .c file was more appropriate for others.  This step added    inclusions to around 150 files.  3. The script was run again and the output was compared to the edits    from #2 to make sure no file was left behind.  4. Several build tests were done and a couple of problems were fixed.    e.g. lib/decompress_*.c used malloc/free() wrappers around slab    APIs requiring slab.h to be added manually.  5. The script was run on all .h files but without automatically    editing them as sprinkling gfp.h and slab.h inclusions around .h    files could easily lead to inclusion dependency hell.  Most gfp.h    inclusion directives were ignored as stuff from gfp.h was usually    wildly available and often used in preprocessor macros.  Each    slab.h inclusion directive was examined and added manually as    necessary.  6. percpu.h was updated not to include slab.h.  7. Build test were done on the following configurations and failures    were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my    distributed build env didn't work with gcov compiles) and a few    more options had to be turned off depending on archs to make things    build (like ipr on powerpc/64 which failed due to missing writeq).     * x86 and x86_64 UP and SMP allmodconfig and a custom test config.    * powerpc and powerpc64 SMP allmodconfig    * sparc and sparc64 SMP allmodconfig    * ia64 SMP allmodconfig    * s390 SMP allmodconfig    * alpha SMP allmodconfig    * um on x86_64 SMP allmodconfig  8. percpu.h modifications were reverted so that it could be applied as    a separate patch and serve as bisection point.  Given the fact that I had only a couple of failures from tests on step 6, I'm fairly confident about the coverage of this conversion patch. If there is a breakage, it's likely to be something in one of the arch headers which should be easily discoverable easily on most builds of the specific arch.  Signed-off-by: Tejun Heo <tj@kernel.org> Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org> Cc: Ingo Molnar <mingo@redhat.com> Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>
f | trace_entries.h | s | 7.2K | 241 | Ingo Molnar | mingo@kernel.org | 1332573549 |  | Merge branch 'tip/perf/urgent' of git://git.kernel.org/pub/scm/linux/kernel/git/rostedt/linux-trace into perf/urgent
f | trace_event_perf.c | s | 7.8K | 271 | Jiri Olsa | jolsa@redhat.com | 1329840510 |  | ftrace, perf: Add filter support for function trace event  Adding support to filter function trace event via perf interface. It is now possible to use filter interface in the perf tool like:    perf record -e ftrace:function --filter="(ip == mm_*)" ls  The filter syntax is restricted to the the 'ip' field only, and following operators are accepted '==' '!=' '||||', ending up with the filter strings like:    ip == f1[, ]f2 ... |||| ip != f3[, ]f4 ...  with comma ',' or space ' ' as a function separator. If the space ' ' is used as a separator, the right side of the assignment needs to be enclosed in double quotes '"', e.g.:    perf record -e ftrace:function --filter '(ip == do_execve,sys_*,ext*)' ls   perf record -e ftrace:function --filter '(ip == "do_execve,sys_*,ext*")' ls   perf record -e ftrace:function --filter '(ip == "do_execve sys_* ext*")' ls  The '==' operator adds trace filter with same effect as would be added via set_ftrace_filter file.  The '!=' operator adds trace filter with same effect as would be added via set_ftrace_notrace file.  The right side of the '!=', '==' operators is list of functions or regexp. to be added to filter separated by space.  The '||||' operator is used for connecting multiple filter definitions together. It is possible to have more than one '==' and '!=' operators within one filter string.  Link: http://lkml.kernel.org/r/1329317514-8131-8-git-send-email-jolsa@redhat.com  Signed-off-by: Jiri Olsa <jolsa@redhat.com> Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
f | blktrace.c | s | 41K | 1513 | Stephen Boyd | sboyd@codeaurora.org | 1333664750 |  | simple_open: automatically convert to simple_open()  Many users of debugfs copy the implementation of default_open() when they want to support a custom read/write function op.  This leads to a proliferation of the default_open() implementation across the entire tree.  Now that the common implementation has been consolidated into libfs we can replace all the users of this function with simple_open().  This replacement was done with the following semantic patch:  <smpl> @ open @ identifier open_f != simple_open; identifier i, f; @@ -int open_f(struct inode *i, struct file *f) -{ ( -if (i->i_private) -f->private_data = i->i_private; || -f->private_data = i->i_private; ) -return 0; -}  @ has_open depends on open @ identifier fops; identifier open.open_f; @@ struct file_operations fops = { ... -.open = open_f, +.open = simple_open, ... }; </smpl>  [akpm@linux-foundation.org: checkpatch fixes] Signed-off-by: Stephen Boyd <sboyd@codeaurora.org> Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org> Cc: Al Viro <viro@zeniv.linux.org.uk> Cc: Julia Lawall <Julia.Lawall@lip6.fr> Acked-by: Ingo Molnar <mingo@elte.hu> Signed-off-by: Andrew Morton <akpm@linux-foundation.org> Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
f | trace_branch.c | s | 9.1K | 337 | Steven Rostedt | srostedt@redhat.com | 1273861232 |  | tracing: Allow events to share their print functions  Multiple events may use the same method to print their data. Instead of having all events have a pointer to their print funtions, the trace_event structure now points to a trace_event_functions structure that will hold the way to print ouf the event.  The event itself is now passed to the print function to let the print function know what kind of event it should print.  This opens the door to consolidating the way several events print their output.     text	   data	    bss	    dec	    hex	filename 4913961	1088356	 861512	6863829	 68bbd5	vmlinux.orig 4900382	1048964	 861512	6810858	 67ecea	vmlinux.init 4900446	1049028	 861512	6810986	 67ed6a	vmlinux.preprint  This change slightly increases the size but is needed for the next change.  v3: Fix the branch tracer events to handle this change.  v2: Fix the new function graph tracer event calls to handle this change.  Acked-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com> Acked-by: Masami Hiramatsu <mhiramat@redhat.com> Acked-by: Frederic Weisbecker <fweisbec@gmail.com> Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
f | ring_buffer.c | s | 112K | 3684 | Steven Rostedt | srostedt@redhat.com | 1337801717 |  | ring-buffer: Check for valid buffer before changing size  On some machines the number of possible CPUS is not the same as the number of CPUs that is on the machine. Ftrace uses possible_cpus to update the tracing structures but the ring buffer only allocates per cpu buffers for online CPUs when they come up.  When the wakeup tracer was enabled in such a case, the ftrace code enabled all possible cpu buffers, but the code in ring_buffer_resize() did not check to see if the buffer in question was allocated. Since boot up CPUs did not match possible CPUs it caused the following crash:  BUG: unable to handle kernel NULL pointer dereference at 00000020 IP: [<c1097851>] ring_buffer_resize+0x16a/0x28d *pde = 00000000 Oops: 0000 [#1] PREEMPT SMP Dumping ftrace buffer:    (ftrace buffer empty) Modules linked in: [last unloaded: scsi_wait_scan]  Pid: 1387, comm: bash Not tainted 3.4.0-test+ #13                  /DG965MQ EIP: 0060:[<c1097851>] EFLAGS: 00010217 CPU: 0 EIP is at ring_buffer_resize+0x16a/0x28d EAX: f5a14340 EBX: f6026b80 ECX: 00000ff4 EDX: 00000ff3 ESI: 00000000 EDI: 00000002 EBP: f4275ecc ESP: f4275eb0  DS: 007b ES: 007b FS: 00d8 GS: 00e0 SS: 0068 CR0: 80050033 CR2: 00000020 CR3: 34396000 CR4: 000007d0 DR0: 00000000 DR1: 00000000 DR2: 00000000 DR3: 00000000 DR6: ffff0ff0 DR7: 00000400 Process bash (pid: 1387, ti=f4274000 task=f4380cb0 task.ti=f4274000) Stack:  c109cf9a f6026b98 00000162 00160f68 00000006 00160f68 00000002 f4275ef0  c109d013 f4275ee8 c123b72a c1c0bf00 c1cc81dc 00000005 f4275f98 00000007  f4275f70 c109d0c7 7700000e 75656b61 00000070 f5e90900 f5c4e198 00000301 Call Trace:  [<c109cf9a>] ? tracing_set_tracer+0x115/0x1e9  [<c109d013>] tracing_set_tracer+0x18e/0x1e9  [<c123b72a>] ? _copy_from_user+0x30/0x46  [<c109d0c7>] tracing_set_trace_write+0x59/0x7f  [<c10ec01e>] ? fput+0x18/0x1c6  [<c11f8732>] ? security_file_permission+0x27/0x2b  [<c10eaacd>] ? rw_verify_area+0xcf/0xf2  [<c10ec01e>] ? fput+0x18/0x1c6  [<c109d06e>] ? tracing_set_tracer+0x1e9/0x1e9  [<c10ead77>] vfs_write+0x8b/0xe3  [<c10ebead>] ? fget_light+0x30/0x81  [<c10eaf54>] sys_write+0x42/0x63  [<c1834fbf>] sysenter_do_call+0x12/0x28  This happens with the latency tracer as the ftrace code updates the saved max buffer via its cpumask and not with a global setting.  Adding a check in ring_buffer_resize() to make sure the buffer being resized exists, fixes the problem.  Cc: Vaibhav Nagarnaik <vnagarnaik@google.com> Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
f | trace_events_filter.c | s | 50K | 1942 | Jiri Olsa | jolsa@redhat.com | 1329840510 |  | ftrace, perf: Add filter support for function trace event  Adding support to filter function trace event via perf interface. It is now possible to use filter interface in the perf tool like:    perf record -e ftrace:function --filter="(ip == mm_*)" ls  The filter syntax is restricted to the the 'ip' field only, and following operators are accepted '==' '!=' '||||', ending up with the filter strings like:    ip == f1[, ]f2 ... |||| ip != f3[, ]f4 ...  with comma ',' or space ' ' as a function separator. If the space ' ' is used as a separator, the right side of the assignment needs to be enclosed in double quotes '"', e.g.:    perf record -e ftrace:function --filter '(ip == do_execve,sys_*,ext*)' ls   perf record -e ftrace:function --filter '(ip == "do_execve,sys_*,ext*")' ls   perf record -e ftrace:function --filter '(ip == "do_execve sys_* ext*")' ls  The '==' operator adds trace filter with same effect as would be added via set_ftrace_filter file.  The '!=' operator adds trace filter with same effect as would be added via set_ftrace_notrace file.  The right side of the '!=', '==' operators is list of functions or regexp. to be added to filter separated by space.  The '||||' operator is used for connecting multiple filter definitions together. It is possible to have more than one '==' and '!=' operators within one filter string.  Link: http://lkml.kernel.org/r/1329317514-8131-8-git-send-email-jolsa@redhat.com  Signed-off-by: Jiri Olsa <jolsa@redhat.com> Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
f | trace_clock.c | s | 3.0K | 108 | Steven Rostedt | srostedt@redhat.com | 1316446558 |  | tracing: Add a counter clock for those that do not trust clocks  When debugging tight race conditions, it can be helpful to have a synchronized tracing method. Although in most cases the global clock provides this functionality, if timings is not the issue, it is more comforting to know that the order of events really happened in a precise order.  Instead of using a clock, add a "counter" that is simply an incrementing atomic 64bit counter that orders the events as they are perceived to happen.  The trace_clock_counter() is added from the attempt by Peter Zijlstra trying to convert the trace_clock_global() to it. I took Peter's counter code and made trace_clock_counter() instead, and added it to the choice of clocks. Just echo counter > /debug/tracing/trace_clock to activate it.  Requested-by: Thomas Gleixner <tglx@linutronix.de> Requested-by: Peter Zijlstra <a.p.zijlstra@chello.nl> Reviewed-By: Valdis Kletnieks <valdis.kletnieks@vt.edu> Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
f | trace_selftest.c | s | 20K | 764 | Steven Rostedt | srostedt@redhat.com | 1305761091 |  | ftrace: Add self-tests for multiple function trace users  Add some basic sanity tests for multiple users of the function tracer at startup.  Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
f | trace_stack.c | s | 8.3K | 304 | Steven Rostedt | srostedt@redhat.com | 1324470409 |  | tracing: Have stack tracing set filtered functions at boot  Add stacktrace_filter= to the kernel command line that lets the user pick specific functions to check the stack on.  Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
f | trace_functions_graph.c | s | 34K | 1232 | Steven Rostedt | srostedt@redhat.com | 1310091987 |  | tracing: Still trace filtered irq functions when irq trace is disabled  If a function is set to be traced by the set_graph_function, but the option funcgraph-irqs is zero, and the traced function happens to be called from a interrupt, it will not be traced.  The point of funcgraph-irqs is to not trace interrupts when we are preempted by an irq, not to not trace functions we want to trace that happen to be *in* a irq.  Luckily the current->trace_recursion element is perfect to add a flag to help us be able to trace functions within an interrupt even when we are not tracing interrupts that preempt the trace.  Reported-by: Heiko Carstens <heiko.carstens@de.ibm.com> Tested-by: Heiko Carstens <heiko.carstens@de.ibm.com> Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
f | trace_functions.c | s | 8.2K | 327 | Steven Rostedt | srostedt@redhat.com | 1310052608 |  | ftrace: Fix regression of :mod:module function enabling  The new code that allows different utilities to pick and choose what functions they trace broke the :mod: hook that allows users to trace only functions of a particular module.  The reason is that the :mod: hook bypasses the hash that is setup to allow individual users to trace their own functions and uses the global hash directly. But if the global hash has not been set up, it will cause a bug:  echo '*:mod:radeon' > /sys/kernel/debug/set_ftrace_filter  produces:   [drm:drm_mode_getfb] *ERROR* invalid framebuffer id  [drm:radeon_crtc_page_flip] *ERROR* failed to reserve new rbo buffer before flip  BUG: unable to handle kernel paging request at ffffffff8160ec90  IP: [<ffffffff810d9136>] add_hash_entry+0x66/0xd0  PGD 1a05067 PUD 1a09063 PMD 80000000016001e1  Oops: 0003 [#1] SMP Jul  7 04:02:28 phyllis kernel: [55303.858604] CPU 1  Modules linked in: cryptd aes_x86_64 aes_generic binfmt_misc rfcomm bnep ip6table_filter hid radeon r8169 ahci libahci mii ttm drm_kms_helper drm video i2c_algo_bit intel_agp intel_gtt   Pid: 10344, comm: bash Tainted: G        WC  3.0.0-rc5 #1 Dell Inc. Inspiron N5010/0YXXJJ  RIP: 0010:[<ffffffff810d9136>]  [<ffffffff810d9136>] add_hash_entry+0x66/0xd0  RSP: 0018:ffff88003a96bda8  EFLAGS: 00010246  RAX: ffff8801301735c0 RBX: ffffffff8160ec80 RCX: 0000000000306ee0  RDX: 0000000000000000 RSI: 0000000000000000 RDI: ffff880137c92940  RBP: ffff88003a96bdb8 R08: ffff880137c95680 R09: 0000000000000000  R10: 0000000000000001 R11: 0000000000000000 R12: ffffffff81c9df78  R13: ffff8801153d1000 R14: 0000000000000000 R15: 0000000000000000  FS: 00007f329c18a700(0000) GS:ffff880137c80000(0000) knlGS:0000000000000000  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033  CR2: ffffffff8160ec90 CR3: 000000003002b000 CR4: 00000000000006e0  DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000  DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400  Process bash (pid: 10344, threadinfo ffff88003a96a000, task ffff88012fcfc470)  Stack:   0000000000000fd0 00000000000000fc ffff88003a96be38 ffffffff810d92f5   ffff88011c4c4e00 ffff880000000000 000000000b69f4d0 ffffffff8160ec80   ffff8800300e6f06 0000000081130295 0000000000000282 ffff8800300e6f00  Call Trace:   [<ffffffff810d92f5>] match_records+0x155/0x1b0   [<ffffffff810d940c>] ftrace_mod_callback+0xbc/0x100   [<ffffffff810dafdf>] ftrace_regex_write+0x16f/0x210   [<ffffffff810db09f>] ftrace_filter_write+0xf/0x20   [<ffffffff81166e48>] vfs_write+0xc8/0x190   [<ffffffff81167001>] sys_write+0x51/0x90   [<ffffffff815c7e02>] system_call_fastpath+0x16/0x1b  Code: 48 8b 33 31 d2 48 85 f6 75 33 49 89 d4 4c 03 63 08 49 8b 14 24 48 85 d2 48 89 10 74 04 48 89 42 08 49 89 04 24 4c 89 60 08 31 d2  RIP [<ffffffff810d9136>] add_hash_entry+0x66/0xd0   RSP <ffff88003a96bda8>  CR2: ffffffff8160ec90  ---[ end trace a5d031828efdd88e ]---  Reported-by: Brian Marete <marete@toshnix.com> Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
f | trace_stat.h | s | 973B | 29 | Lai Jiangshan | laijs@cn.fujitsu.com | 1247220845 |  | tracing/stat: Add stat_release() callback  Add stat_release() callback to struct tracer_stat, so a stat tracer can release it's entries after the stat file has been read out.  Signed-off-by: Lai Jiangshan <laijs@cn.fujitsu.com> Signed-off-by: Li Zefan <lizf@cn.fujitsu.com> Cc: Lai Jiangshan <laijs@cn.fujitsu.com> Cc: Steven Rostedt <rostedt@goodmis.org> Cc: Frederic Weisbecker <fweisbec@gmail.com> LKML-Reference: <4A51B16A.6020708@cn.fujitsu.com> Signed-off-by: Ingo Molnar <mingo@elte.hu>
f | trace_probe.c | s | 20K | 707 | Srikar Dronamraju | srikar@linux.vnet.ibm.com | 1336393817 |  | tracing: Provide trace events interface for uprobes  Implements trace_event support for uprobes. In its current form it can be used to put probes at a specified offset in a file and dump the required registers when the code flow reaches the probed address.  The following example shows how to dump the instruction pointer and %ax a register at the probed text address.  Here we are trying to probe zfree in /bin/zsh:   # cd /sys/kernel/debug/tracing/  # cat /proc/`pgrep  zsh`/maps || grep /bin/zsh || grep r-xp  00400000-0048a000 r-xp 00000000 08:03 130904 /bin/zsh  # objdump -T /bin/zsh || grep -w zfree  0000000000446420 g    DF .text  0000000000000012  Base  zfree # echo 'p /bin/zsh:0x46420 %ip %ax' > uprobe_events  # cat uprobe_events  p:uprobes/p_zsh_0x46420 /bin/zsh:0x0000000000046420  # echo 1 > events/uprobes/enable  # sleep 20  # echo 0 > events/uprobes/enable  # cat trace  # tracer: nop  #  #           TASK-PID    CPU#    TIMESTAMP  FUNCTION  #              || ||       ||          ||         ||               zsh-24842 [006] 258544.995456: p_zsh_0x46420: (0x446420) arg1=446421 arg2=79               zsh-24842 [007] 258545.000270: p_zsh_0x46420: (0x446420) arg1=446421 arg2=79               zsh-24842 [002] 258545.043929: p_zsh_0x46420: (0x446420) arg1=446421 arg2=79               zsh-24842 [004] 258547.046129: p_zsh_0x46420: (0x446420) arg1=446421 arg2=79  Signed-off-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com> Acked-by: Steven Rostedt <rostedt@goodmis.org> Acked-by: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com> Cc: Linus Torvalds <torvalds@linux-foundation.org> Cc: Ananth N Mavinakayanahalli <ananth@in.ibm.com> Cc: Jim Keniston <jkenisto@linux.vnet.ibm.com> Cc: Linux-mm <linux-mm@kvack.org> Cc: Oleg Nesterov <oleg@redhat.com> Cc: Andi Kleen <andi@firstfloor.org> Cc: Christoph Hellwig <hch@infradead.org> Cc: Arnaldo Carvalho de Melo <acme@infradead.org> Cc: Anton Arapov <anton@redhat.com> Cc: Peter Zijlstra <peterz@infradead.org> Link: http://lkml.kernel.org/r/20120411103043.GB29437@linux.vnet.ibm.com Signed-off-by: Ingo Molnar <mingo@kernel.org>
f | trace_output.c | s | 27K | 1051 | Steven Rostedt | srostedt@redhat.com | 1334869213 |  | tracing: Fix stacktrace of latency tracers (irqsoff and friends)  While debugging a latency with someone on IRC (mirage335) on #linux-rt (OFTC), we discovered that the stacktrace output of the latency tracers (preemptirqsoff) was empty.  This bug was caused by the creation of the dynamic length stack trace again (like commit 12b5da3 "tracing: Fix ent_size in trace output" was).  This bug is caused by the latency tracers requiring the next event to determine the time between the current event and the next. But by grabbing the next event, the iter->ent_size is set to the next event instead of the current one. As the stacktrace event is the last event, this makes the ent_size zero and causes nothing to be printed for the stack trace. The dynamic stacktrace uses the ent_size to determine how much of the stack can be printed. The ent_size of zero means no stack.  The simple fix is to save the iter->ent_size before finding the next event.  Note, mirage335 asked to remain anonymous from LKML and git, so I will not add the Reported-by and Tested-by tags, even though he did report the issue and tested the fix.  Cc: stable@vger.kernel.org # 3.1+ Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
f | trace_printk.c | s | 7.6K | 291 | Steven Rostedt | srostedt@redhat.com | 1335230155 |  | tracing: Add percpu buffers for trace_printk()  Currently, trace_printk() uses a single buffer to write into to calculate the size and format needed to save the trace. To do this safely in an SMP environment, a spin_lock() is taken to only allow one writer at a time to the buffer. But this could also affect what is being traced, and add synchronization that would not be there otherwise.  Ideally, using percpu buffers would be useful, but since trace_printk() is only used in development, having per cpu buffers for something never used is a waste of space. Thus, the use of the trace_bprintk() format section is changed to be used for static fmts as well as dynamic ones. Then at boot up, we can check if the section that holds the trace_printk formats is non-empty, and if it does contain something, then we know a trace_printk() has been added to the kernel. At this time the trace_printk per cpu buffers are allocated. A check is also done at module load time in case a module is added that contains a trace_printk().  Once the buffers are allocated, they are never freed. If you use a trace_printk() then you should know what you are doing.  A buffer is made for each type of context:    normal   softirq   irq   nmi  The context is checked and the appropriate buffer is used. This allows for totally lockless usage of trace_printk(), and they no longer even disable interrupts.  Requested-by: Peter Zijlstra <a.p.zijlstra@chello.nl> Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
f | trace_nop.c | s | 2.2K | 85 | Frederic Weisbecker | fweisbec@gmail.com | 1237796535 |  | tracing/ftrace: make nop-tracer use polling wait for events on pipe  Impact: display events when they arrive  Now that the events don't use wake_up() anymore, we need the nop tracer to poll waiting for events on the pipe. Especially because nop is useful to look at orphan traces types (traces types that don't rely on specific tracers) because it doesn't produce traces itself.  And unlike other tracers that trigger specific traces periodically, nop triggers no traces by itself that can wake him.  Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com> Cc: Steven Rostedt <rostedt@goodmis.org> LKML-Reference: <1237759847-21025-5-git-send-email-fweisbec@gmail.com> Signed-off-by: Ingo Molnar <mingo@elte.hu>
f | trace_probe.h | s | 4.6K | 138 | Srikar Dronamraju | srikar@linux.vnet.ibm.com | 1336393817 |  | tracing: Provide trace events interface for uprobes  Implements trace_event support for uprobes. In its current form it can be used to put probes at a specified offset in a file and dump the required registers when the code flow reaches the probed address.  The following example shows how to dump the instruction pointer and %ax a register at the probed text address.  Here we are trying to probe zfree in /bin/zsh:   # cd /sys/kernel/debug/tracing/  # cat /proc/`pgrep  zsh`/maps || grep /bin/zsh || grep r-xp  00400000-0048a000 r-xp 00000000 08:03 130904 /bin/zsh  # objdump -T /bin/zsh || grep -w zfree  0000000000446420 g    DF .text  0000000000000012  Base  zfree # echo 'p /bin/zsh:0x46420 %ip %ax' > uprobe_events  # cat uprobe_events  p:uprobes/p_zsh_0x46420 /bin/zsh:0x0000000000046420  # echo 1 > events/uprobes/enable  # sleep 20  # echo 0 > events/uprobes/enable  # cat trace  # tracer: nop  #  #           TASK-PID    CPU#    TIMESTAMP  FUNCTION  #              || ||       ||          ||         ||               zsh-24842 [006] 258544.995456: p_zsh_0x46420: (0x446420) arg1=446421 arg2=79               zsh-24842 [007] 258545.000270: p_zsh_0x46420: (0x446420) arg1=446421 arg2=79               zsh-24842 [002] 258545.043929: p_zsh_0x46420: (0x446420) arg1=446421 arg2=79               zsh-24842 [004] 258547.046129: p_zsh_0x46420: (0x446420) arg1=446421 arg2=79  Signed-off-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com> Acked-by: Steven Rostedt <rostedt@goodmis.org> Acked-by: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com> Cc: Linus Torvalds <torvalds@linux-foundation.org> Cc: Ananth N Mavinakayanahalli <ananth@in.ibm.com> Cc: Jim Keniston <jkenisto@linux.vnet.ibm.com> Cc: Linux-mm <linux-mm@kvack.org> Cc: Oleg Nesterov <oleg@redhat.com> Cc: Andi Kleen <andi@firstfloor.org> Cc: Christoph Hellwig <hch@infradead.org> Cc: Arnaldo Carvalho de Melo <acme@infradead.org> Cc: Anton Arapov <anton@redhat.com> Cc: Peter Zijlstra <peterz@infradead.org> Link: http://lkml.kernel.org/r/20120411103043.GB29437@linux.vnet.ibm.com Signed-off-by: Ingo Molnar <mingo@kernel.org>
f | trace_irqsoff.c | s | 15K | 570 | Ingo Molnar | mingo@elte.hu | 1320995977 |  | Merge branch 'tip/perf/core' of git://git.kernel.org/pub/scm/linux/kernel/git/rostedt/linux-trace into perf/core
f | trace_kdb.c | s | 3.0K | 113 | Jason Wessel | jason.wessel@windriver.com | 1287779651 |  | kdb,ftdump: Remove reference to internal kdb include  Now that include/linux/kdb.h properly exports all the functions required to dynamically add a kdb shell command, the reference to the private kdb header can be removed.  Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
f | trace_mmiotrace.c | s | 9.0K | 323 | Arun Sharma | asharma@fb.com | 1311724187 |  | atomic: use <linux/atomic.h>  This allows us to move duplicated code in <asm/atomic.h> (atomic_inc_not_zero() for now) to <linux/atomic.h>  Signed-off-by: Arun Sharma <asharma@fb.com> Reviewed-by: Eric Dumazet <eric.dumazet@gmail.com> Cc: Ingo Molnar <mingo@elte.hu> Cc: David Miller <davem@davemloft.net> Cc: Eric Dumazet <eric.dumazet@gmail.com> Acked-by: Mike Frysinger <vapier@gentoo.org> Signed-off-by: Andrew Morton <akpm@linux-foundation.org> Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
f | Kconfig | g | 15K |  | Linus Torvalds | torvalds@linux-foundation.org | 1337884774 |  | Merge branch 'perf-uprobes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip  Pull user-space probe instrumentation from Ingo Molnar:  "The uprobes code originates from SystemTap and has been used for years   in Fedora and RHEL kernels.  This version is much rewritten, reviews   from PeterZ, Oleg and myself shaped the end result.    This tree includes uprobes support in 'perf probe' - but SystemTap   (and other tools) can take advantage of user probe points as well.    Sample usage of uprobes via perf, for example to profile malloc()   calls without modifying user-space binaries.    First boot a new kernel with CONFIG_UPROBE_EVENT=y enabled.    If you don't know which function you want to probe you can pick one   from 'perf top' or can get a list all functions that can be probed   within libc (binaries can be specified as well):  	$ perf probe -F -x /lib/libc.so.6    To probe libc's malloc():  	$ perf probe -x /lib64/libc.so.6 malloc 	Added new event: 	probe_libc:malloc    (on 0x7eac0)    You can now use it in all perf tools, such as:  	perf record -e probe_libc:malloc -aR sleep 1    Make use of it to create a call graph (as the flat profile is going to   look very boring):  	$ perf record -e probe_libc:malloc -gR make 	[ perf record: Woken up 173 times to write data ] 	[ perf record: Captured and wrote 44.190 MB perf.data (~1930712  	$ perf report || less  	  32.03%            git  libc-2.15.so   [.] malloc 	                    || 	                    --- malloc  	  29.49%            cc1  libc-2.15.so   [.] malloc 	                    || 	                    --- malloc 	                       || 	                       ||--0.95%-- 0x208eb1000000000 	                       || 	                       ||--0.63%-- htab_traverse_noresize  	  11.04%             as  libc-2.15.so   [.] malloc 	                     || 	                     --- malloc 	                        ||  	   7.15%             ld  libc-2.15.so   [.] malloc 	                     || 	                     --- malloc 	                        ||  	   5.07%             sh  libc-2.15.so   [.] malloc 	                     || 	                     --- malloc 	                        || 	   4.99%  python-config  libc-2.15.so   [.] malloc 	          || 	          --- malloc 	             || 	   4.54%           make  libc-2.15.so   [.] malloc 	                   || 	                   --- malloc 	                      || 	                      ||--7.34%-- glob 	                      ||          || 	                      ||          ||--93.18%-- 0x41588f 	                      ||          || 	                      ||           --6.82%-- glob 	                      ||                     0x41588f  	   ...    Or:  	$ perf report -g flat || less  	# Overhead        Command  Shared Object      Symbol 	# ........  .............  .............  .......... 	# 	  32.03%            git  libc-2.15.so   [.] malloc 	          27.19% 	              malloc  	  29.49%            cc1  libc-2.15.so   [.] malloc 	          24.77% 	              malloc  	  11.04%             as  libc-2.15.so   [.] malloc 	          11.02% 	              malloc  	   7.15%             ld  libc-2.15.so   [.] malloc 	           6.57% 	              malloc  	 ...    The core uprobes design is fairly straightforward: uprobes probe   points register themselves at (inode:offset) addresses of   libraries/binaries, after which all existing (or new) vmas that map   that address will have a software breakpoint injected at that address.   vmas are COW-ed to preserve original content.  The probe points are   kept in an rbtree.    If user-space executes the probed inode:offset instruction address   then an event is generated which can be recovered from the regular   perf event channels and mmap-ed ring-buffer.    Multiple probes at the same address are supported, they create a   dynamic callback list of event consumers.    The basic model is further complicated by the XOL speedup: the   original instruction that is probed is copied (in an architecture   specific fashion) and executed out of line when the probe triggers.   The XOL area is a single vma per process, with a fixed number of   entries (which limits probe execution parallelism).    The API: uprobes are installed/removed via   /sys/kernel/debug/tracing/uprobe_events, the API is integrated to   align with the kprobes interface as much as possible, but is separate   to it.    Injecting a probe point is privileged operation, which can be relaxed   by setting perf_paranoid to -1.    You can use multiple probes as well and mix them with kprobes and   regular PMU events or tracepoints, when instrumenting a task."  Fix up trivial conflicts in mm/memory.c due to previous cleanup of unmap_single_vma().  * 'perf-uprobes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (21 commits)   perf probe: Detect probe target when m/x options are absent   perf probe: Provide perf interface for uprobes   tracing: Fix kconfig warning due to a typo   tracing: Provide trace events interface for uprobes   tracing: Extract out common code for kprobes/uprobes trace events   tracing: Modify is_delete, is_return from int to bool   uprobes/core: Decrement uprobe count before the pages are unmapped   uprobes/core: Make background page replacement logic account for rss_stat counters   uprobes/core: Optimize probe hits with the help of a counter   uprobes/core: Allocate XOL slots for uprobes use   uprobes/core: Handle breakpoint and singlestep exceptions   uprobes/core: Rename bkpt to swbp   uprobes/core: Make order of function parameters consistent across functions   uprobes/core: Make macro names consistent   uprobes: Update copyright notices   uprobes/core: Move insn to arch specific structure   uprobes/core: Remove uprobe_opcode_sz   uprobes/core: Make instruction tables volatile   uprobes: Move to kernel/events/   uprobes/core: Clean up, refactor and improve the code   ...
f | trace_events.c | s | 37K | 1408 | Steven Rostedt | srostedt@redhat.com | 1336679743 |  | tracing: Do not enable function event with enable  With the adding of function tracing event to perf, it caused a side effect that produces the following warning when enabling all events in ftrace:   # echo 1 > /sys/kernel/debug/tracing/events/enable  [console] event trace: Could not enable event function  This is because when enabling all events via the debugfs system it ignores events that do not have a ->reg() function assigned. This was to skip over the ftrace internal events (as they are not TRACE_EVENTs). But as the ftrace function event now has a ->reg() function attached to it for use with perf, it is no longer ignored.  Worse yet, this ->reg() function is being called when it should not be. It returns an error and causes the above warning to be printed.  By adding a new event_call flag (TRACE_EVENT_FL_IGNORE_ENABLE) and have all ftrace internel event structures have it set, setting the events/enable will no longe try to incorrectly enable the function event and does not warn.  Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
f | power-traces.c | s | 418B | 16 | Thomas Renninger | trenn@suse.de | 1294125414 |  | perf: Clean up power events by introducing new, more generic ones  Add these new power trace events:   power:cpu_idle  power:cpu_frequency  power:machine_suspend  The old C-state/idle accounting events:   power:power_start   power:power_end  Have now a replacement (but we are still keeping the old tracepoints for compatibility):    power:cpu_idle  and   power:power_frequency  is replaced with:   power:cpu_frequency  power:machine_suspend is newly introduced.  Jean Pihet has a patch integrated into the generic layer (kernel/power/suspend.c) which will make use of it.  the type= field got removed from both, it was never used and the type is differed by the event type itself.  perf timechart userspace tool gets adjusted in a separate patch.  Signed-off-by: Thomas Renninger <trenn@suse.de> Signed-off-by: Ingo Molnar <mingo@elte.hu> Acked-by: Arjan van de Ven <arjan@linux.intel.com> Acked-by: Jean Pihet <jean.pihet@newoldbits.com> Cc: Arnaldo Carvalho de Melo <acme@redhat.com> Cc: Peter Zijlstra <a.p.zijlstra@chello.nl> Cc: Linus Torvalds <torvalds@linux-foundation.org> Cc: rjw@sisk.pl LKML-Reference: <1294073445-14812-3-git-send-email-trenn@suse.de> Signed-off-by: Ingo Molnar <mingo@elte.hu> LKML-Reference: <1290072314-31155-2-git-send-email-trenn@suse.de>
f | trace_selftest_dynamic.c | s | 168B | 11 | Steven Rostedt | srostedt@redhat.com | 1305761091 |  | ftrace: Add self-tests for multiple function trace users  Add some basic sanity tests for multiple users of the function tracer at startup.  Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
f | trace.c | s | 117K | 4195 | Linus Torvalds | torvalds@linux-foundation.org | 1341355510 |  | Merge branch 'for-linus' of git://git.kernel.dk/linux-block  Pull block bits from Jens Axboe:  "As vacation is coming up, thought I'd better get rid of my pending   changes in my for-linus branch for this iteration.  It contains:     - Two patches for mtip32xx.  Killing a non-compliant sysfs interface      and moving it to debugfs, where it belongs.     - A few patches from Asias.  Two legit bug fixes, and one killing an      interface that is no longer in use.     - A patch from Jan, making the annoying partition ioctl warning a bit      less annoying, by restricting it to !CAP_SYS_RAWIO only.     - Three bug fixes for drbd from Lars Ellenberg.     - A fix for an old regression for umem, it hasn't really worked since      the plugging scheme was changed in 3.0.     - A few fixes from Tejun.     - A splice fix from Eric Dumazet, fixing an issue with pipe      resizing."  * 'for-linus' of git://git.kernel.dk/linux-block:   scsi: Silence unnecessary warnings about ioctl to partition   block: Drop dead function blk_abort_queue()   block: Mitigate lock unbalance caused by lock switching   block: Avoid missed wakeup in request waitqueue   umem: fix up unplugging   splice: fix racy pipe->buffers uses   drbd: fix null pointer dereference with on-congestion policy when diskless   drbd: fix list corruption by failing but already aborted reads   drbd: fix access of unallocated pages and kernel panic   xen/blkfront: Add WARN to deal with misbehaving backends.   blkcg: drop local variable @q from blkg_destroy()   mtip32xx: Create debugfs entries for troubleshooting   mtip32xx: Remove 'registers' and 'flags' from sysfs   blkcg: fix blkg_alloc() failure path   block: blkcg_policy_cfq shouldn't be used if !CONFIG_CFQ_GROUP_IOSCHED   block: fix return value on cfq_init() failure   mtip32xx: Remove version.h header file inclusion   xen/blkback: Copy id field when doing BLKIF_DISCARD.
f | ring_buffer_benchmark.c | s | 10K | 405 | Vaibhav Nagarnaik | vnagarnaik@google.com | 1308103479 |  | tracing: Use NUMA allocation for per-cpu ring buffer pages  The tracing ring buffer is a group of per-cpu ring buffers where allocation and logging is done on a per-cpu basis. The events that are generated on a particular CPU are logged in the corresponding buffer. This is to provide wait-free writes between CPUs and good NUMA node locality while accessing the ring buffer.  However, the allocation routines consider NUMA locality only for buffer page metadata and not for the actual buffer page. This causes the pages to be allocated on the NUMA node local to the CPU where the allocation routine is running at the time.  This patch fixes the problem by using a NUMA node specific allocation routine so that the pages are allocated from a NUMA node local to the logging CPU.  I tested with the getuid_microbench from autotest. It is a simple binary that calls getuid() in a loop and measures the average time for the syscall to complete. The following command was used to test: $ getuid_microbench 1000000  Compared the numbers found on kernel with and without this patch and found that logging latency decreases by 30-50 ns/call. tracing with non-NUMA allocation - 569 ns/call tracing with NUMA allocation     - 512 ns/call  Signed-off-by: Vaibhav Nagarnaik <vnagarnaik@google.com> Cc: Frederic Weisbecker <fweisbec@gmail.com> Cc: Ingo Molnar <mingo@redhat.com> Cc: Michael Rubin <mrubin@google.com> Cc: David Sharp <dhsharp@google.com> Link: http://lkml.kernel.org/r/1304470602-20366-1-git-send-email-vnagarnaik@google.com Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
f | trace_uprobe.c | s | 17K | 641 | Srikar Dronamraju | srikar@linux.vnet.ibm.com | 1336393817 |  | tracing: Provide trace events interface for uprobes  Implements trace_event support for uprobes. In its current form it can be used to put probes at a specified offset in a file and dump the required registers when the code flow reaches the probed address.  The following example shows how to dump the instruction pointer and %ax a register at the probed text address.  Here we are trying to probe zfree in /bin/zsh:   # cd /sys/kernel/debug/tracing/  # cat /proc/`pgrep  zsh`/maps || grep /bin/zsh || grep r-xp  00400000-0048a000 r-xp 00000000 08:03 130904 /bin/zsh  # objdump -T /bin/zsh || grep -w zfree  0000000000446420 g    DF .text  0000000000000012  Base  zfree # echo 'p /bin/zsh:0x46420 %ip %ax' > uprobe_events  # cat uprobe_events  p:uprobes/p_zsh_0x46420 /bin/zsh:0x0000000000046420  # echo 1 > events/uprobes/enable  # sleep 20  # echo 0 > events/uprobes/enable  # cat trace  # tracer: nop  #  #           TASK-PID    CPU#    TIMESTAMP  FUNCTION  #              || ||       ||          ||         ||               zsh-24842 [006] 258544.995456: p_zsh_0x46420: (0x446420) arg1=446421 arg2=79               zsh-24842 [007] 258545.000270: p_zsh_0x46420: (0x446420) arg1=446421 arg2=79               zsh-24842 [002] 258545.043929: p_zsh_0x46420: (0x446420) arg1=446421 arg2=79               zsh-24842 [004] 258547.046129: p_zsh_0x46420: (0x446420) arg1=446421 arg2=79  Signed-off-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com> Acked-by: Steven Rostedt <rostedt@goodmis.org> Acked-by: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com> Cc: Linus Torvalds <torvalds@linux-foundation.org> Cc: Ananth N Mavinakayanahalli <ananth@in.ibm.com> Cc: Jim Keniston <jkenisto@linux.vnet.ibm.com> Cc: Linux-mm <linux-mm@kvack.org> Cc: Oleg Nesterov <oleg@redhat.com> Cc: Andi Kleen <andi@firstfloor.org> Cc: Christoph Hellwig <hch@infradead.org> Cc: Arnaldo Carvalho de Melo <acme@infradead.org> Cc: Anton Arapov <anton@redhat.com> Cc: Peter Zijlstra <peterz@infradead.org> Link: http://lkml.kernel.org/r/20120411103043.GB29437@linux.vnet.ibm.com Signed-off-by: Ingo Molnar <mingo@kernel.org>
f | rpm-traces.c | s | 474B | 17 | Ming Lei | ming.lei@canonical.com | 1317156807 |  | PM / Runtime: Introduce trace points for tracing rpm_* functions  This patch introduces 3 trace points to prepare for tracing rpm_idle/rpm_suspend/rpm_resume functions, so we can use these trace points to replace the current dev_dbg().  Signed-off-by: Ming Lei <ming.lei@canonical.com> Acked-by: Steven Rostedt <rostedt@goodmis.org> Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
f | ftrace.c | s | 100K | 3807 | Steven Rostedt | srostedt@redhat.com | 1337212827 |  | ftrace/x86: Have x86 ftrace use the ftrace_modify_all_code()  To remove duplicate code, have the ftrace arch_ftrace_update_code() use the generic ftrace_modify_all_code(). This requires that the default ftrace_replace_code() becomes a weak function so that an arch may override it.  Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
f | trace_kprobe.c | s | 31K | 1076 | Srikar Dronamraju | srikar@linux.vnet.ibm.com | 1336393817 |  | tracing: Provide trace events interface for uprobes  Implements trace_event support for uprobes. In its current form it can be used to put probes at a specified offset in a file and dump the required registers when the code flow reaches the probed address.  The following example shows how to dump the instruction pointer and %ax a register at the probed text address.  Here we are trying to probe zfree in /bin/zsh:   # cd /sys/kernel/debug/tracing/  # cat /proc/`pgrep  zsh`/maps || grep /bin/zsh || grep r-xp  00400000-0048a000 r-xp 00000000 08:03 130904 /bin/zsh  # objdump -T /bin/zsh || grep -w zfree  0000000000446420 g    DF .text  0000000000000012  Base  zfree # echo 'p /bin/zsh:0x46420 %ip %ax' > uprobe_events  # cat uprobe_events  p:uprobes/p_zsh_0x46420 /bin/zsh:0x0000000000046420  # echo 1 > events/uprobes/enable  # sleep 20  # echo 0 > events/uprobes/enable  # cat trace  # tracer: nop  #  #           TASK-PID    CPU#    TIMESTAMP  FUNCTION  #              || ||       ||          ||         ||               zsh-24842 [006] 258544.995456: p_zsh_0x46420: (0x446420) arg1=446421 arg2=79               zsh-24842 [007] 258545.000270: p_zsh_0x46420: (0x446420) arg1=446421 arg2=79               zsh-24842 [002] 258545.043929: p_zsh_0x46420: (0x446420) arg1=446421 arg2=79               zsh-24842 [004] 258547.046129: p_zsh_0x46420: (0x446420) arg1=446421 arg2=79  Signed-off-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com> Acked-by: Steven Rostedt <rostedt@goodmis.org> Acked-by: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com> Cc: Linus Torvalds <torvalds@linux-foundation.org> Cc: Ananth N Mavinakayanahalli <ananth@in.ibm.com> Cc: Jim Keniston <jkenisto@linux.vnet.ibm.com> Cc: Linux-mm <linux-mm@kvack.org> Cc: Oleg Nesterov <oleg@redhat.com> Cc: Andi Kleen <andi@firstfloor.org> Cc: Christoph Hellwig <hch@infradead.org> Cc: Arnaldo Carvalho de Melo <acme@infradead.org> Cc: Anton Arapov <anton@redhat.com> Cc: Peter Zijlstra <peterz@infradead.org> Link: http://lkml.kernel.org/r/20120411103043.GB29437@linux.vnet.ibm.com Signed-off-by: Ingo Molnar <mingo@kernel.org>
f | trace_sched_switch.c | s | 5.8K | 209 | Steven Rostedt | srostedt@redhat.com | 1297203296 |  | tracing: Remove obsolete sched_switch tracer  The trace events sched_switch and sched_wakeup do the same thing as the stand alone sched_switch tracer does. It is no longer needed.  Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
