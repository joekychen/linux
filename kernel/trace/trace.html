<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › trace › trace.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>trace.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * ring buffer based function tracer</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2007-2008 Steven Rostedt &lt;srostedt@redhat.com&gt;</span>
<span class="cm"> * Copyright (C) 2008 Ingo Molnar &lt;mingo@redhat.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Originally taken from the RT patch by:</span>
<span class="cm"> *    Arnaldo Carvalho de Melo &lt;acme@redhat.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Based on code from the latency_tracer, that is:</span>
<span class="cm"> *  Copyright (C) 2004-2006 Ingo Molnar</span>
<span class="cm"> *  Copyright (C) 2004 William Lee Irwin III</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/ring_buffer.h&gt;</span>
<span class="cp">#include &lt;generated/utsrelease.h&gt;</span>
<span class="cp">#include &lt;linux/stacktrace.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>
<span class="cp">#include &lt;linux/kallsyms.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/irqflags.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/hardirq.h&gt;</span>
<span class="cp">#include &lt;linux/linkage.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/kprobes.h&gt;</span>
<span class="cp">#include &lt;linux/ftrace.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/splice.h&gt;</span>
<span class="cp">#include &lt;linux/kdebug.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/rwsem.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/nmi.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>

<span class="cp">#include &quot;trace.h&quot;</span>
<span class="cp">#include &quot;trace_output.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * On boot up, the ring buffer is set to the minimum size, so that</span>
<span class="cm"> * we do not waste memory on systems that are not using tracing.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ring_buffer_expanded</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * We need to change this state when a selftest is running.</span>
<span class="cm"> * A selftest will lurk into the ring-buffer to count the</span>
<span class="cm"> * entries inserted during the selftest although some concurrent</span>
<span class="cm"> * insertions into the ring-buffer such as trace_printk could occurred</span>
<span class="cm"> * at the same time, giving false positive or negative results.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">__read_mostly</span> <span class="n">tracing_selftest_running</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * If a tracer is running, we do not want to run SELFTEST.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="n">__read_mostly</span> <span class="n">tracing_selftest_disabled</span><span class="p">;</span>

<span class="cm">/* For tracers that don&#39;t implement custom flags */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tracer_opt</span> <span class="n">dummy_tracer_opt</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">tracer_flags</span> <span class="n">dummy_tracer_flags</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">opts</span> <span class="o">=</span> <span class="n">dummy_tracer_opt</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dummy_set_flag</span><span class="p">(</span><span class="n">u32</span> <span class="n">old_flags</span><span class="p">,</span> <span class="n">u32</span> <span class="n">bit</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Kill all tracing for good (never come back).</span>
<span class="cm"> * It is initialized to 1 but will turn to zero if the initialization</span>
<span class="cm"> * of the tracer is successful. But that is the only place that sets</span>
<span class="cm"> * this back to zero.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">tracing_disabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">ftrace_cpu_disabled</span><span class="p">);</span>

<span class="n">cpumask_var_t</span> <span class="n">__read_mostly</span>	<span class="n">tracing_buffer_mask</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * ftrace_dump_on_oops - variable to dump ftrace buffer on oops</span>
<span class="cm"> *</span>
<span class="cm"> * If there is an oops (or kernel panic) and the ftrace_dump_on_oops</span>
<span class="cm"> * is set, then ftrace_dump is called. This will output the contents</span>
<span class="cm"> * of the ftrace buffers to the console.  This is very useful for</span>
<span class="cm"> * capturing traces that lead to crashes and outputing it to a</span>
<span class="cm"> * serial console.</span>
<span class="cm"> *</span>
<span class="cm"> * It is default off, but you can enable it with either specifying</span>
<span class="cm"> * &quot;ftrace_dump_on_oops&quot; in the kernel command line, or setting</span>
<span class="cm"> * /proc/sys/kernel/ftrace_dump_on_oops</span>
<span class="cm"> * Set 1 if you want to dump buffers of all CPUs</span>
<span class="cm"> * Set 2 if you want to dump the buffer of the CPU that triggered oops</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="n">ftrace_dump_mode</span> <span class="n">ftrace_dump_on_oops</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">tracing_set_tracer</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>

<span class="cp">#define MAX_TRACER_SIZE		100</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">bootup_tracer_buf</span><span class="p">[</span><span class="n">MAX_TRACER_SIZE</span><span class="p">]</span> <span class="n">__initdata</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">default_bootup_tracer</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">set_cmdline_ftrace</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="n">bootup_tracer_buf</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">MAX_TRACER_SIZE</span><span class="p">);</span>
	<span class="n">default_bootup_tracer</span> <span class="o">=</span> <span class="n">bootup_tracer_buf</span><span class="p">;</span>
	<span class="cm">/* We are using ftrace early, expand it */</span>
	<span class="n">ring_buffer_expanded</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;ftrace=&quot;</span><span class="p">,</span> <span class="n">set_cmdline_ftrace</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">set_ftrace_dump_on_oops</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">str</span><span class="o">++</span> <span class="o">!=</span> <span class="sc">&#39;=&#39;</span> <span class="o">||</span> <span class="o">!*</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ftrace_dump_on_oops</span> <span class="o">=</span> <span class="n">DUMP_ALL</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="s">&quot;orig_cpu&quot;</span><span class="p">,</span> <span class="n">str</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ftrace_dump_on_oops</span> <span class="o">=</span> <span class="n">DUMP_ORIG</span><span class="p">;</span>
                <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;ftrace_dump_on_oops&quot;</span><span class="p">,</span> <span class="n">set_ftrace_dump_on_oops</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">ns2usecs</span><span class="p">(</span><span class="n">cycle_t</span> <span class="n">nsec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nsec</span> <span class="o">+=</span> <span class="mi">500</span><span class="p">;</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">nsec</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">nsec</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The global_trace is the descriptor that holds the tracing</span>
<span class="cm"> * buffers for the live tracing. For each CPU, it contains</span>
<span class="cm"> * a link list of pages that will store trace entries. The</span>
<span class="cm"> * page descriptor of the pages in the memory is used to hold</span>
<span class="cm"> * the link list by linking the lru item in the page descriptor</span>
<span class="cm"> * to each of the pages in the buffer per CPU.</span>
<span class="cm"> *</span>
<span class="cm"> * For each active CPU there is a data field that holds the</span>
<span class="cm"> * pages for the buffer for that CPU. Each CPU has the same number</span>
<span class="cm"> * of pages allocated for its buffer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">trace_array</span>	<span class="n">global_trace</span><span class="p">;</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_array_cpu</span><span class="p">,</span> <span class="n">global_trace_cpu</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">filter_current_check_discard</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">rec</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">filter_check_discard</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">filter_current_check_discard</span><span class="p">);</span>

<span class="n">cycle_t</span> <span class="nf">ftrace_now</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">ts</span><span class="p">;</span>

	<span class="cm">/* Early boot up does not have a buffer yet */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">global_trace</span><span class="p">.</span><span class="n">buffer</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">trace_clock_local</span><span class="p">();</span>

	<span class="n">ts</span> <span class="o">=</span> <span class="n">ring_buffer_time_stamp</span><span class="p">(</span><span class="n">global_trace</span><span class="p">.</span><span class="n">buffer</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">ring_buffer_normalize_time_stamp</span><span class="p">(</span><span class="n">global_trace</span><span class="p">.</span><span class="n">buffer</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ts</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ts</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The max_tr is used to snapshot the global_trace when a maximum</span>
<span class="cm"> * latency is reached. Some tracers will use this to store a maximum</span>
<span class="cm"> * trace while it continues examining live traces.</span>
<span class="cm"> *</span>
<span class="cm"> * The buffers for the max_tr are set up the same as the global_trace.</span>
<span class="cm"> * When a snapshot is taken, the link list of the max_tr is swapped</span>
<span class="cm"> * with the link list of the global_trace and the buffers are reset for</span>
<span class="cm"> * the global_trace so the tracing can continue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">trace_array</span>	<span class="n">max_tr</span><span class="p">;</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_array_cpu</span><span class="p">,</span> <span class="n">max_tr_data</span><span class="p">);</span>

<span class="cm">/* tracer_enabled is used to toggle activation of a tracer */</span>
<span class="k">static</span> <span class="kt">int</span>			<span class="n">tracer_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * tracing_is_enabled - return tracer_enabled status</span>
<span class="cm"> *</span>
<span class="cm"> * This function is used by other tracers to know the status</span>
<span class="cm"> * of the tracer_enabled flag.  Tracers may use this function</span>
<span class="cm"> * to know if it should enable their features when starting</span>
<span class="cm"> * up. See irqsoff tracer for an example (start_irqsoff_tracer).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">tracing_is_enabled</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tracer_enabled</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * trace_buf_size is the size in bytes that is allocated</span>
<span class="cm"> * for a buffer. Note, the number of bytes is always rounded</span>
<span class="cm"> * to page size.</span>
<span class="cm"> *</span>
<span class="cm"> * This number is purposely set to a low number of 16384.</span>
<span class="cm"> * If the dump on oops happens, it will be much appreciated</span>
<span class="cm"> * to not have to wait for all that output. Anyway this can be</span>
<span class="cm"> * boot time and run time configurable.</span>
<span class="cm"> */</span>
<span class="cp">#define TRACE_BUF_SIZE_DEFAULT	1441792UL </span><span class="cm">/* 16384 * 88 (sizeof(entry)) */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">trace_buf_size</span> <span class="o">=</span> <span class="n">TRACE_BUF_SIZE_DEFAULT</span><span class="p">;</span>

<span class="cm">/* trace_types holds a link list of available tracers. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tracer</span>		<span class="o">*</span><span class="n">trace_types</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cm">/* current_trace points to the tracer that is currently active */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tracer</span>		<span class="o">*</span><span class="n">current_trace</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * trace_types_lock is used to protect the trace_types list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">trace_types_lock</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * serialize the access of the ring buffer</span>
<span class="cm"> *</span>
<span class="cm"> * ring buffer serializes readers, but it is low level protection.</span>
<span class="cm"> * The validity of the events (which returns by ring_buffer_peek() ..etc)</span>
<span class="cm"> * are not protected by ring buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * The content of events may become garbage if we allow other process consumes</span>
<span class="cm"> * these events concurrently:</span>
<span class="cm"> *   A) the page of the consumed events may become a normal page</span>
<span class="cm"> *      (not reader page) in ring buffer, and this page will be rewrited</span>
<span class="cm"> *      by events producer.</span>
<span class="cm"> *   B) The page of the consumed events may become a page for splice_read,</span>
<span class="cm"> *      and this page will be returned to system.</span>
<span class="cm"> *</span>
<span class="cm"> * These primitives allow multi process access to different cpu ring buffer</span>
<span class="cm"> * concurrently.</span>
<span class="cm"> *</span>
<span class="cm"> * These primitives don&#39;t distinguish read-only and read-consume access.</span>
<span class="cm"> * Multi read-only access are also serialized.</span>
<span class="cm"> */</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="k">static</span> <span class="n">DECLARE_RWSEM</span><span class="p">(</span><span class="n">all_cpu_access_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">mutex</span><span class="p">,</span> <span class="n">cpu_access_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">trace_access_lock</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">TRACE_PIPE_ALL_CPU</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* gain it for accessing the whole ring buffer. */</span>
		<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">all_cpu_access_lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* gain it for accessing a cpu ring buffer. */</span>

		<span class="cm">/* Firstly block other trace_access_lock(TRACE_PIPE_ALL_CPU). */</span>
		<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">all_cpu_access_lock</span><span class="p">);</span>

		<span class="cm">/* Secondly block other access to this @cpu ring buffer. */</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_access_lock</span><span class="p">,</span> <span class="n">cpu</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">trace_access_unlock</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">TRACE_PIPE_ALL_CPU</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">all_cpu_access_lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_access_lock</span><span class="p">,</span> <span class="n">cpu</span><span class="p">));</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">all_cpu_access_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">trace_access_lock_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_access_lock</span><span class="p">,</span> <span class="n">cpu</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">access_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">trace_access_lock</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">cpu</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">access_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">trace_access_unlock</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">cpu</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">access_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">trace_access_lock_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cm">/* trace_wait is a waitqueue for tasks blocked on trace_poll */</span>
<span class="k">static</span> <span class="n">DECLARE_WAIT_QUEUE_HEAD</span><span class="p">(</span><span class="n">trace_wait</span><span class="p">);</span>

<span class="cm">/* trace_flags holds trace_options default values */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">trace_flags</span> <span class="o">=</span> <span class="n">TRACE_ITER_PRINT_PARENT</span> <span class="o">|</span> <span class="n">TRACE_ITER_PRINTK</span> <span class="o">|</span>
	<span class="n">TRACE_ITER_ANNOTATE</span> <span class="o">|</span> <span class="n">TRACE_ITER_CONTEXT_INFO</span> <span class="o">|</span> <span class="n">TRACE_ITER_SLEEP_TIME</span> <span class="o">|</span>
	<span class="n">TRACE_ITER_GRAPH_TIME</span> <span class="o">|</span> <span class="n">TRACE_ITER_RECORD_CMD</span> <span class="o">|</span> <span class="n">TRACE_ITER_OVERWRITE</span> <span class="o">|</span>
	<span class="n">TRACE_ITER_IRQ_INFO</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">trace_stop_count</span><span class="p">;</span>
<span class="k">static</span> <span class="n">DEFINE_RAW_SPINLOCK</span><span class="p">(</span><span class="n">tracing_start_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">wakeup_work_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DECLARE_DELAYED_WORK</span><span class="p">(</span><span class="n">wakeup_work</span><span class="p">,</span> <span class="n">wakeup_work_handler</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * tracing_on - enable tracing buffers</span>
<span class="cm"> *</span>
<span class="cm"> * This function enables tracing buffers that may have been</span>
<span class="cm"> * disabled with tracing_off.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tracing_on</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">global_trace</span><span class="p">.</span><span class="n">buffer</span><span class="p">)</span>
		<span class="n">ring_buffer_record_on</span><span class="p">(</span><span class="n">global_trace</span><span class="p">.</span><span class="n">buffer</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * This flag is only looked at when buffers haven&#39;t been</span>
<span class="cm">	 * allocated yet. We don&#39;t really care about the race</span>
<span class="cm">	 * between setting this flag and actually turning</span>
<span class="cm">	 * on the buffer.</span>
<span class="cm">	 */</span>
	<span class="n">global_trace</span><span class="p">.</span><span class="n">buffer_disabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">tracing_on</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * tracing_off - turn off tracing buffers</span>
<span class="cm"> *</span>
<span class="cm"> * This function stops the tracing buffers from recording data.</span>
<span class="cm"> * It does not disable any overhead the tracers themselves may</span>
<span class="cm"> * be causing. This function simply causes all recording to</span>
<span class="cm"> * the ring buffers to fail.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tracing_off</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">global_trace</span><span class="p">.</span><span class="n">buffer</span><span class="p">)</span>
		<span class="n">ring_buffer_record_off</span><span class="p">(</span><span class="n">global_trace</span><span class="p">.</span><span class="n">buffer</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * This flag is only looked at when buffers haven&#39;t been</span>
<span class="cm">	 * allocated yet. We don&#39;t really care about the race</span>
<span class="cm">	 * between setting this flag and actually turning</span>
<span class="cm">	 * on the buffer.</span>
<span class="cm">	 */</span>
	<span class="n">global_trace</span><span class="p">.</span><span class="n">buffer_disabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">tracing_off</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * tracing_is_on - show state of ring buffers enabled</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">tracing_is_on</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">global_trace</span><span class="p">.</span><span class="n">buffer</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ring_buffer_record_is_on</span><span class="p">(</span><span class="n">global_trace</span><span class="p">.</span><span class="n">buffer</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">global_trace</span><span class="p">.</span><span class="n">buffer_disabled</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">tracing_is_on</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * trace_wake_up - wake up tasks waiting for trace input</span>
<span class="cm"> *</span>
<span class="cm"> * Schedules a delayed work to wake up any task that is blocked on the</span>
<span class="cm"> * trace_wait queue. These is used with trace_poll for tasks polling the</span>
<span class="cm"> * trace.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">trace_wake_up</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delay</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trace_flags</span> <span class="o">&amp;</span> <span class="n">TRACE_ITER_BLOCK</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wakeup_work</span><span class="p">,</span> <span class="n">delay</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">set_buf_size</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">buf_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">str</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">buf_size</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">);</span>
	<span class="cm">/* nr_entries can not be zero */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">trace_buf_size</span> <span class="o">=</span> <span class="n">buf_size</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;trace_buf_size=&quot;</span><span class="p">,</span> <span class="n">set_buf_size</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">set_tracing_thresh</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">threshhold</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">str</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">strict_strtoul</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">threshhold</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tracing_thresh</span> <span class="o">=</span> <span class="n">threshhold</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;tracing_thresh=&quot;</span><span class="p">,</span> <span class="n">set_tracing_thresh</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">nsecs_to_usecs</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nsecs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nsecs</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* These must match the bit postions in trace_iterator_flags */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">trace_options</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;print-parent&quot;</span><span class="p">,</span>
	<span class="s">&quot;sym-offset&quot;</span><span class="p">,</span>
	<span class="s">&quot;sym-addr&quot;</span><span class="p">,</span>
	<span class="s">&quot;verbose&quot;</span><span class="p">,</span>
	<span class="s">&quot;raw&quot;</span><span class="p">,</span>
	<span class="s">&quot;hex&quot;</span><span class="p">,</span>
	<span class="s">&quot;bin&quot;</span><span class="p">,</span>
	<span class="s">&quot;block&quot;</span><span class="p">,</span>
	<span class="s">&quot;stacktrace&quot;</span><span class="p">,</span>
	<span class="s">&quot;trace_printk&quot;</span><span class="p">,</span>
	<span class="s">&quot;ftrace_preempt&quot;</span><span class="p">,</span>
	<span class="s">&quot;branch&quot;</span><span class="p">,</span>
	<span class="s">&quot;annotate&quot;</span><span class="p">,</span>
	<span class="s">&quot;userstacktrace&quot;</span><span class="p">,</span>
	<span class="s">&quot;sym-userobj&quot;</span><span class="p">,</span>
	<span class="s">&quot;printk-msg-only&quot;</span><span class="p">,</span>
	<span class="s">&quot;context-info&quot;</span><span class="p">,</span>
	<span class="s">&quot;latency-format&quot;</span><span class="p">,</span>
	<span class="s">&quot;sleep-time&quot;</span><span class="p">,</span>
	<span class="s">&quot;graph-time&quot;</span><span class="p">,</span>
	<span class="s">&quot;record-cmd&quot;</span><span class="p">,</span>
	<span class="s">&quot;overwrite&quot;</span><span class="p">,</span>
	<span class="s">&quot;disable_on_free&quot;</span><span class="p">,</span>
	<span class="s">&quot;irq-info&quot;</span><span class="p">,</span>
	<span class="nb">NULL</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="p">}</span> <span class="n">trace_clocks</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">trace_clock_local</span><span class="p">,</span>	<span class="s">&quot;local&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">trace_clock_global</span><span class="p">,</span>	<span class="s">&quot;global&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">trace_clock_counter</span><span class="p">,</span>	<span class="s">&quot;counter&quot;</span> <span class="p">},</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">trace_clock_id</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * trace_parser_get_init - gets the buffer for trace parser</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">trace_parser_get_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_parser</span> <span class="o">*</span><span class="n">parser</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">parser</span><span class="p">));</span>

	<span class="n">parser</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parser</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">parser</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * trace_parser_put - frees the buffer for trace parser</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">trace_parser_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_parser</span> <span class="o">*</span><span class="n">parser</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">parser</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * trace_get_user - reads the user input string separated by  space</span>
<span class="cm"> * (matched by isspace(ch))</span>
<span class="cm"> *</span>
<span class="cm"> * For each string found the &#39;struct trace_parser&#39; is updated,</span>
<span class="cm"> * and the function returns.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns number of bytes read.</span>
<span class="cm"> *</span>
<span class="cm"> * See kernel/trace/trace.h for &#39;struct trace_parser&#39; details.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">trace_get_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_parser</span> <span class="o">*</span><span class="n">parser</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
	<span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">ppos</span><span class="p">)</span>
		<span class="n">trace_parser_clear</span><span class="p">(</span><span class="n">parser</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_user</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">ubuf</span><span class="o">++</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">read</span><span class="o">++</span><span class="p">;</span>
	<span class="n">cnt</span><span class="o">--</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The parser is not finished with the last write,</span>
<span class="cm">	 * continue reading the user input without skipping spaces.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parser</span><span class="o">-&gt;</span><span class="n">cont</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* skip white space */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&amp;&amp;</span> <span class="n">isspace</span><span class="p">(</span><span class="n">ch</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">get_user</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">ubuf</span><span class="o">++</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">read</span><span class="o">++</span><span class="p">;</span>
			<span class="n">cnt</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* only spaces were written */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">isspace</span><span class="p">(</span><span class="n">ch</span><span class="p">))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">ppos</span> <span class="o">+=</span> <span class="n">read</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">read</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">parser</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* read the non-space input */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isspace</span><span class="p">(</span><span class="n">ch</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">parser</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">parser</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">parser</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="n">parser</span><span class="o">-&gt;</span><span class="n">idx</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">get_user</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">ubuf</span><span class="o">++</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">read</span><span class="o">++</span><span class="p">;</span>
		<span class="n">cnt</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We either got finished input or we have to wait for another call. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isspace</span><span class="p">(</span><span class="n">ch</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">parser</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="n">parser</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">parser</span><span class="o">-&gt;</span><span class="n">cont</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">parser</span><span class="o">-&gt;</span><span class="n">cont</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">parser</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="n">parser</span><span class="o">-&gt;</span><span class="n">idx</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">ppos</span> <span class="o">+=</span> <span class="n">read</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">read</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">ssize_t</span> <span class="nf">trace_seq_to_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_seq</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cnt</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">readpos</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">readpos</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
		<span class="n">cnt</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">readpos</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">cnt</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">cnt</span> <span class="o">-=</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">readpos</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">trace_seq_to_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_seq</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">readpos</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">readpos</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
		<span class="n">cnt</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">readpos</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">readpos</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ftrace_max_lock is used to protect the swapping of buffers</span>
<span class="cm"> * when taking a max snapshot. The buffers themselves are</span>
<span class="cm"> * protected by per_cpu spinlocks. But the action of the swap</span>
<span class="cm"> * needs its own lock.</span>
<span class="cm"> *</span>
<span class="cm"> * This is defined as a arch_spinlock_t in order to help</span>
<span class="cm"> * with performance when lockdep debugging is enabled.</span>
<span class="cm"> *</span>
<span class="cm"> * It is also used in other places outside the update_max_tr</span>
<span class="cm"> * so it needs to be defined outside of the</span>
<span class="cm"> * CONFIG_TRACER_MAX_TRACE.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">arch_spinlock_t</span> <span class="n">ftrace_max_lock</span> <span class="o">=</span>
	<span class="p">(</span><span class="n">arch_spinlock_t</span><span class="p">)</span><span class="n">__ARCH_SPIN_LOCK_UNLOCKED</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__read_mostly</span>	<span class="n">tracing_thresh</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_TRACER_MAX_TRACE</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__read_mostly</span>	<span class="n">tracing_max_latency</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Copy the new maximum trace into the separate maximum-trace</span>
<span class="cm"> * structure. (this way the maximum trace is permanently saved,</span>
<span class="cm"> * for later retrieval via /sys/kernel/debug/tracing/latency_trace)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">__update_max_tr</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_array</span> <span class="o">*</span><span class="n">tr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trace_array_cpu</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">tr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">trace_array_cpu</span> <span class="o">*</span><span class="n">max_data</span><span class="p">;</span>

	<span class="n">max_tr</span><span class="p">.</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="n">max_tr</span><span class="p">.</span><span class="n">time_start</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">preempt_timestamp</span><span class="p">;</span>

	<span class="n">max_data</span> <span class="o">=</span> <span class="n">max_tr</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
	<span class="n">max_data</span><span class="o">-&gt;</span><span class="n">saved_latency</span> <span class="o">=</span> <span class="n">tracing_max_latency</span><span class="p">;</span>
	<span class="n">max_data</span><span class="o">-&gt;</span><span class="n">critical_start</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">critical_start</span><span class="p">;</span>
	<span class="n">max_data</span><span class="o">-&gt;</span><span class="n">critical_end</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">critical_end</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">max_data</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">TASK_COMM_LEN</span><span class="p">);</span>
	<span class="n">max_data</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
	<span class="n">max_data</span><span class="o">-&gt;</span><span class="n">uid</span> <span class="o">=</span> <span class="n">task_uid</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">max_data</span><span class="o">-&gt;</span><span class="n">nice</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">static_prio</span> <span class="o">-</span> <span class="mi">20</span> <span class="o">-</span> <span class="n">MAX_RT_PRIO</span><span class="p">;</span>
	<span class="n">max_data</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">policy</span><span class="p">;</span>
	<span class="n">max_data</span><span class="o">-&gt;</span><span class="n">rt_priority</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">rt_priority</span><span class="p">;</span>

	<span class="cm">/* record this tasks comm */</span>
	<span class="n">tracing_record_cmdline</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * update_max_tr - snapshot all trace buffers from global_trace to max_tr</span>
<span class="cm"> * @tr: tracer</span>
<span class="cm"> * @tsk: the task with the latency</span>
<span class="cm"> * @cpu: The cpu that initiated the trace.</span>
<span class="cm"> *</span>
<span class="cm"> * Flip the buffers between the @tr and the max_tr and record information</span>
<span class="cm"> * about which task was the cause of this latency.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">update_max_tr</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_array</span> <span class="o">*</span><span class="n">tr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">tr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trace_stop_count</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">current_trace</span><span class="o">-&gt;</span><span class="n">use_max_tr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">arch_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_max_lock</span><span class="p">);</span>

	<span class="n">tr</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">max_tr</span><span class="p">.</span><span class="n">buffer</span><span class="p">;</span>
	<span class="n">max_tr</span><span class="p">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>

	<span class="n">__update_max_tr</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">tsk</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">arch_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_max_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * update_max_tr_single - only copy one trace over, and reset the rest</span>
<span class="cm"> * @tr - tracer</span>
<span class="cm"> * @tsk - task with the latency</span>
<span class="cm"> * @cpu - the cpu of the buffer to copy.</span>
<span class="cm"> *</span>
<span class="cm"> * Flip the trace of a single CPU buffer between the @tr and the max_tr.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">update_max_tr_single</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_array</span> <span class="o">*</span><span class="n">tr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trace_stop_count</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">current_trace</span><span class="o">-&gt;</span><span class="n">use_max_tr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">arch_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_max_lock</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ring_buffer_swap_cpu</span><span class="p">(</span><span class="n">max_tr</span><span class="p">.</span><span class="n">buffer</span><span class="p">,</span> <span class="n">tr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We failed to swap the buffer due to a commit taking</span>
<span class="cm">		 * place on this CPU. We fail to record, but we reset</span>
<span class="cm">		 * the max trace buffer (no one writes directly to it)</span>
<span class="cm">		 * and flag that it failed.</span>
<span class="cm">		 */</span>
		<span class="n">trace_array_printk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">max_tr</span><span class="p">,</span> <span class="n">_THIS_IP_</span><span class="p">,</span>
			<span class="s">&quot;Failed to swap buffers due to commit in progress</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EAGAIN</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">);</span>

	<span class="n">__update_max_tr</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">tsk</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">arch_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_max_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_TRACER_MAX_TRACE */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * register_tracer - register a tracer with the ftrace system.</span>
<span class="cm"> * @type - the plugin for the tracer</span>
<span class="cm"> *</span>
<span class="cm"> * Register a new plugin tracer.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">register_tracer</span><span class="p">(</span><span class="k">struct</span> <span class="n">tracer</span> <span class="o">*</span><span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tracer</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Tracer must have a name</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">MAX_TRACER_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Tracer has a name longer than %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">MAX_TRACER_SIZE</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>

	<span class="n">tracing_selftest_running</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">t</span> <span class="o">=</span> <span class="n">trace_types</span><span class="p">;</span> <span class="n">t</span><span class="p">;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* already found */</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Tracer %s already registered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">set_flag</span><span class="p">)</span>
		<span class="n">type</span><span class="o">-&gt;</span><span class="n">set_flag</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dummy_set_flag</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span>
		<span class="n">type</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dummy_tracer_flags</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">flags</span><span class="o">-&gt;</span><span class="n">opts</span><span class="p">)</span>
			<span class="n">type</span><span class="o">-&gt;</span><span class="n">flags</span><span class="o">-&gt;</span><span class="n">opts</span> <span class="o">=</span> <span class="n">dummy_tracer_opt</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">wait_pipe</span><span class="p">)</span>
		<span class="n">type</span><span class="o">-&gt;</span><span class="n">wait_pipe</span> <span class="o">=</span> <span class="n">default_wait_pipe</span><span class="p">;</span>


<span class="cp">#ifdef CONFIG_FTRACE_STARTUP_TEST</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">selftest</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">tracing_selftest_disabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tracer</span> <span class="o">*</span><span class="n">saved_tracer</span> <span class="o">=</span> <span class="n">current_trace</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">trace_array</span> <span class="o">*</span><span class="n">tr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">global_trace</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Run a selftest on this tracer.</span>
<span class="cm">		 * Here we reset the trace buffer, and set the current</span>
<span class="cm">		 * tracer to be this tracer. The tracer can then run some</span>
<span class="cm">		 * internal tracing to verify that everything is in order.</span>
<span class="cm">		 * If we fail, we do not register this tracer.</span>
<span class="cm">		 */</span>
		<span class="n">tracing_reset_online_cpus</span><span class="p">(</span><span class="n">tr</span><span class="p">);</span>

		<span class="n">current_trace</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>

		<span class="cm">/* If we expanded the buffers, make sure the max is expanded too */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ring_buffer_expanded</span> <span class="o">&amp;&amp;</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">use_max_tr</span><span class="p">)</span>
			<span class="n">ring_buffer_resize</span><span class="p">(</span><span class="n">max_tr</span><span class="p">.</span><span class="n">buffer</span><span class="p">,</span> <span class="n">trace_buf_size</span><span class="p">,</span>
						<span class="n">RING_BUFFER_ALL_CPUS</span><span class="p">);</span>

		<span class="cm">/* the test is responsible for initializing and enabling */</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Testing tracer %s: &quot;</span><span class="p">,</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">selftest</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">tr</span><span class="p">);</span>
		<span class="cm">/* the test is responsible for resetting too */</span>
		<span class="n">current_trace</span> <span class="o">=</span> <span class="n">saved_tracer</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;FAILED!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Only reset on passing, to avoid touching corrupted buffers */</span>
		<span class="n">tracing_reset_online_cpus</span><span class="p">(</span><span class="n">tr</span><span class="p">);</span>

		<span class="cm">/* Shrink the max buffer again */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ring_buffer_expanded</span> <span class="o">&amp;&amp;</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">use_max_tr</span><span class="p">)</span>
			<span class="n">ring_buffer_resize</span><span class="p">(</span><span class="n">max_tr</span><span class="p">.</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
						<span class="n">RING_BUFFER_ALL_CPUS</span><span class="p">);</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;PASSED</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">type</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">trace_types</span><span class="p">;</span>
	<span class="n">trace_types</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>

 <span class="nl">out:</span>
	<span class="n">tracing_selftest_running</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">||</span> <span class="o">!</span><span class="n">default_bootup_tracer</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">default_bootup_tracer</span><span class="p">,</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">MAX_TRACER_SIZE</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Starting tracer &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="cm">/* Do we want this tracer to start on bootup? */</span>
	<span class="n">tracing_set_tracer</span><span class="p">(</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">default_bootup_tracer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/* disable other selftests, since this will break it. */</span>
	<span class="n">tracing_selftest_disabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_FTRACE_STARTUP_TEST</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Disabling FTRACE selftests due to running tracer &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="cp">#endif</span>

 <span class="nl">out_unlock:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">unregister_tracer</span><span class="p">(</span><span class="k">struct</span> <span class="n">tracer</span> <span class="o">*</span><span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tracer</span> <span class="o">**</span><span class="n">t</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">t</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">trace_types</span><span class="p">;</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span> <span class="n">t</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">t</span> <span class="o">==</span> <span class="n">type</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Tracer %s not registered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

 <span class="nl">found:</span>
	<span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">current_trace</span> <span class="o">&amp;&amp;</span> <span class="n">tracer_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tracer_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tracing_stop</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">current_trace</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">)</span>
			<span class="n">current_trace</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global_trace</span><span class="p">);</span>
		<span class="n">current_trace</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nop_trace</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">tracing_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_array</span> <span class="o">*</span><span class="n">tr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">tr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">;</span>

	<span class="n">ring_buffer_record_disable</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>

	<span class="cm">/* Make sure all commits have finished */</span>
	<span class="n">synchronize_sched</span><span class="p">();</span>
	<span class="n">ring_buffer_reset_cpu</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="n">ring_buffer_record_enable</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">tracing_reset_online_cpus</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_array</span> <span class="o">*</span><span class="n">tr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">tr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">ring_buffer_record_disable</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>

	<span class="cm">/* Make sure all commits have finished */</span>
	<span class="n">synchronize_sched</span><span class="p">();</span>

	<span class="n">tr</span><span class="o">-&gt;</span><span class="n">time_start</span> <span class="o">=</span> <span class="n">ftrace_now</span><span class="p">(</span><span class="n">tr</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">);</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">ring_buffer_reset_cpu</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="n">ring_buffer_record_enable</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">tracing_reset_current</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tracing_reset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global_trace</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">tracing_reset_current_online_cpus</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tracing_reset_online_cpus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global_trace</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define SAVED_CMDLINES 128</span>
<span class="cp">#define NO_CMDLINE_MAP UINT_MAX</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="n">map_pid_to_cmdline</span><span class="p">[</span><span class="n">PID_MAX_DEFAULT</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="n">map_cmdline_to_pid</span><span class="p">[</span><span class="n">SAVED_CMDLINES</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">saved_cmdlines</span><span class="p">[</span><span class="n">SAVED_CMDLINES</span><span class="p">][</span><span class="n">TASK_COMM_LEN</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">cmdline_idx</span><span class="p">;</span>
<span class="k">static</span> <span class="n">arch_spinlock_t</span> <span class="n">trace_cmdline_lock</span> <span class="o">=</span> <span class="n">__ARCH_SPIN_LOCK_UNLOCKED</span><span class="p">;</span>

<span class="cm">/* temporary disable recording */</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">trace_record_cmdline_disabled</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">trace_init_cmdlines</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map_pid_to_cmdline</span><span class="p">,</span> <span class="n">NO_CMDLINE_MAP</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">map_pid_to_cmdline</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map_cmdline_to_pid</span><span class="p">,</span> <span class="n">NO_CMDLINE_MAP</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">map_cmdline_to_pid</span><span class="p">));</span>
	<span class="n">cmdline_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">is_tracing_stopped</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">trace_stop_count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ftrace_off_permanent - disable all ftrace code permanently</span>
<span class="cm"> *</span>
<span class="cm"> * This should only be called when a serious anomally has</span>
<span class="cm"> * been detected.  This will turn off the function tracing,</span>
<span class="cm"> * ring buffers, and other tracing utilites. It takes no</span>
<span class="cm"> * locks and can be called from any context.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ftrace_off_permanent</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tracing_disabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ftrace_stop</span><span class="p">();</span>
	<span class="n">tracing_off_permanent</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tracing_start - quick start of the tracer</span>
<span class="cm"> *</span>
<span class="cm"> * If tracing is enabled but was stopped by tracing_stop,</span>
<span class="cm"> * this will start the tracer back up.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tracing_start</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tracing_disabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tracing_start_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">trace_stop_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">trace_stop_count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Someone screwed up their debugging */</span>
			<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">trace_stop_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Prevent the buffers from switching */</span>
	<span class="n">arch_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_max_lock</span><span class="p">);</span>

	<span class="n">buffer</span> <span class="o">=</span> <span class="n">global_trace</span><span class="p">.</span><span class="n">buffer</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span><span class="p">)</span>
		<span class="n">ring_buffer_record_enable</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>

	<span class="n">buffer</span> <span class="o">=</span> <span class="n">max_tr</span><span class="p">.</span><span class="n">buffer</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span><span class="p">)</span>
		<span class="n">ring_buffer_record_enable</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>

	<span class="n">arch_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_max_lock</span><span class="p">);</span>

	<span class="n">ftrace_start</span><span class="p">();</span>
 <span class="nl">out:</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tracing_start_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tracing_stop - quick stop of the tracer</span>
<span class="cm"> *</span>
<span class="cm"> * Light weight way to stop tracing. Use in conjunction with</span>
<span class="cm"> * tracing_start.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tracing_stop</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">ftrace_stop</span><span class="p">();</span>
	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tracing_start_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trace_stop_count</span><span class="o">++</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Prevent the buffers from switching */</span>
	<span class="n">arch_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_max_lock</span><span class="p">);</span>

	<span class="n">buffer</span> <span class="o">=</span> <span class="n">global_trace</span><span class="p">.</span><span class="n">buffer</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span><span class="p">)</span>
		<span class="n">ring_buffer_record_disable</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>

	<span class="n">buffer</span> <span class="o">=</span> <span class="n">max_tr</span><span class="p">.</span><span class="n">buffer</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span><span class="p">)</span>
		<span class="n">ring_buffer_record_disable</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>

	<span class="n">arch_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_max_lock</span><span class="p">);</span>

 <span class="nl">out:</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tracing_start_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">trace_stop_cmdline_recording</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">trace_save_cmdline</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">pid</span><span class="p">,</span> <span class="n">idx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">||</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">&gt;</span> <span class="n">PID_MAX_DEFAULT</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * It&#39;s not the end of the world if we don&#39;t get</span>
<span class="cm">	 * the lock, but we also don&#39;t want to spin</span>
<span class="cm">	 * nor do we want to disable interrupts,</span>
<span class="cm">	 * so if we miss here, then better luck next time.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arch_spin_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_cmdline_lock</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">idx</span> <span class="o">=</span> <span class="n">map_pid_to_cmdline</span><span class="p">[</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="n">NO_CMDLINE_MAP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">cmdline_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">SAVED_CMDLINES</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check whether the cmdline buffer at idx has a pid</span>
<span class="cm">		 * mapped. We are going to overwrite that entry so we</span>
<span class="cm">		 * need to clear the map_pid_to_cmdline. Otherwise we</span>
<span class="cm">		 * would read the new comm for the old pid.</span>
<span class="cm">		 */</span>
		<span class="n">pid</span> <span class="o">=</span> <span class="n">map_cmdline_to_pid</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">!=</span> <span class="n">NO_CMDLINE_MAP</span><span class="p">)</span>
			<span class="n">map_pid_to_cmdline</span><span class="p">[</span><span class="n">pid</span><span class="p">]</span> <span class="o">=</span> <span class="n">NO_CMDLINE_MAP</span><span class="p">;</span>

		<span class="n">map_cmdline_to_pid</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
		<span class="n">map_pid_to_cmdline</span><span class="p">[</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>

		<span class="n">cmdline_idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">saved_cmdlines</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">TASK_COMM_LEN</span><span class="p">);</span>

	<span class="n">arch_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_cmdline_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">trace_find_cmdline</span><span class="p">(</span><span class="kt">int</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">char</span> <span class="n">comm</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">map</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">strcpy</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="s">&quot;&lt;idle&gt;&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">pid</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">strcpy</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="s">&quot;&lt;XXX&gt;&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">&gt;</span> <span class="n">PID_MAX_DEFAULT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">strcpy</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="s">&quot;&lt;...&gt;&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">arch_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_cmdline_lock</span><span class="p">);</span>
	<span class="n">map</span> <span class="o">=</span> <span class="n">map_pid_to_cmdline</span><span class="p">[</span><span class="n">pid</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">map</span> <span class="o">!=</span> <span class="n">NO_CMDLINE_MAP</span><span class="p">)</span>
		<span class="n">strcpy</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="n">saved_cmdlines</span><span class="p">[</span><span class="n">map</span><span class="p">]);</span>
	<span class="k">else</span>
		<span class="n">strcpy</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="s">&quot;&lt;...&gt;&quot;</span><span class="p">);</span>

	<span class="n">arch_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_cmdline_lock</span><span class="p">);</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">tracing_record_cmdline</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_record_cmdline_disabled</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">tracer_enabled</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">tracing_is_on</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">trace_save_cmdline</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">tracing_generic_entry_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">pc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">preempt_count</span>		<span class="o">=</span> <span class="n">pc</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">pid</span>			<span class="o">=</span> <span class="p">(</span><span class="n">tsk</span><span class="p">)</span> <span class="o">?</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">padding</span>			<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span>
<span class="cp">#ifdef CONFIG_TRACE_IRQFLAGS_SUPPORT</span>
		<span class="p">(</span><span class="n">irqs_disabled_flags</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span> <span class="o">?</span> <span class="n">TRACE_FLAG_IRQS_OFF</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span>
<span class="cp">#else</span>
		<span class="n">TRACE_FLAG_IRQS_NOSUPPORT</span> <span class="o">|</span>
<span class="cp">#endif</span>
		<span class="p">((</span><span class="n">pc</span> <span class="o">&amp;</span> <span class="n">HARDIRQ_MASK</span><span class="p">)</span> <span class="o">?</span> <span class="n">TRACE_FLAG_HARDIRQ</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">((</span><span class="n">pc</span> <span class="o">&amp;</span> <span class="n">SOFTIRQ_MASK</span><span class="p">)</span> <span class="o">?</span> <span class="n">TRACE_FLAG_SOFTIRQ</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">need_resched</span><span class="p">()</span> <span class="o">?</span> <span class="n">TRACE_FLAG_NEED_RESCHED</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">tracing_generic_entry_update</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span>
<span class="nf">trace_buffer_lock_reserve</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">ring_buffer_lock_reserve</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">trace_entry</span> <span class="o">*</span><span class="n">ent</span> <span class="o">=</span> <span class="n">ring_buffer_event_data</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

		<span class="n">tracing_generic_entry_update</span><span class="p">(</span><span class="n">ent</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">pc</span><span class="p">);</span>
		<span class="n">ent</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">event</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">__trace_buffer_unlock_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pc</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">wake</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ring_buffer_unlock_commit</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>

	<span class="n">ftrace_trace_stack</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">pc</span><span class="p">);</span>
	<span class="n">ftrace_trace_userstack</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">pc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wake</span><span class="p">)</span>
		<span class="n">trace_wake_up</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">trace_buffer_unlock_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__trace_buffer_unlock_commit</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span>
<span class="nf">trace_current_buffer_lock_reserve</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">**</span><span class="n">current_rb</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">current_rb</span> <span class="o">=</span> <span class="n">global_trace</span><span class="p">.</span><span class="n">buffer</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">trace_buffer_lock_reserve</span><span class="p">(</span><span class="o">*</span><span class="n">current_rb</span><span class="p">,</span>
					 <span class="n">type</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">pc</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">trace_current_buffer_lock_reserve</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">trace_current_buffer_unlock_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__trace_buffer_unlock_commit</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">trace_current_buffer_unlock_commit</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">trace_nowake_buffer_unlock_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__trace_buffer_unlock_commit</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">trace_nowake_buffer_unlock_commit</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">trace_nowake_buffer_unlock_commit_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pc</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ring_buffer_unlock_commit</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>

	<span class="n">ftrace_trace_stack_regs</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="n">ftrace_trace_userstack</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">pc</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">trace_nowake_buffer_unlock_commit_regs</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">trace_current_buffer_discard_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ring_buffer_discard_commit</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">trace_current_buffer_discard_commit</span><span class="p">);</span>

<span class="kt">void</span>
<span class="nf">trace_function</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_array</span> <span class="o">*</span><span class="n">tr</span><span class="p">,</span>
	       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">parent_ip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span>
	       <span class="kt">int</span> <span class="n">pc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event_function</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">tr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

	<span class="cm">/* If we are reading the ring buffer, don&#39;t trace */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">ftrace_cpu_disabled</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">trace_buffer_lock_reserve</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">TRACE_FN</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">),</span>
					  <span class="n">flags</span><span class="p">,</span> <span class="n">pc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">entry</span>	<span class="o">=</span> <span class="n">ring_buffer_event_data</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">ip</span>			<span class="o">=</span> <span class="n">ip</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">parent_ip</span>		<span class="o">=</span> <span class="n">parent_ip</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">filter_check_discard</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">event</span><span class="p">))</span>
		<span class="n">ring_buffer_unlock_commit</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">ftrace</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_array</span> <span class="o">*</span><span class="n">tr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">trace_array_cpu</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">parent_ip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span>
       <span class="kt">int</span> <span class="n">pc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">disabled</span><span class="p">)))</span>
		<span class="n">trace_function</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">parent_ip</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">pc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_STACKTRACE</span>

<span class="cp">#define FTRACE_STACK_MAX_ENTRIES (PAGE_SIZE / sizeof(unsigned long))</span>
<span class="k">struct</span> <span class="n">ftrace_stack</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">calls</span><span class="p">[</span><span class="n">FTRACE_STACK_MAX_ENTRIES</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_stack</span><span class="p">,</span> <span class="n">ftrace_stack</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">ftrace_stack_reserve</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__ftrace_trace_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">skip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event_kernel_stack</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">stack_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">stack_trace</span> <span class="n">trace</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">use_stack</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">FTRACE_STACK_ENTRIES</span><span class="p">;</span>

	<span class="n">trace</span><span class="p">.</span><span class="n">nr_entries</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">trace</span><span class="p">.</span><span class="n">skip</span>		<span class="o">=</span> <span class="n">skip</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since events can happen in NMIs there&#39;s no safe way to</span>
<span class="cm">	 * use the per cpu ftrace_stacks. We reserve it and if an interrupt</span>
<span class="cm">	 * or NMI comes in, it will just have to use the default</span>
<span class="cm">	 * FTRACE_STACK_SIZE.</span>
<span class="cm">	 */</span>
	<span class="n">preempt_disable_notrace</span><span class="p">();</span>

	<span class="n">use_stack</span> <span class="o">=</span> <span class="o">++</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">ftrace_stack_reserve</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * We don&#39;t need any atomic variables, just a barrier.</span>
<span class="cm">	 * If an interrupt comes in, we don&#39;t care, because it would</span>
<span class="cm">	 * have exited and put the counter back to what we want.</span>
<span class="cm">	 * We just need a barrier to keep gcc from moving things</span>
<span class="cm">	 * around.</span>
<span class="cm">	 */</span>
	<span class="n">barrier</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">use_stack</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">trace</span><span class="p">.</span><span class="n">entries</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">ftrace_stack</span><span class="p">).</span><span class="n">calls</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">trace</span><span class="p">.</span><span class="n">max_entries</span>	<span class="o">=</span> <span class="n">FTRACE_STACK_MAX_ENTRIES</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="p">)</span>
			<span class="n">save_stack_trace_regs</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trace</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">save_stack_trace</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">trace</span><span class="p">.</span><span class="n">nr_entries</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">)</span>
			<span class="n">size</span> <span class="o">=</span> <span class="n">trace</span><span class="p">.</span><span class="n">nr_entries</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="cm">/* From now on, use_stack is a boolean */</span>
		<span class="n">use_stack</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">*=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">trace_buffer_lock_reserve</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">TRACE_STACK</span><span class="p">,</span>
					  <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">)</span> <span class="o">+</span> <span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">pc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">ring_buffer_event_data</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">caller</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">use_stack</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">caller</span><span class="p">,</span> <span class="n">trace</span><span class="p">.</span><span class="n">entries</span><span class="p">,</span>
		       <span class="n">trace</span><span class="p">.</span><span class="n">nr_entries</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">));</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">trace</span><span class="p">.</span><span class="n">max_entries</span>	<span class="o">=</span> <span class="n">FTRACE_STACK_ENTRIES</span><span class="p">;</span>
		<span class="n">trace</span><span class="p">.</span><span class="n">entries</span>		<span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">caller</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="p">)</span>
			<span class="n">save_stack_trace_regs</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trace</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">save_stack_trace</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">trace</span><span class="p">.</span><span class="n">nr_entries</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">filter_check_discard</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">event</span><span class="p">))</span>
		<span class="n">ring_buffer_unlock_commit</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>

 <span class="nl">out:</span>
	<span class="cm">/* Again, don&#39;t let gcc optimize things here */</span>
	<span class="n">barrier</span><span class="p">();</span>
	<span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">ftrace_stack_reserve</span><span class="p">)</span><span class="o">--</span><span class="p">;</span>
	<span class="n">preempt_enable_notrace</span><span class="p">();</span>

<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ftrace_trace_stack_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">skip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">trace_flags</span> <span class="o">&amp;</span> <span class="n">TRACE_ITER_STACKTRACE</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">__ftrace_trace_stack</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">skip</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ftrace_trace_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">skip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">trace_flags</span> <span class="o">&amp;</span> <span class="n">TRACE_ITER_STACKTRACE</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">__ftrace_trace_stack</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">skip</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__trace_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_array</span> <span class="o">*</span><span class="n">tr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">skip</span><span class="p">,</span>
		   <span class="kt">int</span> <span class="n">pc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__ftrace_trace_stack</span><span class="p">(</span><span class="n">tr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">skip</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * trace_dump_stack - record a stack back trace in the trace buffer</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">trace_dump_stack</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tracing_disabled</span> <span class="o">||</span> <span class="n">tracing_selftest_running</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">local_save_flags</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* skipping 3 traces, seems to get us at the caller of this function */</span>
	<span class="n">__ftrace_trace_stack</span><span class="p">(</span><span class="n">global_trace</span><span class="p">.</span><span class="n">buffer</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">preempt_count</span><span class="p">(),</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">user_stack_count</span><span class="p">);</span>

<span class="kt">void</span>
<span class="nf">ftrace_trace_userstack</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event_user_stack</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">userstack_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">stack_trace</span> <span class="n">trace</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">trace_flags</span> <span class="o">&amp;</span> <span class="n">TRACE_ITER_USERSTACKTRACE</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * NMIs can not handle page faults, even with fix ups.</span>
<span class="cm">	 * The save user stack can (and often does) fault.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">in_nmi</span><span class="p">()))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * prevent recursion, since the user stack tracing may</span>
<span class="cm">	 * trigger other kernel events.</span>
<span class="cm">	 */</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">user_stack_count</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">__this_cpu_inc</span><span class="p">(</span><span class="n">user_stack_count</span><span class="p">);</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">trace_buffer_lock_reserve</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">TRACE_USER_STACK</span><span class="p">,</span>
					  <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">),</span> <span class="n">flags</span><span class="p">,</span> <span class="n">pc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_drop_count</span><span class="p">;</span>
	<span class="n">entry</span>	<span class="o">=</span> <span class="n">ring_buffer_event_data</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">tgid</span>		<span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">caller</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">caller</span><span class="p">));</span>

	<span class="n">trace</span><span class="p">.</span><span class="n">nr_entries</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">trace</span><span class="p">.</span><span class="n">max_entries</span>	<span class="o">=</span> <span class="n">FTRACE_STACK_ENTRIES</span><span class="p">;</span>
	<span class="n">trace</span><span class="p">.</span><span class="n">skip</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">trace</span><span class="p">.</span><span class="n">entries</span>		<span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">caller</span><span class="p">;</span>

	<span class="n">save_stack_trace_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">filter_check_discard</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">event</span><span class="p">))</span>
		<span class="n">ring_buffer_unlock_commit</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>

 <span class="nl">out_drop_count:</span>
	<span class="n">__this_cpu_dec</span><span class="p">(</span><span class="n">user_stack_count</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#ifdef UNUSED</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__trace_userstack</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_array</span> <span class="o">*</span><span class="n">tr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ftrace_trace_userstack</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">preempt_count</span><span class="p">());</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* UNUSED */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_STACKTRACE */</span><span class="cp"></span>

<span class="cm">/* created for use with alloc_percpu */</span>
<span class="k">struct</span> <span class="n">trace_buffer_struct</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">TRACE_BUF_SIZE</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">trace_buffer_struct</span> <span class="o">*</span><span class="n">trace_percpu_buffer</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">trace_buffer_struct</span> <span class="o">*</span><span class="n">trace_percpu_sirq_buffer</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">trace_buffer_struct</span> <span class="o">*</span><span class="n">trace_percpu_irq_buffer</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">trace_buffer_struct</span> <span class="o">*</span><span class="n">trace_percpu_nmi_buffer</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The buffer used is dependent on the context. There is a per cpu</span>
<span class="cm"> * buffer for normal context, softirq contex, hard irq context and</span>
<span class="cm"> * for NMI context. Thise allows for lockless recording.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, if the buffers failed to be allocated, then this returns NULL</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">get_trace_buf</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trace_buffer_struct</span> <span class="o">*</span><span class="n">percpu_buffer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">trace_buffer_struct</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we have allocated per cpu buffers, then we do not</span>
<span class="cm">	 * need to do any locking.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in_nmi</span><span class="p">())</span>
		<span class="n">percpu_buffer</span> <span class="o">=</span> <span class="n">trace_percpu_nmi_buffer</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">in_irq</span><span class="p">())</span>
		<span class="n">percpu_buffer</span> <span class="o">=</span> <span class="n">trace_percpu_irq_buffer</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">in_softirq</span><span class="p">())</span>
		<span class="n">percpu_buffer</span> <span class="o">=</span> <span class="n">trace_percpu_sirq_buffer</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">percpu_buffer</span> <span class="o">=</span> <span class="n">trace_percpu_buffer</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">percpu_buffer</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">buffer</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">percpu_buffer</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>

	<span class="k">return</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">alloc_percpu_trace_buffer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trace_buffer_struct</span> <span class="o">*</span><span class="n">buffers</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">trace_buffer_struct</span> <span class="o">*</span><span class="n">sirq_buffers</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">trace_buffer_struct</span> <span class="o">*</span><span class="n">irq_buffers</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">trace_buffer_struct</span> <span class="o">*</span><span class="n">nmi_buffers</span><span class="p">;</span>

	<span class="n">buffers</span> <span class="o">=</span> <span class="n">alloc_percpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_buffer_struct</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffers</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_warn</span><span class="p">;</span>

	<span class="n">sirq_buffers</span> <span class="o">=</span> <span class="n">alloc_percpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_buffer_struct</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sirq_buffers</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_sirq</span><span class="p">;</span>

	<span class="n">irq_buffers</span> <span class="o">=</span> <span class="n">alloc_percpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_buffer_struct</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">irq_buffers</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_irq</span><span class="p">;</span>

	<span class="n">nmi_buffers</span> <span class="o">=</span> <span class="n">alloc_percpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_buffer_struct</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nmi_buffers</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_nmi</span><span class="p">;</span>

	<span class="n">trace_percpu_buffer</span> <span class="o">=</span> <span class="n">buffers</span><span class="p">;</span>
	<span class="n">trace_percpu_sirq_buffer</span> <span class="o">=</span> <span class="n">sirq_buffers</span><span class="p">;</span>
	<span class="n">trace_percpu_irq_buffer</span> <span class="o">=</span> <span class="n">irq_buffers</span><span class="p">;</span>
	<span class="n">trace_percpu_nmi_buffer</span> <span class="o">=</span> <span class="n">nmi_buffers</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">err_nmi:</span>
	<span class="n">free_percpu</span><span class="p">(</span><span class="n">irq_buffers</span><span class="p">);</span>
 <span class="nl">err_irq:</span>
	<span class="n">free_percpu</span><span class="p">(</span><span class="n">sirq_buffers</span><span class="p">);</span>
 <span class="nl">err_sirq:</span>
	<span class="n">free_percpu</span><span class="p">(</span><span class="n">buffers</span><span class="p">);</span>
 <span class="nl">err_warn:</span>
	<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Could not allocate percpu trace_printk buffer&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">trace_printk_init_buffers</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">buffers_allocated</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buffers_allocated</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">alloc_percpu_trace_buffer</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;ftrace: Allocated trace_printk buffers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">buffers_allocated</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * trace_vbprintk - write binary msg to tracing buffer</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">trace_vbprintk</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event_bprint</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">trace_array</span> <span class="o">*</span><span class="n">tr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">global_trace</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bprint_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tbuffer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">pc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tracing_selftest_running</span> <span class="o">||</span> <span class="n">tracing_disabled</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t pollute graph traces with trace_vprintk internals */</span>
	<span class="n">pause_graph_tracing</span><span class="p">();</span>

	<span class="n">pc</span> <span class="o">=</span> <span class="n">preempt_count</span><span class="p">();</span>
	<span class="n">preempt_disable_notrace</span><span class="p">();</span>

	<span class="n">tbuffer</span> <span class="o">=</span> <span class="n">get_trace_buf</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tbuffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">vbin_printf</span><span class="p">((</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">tbuffer</span><span class="p">,</span> <span class="n">TRACE_BUF_SIZE</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">TRACE_BUF_SIZE</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">local_save_flags</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">buffer</span> <span class="o">=</span> <span class="n">tr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">;</span>
	<span class="n">event</span> <span class="o">=</span> <span class="n">trace_buffer_lock_reserve</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">TRACE_BPRINT</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
					  <span class="n">flags</span><span class="p">,</span> <span class="n">pc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">ring_buffer_event_data</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">ip</span>			<span class="o">=</span> <span class="n">ip</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">fmt</span>			<span class="o">=</span> <span class="n">fmt</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">tbuffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">filter_check_discard</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">event</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ring_buffer_unlock_commit</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
		<span class="n">ftrace_trace_stack</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">pc</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">preempt_enable_notrace</span><span class="p">();</span>
	<span class="n">unpause_graph_tracing</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">trace_vbprintk</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">trace_array_printk</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_array</span> <span class="o">*</span><span class="n">tr</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">va_list</span> <span class="n">ap</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">trace_flags</span> <span class="o">&amp;</span> <span class="n">TRACE_ITER_PRINTK</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">trace_array_vprintk</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">ap</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">trace_array_vprintk</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_array</span> <span class="o">*</span><span class="n">tr</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">*</span><span class="n">call</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event_print</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">pc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">print_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tbuffer</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tracing_disabled</span> <span class="o">||</span> <span class="n">tracing_selftest_running</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t pollute graph traces with trace_vprintk internals */</span>
	<span class="n">pause_graph_tracing</span><span class="p">();</span>

	<span class="n">pc</span> <span class="o">=</span> <span class="n">preempt_count</span><span class="p">();</span>
	<span class="n">preempt_disable_notrace</span><span class="p">();</span>


	<span class="n">tbuffer</span> <span class="o">=</span> <span class="n">get_trace_buf</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tbuffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">vsnprintf</span><span class="p">(</span><span class="n">tbuffer</span><span class="p">,</span> <span class="n">TRACE_BUF_SIZE</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">TRACE_BUF_SIZE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">local_save_flags</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">)</span> <span class="o">+</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">buffer</span> <span class="o">=</span> <span class="n">tr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">;</span>
	<span class="n">event</span> <span class="o">=</span> <span class="n">trace_buffer_lock_reserve</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">TRACE_PRINT</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
					  <span class="n">flags</span><span class="p">,</span> <span class="n">pc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">ring_buffer_event_data</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">=</span> <span class="n">ip</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">tbuffer</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">filter_check_discard</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">event</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ring_buffer_unlock_commit</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
		<span class="n">ftrace_trace_stack</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">pc</span><span class="p">);</span>
	<span class="p">}</span>
 <span class="nl">out:</span>
	<span class="n">preempt_enable_notrace</span><span class="p">();</span>
	<span class="n">unpause_graph_tracing</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">trace_vprintk</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">trace_array_vprintk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global_trace</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">trace_vprintk</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">trace_iterator_increment</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_iterator</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">idx</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">buffer_iter</span><span class="p">[</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">])</span>
		<span class="n">ring_buffer_read</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">buffer_iter</span><span class="p">[</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">trace_entry</span> <span class="o">*</span>
<span class="nf">peek_next_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_iterator</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">ts</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">lost_events</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring_buffer_iter</span> <span class="o">*</span><span class="n">buf_iter</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">buffer_iter</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buf_iter</span><span class="p">)</span>
		<span class="n">event</span> <span class="o">=</span> <span class="n">ring_buffer_iter_peek</span><span class="p">(</span><span class="n">buf_iter</span><span class="p">,</span> <span class="n">ts</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">event</span> <span class="o">=</span> <span class="n">ring_buffer_peek</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">tr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span>
					 <span class="n">lost_events</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">ent_size</span> <span class="o">=</span> <span class="n">ring_buffer_event_length</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ring_buffer_event_data</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">ent_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">trace_entry</span> <span class="o">*</span>
<span class="nf">__find_next_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_iterator</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ent_cpu</span><span class="p">,</span>
		  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">missing_events</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">ent_ts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">tr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">trace_entry</span> <span class="o">*</span><span class="n">ent</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lost_events</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">next_lost</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu_file</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">cpu_file</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">next_ts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ts</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">next_cpu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">next_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we are in a per_cpu trace file, don&#39;t bother by iterating over</span>
<span class="cm">	 * all cpu and peek directly.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_file</span> <span class="o">&gt;</span> <span class="n">TRACE_PIPE_ALL_CPU</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ring_buffer_empty_cpu</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">cpu_file</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">ent</span> <span class="o">=</span> <span class="n">peek_next_entry</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">cpu_file</span><span class="p">,</span> <span class="n">ent_ts</span><span class="p">,</span> <span class="n">missing_events</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ent_cpu</span><span class="p">)</span>
			<span class="o">*</span><span class="n">ent_cpu</span> <span class="o">=</span> <span class="n">cpu_file</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">ent</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">for_each_tracing_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ring_buffer_empty_cpu</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">cpu</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">ent</span> <span class="o">=</span> <span class="n">peek_next_entry</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ts</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lost_events</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Pick the entry with the smallest timestamp:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ent</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">next</span> <span class="o">||</span> <span class="n">ts</span> <span class="o">&lt;</span> <span class="n">next_ts</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">next</span> <span class="o">=</span> <span class="n">ent</span><span class="p">;</span>
			<span class="n">next_cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
			<span class="n">next_ts</span> <span class="o">=</span> <span class="n">ts</span><span class="p">;</span>
			<span class="n">next_lost</span> <span class="o">=</span> <span class="n">lost_events</span><span class="p">;</span>
			<span class="n">next_size</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">ent_size</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">ent_size</span> <span class="o">=</span> <span class="n">next_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ent_cpu</span><span class="p">)</span>
		<span class="o">*</span><span class="n">ent_cpu</span> <span class="o">=</span> <span class="n">next_cpu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ent_ts</span><span class="p">)</span>
		<span class="o">*</span><span class="n">ent_ts</span> <span class="o">=</span> <span class="n">next_ts</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">missing_events</span><span class="p">)</span>
		<span class="o">*</span><span class="n">missing_events</span> <span class="o">=</span> <span class="n">next_lost</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Find the next real entry, without updating the iterator itself */</span>
<span class="k">struct</span> <span class="n">trace_entry</span> <span class="o">*</span><span class="nf">trace_find_next_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_iterator</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span>
					  <span class="kt">int</span> <span class="o">*</span><span class="n">ent_cpu</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">ent_ts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__find_next_entry</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">ent_cpu</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">ent_ts</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Find the next real entry, and increment the iterator to the next entry */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">trace_find_next_entry_inc</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_iterator</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">ent</span> <span class="o">=</span> <span class="n">__find_next_entry</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">lost_events</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">ts</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">ent</span><span class="p">)</span>
		<span class="n">trace_iterator_increment</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">ent</span> <span class="o">?</span> <span class="n">iter</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">trace_consume</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_iterator</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ring_buffer_consume</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">tr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">ts</span><span class="p">,</span>
			    <span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">lost_events</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">s_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trace_iterator</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ent</span><span class="p">;</span>

	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">leftover</span><span class="p">);</span>

	<span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* can&#39;t go backwards */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ent</span> <span class="o">=</span> <span class="n">trace_find_next_entry_inc</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ent</span> <span class="o">=</span> <span class="n">iter</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">ent</span> <span class="o">&amp;&amp;</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">)</span>
		<span class="n">ent</span> <span class="o">=</span> <span class="n">trace_find_next_entry_inc</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>

	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">=</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ent</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">tracing_iter_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_iterator</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trace_array</span> <span class="o">*</span><span class="n">tr</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">tr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring_buffer_iter</span> <span class="o">*</span><span class="n">buf_iter</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">entries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ts</span><span class="p">;</span>

	<span class="n">tr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">skipped_entries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">buffer_iter</span><span class="p">[</span><span class="n">cpu</span><span class="p">])</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">buf_iter</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">buffer_iter</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
	<span class="n">ring_buffer_iter_reset</span><span class="p">(</span><span class="n">buf_iter</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We could have the case with the max latency tracers</span>
<span class="cm">	 * that a reset never took place on a cpu. This is evident</span>
<span class="cm">	 * by the timestamp being before the start of the buffer.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">event</span> <span class="o">=</span> <span class="n">ring_buffer_iter_peek</span><span class="p">(</span><span class="n">buf_iter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ts</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ts</span> <span class="o">&gt;=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">tr</span><span class="o">-&gt;</span><span class="n">time_start</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">entries</span><span class="o">++</span><span class="p">;</span>
		<span class="n">ring_buffer_read</span><span class="p">(</span><span class="n">buf_iter</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">tr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">skipped_entries</span> <span class="o">=</span> <span class="n">entries</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The current tracer is copied to avoid a global locking</span>
<span class="cm"> * all around.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">s_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trace_iterator</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">tracer</span> <span class="o">*</span><span class="n">old_tracer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu_file</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">cpu_file</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="cm">/* copy the tracer to avoid using a global lock all around */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">old_tracer</span> <span class="o">!=</span> <span class="n">current_trace</span> <span class="o">&amp;&amp;</span> <span class="n">current_trace</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">old_tracer</span> <span class="o">=</span> <span class="n">current_trace</span><span class="p">;</span>
		<span class="o">*</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">trace</span> <span class="o">=</span> <span class="o">*</span><span class="n">current_trace</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_record_cmdline_disabled</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pos</span> <span class="o">!=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">ent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_file</span> <span class="o">==</span> <span class="n">TRACE_PIPE_ALL_CPU</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">for_each_tracing_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
				<span class="n">tracing_iter_reset</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">tracing_iter_reset</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">cpu_file</span><span class="p">);</span>

		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">leftover</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">iter</span><span class="p">;</span> <span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">s_next</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">))</span>
			<span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we overflowed the seq_file before, then we want</span>
<span class="cm">		 * to just reuse the trace_seq buffer again.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">leftover</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">iter</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">l</span> <span class="o">=</span> <span class="o">*</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">s_next</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">trace_event_read_lock</span><span class="p">();</span>
	<span class="n">trace_access_lock</span><span class="p">(</span><span class="n">cpu_file</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">s_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trace_iterator</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_record_cmdline_disabled</span><span class="p">);</span>
	<span class="n">trace_access_unlock</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">cpu_file</span><span class="p">);</span>
	<span class="n">trace_event_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">get_total_entries</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_array</span> <span class="o">*</span><span class="n">tr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">total</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">entries</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="o">*</span><span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="o">*</span><span class="n">entries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">for_each_tracing_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">ring_buffer_entries_cpu</span><span class="p">(</span><span class="n">tr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If this buffer has skipped entries, then we hold all</span>
<span class="cm">		 * entries for the trace and we need to ignore the</span>
<span class="cm">		 * ones before the time stamp.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">skipped_entries</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">count</span> <span class="o">-=</span> <span class="n">tr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">skipped_entries</span><span class="p">;</span>
			<span class="cm">/* total is the same as the entries */</span>
			<span class="o">*</span><span class="n">total</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="o">*</span><span class="n">total</span> <span class="o">+=</span> <span class="n">count</span> <span class="o">+</span>
				<span class="n">ring_buffer_overrun_cpu</span><span class="p">(</span><span class="n">tr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="o">*</span><span class="n">entries</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_lat_help_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;#                  _------=&gt; CPU#            </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;#                 / _-----=&gt; irqs-off        </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;#                | / _----=&gt; need-resched    </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;#                || / _---=&gt; hardirq/softirq </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;#                ||| / _--=&gt; preempt-depth   </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;#                |||| /     delay             </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;#  cmd     pid   ||||| time  |   caller      </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;#     </span><span class="se">\\</span><span class="s">   /      |||||  </span><span class="se">\\</span><span class="s">    |   /           </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_event_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_array</span> <span class="o">*</span><span class="n">tr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">entries</span><span class="p">;</span>

	<span class="n">get_total_entries</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">total</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entries</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;# entries-in-buffer/entries-written: %lu/%lu   #P:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">entries</span><span class="p">,</span> <span class="n">total</span><span class="p">,</span> <span class="n">num_online_cpus</span><span class="p">());</span>
	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;#</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_func_help_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_array</span> <span class="o">*</span><span class="n">tr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">print_event_info</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;#           TASK-PID   CPU#      TIMESTAMP  FUNCTION</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;#              | |       |          |         |</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_func_help_header_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_array</span> <span class="o">*</span><span class="n">tr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">print_event_info</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;#                              _-----=&gt; irqs-off</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;#                             / _----=&gt; need-resched</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;#                            | / _---=&gt; hardirq/softirq</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;#                            || / _--=&gt; preempt-depth</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;#                            ||| /     delay</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;#              | |       |   ||||       |         |</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">print_trace_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">trace_iterator</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sym_flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">trace_flags</span> <span class="o">&amp;</span> <span class="n">TRACE_ITER_SYM_MASK</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">trace_array</span> <span class="o">*</span><span class="n">tr</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">tr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">trace_array_cpu</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">tr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">tr</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">tracer</span> <span class="o">*</span><span class="n">type</span> <span class="o">=</span> <span class="n">current_trace</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">entries</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;preemption&quot;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span>
		<span class="n">name</span> <span class="o">=</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>

	<span class="n">get_total_entries</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">total</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entries</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;# %s latency trace v1.1.5 on %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">name</span><span class="p">,</span> <span class="n">UTS_RELEASE</span><span class="p">);</span>
	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;# -----------------------------------&quot;</span>
		 <span class="s">&quot;---------------------------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;# latency: %lu us, #%lu/%lu, CPU#%d |&quot;</span>
		   <span class="s">&quot; (M:%s VP:%d, KP:%d, SP:%d HP:%d&quot;</span><span class="p">,</span>
		   <span class="n">nsecs_to_usecs</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">saved_latency</span><span class="p">),</span>
		   <span class="n">entries</span><span class="p">,</span>
		   <span class="n">total</span><span class="p">,</span>
		   <span class="n">tr</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span>
<span class="cp">#if defined(CONFIG_PREEMPT_NONE)</span>
		   <span class="s">&quot;server&quot;</span><span class="p">,</span>
<span class="cp">#elif defined(CONFIG_PREEMPT_VOLUNTARY)</span>
		   <span class="s">&quot;desktop&quot;</span><span class="p">,</span>
<span class="cp">#elif defined(CONFIG_PREEMPT)</span>
		   <span class="s">&quot;preempt&quot;</span><span class="p">,</span>
<span class="cp">#else</span>
		   <span class="s">&quot;unknown&quot;</span><span class="p">,</span>
<span class="cp">#endif</span>
		   <span class="cm">/* These are reserved for later use */</span>
		   <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; #P:%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">num_online_cpus</span><span class="p">());</span>
<span class="cp">#else</span>
	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;#    -----------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;#    | task: %.16s-%d &quot;</span>
		   <span class="s">&quot;(uid:%d nice:%ld policy:%ld rt_prio:%ld)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">data</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">nice</span><span class="p">,</span>
		   <span class="n">data</span><span class="o">-&gt;</span><span class="n">policy</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">rt_priority</span><span class="p">);</span>
	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;#    -----------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">critical_start</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;#  =&gt; started at: &quot;</span><span class="p">);</span>
		<span class="n">seq_print_ip_sym</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">critical_start</span><span class="p">,</span> <span class="n">sym_flags</span><span class="p">);</span>
		<span class="n">trace_print_seq</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">);</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">#  =&gt; ended at:   &quot;</span><span class="p">);</span>
		<span class="n">seq_print_ip_sym</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">critical_end</span><span class="p">,</span> <span class="n">sym_flags</span><span class="p">);</span>
		<span class="n">trace_print_seq</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">);</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">#</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;#</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">test_cpu_buff_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_iterator</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trace_seq</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">trace_flags</span> <span class="o">&amp;</span> <span class="n">TRACE_ITER_ANNOTATE</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">iter_flags</span> <span class="o">&amp;</span> <span class="n">TRACE_FILE_ANNOTATE</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">started</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">tr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">skipped_entries</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">started</span><span class="p">);</span>

	<span class="cm">/* Don&#39;t print started cpu buffer for the first entry of the trace */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">trace_seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;##### CPU %u buffer started ####</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">iter</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">print_line_t</span> <span class="nf">print_trace_fmt</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_iterator</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trace_seq</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sym_flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">trace_flags</span> <span class="o">&amp;</span> <span class="n">TRACE_ITER_SYM_MASK</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">trace_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">trace_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">ent</span><span class="p">;</span>

	<span class="n">test_cpu_buff_start</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">ftrace_find_event</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trace_flags</span> <span class="o">&amp;</span> <span class="n">TRACE_ITER_CONTEXT_INFO</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">iter_flags</span> <span class="o">&amp;</span> <span class="n">TRACE_FILE_LAT_FMT</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trace_print_lat_context</span><span class="p">(</span><span class="n">iter</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">partial</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trace_print_context</span><span class="p">(</span><span class="n">iter</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">partial</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">funcs</span><span class="o">-&gt;</span><span class="n">trace</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">sym_flags</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trace_seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;Unknown type %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">partial</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">TRACE_TYPE_HANDLED</span><span class="p">;</span>
<span class="nl">partial:</span>
	<span class="k">return</span> <span class="n">TRACE_TYPE_PARTIAL_LINE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">print_line_t</span> <span class="nf">print_raw_fmt</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_iterator</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trace_seq</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">trace_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">trace_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">ent</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trace_flags</span> <span class="o">&amp;</span> <span class="n">TRACE_ITER_CONTEXT_INFO</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trace_seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;%d %d %llu &quot;</span><span class="p">,</span>
				      <span class="n">entry</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">ts</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">partial</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">ftrace_find_event</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">funcs</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trace_seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;%d ?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">partial</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">TRACE_TYPE_HANDLED</span><span class="p">;</span>
<span class="nl">partial:</span>
	<span class="k">return</span> <span class="n">TRACE_TYPE_PARTIAL_LINE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">print_line_t</span> <span class="nf">print_hex_fmt</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_iterator</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trace_seq</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">newline</span> <span class="o">=</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">trace_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">trace_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">ent</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trace_flags</span> <span class="o">&amp;</span> <span class="n">TRACE_ITER_CONTEXT_INFO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">SEQ_PUT_HEX_FIELD_RET</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="n">SEQ_PUT_HEX_FIELD_RET</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">);</span>
		<span class="n">SEQ_PUT_HEX_FIELD_RET</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">ts</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">ftrace_find_event</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">enum</span> <span class="n">print_line_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">funcs</span><span class="o">-&gt;</span><span class="n">hex</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">TRACE_TYPE_HANDLED</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">SEQ_PUT_FIELD_RET</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">newline</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">TRACE_TYPE_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">print_line_t</span> <span class="nf">print_bin_fmt</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_iterator</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trace_seq</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">trace_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">trace_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">ent</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trace_flags</span> <span class="o">&amp;</span> <span class="n">TRACE_ITER_CONTEXT_INFO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">SEQ_PUT_FIELD_RET</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="n">SEQ_PUT_FIELD_RET</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">);</span>
		<span class="n">SEQ_PUT_FIELD_RET</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">ts</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">ftrace_find_event</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">event</span> <span class="o">?</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">funcs</span><span class="o">-&gt;</span><span class="n">binary</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">event</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">TRACE_TYPE_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">trace_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_iterator</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="cm">/* If we are looking at one CPU buffer, only check that one */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">cpu_file</span> <span class="o">!=</span> <span class="n">TRACE_PIPE_ALL_CPU</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpu</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">cpu_file</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">buffer_iter</span><span class="p">[</span><span class="n">cpu</span><span class="p">])</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ring_buffer_iter_empty</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">buffer_iter</span><span class="p">[</span><span class="n">cpu</span><span class="p">]))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ring_buffer_empty_cpu</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">tr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">cpu</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">for_each_tracing_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">buffer_iter</span><span class="p">[</span><span class="n">cpu</span><span class="p">])</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ring_buffer_iter_empty</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">buffer_iter</span><span class="p">[</span><span class="n">cpu</span><span class="p">]))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ring_buffer_empty_cpu</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">tr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">cpu</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*  Called with trace_event_read_lock() held. */</span>
<span class="k">enum</span> <span class="n">print_line_t</span> <span class="nf">print_trace_line</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_iterator</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">print_line_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">lost_events</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">trace_seq_printf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;CPU:%d [LOST %lu EVENTS]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">iter</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">lost_events</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">TRACE_TYPE_PARTIAL_LINE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">trace</span> <span class="o">&amp;&amp;</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">trace</span><span class="o">-&gt;</span><span class="n">print_line</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">trace</span><span class="o">-&gt;</span><span class="n">print_line</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">TRACE_TYPE_UNHANDLED</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">ent</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">TRACE_BPRINT</span> <span class="o">&amp;&amp;</span>
			<span class="n">trace_flags</span> <span class="o">&amp;</span> <span class="n">TRACE_ITER_PRINTK</span> <span class="o">&amp;&amp;</span>
			<span class="n">trace_flags</span> <span class="o">&amp;</span> <span class="n">TRACE_ITER_PRINTK_MSGONLY</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">trace_print_bprintk_msg_only</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">ent</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">TRACE_PRINT</span> <span class="o">&amp;&amp;</span>
			<span class="n">trace_flags</span> <span class="o">&amp;</span> <span class="n">TRACE_ITER_PRINTK</span> <span class="o">&amp;&amp;</span>
			<span class="n">trace_flags</span> <span class="o">&amp;</span> <span class="n">TRACE_ITER_PRINTK_MSGONLY</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">trace_print_printk_msg_only</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trace_flags</span> <span class="o">&amp;</span> <span class="n">TRACE_ITER_BIN</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">print_bin_fmt</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trace_flags</span> <span class="o">&amp;</span> <span class="n">TRACE_ITER_HEX</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">print_hex_fmt</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trace_flags</span> <span class="o">&amp;</span> <span class="n">TRACE_ITER_RAW</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">print_raw_fmt</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">print_trace_fmt</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">trace_latency_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trace_iterator</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="cm">/* print nothing if the buffers are empty */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trace_empty</span><span class="p">(</span><span class="n">iter</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">iter_flags</span> <span class="o">&amp;</span> <span class="n">TRACE_FILE_LAT_FMT</span><span class="p">)</span>
		<span class="n">print_trace_header</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">iter</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">trace_flags</span> <span class="o">&amp;</span> <span class="n">TRACE_ITER_VERBOSE</span><span class="p">))</span>
		<span class="n">print_lat_help_header</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">trace_default_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trace_iterator</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">trace_flags</span> <span class="o">&amp;</span> <span class="n">TRACE_ITER_CONTEXT_INFO</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">iter_flags</span> <span class="o">&amp;</span> <span class="n">TRACE_FILE_LAT_FMT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* print nothing if the buffers are empty */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">trace_empty</span><span class="p">(</span><span class="n">iter</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">print_trace_header</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">iter</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">trace_flags</span> <span class="o">&amp;</span> <span class="n">TRACE_ITER_VERBOSE</span><span class="p">))</span>
			<span class="n">print_lat_help_header</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">trace_flags</span> <span class="o">&amp;</span> <span class="n">TRACE_ITER_VERBOSE</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">trace_flags</span> <span class="o">&amp;</span> <span class="n">TRACE_ITER_IRQ_INFO</span><span class="p">)</span>
				<span class="n">print_func_help_header_irq</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">tr</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">print_func_help_header</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">tr</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">test_ftrace_alive</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ftrace_is_dead</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;# WARNING: FUNCTION TRACING IS CORRUPTED</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;#          MAY BE MISSING FUNCTION EVENTS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">s_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trace_iterator</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">ent</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">tr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;# tracer: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">trace</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;#</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">test_ftrace_alive</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">trace</span> <span class="o">&amp;&amp;</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">trace</span><span class="o">-&gt;</span><span class="n">print_header</span><span class="p">)</span>
			<span class="n">iter</span><span class="o">-&gt;</span><span class="n">trace</span><span class="o">-&gt;</span><span class="n">print_header</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">trace_default_header</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">leftover</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we filled the seq_file buffer earlier, we</span>
<span class="cm">		 * want to just show it now.</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">trace_print_seq</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">);</span>

		<span class="cm">/* ret should this time be zero, but you never know */</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">leftover</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">print_trace_line</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">trace_print_seq</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we overflow the seq_file buffer, then it will</span>
<span class="cm">		 * ask us for this data again at start up.</span>
<span class="cm">		 * Use that instead.</span>
<span class="cm">		 *  ret is 0 if seq_file write succeeded.</span>
<span class="cm">		 *        -1 otherwise.</span>
<span class="cm">		 */</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">leftover</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">tracer_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span>		<span class="o">=</span> <span class="n">s_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>		<span class="o">=</span> <span class="n">s_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>		<span class="o">=</span> <span class="n">s_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>		<span class="o">=</span> <span class="n">s_show</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">trace_iterator</span> <span class="o">*</span>
<span class="nf">__tracing_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">cpu_file</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">trace_iterator</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tracing_disabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>

	<span class="n">iter</span> <span class="o">=</span> <span class="n">__seq_open_private</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tracer_seq_ops</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iter</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We make a copy of the current tracer to avoid concurrent</span>
<span class="cm">	 * changes on it while we are reading.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">trace</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">trace</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">trace</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">current_trace</span><span class="p">)</span>
		<span class="o">*</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">trace</span> <span class="o">=</span> <span class="o">*</span><span class="n">current_trace</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zalloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">started</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">current_trace</span> <span class="o">&amp;&amp;</span> <span class="n">current_trace</span><span class="o">-&gt;</span><span class="n">print_max</span><span class="p">)</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">tr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">max_tr</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">tr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">global_trace</span><span class="p">;</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">cpu_file</span> <span class="o">=</span> <span class="n">cpu_file</span><span class="p">;</span>

	<span class="cm">/* Notify the tracer early; before we stop tracing. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">trace</span> <span class="o">&amp;&amp;</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">trace</span><span class="o">-&gt;</span><span class="n">open</span><span class="p">)</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">trace</span><span class="o">-&gt;</span><span class="n">open</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>

	<span class="cm">/* Annotate start of buffers if we had overruns */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ring_buffer_overruns</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">tr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">))</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">iter_flags</span> <span class="o">|=</span> <span class="n">TRACE_FILE_ANNOTATE</span><span class="p">;</span>

	<span class="cm">/* stop the trace while dumping */</span>
	<span class="n">tracing_stop</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">cpu_file</span> <span class="o">==</span> <span class="n">TRACE_PIPE_ALL_CPU</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">for_each_tracing_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iter</span><span class="o">-&gt;</span><span class="n">buffer_iter</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">ring_buffer_read_prepare</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">tr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ring_buffer_read_prepare_sync</span><span class="p">();</span>
		<span class="n">for_each_tracing_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ring_buffer_read_start</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">buffer_iter</span><span class="p">[</span><span class="n">cpu</span><span class="p">]);</span>
			<span class="n">tracing_iter_reset</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cpu</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">cpu_file</span><span class="p">;</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">buffer_iter</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">ring_buffer_read_prepare</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">tr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">ring_buffer_read_prepare_sync</span><span class="p">();</span>
		<span class="n">ring_buffer_read_start</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">buffer_iter</span><span class="p">[</span><span class="n">cpu</span><span class="p">]);</span>
		<span class="n">tracing_iter_reset</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">iter</span><span class="p">;</span>

 <span class="nl">fail:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">trace</span><span class="p">);</span>
	<span class="n">seq_release_private</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">tracing_open_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tracing_disabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tracing_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">trace_iterator</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_READ</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">iter</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>
	<span class="n">for_each_tracing_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">buffer_iter</span><span class="p">[</span><span class="n">cpu</span><span class="p">])</span>
			<span class="n">ring_buffer_read_finish</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">buffer_iter</span><span class="p">[</span><span class="n">cpu</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">trace</span> <span class="o">&amp;&amp;</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">trace</span><span class="o">-&gt;</span><span class="n">close</span><span class="p">)</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">trace</span><span class="o">-&gt;</span><span class="n">close</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>

	<span class="cm">/* reenable tracing if it was previously enabled */</span>
	<span class="n">tracing_start</span><span class="p">();</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>

	<span class="n">mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">started</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">trace</span><span class="p">);</span>
	<span class="n">seq_release_private</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tracing_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trace_iterator</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* If this file was open for write, then erase contents */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_TRUNC</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">long</span> <span class="n">cpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">TRACE_PIPE_ALL_CPU</span><span class="p">)</span>
			<span class="n">tracing_reset_online_cpus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global_trace</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">tracing_reset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global_trace</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_READ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iter</span> <span class="o">=</span> <span class="n">__tracing_open</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">iter</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">trace_flags</span> <span class="o">&amp;</span> <span class="n">TRACE_ITER_LATENCY_FMT</span><span class="p">)</span>
			<span class="n">iter</span><span class="o">-&gt;</span><span class="n">iter_flags</span> <span class="o">|=</span> <span class="n">TRACE_FILE_LAT_FMT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">t_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tracer</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>

	<span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">)</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">t_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tracer</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">t</span> <span class="o">=</span> <span class="n">trace_types</span><span class="p">;</span> <span class="n">t</span> <span class="o">&amp;&amp;</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">t_next</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">))</span>
		<span class="p">;</span>

	<span class="k">return</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">t_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">t_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tracer</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
		<span class="n">seq_putc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">seq_putc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">show_traces_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span>		<span class="o">=</span> <span class="n">t_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>		<span class="o">=</span> <span class="n">t_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>		<span class="o">=</span> <span class="n">t_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>		<span class="o">=</span> <span class="n">t_show</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">show_traces_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tracing_disabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">show_traces_seq_ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">tracing_write_stub</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
		   <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">loff_t</span> <span class="nf">tracing_seek</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">origin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_READ</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">seq_lseek</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">origin</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">tracing_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">tracing_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">tracing_write_stub</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">tracing_seek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">tracing_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">show_traces_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">show_traces_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">seq_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Only trace on a CPU if the bitmask is set:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">cpumask_var_t</span> <span class="n">tracing_cpumask</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The tracer itself will not take this lock, but still we want</span>
<span class="cm"> * to provide a consistent cpumask to user-space:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">tracing_cpumask_update_lock</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Temporary storage for the character representation of the</span>
<span class="cm"> * CPU bitmask (and one more byte for the newline):</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">mask_str</span><span class="p">[</span><span class="n">NR_CPUS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">tracing_cpumask_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
		     <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tracing_cpumask_update_lock</span><span class="p">);</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">cpumask_scnprintf</span><span class="p">(</span><span class="n">mask_str</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">tracing_cpumask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">-</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">count</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">mask_str</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">mask_str</span><span class="p">,</span> <span class="n">NR_CPUS</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

<span class="nl">out_err:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tracing_cpumask_update_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">tracing_cpumask_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
		      <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="n">cpumask_var_t</span> <span class="n">tracing_cpumask_new</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tracing_cpumask_new</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">cpumask_parse_user</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">tracing_cpumask_new</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_unlock</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tracing_cpumask_update_lock</span><span class="p">);</span>

	<span class="n">local_irq_disable</span><span class="p">();</span>
	<span class="n">arch_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_max_lock</span><span class="p">);</span>
	<span class="n">for_each_tracing_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Increase/decrease the disabled counter if we are</span>
<span class="cm">		 * about to flip a bit in the cpumask:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">tracing_cpumask</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">tracing_cpumask_new</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global_trace</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">disabled</span><span class="p">);</span>
			<span class="n">ring_buffer_record_disable_cpu</span><span class="p">(</span><span class="n">global_trace</span><span class="p">.</span><span class="n">buffer</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">tracing_cpumask</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">tracing_cpumask_new</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global_trace</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">disabled</span><span class="p">);</span>
			<span class="n">ring_buffer_record_enable_cpu</span><span class="p">(</span><span class="n">global_trace</span><span class="p">.</span><span class="n">buffer</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">arch_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_max_lock</span><span class="p">);</span>
	<span class="n">local_irq_enable</span><span class="p">();</span>

	<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">tracing_cpumask</span><span class="p">,</span> <span class="n">tracing_cpumask_new</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tracing_cpumask_update_lock</span><span class="p">);</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">tracing_cpumask_new</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>

<span class="nl">err_unlock:</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">tracing_cpumask_new</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">tracing_cpumask_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">tracing_open_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">tracing_cpumask_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">tracing_cpumask_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tracing_trace_options_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tracer_opt</span> <span class="o">*</span><span class="n">trace_opts</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tracer_flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>
	<span class="n">tracer_flags</span> <span class="o">=</span> <span class="n">current_trace</span><span class="o">-&gt;</span><span class="n">flags</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
	<span class="n">trace_opts</span> <span class="o">=</span> <span class="n">current_trace</span><span class="o">-&gt;</span><span class="n">flags</span><span class="o">-&gt;</span><span class="n">opts</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">trace_options</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">trace_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">trace_options</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">else</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;no%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">trace_options</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">trace_opts</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tracer_flags</span> <span class="o">&amp;</span> <span class="n">trace_opts</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bit</span><span class="p">)</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">trace_opts</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;no%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">trace_opts</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__set_tracer_option</span><span class="p">(</span><span class="k">struct</span> <span class="n">tracer</span> <span class="o">*</span><span class="n">trace</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">tracer_flags</span> <span class="o">*</span><span class="n">tracer_flags</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">tracer_opt</span> <span class="o">*</span><span class="n">opts</span><span class="p">,</span> <span class="kt">int</span> <span class="n">neg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">trace</span><span class="o">-&gt;</span><span class="n">set_flag</span><span class="p">(</span><span class="n">tracer_flags</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="n">opts</span><span class="o">-&gt;</span><span class="n">bit</span><span class="p">,</span> <span class="o">!</span><span class="n">neg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">neg</span><span class="p">)</span>
		<span class="n">tracer_flags</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">bit</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">tracer_flags</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">|=</span> <span class="n">opts</span><span class="o">-&gt;</span><span class="n">bit</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Try to assign a tracer specific option */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_tracer_option</span><span class="p">(</span><span class="k">struct</span> <span class="n">tracer</span> <span class="o">*</span><span class="n">trace</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cmp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">neg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tracer_flags</span> <span class="o">*</span><span class="n">tracer_flags</span> <span class="o">=</span> <span class="n">trace</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tracer_opt</span> <span class="o">*</span><span class="n">opts</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tracer_flags</span><span class="o">-&gt;</span><span class="n">opts</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">opts</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tracer_flags</span><span class="o">-&gt;</span><span class="n">opts</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">cmp</span><span class="p">,</span> <span class="n">opts</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">__set_tracer_option</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">trace</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span>
						   <span class="n">opts</span><span class="p">,</span> <span class="n">neg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_tracer_flags</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enabled</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* do nothing if flag is already set */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!!</span><span class="p">(</span><span class="n">trace_flags</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="o">!!</span><span class="n">enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enabled</span><span class="p">)</span>
		<span class="n">trace_flags</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">trace_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="n">TRACE_ITER_RECORD_CMD</span><span class="p">)</span>
		<span class="n">trace_event_enable_cmd_record</span><span class="p">(</span><span class="n">enabled</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="n">TRACE_ITER_OVERWRITE</span><span class="p">)</span>
		<span class="n">ring_buffer_change_overwrite</span><span class="p">(</span><span class="n">global_trace</span><span class="p">.</span><span class="n">buffer</span><span class="p">,</span> <span class="n">enabled</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">tracing_trace_options_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">cmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">neg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">buf</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cmp</span> <span class="o">=</span> <span class="n">strstrip</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">cmp</span><span class="p">,</span> <span class="s">&quot;no&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">neg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">cmp</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">trace_options</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">cmp</span><span class="p">,</span> <span class="n">trace_options</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">set_tracer_flags</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">,</span> <span class="o">!</span><span class="n">neg</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* If no option could be set, test the specific tracer options */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trace_options</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">set_tracer_option</span><span class="p">(</span><span class="n">current_trace</span><span class="p">,</span> <span class="n">cmp</span><span class="p">,</span> <span class="n">neg</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">ppos</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tracing_trace_options_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tracing_disabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">tracing_trace_options_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">tracing_iter_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">tracing_trace_options_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">tracing_trace_options_write</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">readme_msg</span><span class="p">[]</span> <span class="o">=</span>
	<span class="s">&quot;tracing mini-HOWTO:</span><span class="se">\n\n</span><span class="s">&quot;</span>
	<span class="s">&quot;# mount -t debugfs nodev /sys/kernel/debug</span><span class="se">\n\n</span><span class="s">&quot;</span>
	<span class="s">&quot;# cat /sys/kernel/debug/tracing/available_tracers</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;wakeup wakeup_rt preemptirqsoff preemptoff irqsoff function nop</span><span class="se">\n\n</span><span class="s">&quot;</span>
	<span class="s">&quot;# cat /sys/kernel/debug/tracing/current_tracer</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;nop</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;# echo wakeup &gt; /sys/kernel/debug/tracing/current_tracer</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;# cat /sys/kernel/debug/tracing/current_tracer</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;wakeup</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;# cat /sys/kernel/debug/tracing/trace_options</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;noprint-parent nosym-offset nosym-addr noverbose</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;# echo print-parent &gt; /sys/kernel/debug/tracing/trace_options</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;# echo 1 &gt; /sys/kernel/debug/tracing/tracing_on</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;# cat /sys/kernel/debug/tracing/trace &gt; /tmp/trace.txt</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;# echo 0 &gt; /sys/kernel/debug/tracing/tracing_on</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="p">;</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">tracing_readme_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
		       <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span>
					<span class="n">readme_msg</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">readme_msg</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">tracing_readme_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">tracing_open_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">tracing_readme_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">tracing_saved_cmdlines_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf_comm</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">file_buf</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">file_buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">SAVED_CMDLINES</span><span class="o">*</span><span class="p">(</span><span class="mi">16</span><span class="o">+</span><span class="n">TASK_COMM_LEN</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file_buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">buf_comm</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">TASK_COMM_LEN</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf_comm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">file_buf</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">file_buf</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SAVED_CMDLINES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

		<span class="n">pid</span> <span class="o">=</span> <span class="n">map_cmdline_to_pid</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">pid</span> <span class="o">==</span> <span class="n">NO_CMDLINE_MAP</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">trace_find_cmdline</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">buf_comm</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">buf_comm</span><span class="p">);</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">r</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span>
				      <span class="n">file_buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">file_buf</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buf_comm</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">tracing_saved_cmdlines_fops</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">open</span>       <span class="o">=</span> <span class="n">tracing_open_generic</span><span class="p">,</span>
    <span class="p">.</span><span class="n">read</span>       <span class="o">=</span> <span class="n">tracing_saved_cmdlines_read</span><span class="p">,</span>
    <span class="p">.</span><span class="n">llseek</span>	<span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">tracing_ctrl_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
		  <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tracer_enabled</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">tracing_ctrl_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
		   <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trace_array</span> <span class="o">*</span><span class="n">tr</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">kstrtoul_from_user</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="o">!!</span><span class="n">val</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tracer_enabled</span> <span class="o">^</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Only need to warn if this is used to change the state */</span>
		<span class="n">WARN_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;tracing_enabled is deprecated. Use tracing_on&quot;</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tracer_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">current_trace</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">)</span>
				<span class="n">current_trace</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">(</span><span class="n">tr</span><span class="p">);</span>
			<span class="n">tracing_start</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">tracer_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">tracing_stop</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">current_trace</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">)</span>
				<span class="n">current_trace</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">(</span><span class="n">tr</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>

	<span class="o">*</span><span class="n">ppos</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">tracing_set_trace_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
		       <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">MAX_TRACER_SIZE</span><span class="o">+</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current_trace</span><span class="p">)</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current_trace</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">tracer_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">tracer</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">trace_array</span> <span class="o">*</span><span class="n">tr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tracing_reset_online_cpus</span><span class="p">(</span><span class="n">tr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="n">tr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_buffer_entries</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_array</span> <span class="o">*</span><span class="n">tr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="n">for_each_tracing_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">tr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__tracing_resize_ring_buffer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If kernel or user changes the size of the ring buffer</span>
<span class="cm">	 * we use the size that was given, and we can forget about</span>
<span class="cm">	 * expanding it later.</span>
<span class="cm">	 */</span>
	<span class="n">ring_buffer_expanded</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ring_buffer_resize</span><span class="p">(</span><span class="n">global_trace</span><span class="p">.</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">current_trace</span><span class="o">-&gt;</span><span class="n">use_max_tr</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ring_buffer_resize</span><span class="p">(</span><span class="n">max_tr</span><span class="p">.</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">RING_BUFFER_ALL_CPUS</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">for_each_tracing_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">r</span> <span class="o">=</span> <span class="n">ring_buffer_resize</span><span class="p">(</span><span class="n">global_trace</span><span class="p">.</span><span class="n">buffer</span><span class="p">,</span>
						<span class="n">global_trace</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">,</span>
						<span class="n">i</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">ring_buffer_resize</span><span class="p">(</span><span class="n">global_trace</span><span class="p">.</span><span class="n">buffer</span><span class="p">,</span>
						<span class="n">global_trace</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">,</span>
						<span class="n">cpu</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * AARGH! We are left with different</span>
<span class="cm">			 * size max buffer!!!!</span>
<span class="cm">			 * The max buffer is our &quot;snapshot&quot; buffer.</span>
<span class="cm">			 * When a tracer needs a snapshot (one of the</span>
<span class="cm">			 * latency tracers), it swaps the max buffer</span>
<span class="cm">			 * with the saved snap shot. We succeeded to</span>
<span class="cm">			 * update the size of the main buffer, but failed to</span>
<span class="cm">			 * update the size of the max buffer. But when we tried</span>
<span class="cm">			 * to reset the main buffer to the original size, we</span>
<span class="cm">			 * failed there too. This is very unlikely to</span>
<span class="cm">			 * happen, but if it does, warn and kill all</span>
<span class="cm">			 * tracing.</span>
<span class="cm">			 */</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">tracing_disabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">RING_BUFFER_ALL_CPUS</span><span class="p">)</span>
		<span class="n">set_buffer_entries</span><span class="p">(</span><span class="o">&amp;</span><span class="n">max_tr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">max_tr</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

 <span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">RING_BUFFER_ALL_CPUS</span><span class="p">)</span>
		<span class="n">set_buffer_entries</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global_trace</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">global_trace</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">tracing_resize_ring_buffer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_id</span> <span class="o">!=</span> <span class="n">RING_BUFFER_ALL_CPUS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* make sure, this cpu is enabled in the mask */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">,</span> <span class="n">tracing_buffer_mask</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__tracing_resize_ring_buffer</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">cpu_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * tracing_update_buffers - used by tracing facility to expand ring buffers</span>
<span class="cm"> *</span>
<span class="cm"> * To save on memory when the tracing is never used on a system with it</span>
<span class="cm"> * configured in. The ring buffers are set to a minimum size. But once</span>
<span class="cm"> * a user starts to use the tracing facility, then they need to grow</span>
<span class="cm"> * to their default size.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is to be called when a tracer is about to be used.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">tracing_update_buffers</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ring_buffer_expanded</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__tracing_resize_ring_buffer</span><span class="p">(</span><span class="n">trace_buf_size</span><span class="p">,</span>
						<span class="n">RING_BUFFER_ALL_CPUS</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">trace_option_dentry</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">trace_option_dentry</span> <span class="o">*</span>
<span class="n">create_trace_option_files</span><span class="p">(</span><span class="k">struct</span> <span class="n">tracer</span> <span class="o">*</span><span class="n">tracer</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="n">destroy_trace_option_files</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_option_dentry</span> <span class="o">*</span><span class="n">topts</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tracing_set_tracer</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">trace_option_dentry</span> <span class="o">*</span><span class="n">topts</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">trace_array</span> <span class="o">*</span><span class="n">tr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">global_trace</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tracer</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ring_buffer_expanded</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__tracing_resize_ring_buffer</span><span class="p">(</span><span class="n">trace_buf_size</span><span class="p">,</span>
						<span class="n">RING_BUFFER_ALL_CPUS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">t</span> <span class="o">=</span> <span class="n">trace_types</span><span class="p">;</span> <span class="n">t</span><span class="p">;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="n">current_trace</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">trace_branch_disable</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current_trace</span> <span class="o">&amp;&amp;</span> <span class="n">current_trace</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">)</span>
		<span class="n">current_trace</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">(</span><span class="n">tr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current_trace</span> <span class="o">&amp;&amp;</span> <span class="n">current_trace</span><span class="o">-&gt;</span><span class="n">use_max_tr</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We don&#39;t free the ring buffer. instead, resize it because</span>
<span class="cm">		 * The max_tr ring buffer has some state (e.g. ring-&gt;clock) and</span>
<span class="cm">		 * we want preserve it.</span>
<span class="cm">		 */</span>
		<span class="n">ring_buffer_resize</span><span class="p">(</span><span class="n">max_tr</span><span class="p">.</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">RING_BUFFER_ALL_CPUS</span><span class="p">);</span>
		<span class="n">set_buffer_entries</span><span class="p">(</span><span class="o">&amp;</span><span class="n">max_tr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">destroy_trace_option_files</span><span class="p">(</span><span class="n">topts</span><span class="p">);</span>

	<span class="n">current_trace</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>

	<span class="n">topts</span> <span class="o">=</span> <span class="n">create_trace_option_files</span><span class="p">(</span><span class="n">current_trace</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current_trace</span><span class="o">-&gt;</span><span class="n">use_max_tr</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
		<span class="cm">/* we need to make per cpu buffer sizes equivalent */</span>
		<span class="n">for_each_tracing_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">ring_buffer_resize</span><span class="p">(</span><span class="n">max_tr</span><span class="p">.</span><span class="n">buffer</span><span class="p">,</span>
						<span class="n">global_trace</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">,</span>
						<span class="n">cpu</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">max_tr</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">=</span>
					<span class="n">global_trace</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">tracer_init</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">trace_branch_enable</span><span class="p">(</span><span class="n">tr</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">tracing_set_trace_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">MAX_TRACER_SIZE</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="n">MAX_TRACER_SIZE</span><span class="p">)</span>
		<span class="n">cnt</span> <span class="o">=</span> <span class="n">MAX_TRACER_SIZE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">buf</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* strip ending whitespace. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">isspace</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">tracing_set_tracer</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="o">*</span><span class="n">ppos</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">tracing_max_lat_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
		     <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="s">&quot;%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="o">*</span><span class="n">ptr</span> <span class="o">==</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">nsecs_to_usecs</span><span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span>
		<span class="n">r</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">tracing_max_lat_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
		      <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">kstrtoul_from_user</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">val</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tracing_open_pipe</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">cpu_file</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">trace_iterator</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tracing_disabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>

	<span class="cm">/* create a buffer to store the information to pass to userspace */</span>
	<span class="n">iter</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We make a copy of the current tracer to avoid concurrent</span>
<span class="cm">	 * changes on it while we are reading.</span>
<span class="cm">	 */</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">trace</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">trace</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">trace</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current_trace</span><span class="p">)</span>
		<span class="o">*</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">trace</span> <span class="o">=</span> <span class="o">*</span><span class="n">current_trace</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">started</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* trace pipe does not show start of buffer */</span>
	<span class="n">cpumask_setall</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">started</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trace_flags</span> <span class="o">&amp;</span> <span class="n">TRACE_ITER_LATENCY_FMT</span><span class="p">)</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">iter_flags</span> <span class="o">|=</span> <span class="n">TRACE_FILE_LAT_FMT</span><span class="p">;</span>

	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">cpu_file</span> <span class="o">=</span> <span class="n">cpu_file</span><span class="p">;</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">tr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">global_trace</span><span class="p">;</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">iter</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">trace</span><span class="o">-&gt;</span><span class="n">pipe_open</span><span class="p">)</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">trace</span><span class="o">-&gt;</span><span class="n">pipe_open</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>

	<span class="n">nonseekable_open</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">filp</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">trace</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tracing_release_pipe</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trace_iterator</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">trace</span><span class="o">-&gt;</span><span class="n">pipe_close</span><span class="p">)</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">trace</span><span class="o">-&gt;</span><span class="n">pipe_close</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>

	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">started</span><span class="p">);</span>
	<span class="n">mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">trace</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">tracing_poll_pipe</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span><span class="n">poll_table</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trace_iterator</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trace_flags</span> <span class="o">&amp;</span> <span class="n">TRACE_ITER_BLOCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Always select as readable when in blocking mode</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trace_empty</span><span class="p">(</span><span class="n">iter</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">;</span>
		<span class="n">poll_wait</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trace_wait</span><span class="p">,</span> <span class="n">poll_table</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trace_empty</span><span class="p">(</span><span class="n">iter</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">;</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">default_wait_pipe</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_iterator</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DEFINE_WAIT</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>

	<span class="n">prepare_to_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trace_empty</span><span class="p">(</span><span class="n">iter</span><span class="p">))</span>
		<span class="n">schedule</span><span class="p">();</span>

	<span class="n">finish_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is a make-shift waitqueue.</span>
<span class="cm"> * A tracer might use this callback on some rare cases:</span>
<span class="cm"> *</span>
<span class="cm"> *  1) the current tracer might hold the runqueue lock when it wakes up</span>
<span class="cm"> *     a reader, hence a deadlock (sched, function, and function graph tracers)</span>
<span class="cm"> *  2) the function tracers, trace all functions, we don&#39;t want</span>
<span class="cm"> *     the overhead of calling wake_up and friends</span>
<span class="cm"> *     (and tracing them too)</span>
<span class="cm"> *</span>
<span class="cm"> *     Anyway, this is really very primitive wakeup.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">poll_wait_pipe</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_iterator</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
	<span class="cm">/* sleep for 100 msecs, and try again. */</span>
	<span class="n">schedule_timeout</span><span class="p">(</span><span class="n">HZ</span> <span class="o">/</span> <span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Must be called with trace_types_lock mutex held. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tracing_wait_pipe</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trace_iterator</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">trace_empty</span><span class="p">(</span><span class="n">iter</span><span class="p">))</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">trace</span><span class="o">-&gt;</span><span class="n">wait_pipe</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We block until we read something and tracing is disabled.</span>
<span class="cm">		 * We still block if tracing is disabled, but we have never</span>
<span class="cm">		 * read anything. This allows a user to cat this file, and</span>
<span class="cm">		 * then enable tracing. But after we have read something,</span>
<span class="cm">		 * we give an EOF when tracing is again disabled.</span>
<span class="cm">		 *</span>
<span class="cm">		 * iter-&gt;pos will be 0 if we haven&#39;t read anything.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tracer_enabled</span> <span class="o">&amp;&amp;</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Consumer reader.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">tracing_read_pipe</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
		  <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trace_iterator</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">tracer</span> <span class="o">*</span><span class="n">old_tracer</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">sret</span><span class="p">;</span>

	<span class="cm">/* return any leftover data */</span>
	<span class="n">sret</span> <span class="o">=</span> <span class="n">trace_seq_to_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sret</span><span class="p">;</span>

	<span class="n">trace_seq_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">);</span>

	<span class="cm">/* copy the tracer to avoid using a global lock all around */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">old_tracer</span> <span class="o">!=</span> <span class="n">current_trace</span> <span class="o">&amp;&amp;</span> <span class="n">current_trace</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">old_tracer</span> <span class="o">=</span> <span class="n">current_trace</span><span class="p">;</span>
		<span class="o">*</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">trace</span> <span class="o">=</span> <span class="o">*</span><span class="n">current_trace</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Avoid more than one consumer on a single file descriptor</span>
<span class="cm">	 * This is just a matter of traces coherency, the ring buffer itself</span>
<span class="cm">	 * is protected.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">trace</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sret</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">trace</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">waitagain:</span>
	<span class="n">sret</span> <span class="o">=</span> <span class="n">tracing_wait_pipe</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* stop when tracing is finished */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trace_empty</span><span class="p">(</span><span class="n">iter</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="n">cnt</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* reset all but tr, trace, and overruns */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_iterator</span><span class="p">)</span> <span class="o">-</span>
	       <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_iterator</span><span class="p">,</span> <span class="n">seq</span><span class="p">));</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">trace_event_read_lock</span><span class="p">();</span>
	<span class="n">trace_access_lock</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">cpu_file</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">trace_find_next_entry_inc</span><span class="p">(</span><span class="n">iter</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">enum</span> <span class="n">print_line_t</span> <span class="n">ret</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">print_trace_line</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">TRACE_TYPE_PARTIAL_LINE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* don&#39;t print partial lines */</span>
			<span class="n">iter</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">TRACE_TYPE_NO_CONSUME</span><span class="p">)</span>
			<span class="n">trace_consume</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">cnt</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Setting the full flag means we reached the trace_seq buffer</span>
<span class="cm">		 * size and we should leave by partial output condition above.</span>
<span class="cm">		 * One of the trace_seq_* functions is not used properly.</span>
<span class="cm">		 */</span>
		<span class="n">WARN_ONCE</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">full</span><span class="p">,</span> <span class="s">&quot;full flag set for trace type %d&quot;</span><span class="p">,</span>
			  <span class="n">iter</span><span class="o">-&gt;</span><span class="n">ent</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">trace_access_unlock</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">cpu_file</span><span class="p">);</span>
	<span class="n">trace_event_read_unlock</span><span class="p">();</span>

	<span class="cm">/* Now copy what we have to the user */</span>
	<span class="n">sret</span> <span class="o">=</span> <span class="n">trace_seq_to_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">readpos</span> <span class="o">&gt;=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">len</span><span class="p">)</span>
		<span class="n">trace_seq_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there was nothing to send to user, in spite of consuming trace</span>
<span class="cm">	 * entries, go back to wait for more entries.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">waitagain</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tracing_pipe_buf_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">pipe_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__free_page</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tracing_spd_release_pipe</span><span class="p">(</span><span class="k">struct</span> <span class="n">splice_pipe_desc</span> <span class="o">*</span><span class="n">spd</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__free_page</span><span class="p">(</span><span class="n">spd</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">idx</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pipe_buf_operations</span> <span class="n">tracing_pipe_buf_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">can_merge</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map</span>			<span class="o">=</span> <span class="n">generic_pipe_buf_map</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unmap</span>			<span class="o">=</span> <span class="n">generic_pipe_buf_unmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">confirm</span>		<span class="o">=</span> <span class="n">generic_pipe_buf_confirm</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>		<span class="o">=</span> <span class="n">tracing_pipe_buf_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">steal</span>			<span class="o">=</span> <span class="n">generic_pipe_buf_steal</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get</span>			<span class="o">=</span> <span class="n">generic_pipe_buf_get</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">size_t</span>
<span class="nf">tracing_fill_pipe_page</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">rem</span><span class="p">,</span> <span class="k">struct</span> <span class="n">trace_iterator</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Seq buffer is page-sized, exactly what we need. */</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">print_trace_line</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">len</span> <span class="o">-</span> <span class="n">count</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rem</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rem</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">iter</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">len</span> <span class="o">-=</span> <span class="n">count</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">TRACE_TYPE_PARTIAL_LINE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iter</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">len</span> <span class="o">-=</span> <span class="n">count</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">TRACE_TYPE_NO_CONSUME</span><span class="p">)</span>
			<span class="n">trace_consume</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
		<span class="n">rem</span> <span class="o">-=</span> <span class="n">count</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trace_find_next_entry_inc</span><span class="p">(</span><span class="n">iter</span><span class="p">))</span>	<span class="p">{</span>
			<span class="n">rem</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">iter</span><span class="o">-&gt;</span><span class="n">ent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rem</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">tracing_splice_read_pipe</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
					<span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span>
					<span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pages_def</span><span class="p">[</span><span class="n">PIPE_DEF_BUFFERS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">partial_page</span> <span class="n">partial_def</span><span class="p">[</span><span class="n">PIPE_DEF_BUFFERS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">trace_iterator</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">splice_pipe_desc</span> <span class="n">spd</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">pages</span>		<span class="o">=</span> <span class="n">pages_def</span><span class="p">,</span>
		<span class="p">.</span><span class="n">partial</span>	<span class="o">=</span> <span class="n">partial_def</span><span class="p">,</span>
		<span class="p">.</span><span class="n">nr_pages</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="cm">/* This gets updated below. */</span>
		<span class="p">.</span><span class="n">nr_pages_max</span>	<span class="o">=</span> <span class="n">PIPE_DEF_BUFFERS</span><span class="p">,</span>
		<span class="p">.</span><span class="n">flags</span>		<span class="o">=</span> <span class="n">flags</span><span class="p">,</span>
		<span class="p">.</span><span class="n">ops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">tracing_pipe_buf_ops</span><span class="p">,</span>
		<span class="p">.</span><span class="n">spd_release</span>	<span class="o">=</span> <span class="n">tracing_spd_release_pipe</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">tracer</span> <span class="o">*</span><span class="n">old_tracer</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">rem</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">splice_grow_spd</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spd</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* copy the tracer to avoid using a global lock all around */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">old_tracer</span> <span class="o">!=</span> <span class="n">current_trace</span> <span class="o">&amp;&amp;</span> <span class="n">current_trace</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">old_tracer</span> <span class="o">=</span> <span class="n">current_trace</span><span class="p">;</span>
		<span class="o">*</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">trace</span> <span class="o">=</span> <span class="o">*</span><span class="n">current_trace</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">trace</span><span class="o">-&gt;</span><span class="n">splice_read</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">trace</span><span class="o">-&gt;</span><span class="n">splice_read</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span>
					       <span class="n">ppos</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">tracing_wait_pipe</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">ent</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">trace_find_next_entry_inc</span><span class="p">(</span><span class="n">iter</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">trace_event_read_lock</span><span class="p">();</span>
	<span class="n">trace_access_lock</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">cpu_file</span><span class="p">);</span>

	<span class="cm">/* Fill as many pages as possible. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rem</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">buffers</span> <span class="o">&amp;&amp;</span> <span class="n">rem</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spd</span><span class="p">.</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spd</span><span class="p">.</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">rem</span> <span class="o">=</span> <span class="n">tracing_fill_pipe_page</span><span class="p">(</span><span class="n">rem</span><span class="p">,</span> <span class="n">iter</span><span class="p">);</span>

		<span class="cm">/* Copy the data into the page, so we can start over. */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">trace_seq_to_buffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span>
					  <span class="n">page_address</span><span class="p">(</span><span class="n">spd</span><span class="p">.</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
					  <span class="n">iter</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__free_page</span><span class="p">(</span><span class="n">spd</span><span class="p">.</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spd</span><span class="p">.</span><span class="n">partial</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spd</span><span class="p">.</span><span class="n">partial</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>

		<span class="n">trace_seq_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">trace_access_unlock</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">cpu_file</span><span class="p">);</span>
	<span class="n">trace_event_read_unlock</span><span class="p">();</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="n">spd</span><span class="p">.</span><span class="n">nr_pages</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">splice_to_pipe</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spd</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">splice_shrink_spd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">out_err:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">ftrace_entries_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">trace_array</span>	<span class="o">*</span><span class="n">tr</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">cpu</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tracing_entries_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_entries_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tracing_disabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">info</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">info</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">global_trace</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span><span class="p">;</span>

	<span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">tracing_entries_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
		     <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_entries_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">trace_array</span> <span class="o">*</span><span class="n">tr</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">tr</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">RING_BUFFER_ALL_CPUS</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">buf_size_same</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>

		<span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">buf_size_same</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* check if all cpu sizes are same */</span>
		<span class="n">for_each_tracing_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* fill in the size from first enabled cpu */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">size</span> <span class="o">=</span> <span class="n">tr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">!=</span> <span class="n">tr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">buf_size_same</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">buf_size_same</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ring_buffer_expanded</span><span class="p">)</span>
				<span class="n">r</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%lu (expanded: %lu)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					    <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">,</span>
					    <span class="n">trace_buf_size</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">r</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">tracing_entries_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
		      <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_entries_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">kstrtoul_from_user</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* must have at least 1 entry */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">val</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* value is in KB */</span>
	<span class="n">val</span> <span class="o">&lt;&lt;=</span> <span class="mi">10</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">tracing_resize_ring_buffer</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="o">*</span><span class="n">ppos</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">tracing_entries_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_entries_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">tracing_total_entries_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trace_array</span> <span class="o">*</span><span class="n">tr</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">expanded_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>
	<span class="n">for_each_tracing_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="n">tr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ring_buffer_expanded</span><span class="p">)</span>
			<span class="n">expanded_size</span> <span class="o">+=</span> <span class="n">trace_buf_size</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ring_buffer_expanded</span><span class="p">)</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%lu (expanded: %lu)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">expanded_size</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">tracing_free_buffer_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
			  <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * There is no need to read what the user has written, this function</span>
<span class="cm">	 * is just to make sure that there is no error when &quot;echo&quot; is used</span>
<span class="cm">	 */</span>

	<span class="o">*</span><span class="n">ppos</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">tracing_free_buffer_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* disable tracing ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trace_flags</span> <span class="o">&amp;</span> <span class="n">TRACE_ITER_STOP_ON_FREE</span><span class="p">)</span>
		<span class="n">tracing_off</span><span class="p">();</span>
	<span class="cm">/* resize the ring buffer to 0 */</span>
	<span class="n">tracing_resize_ring_buffer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">RING_BUFFER_ALL_CPUS</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">tracing_mark_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
					<span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">fpos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ubuf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring_buffer_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">print_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pages</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">map_page</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">nr_pages</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">written</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tracing_disabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="n">TRACE_BUF_SIZE</span><span class="p">)</span>
		<span class="n">cnt</span> <span class="o">=</span> <span class="n">TRACE_BUF_SIZE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Userspace is injecting traces into the kernel trace buffer.</span>
<span class="cm">	 * We want to be as non intrusive as possible.</span>
<span class="cm">	 * To do so, we do not want to allocate any special buffers</span>
<span class="cm">	 * or take any locks, but instead write the userspace data</span>
<span class="cm">	 * straight into the ring buffer.</span>
<span class="cm">	 *</span>
<span class="cm">	 * First we need to pin the userspace buffer into memory,</span>
<span class="cm">	 * which, most likely it is, because it just referenced it.</span>
<span class="cm">	 * But there&#39;s no guarantee that it is. By using get_user_pages_fast()</span>
<span class="cm">	 * and kmap_atomic/kunmap_atomic() we can get access to the</span>
<span class="cm">	 * pages directly. We then write the data directly into the</span>
<span class="cm">	 * ring buffer.</span>
<span class="cm">	 */</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">TRACE_BUF_SIZE</span> <span class="o">&gt;=</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

	<span class="cm">/* check if we cross pages */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="p">((</span><span class="n">addr</span> <span class="o">+</span> <span class="n">cnt</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">))</span>
		<span class="n">nr_pages</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">addr</span> <span class="o">&amp;=</span> <span class="n">PAGE_MASK</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_user_pages_fast</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pages</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="n">nr_pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">put_page</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">ret</span><span class="p">]);</span>
		<span class="n">written</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">map_page</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">local_save_flags</span><span class="p">(</span><span class="n">irq_flags</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">)</span> <span class="o">+</span> <span class="n">cnt</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span> <span class="cm">/* possible \n added */</span>
	<span class="n">buffer</span> <span class="o">=</span> <span class="n">global_trace</span><span class="p">.</span><span class="n">buffer</span><span class="p">;</span>
	<span class="n">event</span> <span class="o">=</span> <span class="n">trace_buffer_lock_reserve</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">TRACE_PRINT</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
					  <span class="n">irq_flags</span><span class="p">,</span> <span class="n">preempt_count</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Ring buffer disabled, return as if not open for write */</span>
		<span class="n">written</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">ring_buffer_event_data</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">=</span> <span class="n">_THIS_IP_</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr_pages</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">map_page</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="n">len</span><span class="p">],</span> <span class="n">map_page</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cnt</span> <span class="o">-</span> <span class="n">len</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">map_page</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="n">cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="n">cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="n">ring_buffer_unlock_commit</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>

	<span class="n">written</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="o">*</span><span class="n">fpos</span> <span class="o">+=</span> <span class="n">written</span><span class="p">;</span>

 <span class="nl">out_unlock:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">map_page</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">written</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tracing_clock_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">trace_clocks</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span>
			<span class="s">&quot;%s%s%s%s&quot;</span><span class="p">,</span> <span class="n">i</span> <span class="o">?</span> <span class="s">&quot; &quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			<span class="n">i</span> <span class="o">==</span> <span class="n">trace_clock_id</span> <span class="o">?</span> <span class="s">&quot;[&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">trace_clocks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">,</span>
			<span class="n">i</span> <span class="o">==</span> <span class="n">trace_clock_id</span> <span class="o">?</span> <span class="s">&quot;]&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
	<span class="n">seq_putc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">tracing_clock_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
				   <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">fpos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">clockstr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">buf</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">clockstr</span> <span class="o">=</span> <span class="n">strstrip</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">trace_clocks</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">trace_clocks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">,</span> <span class="n">clockstr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">trace_clocks</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">trace_clock_id</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>

	<span class="n">ring_buffer_set_clock</span><span class="p">(</span><span class="n">global_trace</span><span class="p">.</span><span class="n">buffer</span><span class="p">,</span> <span class="n">trace_clocks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">func</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_tr</span><span class="p">.</span><span class="n">buffer</span><span class="p">)</span>
		<span class="n">ring_buffer_set_clock</span><span class="p">(</span><span class="n">max_tr</span><span class="p">.</span><span class="n">buffer</span><span class="p">,</span> <span class="n">trace_clocks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">func</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>

	<span class="o">*</span><span class="n">fpos</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tracing_clock_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tracing_disabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">tracing_clock_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">tracing_max_lat_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">tracing_open_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">tracing_max_lat_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">tracing_max_lat_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">tracing_ctrl_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">tracing_open_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">tracing_ctrl_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">tracing_ctrl_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">set_tracer_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">tracing_open_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">tracing_set_trace_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">tracing_set_trace_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">tracing_pipe_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">tracing_open_pipe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span>		<span class="o">=</span> <span class="n">tracing_poll_pipe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">tracing_read_pipe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">splice_read</span>	<span class="o">=</span> <span class="n">tracing_splice_read_pipe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">tracing_release_pipe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">tracing_entries_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">tracing_entries_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">tracing_entries_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">tracing_entries_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">tracing_entries_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">tracing_total_entries_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">tracing_open_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">tracing_total_entries_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">tracing_free_buffer_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">tracing_free_buffer_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">tracing_free_buffer_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">tracing_mark_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">tracing_open_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">tracing_mark_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">trace_clock_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">tracing_clock_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">tracing_clock_write</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ftrace_buffer_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">trace_array</span>	<span class="o">*</span><span class="n">tr</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">spare</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">cpu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">read</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tracing_buffers_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="kt">long</span><span class="p">)</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_buffer_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tracing_disabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">info</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">info</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tr</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">global_trace</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">cpu</span>	<span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">spare</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/* Force reading ring buffer for first read */</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">read</span>	<span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">nonseekable_open</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">filp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">tracing_buffers_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
		     <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_buffer_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">spare</span><span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">spare</span> <span class="o">=</span> <span class="n">ring_buffer_alloc_read_page</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">spare</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Do we have previous read data to read? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">&lt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">read</span><span class="p">;</span>

	<span class="n">trace_access_lock</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ring_buffer_read_page</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">spare</span><span class="p">,</span>
				    <span class="n">count</span><span class="p">,</span>
				    <span class="n">info</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">trace_access_unlock</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">read:</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">count</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">spare</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">size</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">-=</span> <span class="n">ret</span><span class="p">;</span>

	<span class="o">*</span><span class="n">ppos</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tracing_buffers_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_buffer_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">spare</span><span class="p">)</span>
		<span class="n">ring_buffer_free_read_page</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">spare</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">buffer_ref</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer</span>	<span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">ref</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">buffer_pipe_buf_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">pipe_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_ref</span> <span class="o">*</span><span class="n">ref</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">buffer_ref</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ring_buffer_free_read_page</span><span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ref</span><span class="p">);</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">buffer_pipe_buf_steal</span><span class="p">(</span><span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">pipe_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">buffer_pipe_buf_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">pipe_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_ref</span> <span class="o">*</span><span class="n">ref</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">buffer_ref</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="n">ref</span><span class="o">-&gt;</span><span class="n">ref</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Pipe buffer operations for a buffer. */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pipe_buf_operations</span> <span class="n">buffer_pipe_buf_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">can_merge</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map</span>			<span class="o">=</span> <span class="n">generic_pipe_buf_map</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unmap</span>			<span class="o">=</span> <span class="n">generic_pipe_buf_unmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">confirm</span>		<span class="o">=</span> <span class="n">generic_pipe_buf_confirm</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>		<span class="o">=</span> <span class="n">buffer_pipe_buf_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">steal</span>			<span class="o">=</span> <span class="n">buffer_pipe_buf_steal</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get</span>			<span class="o">=</span> <span class="n">buffer_pipe_buf_get</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Callback from splice_to_pipe(), if we need to release some pages</span>
<span class="cm"> * at the end of the spd in case we error&#39;ed out in filling the pipe.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">buffer_spd_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">splice_pipe_desc</span> <span class="o">*</span><span class="n">spd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_ref</span> <span class="o">*</span><span class="n">ref</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">buffer_ref</span> <span class="o">*</span><span class="p">)</span><span class="n">spd</span><span class="o">-&gt;</span><span class="n">partial</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">private</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ring_buffer_free_read_page</span><span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ref</span><span class="p">);</span>
	<span class="n">spd</span><span class="o">-&gt;</span><span class="n">partial</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">private</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">tracing_buffers_splice_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ftrace_buffer_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">partial_page</span> <span class="n">partial_def</span><span class="p">[</span><span class="n">PIPE_DEF_BUFFERS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pages_def</span><span class="p">[</span><span class="n">PIPE_DEF_BUFFERS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">splice_pipe_desc</span> <span class="n">spd</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">pages</span>		<span class="o">=</span> <span class="n">pages_def</span><span class="p">,</span>
		<span class="p">.</span><span class="n">partial</span>	<span class="o">=</span> <span class="n">partial_def</span><span class="p">,</span>
		<span class="p">.</span><span class="n">nr_pages_max</span>	<span class="o">=</span> <span class="n">PIPE_DEF_BUFFERS</span><span class="p">,</span>
		<span class="p">.</span><span class="n">flags</span>		<span class="o">=</span> <span class="n">flags</span><span class="p">,</span>
		<span class="p">.</span><span class="n">ops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">buffer_pipe_buf_ops</span><span class="p">,</span>
		<span class="p">.</span><span class="n">spd_release</span>	<span class="o">=</span> <span class="n">buffer_spd_release</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">buffer_ref</span> <span class="o">*</span><span class="n">ref</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">entries</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">splice_grow_spd</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spd</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ppos</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WARN_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Ftrace: previous read must page-align</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WARN_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Ftrace: splice_read should page-align</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">len</span> <span class="o">&amp;=</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">trace_access_lock</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">entries</span> <span class="o">=</span> <span class="n">ring_buffer_entries_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">buffers</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">len</span> <span class="o">-=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

		<span class="n">ref</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ref</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ref</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">ref</span><span class="o">-&gt;</span><span class="n">ref</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ref</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">tr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">;</span>
		<span class="n">ref</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">ring_buffer_alloc_read_page</span><span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">ref</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">r</span> <span class="o">=</span> <span class="n">ring_buffer_read_page</span><span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">,</span>
					  <span class="n">len</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ring_buffer_free_read_page</span><span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">ref</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * zero out any left over data, this is going to</span>
<span class="cm">		 * user land.</span>
<span class="cm">		 */</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">ring_buffer_page_len</span><span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">+</span> <span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">size</span><span class="p">);</span>

		<span class="n">page</span> <span class="o">=</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>

		<span class="n">spd</span><span class="p">.</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
		<span class="n">spd</span><span class="p">.</span><span class="n">partial</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="n">spd</span><span class="p">.</span><span class="n">partial</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spd</span><span class="p">.</span><span class="n">partial</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">private</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ref</span><span class="p">;</span>
		<span class="n">spd</span><span class="p">.</span><span class="n">nr_pages</span><span class="o">++</span><span class="p">;</span>
		<span class="o">*</span><span class="n">ppos</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

		<span class="n">entries</span> <span class="o">=</span> <span class="n">ring_buffer_entries_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">trace_access_unlock</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">spd</span><span class="p">.</span><span class="n">nr_pages</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* did we read anything? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spd</span><span class="p">.</span><span class="n">nr_pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SPLICE_F_NONBLOCK</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* TODO: block */</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">splice_to_pipe</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spd</span><span class="p">);</span>
	<span class="n">splice_shrink_spd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spd</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">tracing_buffers_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">tracing_buffers_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">tracing_buffers_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">tracing_buffers_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">splice_read</span>	<span class="o">=</span> <span class="n">tracing_buffers_splice_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">tracing_stats_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
		   <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">trace_array</span> <span class="o">*</span><span class="n">tr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">global_trace</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">trace_seq</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">t</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">usec_rem</span><span class="p">;</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">trace_seq_init</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

	<span class="n">cnt</span> <span class="o">=</span> <span class="n">ring_buffer_entries_cpu</span><span class="p">(</span><span class="n">tr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">trace_seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;entries: %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>

	<span class="n">cnt</span> <span class="o">=</span> <span class="n">ring_buffer_overrun_cpu</span><span class="p">(</span><span class="n">tr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">trace_seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;overrun: %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>

	<span class="n">cnt</span> <span class="o">=</span> <span class="n">ring_buffer_commit_overrun_cpu</span><span class="p">(</span><span class="n">tr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">trace_seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;commit overrun: %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>

	<span class="n">cnt</span> <span class="o">=</span> <span class="n">ring_buffer_bytes_cpu</span><span class="p">(</span><span class="n">tr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">trace_seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;bytes: %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>

	<span class="n">t</span> <span class="o">=</span> <span class="n">ns2usecs</span><span class="p">(</span><span class="n">ring_buffer_oldest_event_ts</span><span class="p">(</span><span class="n">tr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">cpu</span><span class="p">));</span>
	<span class="n">usec_rem</span> <span class="o">=</span> <span class="n">do_div</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">USEC_PER_SEC</span><span class="p">);</span>
	<span class="n">trace_seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;oldest event ts: %5llu.%06lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">usec_rem</span><span class="p">);</span>

	<span class="n">t</span> <span class="o">=</span> <span class="n">ns2usecs</span><span class="p">(</span><span class="n">ring_buffer_time_stamp</span><span class="p">(</span><span class="n">tr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">cpu</span><span class="p">));</span>
	<span class="n">usec_rem</span> <span class="o">=</span> <span class="n">do_div</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">USEC_PER_SEC</span><span class="p">);</span>
	<span class="n">trace_seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;now ts: %5llu.%06lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">usec_rem</span><span class="p">);</span>

	<span class="n">count</span> <span class="o">=</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">tracing_stats_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">tracing_open_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">tracing_stats_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_DYNAMIC_FTRACE</span>

<span class="kt">int</span> <span class="n">__weak</span> <span class="nf">ftrace_arch_read_dyn_info</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">tracing_read_dyn_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
		  <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="n">ftrace_dyn_info_buffer</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
	<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">dyn_info_mutex</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">ftrace_dyn_info_buffer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">ftrace_dyn_info_buffer</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dyn_info_mutex</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%ld &quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">+=</span> <span class="n">ftrace_arch_read_dyn_info</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">r</span><span class="p">);</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">r</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dyn_info_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">tracing_dyn_info_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">tracing_open_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">tracing_read_dyn_info</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d_tracer</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">tracing_init_dentry</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">once</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">d_tracer</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">d_tracer</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debugfs_initialized</span><span class="p">())</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">d_tracer</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="s">&quot;tracing&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d_tracer</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">once</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">once</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Could not create debugfs directory &#39;tracing&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">d_tracer</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d_percpu</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">tracing_dentry_percpu</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">once</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d_tracer</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">d_percpu</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">d_percpu</span><span class="p">;</span>

	<span class="n">d_tracer</span> <span class="o">=</span> <span class="n">tracing_init_dentry</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d_tracer</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">d_percpu</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="s">&quot;per_cpu&quot;</span><span class="p">,</span> <span class="n">d_tracer</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d_percpu</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">once</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">once</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Could not create debugfs directory &#39;per_cpu&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">d_percpu</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tracing_init_debugfs_percpu</span><span class="p">(</span><span class="kt">long</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d_percpu</span> <span class="o">=</span> <span class="n">tracing_dentry_percpu</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d_cpu</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">cpu_dir</span><span class="p">[</span><span class="mi">30</span><span class="p">];</span> <span class="cm">/* 30 characters should be more than enough */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d_percpu</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">cpu_dir</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="s">&quot;cpu%ld&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">d_cpu</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="n">cpu_dir</span><span class="p">,</span> <span class="n">d_percpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d_cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Could not create debugfs &#39;%s&#39; entry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu_dir</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* per cpu trace_pipe */</span>
	<span class="n">trace_create_file</span><span class="p">(</span><span class="s">&quot;trace_pipe&quot;</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">d_cpu</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tracing_pipe_fops</span><span class="p">);</span>

	<span class="cm">/* per cpu trace */</span>
	<span class="n">trace_create_file</span><span class="p">(</span><span class="s">&quot;trace&quot;</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">d_cpu</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tracing_fops</span><span class="p">);</span>

	<span class="n">trace_create_file</span><span class="p">(</span><span class="s">&quot;trace_pipe_raw&quot;</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">d_cpu</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tracing_buffers_fops</span><span class="p">);</span>

	<span class="n">trace_create_file</span><span class="p">(</span><span class="s">&quot;stats&quot;</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">d_cpu</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tracing_stats_fops</span><span class="p">);</span>

	<span class="n">trace_create_file</span><span class="p">(</span><span class="s">&quot;buffer_size_kb&quot;</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">d_cpu</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tracing_entries_fops</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_FTRACE_SELFTEST</span>
<span class="cm">/* Let selftest have access to static functions in this file */</span>
<span class="cp">#include &quot;trace_selftest.c&quot;</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">trace_option_dentry</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">tracer_opt</span>		<span class="o">*</span><span class="n">opt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tracer_flags</span>		<span class="o">*</span><span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span>			<span class="o">*</span><span class="n">entry</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">trace_options_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span>
			<span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trace_option_dentry</span> <span class="o">*</span><span class="n">topt</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">topt</span><span class="o">-&gt;</span><span class="n">flags</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">topt</span><span class="o">-&gt;</span><span class="n">opt</span><span class="o">-&gt;</span><span class="n">bit</span><span class="p">)</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="s">&quot;1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="s">&quot;0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">trace_options_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span>
			 <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trace_option_dentry</span> <span class="o">*</span><span class="n">topt</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">kstrtoul_from_user</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">val</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!!</span><span class="p">(</span><span class="n">topt</span><span class="o">-&gt;</span><span class="n">flags</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">topt</span><span class="o">-&gt;</span><span class="n">opt</span><span class="o">-&gt;</span><span class="n">bit</span><span class="p">)</span> <span class="o">!=</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__set_tracer_option</span><span class="p">(</span><span class="n">current_trace</span><span class="p">,</span> <span class="n">topt</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span>
					  <span class="n">topt</span><span class="o">-&gt;</span><span class="n">opt</span><span class="p">,</span> <span class="o">!</span><span class="n">val</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_types_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">ppos</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">trace_options_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">tracing_open_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">trace_options_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">trace_options_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>	<span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">trace_options_core_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span>
			<span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trace_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">index</span><span class="p">))</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="s">&quot;1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="s">&quot;0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">trace_options_core_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span>
			 <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">kstrtoul_from_user</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">val</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">set_tracer_flags</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">index</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

	<span class="o">*</span><span class="n">ppos</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">trace_options_core_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">tracing_open_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">trace_options_core_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">trace_options_core_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">trace_create_file</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				 <span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
				 <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span><span class="n">fops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Could not create debugfs &#39;%s&#39; entry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">trace_options_init_dentry</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d_tracer</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">t_options</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">t_options</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">t_options</span><span class="p">;</span>

	<span class="n">d_tracer</span> <span class="o">=</span> <span class="n">tracing_init_dentry</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d_tracer</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">t_options</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="s">&quot;options&quot;</span><span class="p">,</span> <span class="n">d_tracer</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t_options</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Could not create debugfs directory &#39;options&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">t_options</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">create_trace_option_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_option_dentry</span> <span class="o">*</span><span class="n">topt</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">tracer_flags</span> <span class="o">*</span><span class="n">flags</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">tracer_opt</span> <span class="o">*</span><span class="n">opt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">t_options</span><span class="p">;</span>

	<span class="n">t_options</span> <span class="o">=</span> <span class="n">trace_options_init_dentry</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t_options</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">topt</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">topt</span><span class="o">-&gt;</span><span class="n">opt</span> <span class="o">=</span> <span class="n">opt</span><span class="p">;</span>

	<span class="n">topt</span><span class="o">-&gt;</span><span class="n">entry</span> <span class="o">=</span> <span class="n">trace_create_file</span><span class="p">(</span><span class="n">opt</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">t_options</span><span class="p">,</span> <span class="n">topt</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">trace_options_fops</span><span class="p">);</span>

<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">trace_option_dentry</span> <span class="o">*</span>
<span class="nf">create_trace_option_files</span><span class="p">(</span><span class="k">struct</span> <span class="n">tracer</span> <span class="o">*</span><span class="n">tracer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trace_option_dentry</span> <span class="o">*</span><span class="n">topts</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tracer_flags</span> <span class="o">*</span><span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tracer_opt</span> <span class="o">*</span><span class="n">opts</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tracer</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">flags</span> <span class="o">=</span> <span class="n">tracer</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">flags</span> <span class="o">||</span> <span class="o">!</span><span class="n">flags</span><span class="o">-&gt;</span><span class="n">opts</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">opts</span> <span class="o">=</span> <span class="n">flags</span><span class="o">-&gt;</span><span class="n">opts</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">opts</span><span class="p">[</span><span class="n">cnt</span><span class="p">].</span><span class="n">name</span><span class="p">;</span> <span class="n">cnt</span><span class="o">++</span><span class="p">)</span>
		<span class="p">;</span>

	<span class="n">topts</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">topts</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">topts</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">opts</span><span class="p">[</span><span class="n">cnt</span><span class="p">].</span><span class="n">name</span><span class="p">;</span> <span class="n">cnt</span><span class="o">++</span><span class="p">)</span>
		<span class="n">create_trace_option_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">topts</span><span class="p">[</span><span class="n">cnt</span><span class="p">],</span> <span class="n">flags</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">opts</span><span class="p">[</span><span class="n">cnt</span><span class="p">]);</span>

	<span class="k">return</span> <span class="n">topts</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">destroy_trace_option_files</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_option_dentry</span> <span class="o">*</span><span class="n">topts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">topts</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">topts</span><span class="p">[</span><span class="n">cnt</span><span class="p">].</span><span class="n">opt</span><span class="p">;</span> <span class="n">cnt</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">topts</span><span class="p">[</span><span class="n">cnt</span><span class="p">].</span><span class="n">entry</span><span class="p">)</span>
			<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">topts</span><span class="p">[</span><span class="n">cnt</span><span class="p">].</span><span class="n">entry</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">topts</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span>
<span class="nf">create_trace_option_core_file</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">option</span><span class="p">,</span> <span class="kt">long</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">t_options</span><span class="p">;</span>

	<span class="n">t_options</span> <span class="o">=</span> <span class="n">trace_options_init_dentry</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t_options</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">trace_create_file</span><span class="p">(</span><span class="n">option</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">t_options</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">index</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">trace_options_core_fops</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">void</span> <span class="nf">create_trace_options_dir</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">t_options</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">t_options</span> <span class="o">=</span> <span class="n">trace_options_init_dentry</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t_options</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">trace_options</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">create_trace_option_core_file</span><span class="p">(</span><span class="n">trace_options</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">rb_simple_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
	       <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trace_array</span> <span class="o">*</span><span class="n">tr</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">tr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span><span class="p">)</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">ring_buffer_record_is_on</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">rb_simple_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trace_array</span> <span class="o">*</span><span class="n">tr</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">tr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">kstrtoul_from_user</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span>
			<span class="n">ring_buffer_record_on</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ring_buffer_record_off</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="p">(</span><span class="o">*</span><span class="n">ppos</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">rb_simple_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">tracing_open_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">rb_simple_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">rb_simple_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">default_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">tracer_init_debugfs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d_tracer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">trace_access_lock_init</span><span class="p">();</span>

	<span class="n">d_tracer</span> <span class="o">=</span> <span class="n">tracing_init_dentry</span><span class="p">();</span>

	<span class="n">trace_create_file</span><span class="p">(</span><span class="s">&quot;tracing_enabled&quot;</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">d_tracer</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">global_trace</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tracing_ctrl_fops</span><span class="p">);</span>

	<span class="n">trace_create_file</span><span class="p">(</span><span class="s">&quot;trace_options&quot;</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">d_tracer</span><span class="p">,</span>
			<span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tracing_iter_fops</span><span class="p">);</span>

	<span class="n">trace_create_file</span><span class="p">(</span><span class="s">&quot;tracing_cpumask&quot;</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">d_tracer</span><span class="p">,</span>
			<span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tracing_cpumask_fops</span><span class="p">);</span>

	<span class="n">trace_create_file</span><span class="p">(</span><span class="s">&quot;trace&quot;</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">d_tracer</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">TRACE_PIPE_ALL_CPU</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tracing_fops</span><span class="p">);</span>

	<span class="n">trace_create_file</span><span class="p">(</span><span class="s">&quot;available_tracers&quot;</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">d_tracer</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">global_trace</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">show_traces_fops</span><span class="p">);</span>

	<span class="n">trace_create_file</span><span class="p">(</span><span class="s">&quot;current_tracer&quot;</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">d_tracer</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">global_trace</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">set_tracer_fops</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_TRACER_MAX_TRACE</span>
	<span class="n">trace_create_file</span><span class="p">(</span><span class="s">&quot;tracing_max_latency&quot;</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">d_tracer</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">tracing_max_latency</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tracing_max_lat_fops</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">trace_create_file</span><span class="p">(</span><span class="s">&quot;tracing_thresh&quot;</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">d_tracer</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">tracing_thresh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tracing_max_lat_fops</span><span class="p">);</span>

	<span class="n">trace_create_file</span><span class="p">(</span><span class="s">&quot;README&quot;</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">d_tracer</span><span class="p">,</span>
			<span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tracing_readme_fops</span><span class="p">);</span>

	<span class="n">trace_create_file</span><span class="p">(</span><span class="s">&quot;trace_pipe&quot;</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">d_tracer</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">TRACE_PIPE_ALL_CPU</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tracing_pipe_fops</span><span class="p">);</span>

	<span class="n">trace_create_file</span><span class="p">(</span><span class="s">&quot;buffer_size_kb&quot;</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">d_tracer</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">RING_BUFFER_ALL_CPUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tracing_entries_fops</span><span class="p">);</span>

	<span class="n">trace_create_file</span><span class="p">(</span><span class="s">&quot;buffer_total_size_kb&quot;</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">d_tracer</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">global_trace</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tracing_total_entries_fops</span><span class="p">);</span>

	<span class="n">trace_create_file</span><span class="p">(</span><span class="s">&quot;free_buffer&quot;</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">d_tracer</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">global_trace</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tracing_free_buffer_fops</span><span class="p">);</span>

	<span class="n">trace_create_file</span><span class="p">(</span><span class="s">&quot;trace_marker&quot;</span><span class="p">,</span> <span class="mo">0220</span><span class="p">,</span> <span class="n">d_tracer</span><span class="p">,</span>
			<span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tracing_mark_fops</span><span class="p">);</span>

	<span class="n">trace_create_file</span><span class="p">(</span><span class="s">&quot;saved_cmdlines&quot;</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">d_tracer</span><span class="p">,</span>
			<span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tracing_saved_cmdlines_fops</span><span class="p">);</span>

	<span class="n">trace_create_file</span><span class="p">(</span><span class="s">&quot;trace_clock&quot;</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">d_tracer</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
			  <span class="o">&amp;</span><span class="n">trace_clock_fops</span><span class="p">);</span>

	<span class="n">trace_create_file</span><span class="p">(</span><span class="s">&quot;tracing_on&quot;</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">d_tracer</span><span class="p">,</span>
			    <span class="o">&amp;</span><span class="n">global_trace</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rb_simple_fops</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_DYNAMIC_FTRACE</span>
	<span class="n">trace_create_file</span><span class="p">(</span><span class="s">&quot;dyn_ftrace_total_info&quot;</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">d_tracer</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">ftrace_update_tot_cnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tracing_dyn_info_fops</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">create_trace_options_dir</span><span class="p">();</span>

	<span class="n">for_each_tracing_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">tracing_init_debugfs_percpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">trace_panic_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">event</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ftrace_dump_on_oops</span><span class="p">)</span>
		<span class="n">ftrace_dump</span><span class="p">(</span><span class="n">ftrace_dump_on_oops</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">trace_panic_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span>  <span class="o">=</span> <span class="n">trace_panic_handler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>           <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">priority</span>       <span class="o">=</span> <span class="mi">150</span>   <span class="cm">/* priority: INT_MAX &gt;= x &gt;= 0 */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">trace_die_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span>
			     <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DIE_OOPS</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">ftrace_dump_on_oops</span><span class="p">)</span>
			<span class="n">ftrace_dump</span><span class="p">(</span><span class="n">ftrace_dump_on_oops</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">trace_die_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">trace_die_handler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="mi">200</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * printk is set to max of 1024, we really don&#39;t need it that big.</span>
<span class="cm"> * Nothing should be printing 1000 characters anyway.</span>
<span class="cm"> */</span>
<span class="cp">#define TRACE_MAX_PRINT		1000</span>

<span class="cm">/*</span>
<span class="cm"> * Define here KERN_TRACE so that we have one place to modify</span>
<span class="cm"> * it if we decide to change what log level the ftrace dump</span>
<span class="cm"> * should be at.</span>
<span class="cm"> */</span>
<span class="cp">#define KERN_TRACE		KERN_EMERG</span>

<span class="kt">void</span>
<span class="nf">trace_printk_seq</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_seq</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Probably should print a warning here. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="mi">1000</span><span class="p">)</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>

	<span class="cm">/* should be zero ended, but we are paranoid. */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_TRACE</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>

	<span class="n">trace_seq_init</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">trace_init_global_iter</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_iterator</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">tr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">global_trace</span><span class="p">;</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">trace</span> <span class="o">=</span> <span class="n">current_trace</span><span class="p">;</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">cpu_file</span> <span class="o">=</span> <span class="n">TRACE_PIPE_ALL_CPU</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">__ftrace_dump</span><span class="p">(</span><span class="n">bool</span> <span class="n">disable_tracing</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ftrace_dump_mode</span> <span class="n">oops_dump_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">arch_spinlock_t</span> <span class="n">ftrace_dump_lock</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">arch_spinlock_t</span><span class="p">)</span><span class="n">__ARCH_SPIN_LOCK_UNLOCKED</span><span class="p">;</span>
	<span class="cm">/* use static because iter can be a bit big for the stack */</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">trace_iterator</span> <span class="n">iter</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">old_userobj</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">dump_ran</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="cm">/* only one dump */</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">arch_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_dump_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dump_ran</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">dump_ran</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">tracing_off</span><span class="p">();</span>

	<span class="cm">/* Did function tracer already get disabled? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ftrace_is_dead</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;# WARNING: FUNCTION TRACING IS CORRUPTED</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;#          MAY BE MISSING FUNCTION EVENTS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">disable_tracing</span><span class="p">)</span>
		<span class="n">ftrace_kill</span><span class="p">();</span>

	<span class="n">trace_init_global_iter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="p">);</span>

	<span class="n">for_each_tracing_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="p">.</span><span class="n">tr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">disabled</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">old_userobj</span> <span class="o">=</span> <span class="n">trace_flags</span> <span class="o">&amp;</span> <span class="n">TRACE_ITER_SYM_USEROBJ</span><span class="p">;</span>

	<span class="cm">/* don&#39;t look at user memory in panic mode */</span>
	<span class="n">trace_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TRACE_ITER_SYM_USEROBJ</span><span class="p">;</span>

	<span class="cm">/* Simulate the iterator */</span>
	<span class="n">iter</span><span class="p">.</span><span class="n">tr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">global_trace</span><span class="p">;</span>
	<span class="n">iter</span><span class="p">.</span><span class="n">trace</span> <span class="o">=</span> <span class="n">current_trace</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">oops_dump_mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DUMP_ALL</span>:
		<span class="n">iter</span><span class="p">.</span><span class="n">cpu_file</span> <span class="o">=</span> <span class="n">TRACE_PIPE_ALL_CPU</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DUMP_ORIG</span>:
		<span class="n">iter</span><span class="p">.</span><span class="n">cpu_file</span> <span class="o">=</span> <span class="n">raw_smp_processor_id</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DUMP_NONE</span>:
		<span class="k">goto</span> <span class="n">out_enable</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_TRACE</span> <span class="s">&quot;Bad dumping mode, switching to all CPUs dump</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">iter</span><span class="p">.</span><span class="n">cpu_file</span> <span class="o">=</span> <span class="n">TRACE_PIPE_ALL_CPU</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_TRACE</span> <span class="s">&quot;Dumping ftrace buffer:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to stop all tracing on all CPUS to read the</span>
<span class="cm">	 * the next buffer. This is a bit expensive, but is</span>
<span class="cm">	 * not done often. We fill all what we can read,</span>
<span class="cm">	 * and then release the locks again.</span>
<span class="cm">	 */</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">trace_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="p">))</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cnt</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_TRACE</span> <span class="s">&quot;---------------------------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">cnt</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* reset all but tr, trace, and overruns */</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="p">.</span><span class="n">seq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_iterator</span><span class="p">)</span> <span class="o">-</span>
		       <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_iterator</span><span class="p">,</span> <span class="n">seq</span><span class="p">));</span>
		<span class="n">iter</span><span class="p">.</span><span class="n">iter_flags</span> <span class="o">|=</span> <span class="n">TRACE_FILE_LAT_FMT</span><span class="p">;</span>
		<span class="n">iter</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">trace_find_next_entry_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">print_trace_line</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">TRACE_TYPE_NO_CONSUME</span><span class="p">)</span>
				<span class="n">trace_consume</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">touch_nmi_watchdog</span><span class="p">();</span>

		<span class="n">trace_printk_seq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="p">.</span><span class="n">seq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cnt</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_TRACE</span> <span class="s">&quot;   (ftrace buffer empty)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_TRACE</span> <span class="s">&quot;---------------------------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

 <span class="nl">out_enable:</span>
	<span class="cm">/* Re-enable tracing if requested */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">disable_tracing</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">trace_flags</span> <span class="o">|=</span> <span class="n">old_userobj</span><span class="p">;</span>

		<span class="n">for_each_tracing_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="p">.</span><span class="n">tr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">disabled</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">tracing_on</span><span class="p">();</span>
	<span class="p">}</span>

 <span class="nl">out:</span>
	<span class="n">arch_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftrace_dump_lock</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* By default: disable tracing after the dump */</span>
<span class="kt">void</span> <span class="nf">ftrace_dump</span><span class="p">(</span><span class="k">enum</span> <span class="n">ftrace_dump_mode</span> <span class="n">oops_dump_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__ftrace_dump</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">oops_dump_mode</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ftrace_dump</span><span class="p">);</span>

<span class="n">__init</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">tracer_alloc_buffers</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ring_buf_size</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ring_buffer_flags</span> <span class="n">rb_flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>


	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tracing_buffer_mask</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tracing_cpumask</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_free_buffer_mask</span><span class="p">;</span>

	<span class="cm">/* Only allocate trace_printk buffers if a trace_printk exists */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__stop___trace_bprintk_fmt</span> <span class="o">!=</span> <span class="n">__start___trace_bprintk_fmt</span><span class="p">)</span>
		<span class="n">trace_printk_init_buffers</span><span class="p">();</span>

	<span class="cm">/* To save memory, keep the ring buffer size to its minimum */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ring_buffer_expanded</span><span class="p">)</span>
		<span class="n">ring_buf_size</span> <span class="o">=</span> <span class="n">trace_buf_size</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ring_buf_size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">rb_flags</span> <span class="o">=</span> <span class="n">trace_flags</span> <span class="o">&amp;</span> <span class="n">TRACE_ITER_OVERWRITE</span> <span class="o">?</span> <span class="n">RB_FL_OVERWRITE</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">tracing_buffer_mask</span><span class="p">,</span> <span class="n">cpu_possible_mask</span><span class="p">);</span>
	<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">tracing_cpumask</span><span class="p">,</span> <span class="n">cpu_all_mask</span><span class="p">);</span>

	<span class="cm">/* TODO: make the number of buffers hot pluggable with CPUS */</span>
	<span class="n">global_trace</span><span class="p">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">ring_buffer_alloc</span><span class="p">(</span><span class="n">ring_buf_size</span><span class="p">,</span> <span class="n">rb_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">global_trace</span><span class="p">.</span><span class="n">buffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;tracer: failed to allocate ring buffer!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_cpumask</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">global_trace</span><span class="p">.</span><span class="n">buffer_disabled</span><span class="p">)</span>
		<span class="n">tracing_off</span><span class="p">();</span>


<span class="cp">#ifdef CONFIG_TRACER_MAX_TRACE</span>
	<span class="n">max_tr</span><span class="p">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">ring_buffer_alloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">rb_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">max_tr</span><span class="p">.</span><span class="n">buffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;tracer: failed to allocate max ring buffer!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">ring_buffer_free</span><span class="p">(</span><span class="n">global_trace</span><span class="p">.</span><span class="n">buffer</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_cpumask</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* Allocate the first page for all buffers */</span>
	<span class="n">for_each_tracing_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">global_trace</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">global_trace_cpu</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">max_tr</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">max_tr_data</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">set_buffer_entries</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global_trace</span><span class="p">,</span>
			   <span class="n">ring_buffer_size</span><span class="p">(</span><span class="n">global_trace</span><span class="p">.</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
<span class="cp">#ifdef CONFIG_TRACER_MAX_TRACE</span>
	<span class="n">set_buffer_entries</span><span class="p">(</span><span class="o">&amp;</span><span class="n">max_tr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">trace_init_cmdlines</span><span class="p">();</span>

	<span class="n">register_tracer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nop_trace</span><span class="p">);</span>
	<span class="n">current_trace</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nop_trace</span><span class="p">;</span>
	<span class="cm">/* All seems OK, enable tracing */</span>
	<span class="n">tracing_disabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">atomic_notifier_chain_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">panic_notifier_list</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">trace_panic_notifier</span><span class="p">);</span>

	<span class="n">register_die_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace_die_notifier</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_free_cpumask:</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">tracing_cpumask</span><span class="p">);</span>
<span class="nl">out_free_buffer_mask:</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">tracing_buffer_mask</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__init</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">clear_boot_tracer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The default tracer at boot buffer is an init section.</span>
<span class="cm">	 * This function is called in lateinit. If we did not</span>
<span class="cm">	 * find the boot tracer, then clear it out, to prevent</span>
<span class="cm">	 * later registration from accessing the buffer that is</span>
<span class="cm">	 * about to be freed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">default_bootup_tracer</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;ftrace bootup tracer &#39;%s&#39; not registered.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">default_bootup_tracer</span><span class="p">);</span>
	<span class="n">default_bootup_tracer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">early_initcall</span><span class="p">(</span><span class="n">tracer_alloc_buffers</span><span class="p">);</span>
<span class="n">fs_initcall</span><span class="p">(</span><span class="n">tracer_init_debugfs</span><span class="p">);</span>
<span class="n">late_initcall</span><span class="p">(</span><span class="n">clear_boot_tracer</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
