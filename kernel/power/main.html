<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › power › main.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>main.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * kernel/power/main.c - PM subsystem core functionality.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2003 Patrick Mochel</span>
<span class="cm"> * Copyright (c) 2003 Open Source Development Lab</span>
<span class="cm"> *</span>
<span class="cm"> * This file is released under the GPLv2</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/kobject.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/resume-trace.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>

<span class="cp">#include &quot;power.h&quot;</span>

<span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">pm_mutex</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PM_SLEEP</span>

<span class="cm">/* Routines for PM-transition notifications */</span>

<span class="k">static</span> <span class="n">BLOCKING_NOTIFIER_HEAD</span><span class="p">(</span><span class="n">pm_chain_head</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">register_pm_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">blocking_notifier_chain_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pm_chain_head</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">register_pm_notifier</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">unregister_pm_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">blocking_notifier_chain_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pm_chain_head</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">unregister_pm_notifier</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">pm_notifier_call_chain</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">blocking_notifier_call_chain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pm_chain_head</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">notifier_to_errno</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* If set, devices may be suspended and resumed asynchronously. */</span>
<span class="kt">int</span> <span class="n">pm_async_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">pm_async_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			     <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pm_async_enabled</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">pm_async_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strict_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">pm_async_enabled</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">power_attr</span><span class="p">(</span><span class="n">pm_async</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PM_DEBUG</span>
<span class="kt">int</span> <span class="n">pm_test_level</span> <span class="o">=</span> <span class="n">TEST_NONE</span><span class="p">;</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">pm_tests</span><span class="p">[</span><span class="n">__TEST_AFTER_LAST</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">TEST_NONE</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;none&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">TEST_CORE</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;core&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">TEST_CPUS</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;processors&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">TEST_PLATFORM</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;platform&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">TEST_DEVICES</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;devices&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">TEST_FREEZER</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;freezer&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">pm_test_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">level</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">level</span> <span class="o">=</span> <span class="n">TEST_FIRST</span><span class="p">;</span> <span class="n">level</span> <span class="o">&lt;=</span> <span class="n">TEST_MAX</span><span class="p">;</span> <span class="n">level</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pm_tests</span><span class="p">[</span><span class="n">level</span><span class="p">])</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="n">pm_test_level</span><span class="p">)</span>
				<span class="n">s</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;[%s] &quot;</span><span class="p">,</span> <span class="n">pm_tests</span><span class="p">[</span><span class="n">level</span><span class="p">]);</span>
			<span class="k">else</span>
				<span class="n">s</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;%s &quot;</span><span class="p">,</span> <span class="n">pm_tests</span><span class="p">[</span><span class="n">level</span><span class="p">]);</span>
		<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="n">buf</span><span class="p">)</span>
		<span class="cm">/* convert the last space to a newline */</span>
		<span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">s</span> <span class="o">-</span> <span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">pm_test_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">memchr</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">p</span> <span class="o">?</span> <span class="n">p</span> <span class="o">-</span> <span class="n">buf</span> <span class="o">:</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">lock_system_sleep</span><span class="p">();</span>

	<span class="n">level</span> <span class="o">=</span> <span class="n">TEST_FIRST</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pm_tests</span><span class="p">[</span><span class="n">level</span><span class="p">];</span> <span class="n">level</span> <span class="o">&lt;=</span> <span class="n">TEST_MAX</span><span class="p">;</span> <span class="n">s</span><span class="o">++</span><span class="p">,</span> <span class="n">level</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">==</span> <span class="n">strlen</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pm_test_level</span> <span class="o">=</span> <span class="n">level</span><span class="p">;</span>
			<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="n">unlock_system_sleep</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">error</span> <span class="o">?</span> <span class="n">error</span> <span class="o">:</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">power_attr</span><span class="p">(</span><span class="n">pm_test</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PM_DEBUG */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_DEBUG_FS</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">suspend_step_name</span><span class="p">(</span><span class="k">enum</span> <span class="n">suspend_stat_step</span> <span class="n">step</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">step</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SUSPEND_FREEZE</span>:
		<span class="k">return</span> <span class="s">&quot;freeze&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SUSPEND_PREPARE</span>:
		<span class="k">return</span> <span class="s">&quot;prepare&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SUSPEND_SUSPEND</span>:
		<span class="k">return</span> <span class="s">&quot;suspend&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SUSPEND_SUSPEND_NOIRQ</span>:
		<span class="k">return</span> <span class="s">&quot;suspend_noirq&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SUSPEND_RESUME_NOIRQ</span>:
		<span class="k">return</span> <span class="s">&quot;resume_noirq&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SUSPEND_RESUME</span>:
		<span class="k">return</span> <span class="s">&quot;resume&quot;</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">suspend_stats_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">last_dev</span><span class="p">,</span> <span class="n">last_errno</span><span class="p">,</span> <span class="n">last_step</span><span class="p">;</span>

	<span class="n">last_dev</span> <span class="o">=</span> <span class="n">suspend_stats</span><span class="p">.</span><span class="n">last_failed_dev</span> <span class="o">+</span> <span class="n">REC_FAILED_NUM</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">last_dev</span> <span class="o">%=</span> <span class="n">REC_FAILED_NUM</span><span class="p">;</span>
	<span class="n">last_errno</span> <span class="o">=</span> <span class="n">suspend_stats</span><span class="p">.</span><span class="n">last_failed_errno</span> <span class="o">+</span> <span class="n">REC_FAILED_NUM</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">last_errno</span> <span class="o">%=</span> <span class="n">REC_FAILED_NUM</span><span class="p">;</span>
	<span class="n">last_step</span> <span class="o">=</span> <span class="n">suspend_stats</span><span class="p">.</span><span class="n">last_failed_step</span> <span class="o">+</span> <span class="n">REC_FAILED_NUM</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">last_step</span> <span class="o">%=</span> <span class="n">REC_FAILED_NUM</span><span class="p">;</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;%s: %d</span><span class="se">\n</span><span class="s">%s: %d</span><span class="se">\n</span><span class="s">%s: %d</span><span class="se">\n</span><span class="s">%s: %d</span><span class="se">\n</span><span class="s">%s: %d</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;%s: %d</span><span class="se">\n</span><span class="s">%s: %d</span><span class="se">\n</span><span class="s">%s: %d</span><span class="se">\n</span><span class="s">%s: %d</span><span class="se">\n</span><span class="s">%s: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="s">&quot;success&quot;</span><span class="p">,</span> <span class="n">suspend_stats</span><span class="p">.</span><span class="n">success</span><span class="p">,</span>
			<span class="s">&quot;fail&quot;</span><span class="p">,</span> <span class="n">suspend_stats</span><span class="p">.</span><span class="n">fail</span><span class="p">,</span>
			<span class="s">&quot;failed_freeze&quot;</span><span class="p">,</span> <span class="n">suspend_stats</span><span class="p">.</span><span class="n">failed_freeze</span><span class="p">,</span>
			<span class="s">&quot;failed_prepare&quot;</span><span class="p">,</span> <span class="n">suspend_stats</span><span class="p">.</span><span class="n">failed_prepare</span><span class="p">,</span>
			<span class="s">&quot;failed_suspend&quot;</span><span class="p">,</span> <span class="n">suspend_stats</span><span class="p">.</span><span class="n">failed_suspend</span><span class="p">,</span>
			<span class="s">&quot;failed_suspend_late&quot;</span><span class="p">,</span>
				<span class="n">suspend_stats</span><span class="p">.</span><span class="n">failed_suspend_late</span><span class="p">,</span>
			<span class="s">&quot;failed_suspend_noirq&quot;</span><span class="p">,</span>
				<span class="n">suspend_stats</span><span class="p">.</span><span class="n">failed_suspend_noirq</span><span class="p">,</span>
			<span class="s">&quot;failed_resume&quot;</span><span class="p">,</span> <span class="n">suspend_stats</span><span class="p">.</span><span class="n">failed_resume</span><span class="p">,</span>
			<span class="s">&quot;failed_resume_early&quot;</span><span class="p">,</span>
				<span class="n">suspend_stats</span><span class="p">.</span><span class="n">failed_resume_early</span><span class="p">,</span>
			<span class="s">&quot;failed_resume_noirq&quot;</span><span class="p">,</span>
				<span class="n">suspend_stats</span><span class="p">.</span><span class="n">failed_resume_noirq</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span>	<span class="s">&quot;failures:</span><span class="se">\n</span><span class="s">  last_failed_dev:</span><span class="se">\t</span><span class="s">%-s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">suspend_stats</span><span class="p">.</span><span class="n">failed_devs</span><span class="p">[</span><span class="n">last_dev</span><span class="p">]);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">REC_FAILED_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">last_dev</span> <span class="o">+</span> <span class="n">REC_FAILED_NUM</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">index</span> <span class="o">%=</span> <span class="n">REC_FAILED_NUM</span><span class="p">;</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t\t\t</span><span class="s">%-s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">suspend_stats</span><span class="p">.</span><span class="n">failed_devs</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span>	<span class="s">&quot;  last_failed_errno:</span><span class="se">\t</span><span class="s">%-d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">suspend_stats</span><span class="p">.</span><span class="n">errno</span><span class="p">[</span><span class="n">last_errno</span><span class="p">]);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">REC_FAILED_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">last_errno</span> <span class="o">+</span> <span class="n">REC_FAILED_NUM</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">index</span> <span class="o">%=</span> <span class="n">REC_FAILED_NUM</span><span class="p">;</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t\t\t</span><span class="s">%-d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">suspend_stats</span><span class="p">.</span><span class="n">errno</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span>	<span class="s">&quot;  last_failed_step:</span><span class="se">\t</span><span class="s">%-s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">suspend_step_name</span><span class="p">(</span>
				<span class="n">suspend_stats</span><span class="p">.</span><span class="n">failed_steps</span><span class="p">[</span><span class="n">last_step</span><span class="p">]));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">REC_FAILED_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">last_step</span> <span class="o">+</span> <span class="n">REC_FAILED_NUM</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">index</span> <span class="o">%=</span> <span class="n">REC_FAILED_NUM</span><span class="p">;</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t\t\t</span><span class="s">%-s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">suspend_step_name</span><span class="p">(</span>
				<span class="n">suspend_stats</span><span class="p">.</span><span class="n">failed_steps</span><span class="p">[</span><span class="n">index</span><span class="p">]));</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">suspend_stats_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">suspend_stats_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">suspend_stats_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>           <span class="o">=</span> <span class="n">suspend_stats_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>           <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>         <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>        <span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">pm_debugfs_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debugfs_create_file</span><span class="p">(</span><span class="s">&quot;suspend_stats&quot;</span><span class="p">,</span> <span class="n">S_IFREG</span> <span class="o">|</span> <span class="n">S_IRUGO</span><span class="p">,</span>
			<span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">suspend_stats_operations</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">late_initcall</span><span class="p">(</span><span class="n">pm_debugfs_init</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_DEBUG_FS */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_PM_SLEEP */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">power_kobj</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> *	state - control system power state.</span>
<span class="cm"> *</span>
<span class="cm"> *	show() returns what states are supported, which is hard-coded to</span>
<span class="cm"> *	&#39;standby&#39; (Power-On Suspend), &#39;mem&#39; (Suspend-to-RAM), and</span>
<span class="cm"> *	&#39;disk&#39; (Suspend-to-Disk).</span>
<span class="cm"> *</span>
<span class="cm"> *	store() accepts one of those strings, translates it into the</span>
<span class="cm"> *	proper enumerated value, and initiates a suspend transition.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">state_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			  <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SUSPEND</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PM_SUSPEND_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pm_states</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">valid_state</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
			<span class="n">s</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="s">&quot;%s &quot;</span><span class="p">,</span> <span class="n">pm_states</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_HIBERNATION</span>
	<span class="n">s</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;disk&quot;</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="n">buf</span><span class="p">)</span>
		<span class="cm">/* convert the last space to a newline */</span>
		<span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">s</span> <span class="o">-</span> <span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">suspend_state_t</span> <span class="nf">decode_state</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SUSPEND</span>
	<span class="n">suspend_state_t</span> <span class="n">state</span> <span class="o">=</span> <span class="n">PM_SUSPEND_STANDBY</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">memchr</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">p</span> <span class="o">?</span> <span class="n">p</span> <span class="o">-</span> <span class="n">buf</span> <span class="o">:</span> <span class="n">n</span><span class="p">;</span>

	<span class="cm">/* Check hibernation first. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;disk&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PM_SUSPEND_MAX</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SUSPEND</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pm_states</span><span class="p">[</span><span class="n">state</span><span class="p">];</span> <span class="n">state</span> <span class="o">&lt;</span> <span class="n">PM_SUSPEND_MAX</span><span class="p">;</span> <span class="n">s</span><span class="o">++</span><span class="p">,</span> <span class="n">state</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">==</span> <span class="n">strlen</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">state</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="n">PM_SUSPEND_ON</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">state_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">suspend_state_t</span> <span class="n">state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">pm_autosleep_lock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pm_autosleep_state</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">PM_SUSPEND_ON</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">state</span> <span class="o">=</span> <span class="n">decode_state</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">&lt;</span> <span class="n">PM_SUSPEND_MAX</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">pm_suspend</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">PM_SUSPEND_MAX</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">hibernate</span><span class="p">();</span>
	<span class="k">else</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

 <span class="nl">out:</span>
	<span class="n">pm_autosleep_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">error</span> <span class="o">?</span> <span class="n">error</span> <span class="o">:</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">power_attr</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PM_SLEEP</span>
<span class="cm">/*</span>
<span class="cm"> * The &#39;wakeup_count&#39; attribute, along with the functions defined in</span>
<span class="cm"> * drivers/base/power/wakeup.c, provides a means by which wakeup events can be</span>
<span class="cm"> * handled in a non-racy way.</span>
<span class="cm"> *</span>
<span class="cm"> * If a wakeup event occurs when the system is in a sleep state, it simply is</span>
<span class="cm"> * woken up.  In turn, if an event that would wake the system up from a sleep</span>
<span class="cm"> * state occurs when it is undergoing a transition to that sleep state, the</span>
<span class="cm"> * transition should be aborted.  Moreover, if such an event occurs when the</span>
<span class="cm"> * system is in the working state, an attempt to start a transition to the</span>
<span class="cm"> * given sleep state should fail during certain period after the detection of</span>
<span class="cm"> * the event.  Using the &#39;state&#39; attribute alone is not sufficient to satisfy</span>
<span class="cm"> * these requirements, because a wakeup event may occur exactly when &#39;state&#39;</span>
<span class="cm"> * is being written to and may be delivered to user space right before it is</span>
<span class="cm"> * frozen, so the event will remain only partially processed until the system is</span>
<span class="cm"> * woken up by another event.  In particular, it won&#39;t cause the transition to</span>
<span class="cm"> * a sleep state to be aborted.</span>
<span class="cm"> *</span>
<span class="cm"> * This difficulty may be overcome if user space uses &#39;wakeup_count&#39; before</span>
<span class="cm"> * writing to &#39;state&#39;.  It first should read from &#39;wakeup_count&#39; and store</span>
<span class="cm"> * the read value.  Then, after carrying out its own preparations for the system</span>
<span class="cm"> * transition to a sleep state, it should write the stored value to</span>
<span class="cm"> * &#39;wakeup_count&#39;.  If that fails, at least one wakeup event has occurred since</span>
<span class="cm"> * &#39;wakeup_count&#39; was read and &#39;state&#39; should not be written to.  Otherwise, it</span>
<span class="cm"> * is allowed to write to &#39;state&#39;, but the transition will be aborted if there</span>
<span class="cm"> * are any wakeup events detected after &#39;wakeup_count&#39; was written to.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">wakeup_count_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">pm_get_wakeup_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="nb">true</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">wakeup_count_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">pm_autosleep_lock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pm_autosleep_state</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">PM_SUSPEND_ON</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%u&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pm_save_wakeup_count</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="p">}</span>

 <span class="nl">out:</span>
	<span class="n">pm_autosleep_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">power_attr</span><span class="p">(</span><span class="n">wakeup_count</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PM_AUTOSLEEP</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">autosleep_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			      <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">suspend_state_t</span> <span class="n">state</span> <span class="o">=</span> <span class="n">pm_autosleep_state</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">PM_SUSPEND_ON</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;off</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SUSPEND</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">&lt;</span> <span class="n">PM_SUSPEND_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">valid_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="o">?</span>
						<span class="n">pm_states</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">:</span> <span class="s">&quot;error&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_HIBERNATION</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;disk</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;error&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">autosleep_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">suspend_state_t</span> <span class="n">state</span> <span class="o">=</span> <span class="n">decode_state</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">PM_SUSPEND_ON</span>
	    <span class="o">&amp;&amp;</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;off&quot;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;off</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">pm_autosleep_set_state</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span> <span class="o">?</span> <span class="n">error</span> <span class="o">:</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">power_attr</span><span class="p">(</span><span class="n">autosleep</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PM_AUTOSLEEP */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_PM_WAKELOCKS</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">wake_lock_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			      <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pm_show_wakelocks</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">wake_lock_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="n">pm_wake_lock</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span> <span class="o">?</span> <span class="n">error</span> <span class="o">:</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">power_attr</span><span class="p">(</span><span class="n">wake_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">wake_unlock_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pm_show_wakelocks</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">wake_unlock_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="n">pm_wake_unlock</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span> <span class="o">?</span> <span class="n">error</span> <span class="o">:</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">power_attr</span><span class="p">(</span><span class="n">wake_unlock</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_PM_WAKELOCKS */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PM_SLEEP */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_PM_TRACE</span>
<span class="kt">int</span> <span class="n">pm_trace_enabled</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">pm_trace_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			     <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pm_trace_enabled</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">pm_trace_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
	       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pm_trace_enabled</span> <span class="o">=</span> <span class="o">!!</span><span class="n">val</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">power_attr</span><span class="p">(</span><span class="n">pm_trace</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">pm_trace_dev_match_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				       <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">show_trace_dev_match</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">pm_trace_dev_match_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">power_attr</span><span class="p">(</span><span class="n">pm_trace_dev_match</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_PM_TRACE */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span> <span class="n">g</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">state_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_PM_TRACE</span>
	<span class="o">&amp;</span><span class="n">pm_trace_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">pm_trace_dev_match_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_PM_SLEEP</span>
	<span class="o">&amp;</span><span class="n">pm_async_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">wakeup_count_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_PM_AUTOSLEEP</span>
	<span class="o">&amp;</span><span class="n">autosleep_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_PM_WAKELOCKS</span>
	<span class="o">&amp;</span><span class="n">wake_lock_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">wake_unlock_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_PM_DEBUG</span>
	<span class="o">&amp;</span><span class="n">pm_test_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="n">attr_group</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">g</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_PM_RUNTIME</span>
<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">pm_wq</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pm_wq</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">pm_start_workqueue</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pm_wq</span> <span class="o">=</span> <span class="n">alloc_workqueue</span><span class="p">(</span><span class="s">&quot;pm&quot;</span><span class="p">,</span> <span class="n">WQ_FREEZABLE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pm_wq</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pm_start_workqueue</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">pm_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="n">pm_start_workqueue</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">hibernate_image_size_init</span><span class="p">();</span>
	<span class="n">hibernate_reserved_size_init</span><span class="p">();</span>
	<span class="n">power_kobj</span> <span class="o">=</span> <span class="n">kobject_create_and_add</span><span class="p">(</span><span class="s">&quot;power&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">power_kobj</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">sysfs_create_group</span><span class="p">(</span><span class="n">power_kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr_group</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">pm_autosleep_init</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">core_initcall</span><span class="p">(</span><span class="n">pm_init</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
