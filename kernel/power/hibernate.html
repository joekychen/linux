<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › power › hibernate.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>hibernate.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * kernel/power/hibernate.c - Hibernation (a.k.a suspend-to-disk) support.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2003 Patrick Mochel</span>
<span class="cm"> * Copyright (c) 2003 Open Source Development Lab</span>
<span class="cm"> * Copyright (c) 2004 Pavel Machek &lt;pavel@ucw.cz&gt;</span>
<span class="cm"> * Copyright (c) 2009 Rafael J. Wysocki, Novell Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This file is released under the GPLv2.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/suspend.h&gt;</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/reboot.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/async.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &lt;linux/pm.h&gt;</span>
<span class="cp">#include &lt;linux/console.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/freezer.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;linux/syscore_ops.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/genhd.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_scan.h&gt;</span>

<span class="cp">#include &quot;power.h&quot;</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">nocompress</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">noresume</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">resume_wait</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">resume_delay</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">resume_file</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span> <span class="o">=</span> <span class="n">CONFIG_PM_STD_PARTITION</span><span class="p">;</span>
<span class="n">dev_t</span> <span class="n">swsusp_resume_device</span><span class="p">;</span>
<span class="n">sector_t</span> <span class="n">swsusp_resume_block</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">in_suspend</span> <span class="n">__nosavedata</span><span class="p">;</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">HIBERNATION_INVALID</span><span class="p">,</span>
	<span class="n">HIBERNATION_PLATFORM</span><span class="p">,</span>
	<span class="n">HIBERNATION_SHUTDOWN</span><span class="p">,</span>
	<span class="n">HIBERNATION_REBOOT</span><span class="p">,</span>
	<span class="cm">/* keep last */</span>
	<span class="n">__HIBERNATION_AFTER_LAST</span>
<span class="p">};</span>
<span class="cp">#define HIBERNATION_MAX (__HIBERNATION_AFTER_LAST-1)</span>
<span class="cp">#define HIBERNATION_FIRST (HIBERNATION_INVALID + 1)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">hibernation_mode</span> <span class="o">=</span> <span class="n">HIBERNATION_SHUTDOWN</span><span class="p">;</span>

<span class="n">bool</span> <span class="n">freezer_test_done</span><span class="p">;</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">platform_hibernation_ops</span> <span class="o">*</span><span class="n">hibernation_ops</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * hibernation_set_ops - Set the global hibernate operations.</span>
<span class="cm"> * @ops: Hibernation operations to use in subsequent hibernation transitions.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">hibernation_set_ops</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">platform_hibernation_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ops</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">begin</span> <span class="o">&amp;&amp;</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">&amp;&amp;</span>  <span class="n">ops</span><span class="o">-&gt;</span><span class="n">pre_snapshot</span>
	    <span class="o">&amp;&amp;</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">prepare</span> <span class="o">&amp;&amp;</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">finish</span> <span class="o">&amp;&amp;</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">enter</span> <span class="o">&amp;&amp;</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">pre_restore</span>
	    <span class="o">&amp;&amp;</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">restore_cleanup</span> <span class="o">&amp;&amp;</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">leave</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lock_system_sleep</span><span class="p">();</span>
	<span class="n">hibernation_ops</span> <span class="o">=</span> <span class="n">ops</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="p">)</span>
		<span class="n">hibernation_mode</span> <span class="o">=</span> <span class="n">HIBERNATION_PLATFORM</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hibernation_mode</span> <span class="o">==</span> <span class="n">HIBERNATION_PLATFORM</span><span class="p">)</span>
		<span class="n">hibernation_mode</span> <span class="o">=</span> <span class="n">HIBERNATION_SHUTDOWN</span><span class="p">;</span>

	<span class="n">unlock_system_sleep</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">entering_platform_hibernation</span><span class="p">;</span>

<span class="n">bool</span> <span class="nf">system_entering_hibernation</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">entering_platform_hibernation</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">system_entering_hibernation</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PM_DEBUG</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hibernation_debug_sleep</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;hibernation debug: Waiting for 5 seconds.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">5000</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hibernation_test</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pm_test_level</span> <span class="o">==</span> <span class="n">level</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hibernation_debug_sleep</span><span class="p">();</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* !CONFIG_PM_DEBUG */</span><span class="cp"></span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hibernation_test</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* !CONFIG_PM_DEBUG */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * platform_begin - Call platform to start hibernation.</span>
<span class="cm"> * @platform_mode: Whether or not to use the platform driver.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">platform_begin</span><span class="p">(</span><span class="kt">int</span> <span class="n">platform_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">platform_mode</span> <span class="o">&amp;&amp;</span> <span class="n">hibernation_ops</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">hibernation_ops</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">()</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * platform_end - Call platform to finish transition to the working state.</span>
<span class="cm"> * @platform_mode: Whether or not to use the platform driver.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">platform_end</span><span class="p">(</span><span class="kt">int</span> <span class="n">platform_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">platform_mode</span> <span class="o">&amp;&amp;</span> <span class="n">hibernation_ops</span><span class="p">)</span>
		<span class="n">hibernation_ops</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * platform_pre_snapshot - Call platform to prepare the machine for hibernation.</span>
<span class="cm"> * @platform_mode: Whether or not to use the platform driver.</span>
<span class="cm"> *</span>
<span class="cm"> * Use the platform driver to prepare the system for creating a hibernate image,</span>
<span class="cm"> * if so configured, and return an error code if that fails.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">platform_pre_snapshot</span><span class="p">(</span><span class="kt">int</span> <span class="n">platform_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">platform_mode</span> <span class="o">&amp;&amp;</span> <span class="n">hibernation_ops</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">hibernation_ops</span><span class="o">-&gt;</span><span class="n">pre_snapshot</span><span class="p">()</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * platform_leave - Call platform to prepare a transition to the working state.</span>
<span class="cm"> * @platform_mode: Whether or not to use the platform driver.</span>
<span class="cm"> *</span>
<span class="cm"> * Use the platform driver prepare to prepare the machine for switching to the</span>
<span class="cm"> * normal mode of operation.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is called on one CPU with interrupts disabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">platform_leave</span><span class="p">(</span><span class="kt">int</span> <span class="n">platform_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">platform_mode</span> <span class="o">&amp;&amp;</span> <span class="n">hibernation_ops</span><span class="p">)</span>
		<span class="n">hibernation_ops</span><span class="o">-&gt;</span><span class="n">leave</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * platform_finish - Call platform to switch the system to the working state.</span>
<span class="cm"> * @platform_mode: Whether or not to use the platform driver.</span>
<span class="cm"> *</span>
<span class="cm"> * Use the platform driver to switch the machine to the normal mode of</span>
<span class="cm"> * operation.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine must be called after platform_prepare().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">platform_finish</span><span class="p">(</span><span class="kt">int</span> <span class="n">platform_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">platform_mode</span> <span class="o">&amp;&amp;</span> <span class="n">hibernation_ops</span><span class="p">)</span>
		<span class="n">hibernation_ops</span><span class="o">-&gt;</span><span class="n">finish</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * platform_pre_restore - Prepare for hibernate image restoration.</span>
<span class="cm"> * @platform_mode: Whether or not to use the platform driver.</span>
<span class="cm"> *</span>
<span class="cm"> * Use the platform driver to prepare the system for resume from a hibernation</span>
<span class="cm"> * image.</span>
<span class="cm"> *</span>
<span class="cm"> * If the restore fails after this function has been called,</span>
<span class="cm"> * platform_restore_cleanup() must be called.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">platform_pre_restore</span><span class="p">(</span><span class="kt">int</span> <span class="n">platform_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">platform_mode</span> <span class="o">&amp;&amp;</span> <span class="n">hibernation_ops</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">hibernation_ops</span><span class="o">-&gt;</span><span class="n">pre_restore</span><span class="p">()</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * platform_restore_cleanup - Switch to the working state after failing restore.</span>
<span class="cm"> * @platform_mode: Whether or not to use the platform driver.</span>
<span class="cm"> *</span>
<span class="cm"> * Use the platform driver to switch the system to the normal mode of operation</span>
<span class="cm"> * after a failing restore.</span>
<span class="cm"> *</span>
<span class="cm"> * If platform_pre_restore() has been called before the failing restore, this</span>
<span class="cm"> * function must be called too, regardless of the result of</span>
<span class="cm"> * platform_pre_restore().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">platform_restore_cleanup</span><span class="p">(</span><span class="kt">int</span> <span class="n">platform_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">platform_mode</span> <span class="o">&amp;&amp;</span> <span class="n">hibernation_ops</span><span class="p">)</span>
		<span class="n">hibernation_ops</span><span class="o">-&gt;</span><span class="n">restore_cleanup</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * platform_recover - Recover from a failure to suspend devices.</span>
<span class="cm"> * @platform_mode: Whether or not to use the platform driver.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">platform_recover</span><span class="p">(</span><span class="kt">int</span> <span class="n">platform_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">platform_mode</span> <span class="o">&amp;&amp;</span> <span class="n">hibernation_ops</span> <span class="o">&amp;&amp;</span> <span class="n">hibernation_ops</span><span class="o">-&gt;</span><span class="n">recover</span><span class="p">)</span>
		<span class="n">hibernation_ops</span><span class="o">-&gt;</span><span class="n">recover</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * swsusp_show_speed - Print time elapsed between two events during hibernation.</span>
<span class="cm"> * @start: Starting event.</span>
<span class="cm"> * @stop: Final event.</span>
<span class="cm"> * @nr_pages: Number of memory pages processed between @start and @stop.</span>
<span class="cm"> * @msg: Additional diagnostic message to print.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">swsusp_show_speed</span><span class="p">(</span><span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">stop</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s64</span> <span class="n">elapsed_centisecs64</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">centisecs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">k</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">kps</span><span class="p">;</span>

	<span class="n">elapsed_centisecs64</span> <span class="o">=</span> <span class="n">timeval_to_ns</span><span class="p">(</span><span class="n">stop</span><span class="p">)</span> <span class="o">-</span> <span class="n">timeval_to_ns</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">elapsed_centisecs64</span><span class="p">,</span> <span class="n">NSEC_PER_SEC</span> <span class="o">/</span> <span class="mi">100</span><span class="p">);</span>
	<span class="n">centisecs</span> <span class="o">=</span> <span class="n">elapsed_centisecs64</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">centisecs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">centisecs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* avoid div-by-zero */</span>
	<span class="n">k</span> <span class="o">=</span> <span class="n">nr_pages</span> <span class="o">*</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="mi">1024</span><span class="p">);</span>
	<span class="n">kps</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span> <span class="o">/</span> <span class="n">centisecs</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;PM: %s %d kbytes in %d.%02d seconds (%d.%02d MB/s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">msg</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span>
			<span class="n">centisecs</span> <span class="o">/</span> <span class="mi">100</span><span class="p">,</span> <span class="n">centisecs</span> <span class="o">%</span> <span class="mi">100</span><span class="p">,</span>
			<span class="n">kps</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">,</span> <span class="p">(</span><span class="n">kps</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * create_image - Create a hibernation image.</span>
<span class="cm"> * @platform_mode: Whether or not to use the platform driver.</span>
<span class="cm"> *</span>
<span class="cm"> * Execute device drivers&#39; &quot;late&quot; and &quot;noirq&quot; freeze callbacks, create a</span>
<span class="cm"> * hibernation image and run the drivers&#39; &quot;noirq&quot; and &quot;early&quot; thaw callbacks.</span>
<span class="cm"> *</span>
<span class="cm"> * Control reappears in this routine after the subsequent restore.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">create_image</span><span class="p">(</span><span class="kt">int</span> <span class="n">platform_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">dpm_suspend_end</span><span class="p">(</span><span class="n">PMSG_FREEZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;PM: Some devices failed to power down, &quot;</span>
			<span class="s">&quot;aborting hibernation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">platform_pre_snapshot</span><span class="p">(</span><span class="n">platform_mode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">||</span> <span class="n">hibernation_test</span><span class="p">(</span><span class="n">TEST_PLATFORM</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">Platform_finish</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">disable_nonboot_cpus</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">||</span> <span class="n">hibernation_test</span><span class="p">(</span><span class="n">TEST_CPUS</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">Enable_cpus</span><span class="p">;</span>

	<span class="n">local_irq_disable</span><span class="p">();</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">syscore_suspend</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;PM: Some system devices failed to power down, &quot;</span>
			<span class="s">&quot;aborting hibernation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">Enable_irqs</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hibernation_test</span><span class="p">(</span><span class="n">TEST_CORE</span><span class="p">)</span> <span class="o">||</span> <span class="n">pm_wakeup_pending</span><span class="p">())</span>
		<span class="k">goto</span> <span class="n">Power_up</span><span class="p">;</span>

	<span class="n">in_suspend</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">save_processor_state</span><span class="p">();</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">swsusp_arch_suspend</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;PM: Error %d creating hibernation image</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error</span><span class="p">);</span>
	<span class="cm">/* Restore control flow magically appears here */</span>
	<span class="n">restore_processor_state</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_suspend</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">events_check_enabled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">platform_leave</span><span class="p">(</span><span class="n">platform_mode</span><span class="p">);</span>
	<span class="p">}</span>

 <span class="nl">Power_up:</span>
	<span class="n">syscore_resume</span><span class="p">();</span>

 <span class="nl">Enable_irqs:</span>
	<span class="n">local_irq_enable</span><span class="p">();</span>

 <span class="nl">Enable_cpus:</span>
	<span class="n">enable_nonboot_cpus</span><span class="p">();</span>

 <span class="nl">Platform_finish:</span>
	<span class="n">platform_finish</span><span class="p">(</span><span class="n">platform_mode</span><span class="p">);</span>

	<span class="n">dpm_resume_start</span><span class="p">(</span><span class="n">in_suspend</span> <span class="o">?</span>
		<span class="p">(</span><span class="n">error</span> <span class="o">?</span> <span class="n">PMSG_RECOVER</span> <span class="o">:</span> <span class="n">PMSG_THAW</span><span class="p">)</span> <span class="o">:</span> <span class="n">PMSG_RESTORE</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hibernation_snapshot - Quiesce devices and create a hibernation image.</span>
<span class="cm"> * @platform_mode: If set, use platform driver to prepare for the transition.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine must be called with pm_mutex held.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">hibernation_snapshot</span><span class="p">(</span><span class="kt">int</span> <span class="n">platform_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pm_message_t</span> <span class="n">msg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">platform_begin</span><span class="p">(</span><span class="n">platform_mode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">Close</span><span class="p">;</span>

	<span class="cm">/* Preallocate image memory before shutting down devices. */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">hibernate_preallocate_memory</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">Close</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">freeze_kernel_threads</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">Cleanup</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hibernation_test</span><span class="p">(</span><span class="n">TEST_FREEZER</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * Indicate to the caller that we are returning due to a</span>
<span class="cm">		 * successful freezer test.</span>
<span class="cm">		 */</span>
		<span class="n">freezer_test_done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">Thaw</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">dpm_prepare</span><span class="p">(</span><span class="n">PMSG_FREEZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dpm_complete</span><span class="p">(</span><span class="n">PMSG_RECOVER</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">Thaw</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">suspend_console</span><span class="p">();</span>
	<span class="n">pm_restrict_gfp_mask</span><span class="p">();</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">dpm_suspend</span><span class="p">(</span><span class="n">PMSG_FREEZE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">||</span> <span class="n">hibernation_test</span><span class="p">(</span><span class="n">TEST_DEVICES</span><span class="p">))</span>
		<span class="n">platform_recover</span><span class="p">(</span><span class="n">platform_mode</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">create_image</span><span class="p">(</span><span class="n">platform_mode</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * In the case that we call create_image() above, the control</span>
<span class="cm">	 * returns here (1) after the image has been created or the</span>
<span class="cm">	 * image creation has failed and (2) after a successful restore.</span>
<span class="cm">	 */</span>

	<span class="cm">/* We may need to release the preallocated image pages here. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">||</span> <span class="o">!</span><span class="n">in_suspend</span><span class="p">)</span>
		<span class="n">swsusp_free</span><span class="p">();</span>

	<span class="n">msg</span> <span class="o">=</span> <span class="n">in_suspend</span> <span class="o">?</span> <span class="p">(</span><span class="n">error</span> <span class="o">?</span> <span class="n">PMSG_RECOVER</span> <span class="o">:</span> <span class="n">PMSG_THAW</span><span class="p">)</span> <span class="o">:</span> <span class="n">PMSG_RESTORE</span><span class="p">;</span>
	<span class="n">dpm_resume</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">||</span> <span class="o">!</span><span class="n">in_suspend</span><span class="p">)</span>
		<span class="n">pm_restore_gfp_mask</span><span class="p">();</span>

	<span class="n">resume_console</span><span class="p">();</span>
	<span class="n">dpm_complete</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>

 <span class="nl">Close:</span>
	<span class="n">platform_end</span><span class="p">(</span><span class="n">platform_mode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

 <span class="nl">Thaw:</span>
	<span class="n">thaw_kernel_threads</span><span class="p">();</span>
 <span class="nl">Cleanup:</span>
	<span class="n">swsusp_free</span><span class="p">();</span>
	<span class="k">goto</span> <span class="n">Close</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * resume_target_kernel - Restore system state from a hibernation image.</span>
<span class="cm"> * @platform_mode: Whether or not to use the platform driver.</span>
<span class="cm"> *</span>
<span class="cm"> * Execute device drivers&#39; &quot;noirq&quot; and &quot;late&quot; freeze callbacks, restore the</span>
<span class="cm"> * contents of highmem that have not been restored yet from the image and run</span>
<span class="cm"> * the low-level code that will restore the remaining contents of memory and</span>
<span class="cm"> * switch to the just restored target kernel.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">resume_target_kernel</span><span class="p">(</span><span class="n">bool</span> <span class="n">platform_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">dpm_suspend_end</span><span class="p">(</span><span class="n">PMSG_QUIESCE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;PM: Some devices failed to power down, &quot;</span>
			<span class="s">&quot;aborting resume</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">platform_pre_restore</span><span class="p">(</span><span class="n">platform_mode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">Cleanup</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">disable_nonboot_cpus</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">Enable_cpus</span><span class="p">;</span>

	<span class="n">local_irq_disable</span><span class="p">();</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">syscore_suspend</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">Enable_irqs</span><span class="p">;</span>

	<span class="n">save_processor_state</span><span class="p">();</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">restore_highmem</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">swsusp_arch_resume</span><span class="p">();</span>
		<span class="cm">/*</span>
<span class="cm">		 * The code below is only ever reached in case of a failure.</span>
<span class="cm">		 * Otherwise, execution continues at the place where</span>
<span class="cm">		 * swsusp_arch_suspend() was called.</span>
<span class="cm">		 */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * This call to restore_highmem() reverts the changes made by</span>
<span class="cm">		 * the previous one.</span>
<span class="cm">		 */</span>
		<span class="n">restore_highmem</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * The only reason why swsusp_arch_resume() can fail is memory being</span>
<span class="cm">	 * very tight, so we have to free it as soon as we can to avoid</span>
<span class="cm">	 * subsequent failures.</span>
<span class="cm">	 */</span>
	<span class="n">swsusp_free</span><span class="p">();</span>
	<span class="n">restore_processor_state</span><span class="p">();</span>
	<span class="n">touch_softlockup_watchdog</span><span class="p">();</span>

	<span class="n">syscore_resume</span><span class="p">();</span>

 <span class="nl">Enable_irqs:</span>
	<span class="n">local_irq_enable</span><span class="p">();</span>

 <span class="nl">Enable_cpus:</span>
	<span class="n">enable_nonboot_cpus</span><span class="p">();</span>

 <span class="nl">Cleanup:</span>
	<span class="n">platform_restore_cleanup</span><span class="p">(</span><span class="n">platform_mode</span><span class="p">);</span>

	<span class="n">dpm_resume_start</span><span class="p">(</span><span class="n">PMSG_RECOVER</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hibernation_restore - Quiesce devices and restore from a hibernation image.</span>
<span class="cm"> * @platform_mode: If set, use platform driver to prepare for the transition.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine must be called with pm_mutex held.  If it is successful, control</span>
<span class="cm"> * reappears in the restored target kernel in hibernation_snapshot().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">hibernation_restore</span><span class="p">(</span><span class="kt">int</span> <span class="n">platform_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">pm_prepare_console</span><span class="p">();</span>
	<span class="n">suspend_console</span><span class="p">();</span>
	<span class="n">pm_restrict_gfp_mask</span><span class="p">();</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">dpm_suspend_start</span><span class="p">(</span><span class="n">PMSG_QUIESCE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">resume_target_kernel</span><span class="p">(</span><span class="n">platform_mode</span><span class="p">);</span>
		<span class="n">dpm_resume_end</span><span class="p">(</span><span class="n">PMSG_RECOVER</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">pm_restore_gfp_mask</span><span class="p">();</span>
	<span class="n">resume_console</span><span class="p">();</span>
	<span class="n">pm_restore_console</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hibernation_platform_enter - Power off the system using the platform driver.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">hibernation_platform_enter</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hibernation_ops</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We have cancelled the power transition by running</span>
<span class="cm">	 * hibernation_ops-&gt;finish() before saving the image, so we should let</span>
<span class="cm">	 * the firmware know that we&#39;re going to enter the sleep state after all</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">hibernation_ops</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">Close</span><span class="p">;</span>

	<span class="n">entering_platform_hibernation</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">suspend_console</span><span class="p">();</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">dpm_suspend_start</span><span class="p">(</span><span class="n">PMSG_HIBERNATE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hibernation_ops</span><span class="o">-&gt;</span><span class="n">recover</span><span class="p">)</span>
			<span class="n">hibernation_ops</span><span class="o">-&gt;</span><span class="n">recover</span><span class="p">();</span>
		<span class="k">goto</span> <span class="n">Resume_devices</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">dpm_suspend_end</span><span class="p">(</span><span class="n">PMSG_HIBERNATE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">Resume_devices</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">hibernation_ops</span><span class="o">-&gt;</span><span class="n">prepare</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">Platform_finish</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">disable_nonboot_cpus</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">Platform_finish</span><span class="p">;</span>

	<span class="n">local_irq_disable</span><span class="p">();</span>
	<span class="n">syscore_suspend</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pm_wakeup_pending</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">Power_up</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hibernation_ops</span><span class="o">-&gt;</span><span class="n">enter</span><span class="p">();</span>
	<span class="cm">/* We should never get here */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>

 <span class="nl">Power_up:</span>
	<span class="n">syscore_resume</span><span class="p">();</span>
	<span class="n">local_irq_enable</span><span class="p">();</span>
	<span class="n">enable_nonboot_cpus</span><span class="p">();</span>

 <span class="nl">Platform_finish:</span>
	<span class="n">hibernation_ops</span><span class="o">-&gt;</span><span class="n">finish</span><span class="p">();</span>

	<span class="n">dpm_resume_start</span><span class="p">(</span><span class="n">PMSG_RESTORE</span><span class="p">);</span>

 <span class="nl">Resume_devices:</span>
	<span class="n">entering_platform_hibernation</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">dpm_resume_end</span><span class="p">(</span><span class="n">PMSG_RESTORE</span><span class="p">);</span>
	<span class="n">resume_console</span><span class="p">();</span>

 <span class="nl">Close:</span>
	<span class="n">hibernation_ops</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * power_down - Shut the machine down for hibernation.</span>
<span class="cm"> *</span>
<span class="cm"> * Use the platform driver, if configured, to put the system into the sleep</span>
<span class="cm"> * state corresponding to hibernation, or try to power it off or reboot,</span>
<span class="cm"> * depending on the value of hibernation_mode.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">power_down</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hibernation_mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HIBERNATION_REBOOT</span>:
		<span class="n">kernel_restart</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HIBERNATION_PLATFORM</span>:
		<span class="n">hibernation_platform_enter</span><span class="p">();</span>
	<span class="k">case</span> <span class="n">HIBERNATION_SHUTDOWN</span>:
		<span class="n">kernel_power_off</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kernel_halt</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * Valid image is on the disk, if we continue we risk serious data</span>
<span class="cm">	 * corruption after resume.</span>
<span class="cm">	 */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;PM: Please power down manually</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hibernate - Carry out system hibernation, including saving the image.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">hibernate</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">lock_system_sleep</span><span class="p">();</span>
	<span class="cm">/* The snapshot device should not be opened while we&#39;re running */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_add_unless</span><span class="p">(</span><span class="o">&amp;</span><span class="n">snapshot_device_available</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">Unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pm_prepare_console</span><span class="p">();</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">pm_notifier_call_chain</span><span class="p">(</span><span class="n">PM_HIBERNATION_PREPARE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">Exit</span><span class="p">;</span>

	<span class="cm">/* Allocate memory management structures */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">create_basic_memory_bitmaps</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">Exit</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;PM: Syncing filesystems ... &quot;</span><span class="p">);</span>
	<span class="n">sys_sync</span><span class="p">();</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;done.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">freeze_processes</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">Free_bitmaps</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">hibernation_snapshot</span><span class="p">(</span><span class="n">hibernation_mode</span> <span class="o">==</span> <span class="n">HIBERNATION_PLATFORM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">||</span> <span class="n">freezer_test_done</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">Thaw</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">in_suspend</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hibernation_mode</span> <span class="o">==</span> <span class="n">HIBERNATION_PLATFORM</span><span class="p">)</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">SF_PLATFORM_MODE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nocompress</span><span class="p">)</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">SF_NOCOMPRESS_MODE</span><span class="p">;</span>
		<span class="k">else</span>
		        <span class="n">flags</span> <span class="o">|=</span> <span class="n">SF_CRC32_MODE</span><span class="p">;</span>

		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;PM: writing image.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">swsusp_write</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">swsusp_free</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
			<span class="n">power_down</span><span class="p">();</span>
		<span class="n">in_suspend</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pm_restore_gfp_mask</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;PM: Image restored successfully.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

 <span class="nl">Thaw:</span>
	<span class="n">thaw_processes</span><span class="p">();</span>

	<span class="cm">/* Don&#39;t bother checking whether freezer_test_done is true */</span>
	<span class="n">freezer_test_done</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

 <span class="nl">Free_bitmaps:</span>
	<span class="n">free_basic_memory_bitmaps</span><span class="p">();</span>
 <span class="nl">Exit:</span>
	<span class="n">pm_notifier_call_chain</span><span class="p">(</span><span class="n">PM_POST_HIBERNATION</span><span class="p">);</span>
	<span class="n">pm_restore_console</span><span class="p">();</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">snapshot_device_available</span><span class="p">);</span>
 <span class="nl">Unlock:</span>
	<span class="n">unlock_system_sleep</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * software_resume - Resume from a saved hibernation image.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is called as a late initcall, when all devices have been</span>
<span class="cm"> * discovered and initialized already.</span>
<span class="cm"> *</span>
<span class="cm"> * The image reading code is called to see if there is a hibernation image</span>
<span class="cm"> * available for reading.  If that is the case, devices are quiesced and the</span>
<span class="cm"> * contents of memory is restored from the saved image.</span>
<span class="cm"> *</span>
<span class="cm"> * If this is successful, control reappears in the restored target kernel in</span>
<span class="cm"> * hibernation_snaphot() which returns to hibernate().  Otherwise, the routine</span>
<span class="cm"> * attempts to recover gracefully and make the kernel return to the normal mode</span>
<span class="cm"> * of operation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">software_resume</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the user said &quot;noresume&quot;.. bail out early.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">noresume</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * name_to_dev_t() below takes a sysfs buffer mutex when sysfs</span>
<span class="cm">	 * is configured into the kernel. Since the regular hibernate</span>
<span class="cm">	 * trigger path is via sysfs which takes a buffer mutex before</span>
<span class="cm">	 * calling hibernate functions (which take pm_mutex) this can</span>
<span class="cm">	 * cause lockdep to complain about a possible ABBA deadlock</span>
<span class="cm">	 * which cannot happen since we&#39;re in the boot code here and</span>
<span class="cm">	 * sysfs can&#39;t be invoked yet. Therefore, we use a subclass</span>
<span class="cm">	 * here to avoid lockdep complaining.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pm_mutex</span><span class="p">,</span> <span class="n">SINGLE_DEPTH_NESTING</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">swsusp_resume_device</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">Check_image</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strlen</span><span class="p">(</span><span class="n">resume_file</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">Unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;PM: Checking hibernation image partition %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">resume_file</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">resume_delay</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Waiting %dsec before reading resume device...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">resume_delay</span><span class="p">);</span>
		<span class="n">ssleep</span><span class="p">(</span><span class="n">resume_delay</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Check if the device is there */</span>
	<span class="n">swsusp_resume_device</span> <span class="o">=</span> <span class="n">name_to_dev_t</span><span class="p">(</span><span class="n">resume_file</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * name_to_dev_t is ineffective to verify parition if resume_file is in</span>
<span class="cm">	 * integer format. (e.g. major:minor)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isdigit</span><span class="p">(</span><span class="n">resume_file</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="n">resume_wait</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">partno</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">get_gendisk</span><span class="p">(</span><span class="n">swsusp_resume_device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">partno</span><span class="p">))</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">swsusp_resume_device</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Some device discovery might still be in progress; we need</span>
<span class="cm">		 * to wait for this to finish.</span>
<span class="cm">		 */</span>
		<span class="n">wait_for_device_probe</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">resume_wait</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">while</span> <span class="p">((</span><span class="n">swsusp_resume_device</span> <span class="o">=</span> <span class="n">name_to_dev_t</span><span class="p">(</span><span class="n">resume_file</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
			<span class="n">async_synchronize_full</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * We can&#39;t depend on SCSI devices being available after loading</span>
<span class="cm">		 * one of their modules until scsi_complete_async_scans() is</span>
<span class="cm">		 * called and the resume device usually is a SCSI one.</span>
<span class="cm">		 */</span>
		<span class="n">scsi_complete_async_scans</span><span class="p">();</span>

		<span class="n">swsusp_resume_device</span> <span class="o">=</span> <span class="n">name_to_dev_t</span><span class="p">(</span><span class="n">resume_file</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">swsusp_resume_device</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">Unlock</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

 <span class="nl">Check_image:</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;PM: Hibernation image partition %d:%d present</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">MAJOR</span><span class="p">(</span><span class="n">swsusp_resume_device</span><span class="p">),</span> <span class="n">MINOR</span><span class="p">(</span><span class="n">swsusp_resume_device</span><span class="p">));</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;PM: Looking for hibernation image.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">swsusp_check</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">Unlock</span><span class="p">;</span>

	<span class="cm">/* The snapshot device should not be opened while we&#39;re running */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_add_unless</span><span class="p">(</span><span class="o">&amp;</span><span class="n">snapshot_device_available</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="n">swsusp_close</span><span class="p">(</span><span class="n">FMODE_READ</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">Unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pm_prepare_console</span><span class="p">();</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">pm_notifier_call_chain</span><span class="p">(</span><span class="n">PM_RESTORE_PREPARE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">close_finish</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">create_basic_memory_bitmaps</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">close_finish</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;PM: Preparing processes for restore.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">freeze_processes</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">swsusp_close</span><span class="p">(</span><span class="n">FMODE_READ</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">Done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;PM: Loading hibernation image.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">swsusp_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">swsusp_close</span><span class="p">(</span><span class="n">FMODE_READ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
		<span class="n">hibernation_restore</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SF_PLATFORM_MODE</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;PM: Failed to load hibernation image, recovering.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">swsusp_free</span><span class="p">();</span>
	<span class="n">thaw_processes</span><span class="p">();</span>
 <span class="nl">Done:</span>
	<span class="n">free_basic_memory_bitmaps</span><span class="p">();</span>
 <span class="nl">Finish:</span>
	<span class="n">pm_notifier_call_chain</span><span class="p">(</span><span class="n">PM_POST_RESTORE</span><span class="p">);</span>
	<span class="n">pm_restore_console</span><span class="p">();</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">snapshot_device_available</span><span class="p">);</span>
	<span class="cm">/* For success case, the suspend path will release the lock */</span>
 <span class="nl">Unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pm_mutex</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;PM: Hibernation image not present or could not be loaded.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="nl">close_finish:</span>
	<span class="n">swsusp_close</span><span class="p">(</span><span class="n">FMODE_READ</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">Finish</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">late_initcall</span><span class="p">(</span><span class="n">software_resume</span><span class="p">);</span>


<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">hibernation_modes</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">HIBERNATION_PLATFORM</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;platform&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">HIBERNATION_SHUTDOWN</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;shutdown&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">HIBERNATION_REBOOT</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;reboot&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * /sys/power/disk - Control hibernation mode.</span>
<span class="cm"> *</span>
<span class="cm"> * Hibernation can be handled in several ways.  There are a few different ways</span>
<span class="cm"> * to put the system into the sleep state: using the platform driver (e.g. ACPI</span>
<span class="cm"> * or other hibernation_ops), powering it off or rebooting it (for testing</span>
<span class="cm"> * mostly).</span>
<span class="cm"> *</span>
<span class="cm"> * The sysfs file /sys/power/disk provides an interface for selecting the</span>
<span class="cm"> * hibernation mode to use.  Reading from this file causes the available modes</span>
<span class="cm"> * to be printed.  There are 3 modes that can be supported:</span>
<span class="cm"> *</span>
<span class="cm"> *	&#39;platform&#39;</span>
<span class="cm"> *	&#39;shutdown&#39;</span>
<span class="cm"> *	&#39;reboot&#39;</span>
<span class="cm"> *</span>
<span class="cm"> * If a platform hibernation driver is in use, &#39;platform&#39; will be supported</span>
<span class="cm"> * and will be used by default.  Otherwise, &#39;shutdown&#39; will be used by default.</span>
<span class="cm"> * The selected option (i.e. the one corresponding to the current value of</span>
<span class="cm"> * hibernation_mode) is enclosed by a square bracket.</span>
<span class="cm"> *</span>
<span class="cm"> * To select a given hibernation mode it is necessary to write the mode&#39;s</span>
<span class="cm"> * string representation (as returned by reading from /sys/power/disk) back</span>
<span class="cm"> * into /sys/power/disk.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">disk_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			 <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">HIBERNATION_FIRST</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">HIBERNATION_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hibernation_modes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">HIBERNATION_SHUTDOWN</span>:
		<span class="k">case</span> <span class="n">HIBERNATION_REBOOT</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">HIBERNATION_PLATFORM</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">hibernation_ops</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="cm">/* not a valid mode, continue with loop */</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">hibernation_mode</span><span class="p">)</span>
			<span class="n">buf</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;[%s] &quot;</span><span class="p">,</span> <span class="n">hibernation_modes</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">else</span>
			<span class="n">buf</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s &quot;</span><span class="p">,</span> <span class="n">hibernation_modes</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">buf</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">buf</span><span class="o">-</span><span class="n">start</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">disk_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">HIBERNATION_INVALID</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">memchr</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">p</span> <span class="o">?</span> <span class="n">p</span> <span class="o">-</span> <span class="n">buf</span> <span class="o">:</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">lock_system_sleep</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">HIBERNATION_FIRST</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">HIBERNATION_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="n">strlen</span><span class="p">(</span><span class="n">hibernation_modes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
		    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">hibernation_modes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mode</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">!=</span> <span class="n">HIBERNATION_INVALID</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">HIBERNATION_SHUTDOWN</span>:
		<span class="k">case</span> <span class="n">HIBERNATION_REBOOT</span>:
			<span class="n">hibernation_mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">HIBERNATION_PLATFORM</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">hibernation_ops</span><span class="p">)</span>
				<span class="n">hibernation_mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;PM: Hibernation mode set to &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">hibernation_modes</span><span class="p">[</span><span class="n">mode</span><span class="p">]);</span>
	<span class="n">unlock_system_sleep</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">error</span> <span class="o">?</span> <span class="n">error</span> <span class="o">:</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">power_attr</span><span class="p">(</span><span class="n">disk</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">resume_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			   <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="s">&quot;%d:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">MAJOR</span><span class="p">(</span><span class="n">swsusp_resume_device</span><span class="p">),</span>
		       <span class="n">MINOR</span><span class="p">(</span><span class="n">swsusp_resume_device</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">resume_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">maj</span><span class="p">,</span> <span class="n">min</span><span class="p">;</span>
	<span class="n">dev_t</span> <span class="n">res</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%u:%u&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">maj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">min</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">maj</span><span class="p">,</span><span class="n">min</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">maj</span> <span class="o">!=</span> <span class="n">MAJOR</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">||</span> <span class="n">min</span> <span class="o">!=</span> <span class="n">MINOR</span><span class="p">(</span><span class="n">res</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">lock_system_sleep</span><span class="p">();</span>
	<span class="n">swsusp_resume_device</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>
	<span class="n">unlock_system_sleep</span><span class="p">();</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;PM: Starting manual resume from disk</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">noresume</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">software_resume</span><span class="p">();</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">power_attr</span><span class="p">(</span><span class="n">resume</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">image_size_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			       <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">image_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">image_size_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%lu&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">image_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">power_attr</span><span class="p">(</span><span class="n">image_size</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">reserved_size_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reserved_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">reserved_size_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%lu&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reserved_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">power_attr</span><span class="p">(</span><span class="n">reserved_size</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span> <span class="n">g</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">disk_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">resume_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">image_size_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">reserved_size_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="n">attr_group</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">g</span><span class="p">,</span>
<span class="p">};</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">pm_disk_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sysfs_create_group</span><span class="p">(</span><span class="n">power_kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr_group</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">core_initcall</span><span class="p">(</span><span class="n">pm_disk_init</span><span class="p">);</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">resume_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">noresume</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">strncpy</span><span class="p">(</span> <span class="n">resume_file</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="mi">255</span> <span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">resume_offset_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">noresume</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;%llu&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">swsusp_resume_block</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">hibernate_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;noresume&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
		<span class="n">noresume</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;nocompress&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
		<span class="n">nocompress</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">noresume_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">noresume</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">resumewait_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">resume_wait</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">resumedelay_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">resume_delay</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;noresume&quot;</span><span class="p">,</span> <span class="n">noresume_setup</span><span class="p">);</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;resume_offset=&quot;</span><span class="p">,</span> <span class="n">resume_offset_setup</span><span class="p">);</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;resume=&quot;</span><span class="p">,</span> <span class="n">resume_setup</span><span class="p">);</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;hibernate=&quot;</span><span class="p">,</span> <span class="n">hibernate_setup</span><span class="p">);</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;resumewait&quot;</span><span class="p">,</span> <span class="n">resumewait_setup</span><span class="p">);</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;resumedelay=&quot;</span><span class="p">,</span> <span class="n">resumedelay_setup</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
