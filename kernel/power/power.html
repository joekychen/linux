<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › power › power.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>power.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &lt;linux/suspend.h&gt;</span>
<span class="cp">#include &lt;linux/suspend_ioctls.h&gt;</span>
<span class="cp">#include &lt;linux/utsname.h&gt;</span>
<span class="cp">#include &lt;linux/freezer.h&gt;</span>

<span class="k">struct</span> <span class="n">swsusp_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">new_utsname</span>	<span class="n">uts</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">version_code</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">num_physpages</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">cpus</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">image_pages</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">pages</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">size</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">)));</span>

<span class="cp">#ifdef CONFIG_HIBERNATION</span>
<span class="cm">/* kernel/power/snapshot.c */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__init</span> <span class="n">hibernate_reserved_size_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__init</span> <span class="n">hibernate_image_size_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_ARCH_HIBERNATION_HEADER</span>
<span class="cm">/* Maximum size of architecture specific data in a hibernation header */</span>
<span class="cp">#define MAX_ARCH_HEADER_SIZE	(sizeof(struct new_utsname) + 4)</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">arch_hibernation_header_save</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_size</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">arch_hibernation_header_restore</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">init_header_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">swsusp_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">arch_hibernation_header_save</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">MAX_ARCH_HEADER_SIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">check_image_kernel</span><span class="p">(</span><span class="k">struct</span> <span class="n">swsusp_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">arch_hibernation_header_restore</span><span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="o">?</span>
			<span class="s">&quot;architecture specific data&quot;</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ARCH_HIBERNATION_HEADER */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Keep some memory free so that I/O operations can succeed without paging</span>
<span class="cm"> * [Might this be more than 4 MB?]</span>
<span class="cm"> */</span>
<span class="cp">#define PAGES_FOR_IO	((4096 * 1024) &gt;&gt; PAGE_SHIFT)</span>

<span class="cm">/*</span>
<span class="cm"> * Keep 1 MB of memory free so that device drivers can allocate some pages in</span>
<span class="cm"> * their .suspend() routines without breaking the suspend to disk.</span>
<span class="cm"> */</span>
<span class="cp">#define SPARE_PAGES	((1024 * 1024) &gt;&gt; PAGE_SHIFT)</span>

<span class="cm">/* kernel/power/hibernate.c */</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">freezer_test_done</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">hibernation_snapshot</span><span class="p">(</span><span class="kt">int</span> <span class="n">platform_mode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">hibernation_restore</span><span class="p">(</span><span class="kt">int</span> <span class="n">platform_mode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">hibernation_platform_enter</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#else </span><span class="cm">/* !CONFIG_HIBERNATION */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hibernate_reserved_size_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hibernate_image_size_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>
<span class="cp">#endif </span><span class="cm">/* !CONFIG_HIBERNATION */</span><span class="cp"></span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">pfn_is_nosave</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

<span class="cp">#define power_attr(_name) \</span>
<span class="cp">static struct kobj_attribute _name##_attr = {	\</span>
<span class="cp">	.attr	= {				\</span>
<span class="cp">		.name = __stringify(_name),	\</span>
<span class="cp">		.mode = 0644,			\</span>
<span class="cp">	},					\</span>
<span class="cp">	.show	= _name##_show,			\</span>
<span class="cp">	.store	= _name##_store,		\</span>
<span class="cp">}</span>

<span class="cm">/* Preferred image size in bytes (default 500 MB) */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">image_size</span><span class="p">;</span>
<span class="cm">/* Size of memory reserved for drivers (default SPARE_PAGES x PAGE_SIZE) */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reserved_size</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">in_suspend</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">dev_t</span> <span class="n">swsusp_resume_device</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">sector_t</span> <span class="n">swsusp_resume_block</span><span class="p">;</span>

<span class="k">extern</span> <span class="n">asmlinkage</span> <span class="kt">int</span> <span class="n">swsusp_arch_suspend</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">asmlinkage</span> <span class="kt">int</span> <span class="n">swsusp_arch_resume</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">create_basic_memory_bitmaps</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">free_basic_memory_bitmaps</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">hibernate_preallocate_memory</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	Auxiliary structure used for reading the snapshot image data and</span>
<span class="cm"> *	metadata from and writing them to the list of page backup entries</span>
<span class="cm"> *	(PBEs) which is the main data structure of swsusp.</span>
<span class="cm"> *</span>
<span class="cm"> *	Using struct snapshot_handle we can transfer the image, including its</span>
<span class="cm"> *	metadata, as a continuous sequence of bytes with the help of</span>
<span class="cm"> *	snapshot_read_next() and snapshot_write_next().</span>
<span class="cm"> *</span>
<span class="cm"> *	The code that writes the image to a storage or transfers it to</span>
<span class="cm"> *	the user land is required to use snapshot_read_next() for this</span>
<span class="cm"> *	purpose and it should not make any assumptions regarding the internal</span>
<span class="cm"> *	structure of the image.  Similarly, the code that reads the image from</span>
<span class="cm"> *	a storage or transfers it from the user land is required to use</span>
<span class="cm"> *	snapshot_write_next().</span>
<span class="cm"> *</span>
<span class="cm"> *	This may allow us to change the internal structure of the image</span>
<span class="cm"> *	in the future with considerably less effort.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">snapshot_handle</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">cur</span><span class="p">;</span>	<span class="cm">/* number of the block of PAGE_SIZE bytes the</span>
<span class="cm">				 * next operation will refer to (ie. current)</span>
<span class="cm">				 */</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="n">buffer</span><span class="p">;</span>	<span class="cm">/* address of the block to read from</span>
<span class="cm">					 * or write to</span>
<span class="cm">					 */</span>
	<span class="kt">int</span>		<span class="n">sync_read</span><span class="p">;</span>	<span class="cm">/* Set to one to notify the caller of</span>
<span class="cm">					 * snapshot_write_next() that it may</span>
<span class="cm">					 * need to call wait_on_bio_chain()</span>
<span class="cm">					 */</span>
<span class="p">};</span>

<span class="cm">/* This macro returns the address from/to which the caller of</span>
<span class="cm"> * snapshot_read_next()/snapshot_write_next() is allowed to</span>
<span class="cm"> * read/write data after the function returns</span>
<span class="cm"> */</span>
<span class="cp">#define data_of(handle)	((handle).buffer)</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">snapshot_additional_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">snapshot_get_image_size</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">snapshot_read_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">snapshot_handle</span> <span class="o">*</span><span class="n">handle</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">snapshot_write_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">snapshot_handle</span> <span class="o">*</span><span class="n">handle</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">snapshot_write_finalize</span><span class="p">(</span><span class="k">struct</span> <span class="n">snapshot_handle</span> <span class="o">*</span><span class="n">handle</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">snapshot_image_loaded</span><span class="p">(</span><span class="k">struct</span> <span class="n">snapshot_handle</span> <span class="o">*</span><span class="n">handle</span><span class="p">);</span>

<span class="cm">/* If unset, the snapshot device cannot be open. */</span>
<span class="k">extern</span> <span class="n">atomic_t</span> <span class="n">snapshot_device_available</span><span class="p">;</span>

<span class="k">extern</span> <span class="n">sector_t</span> <span class="n">alloc_swapdev_block</span><span class="p">(</span><span class="kt">int</span> <span class="n">swap</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">free_all_swap_pages</span><span class="p">(</span><span class="kt">int</span> <span class="n">swap</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">swsusp_swap_in_use</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Flags that can be passed from the hibernatig hernel to the &quot;boot&quot; kernel in</span>
<span class="cm"> * the image header.</span>
<span class="cm"> */</span>
<span class="cp">#define SF_PLATFORM_MODE	1</span>
<span class="cp">#define SF_NOCOMPRESS_MODE	2</span>
<span class="cp">#define SF_CRC32_MODE	        4</span>

<span class="cm">/* kernel/power/hibernate.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">swsusp_check</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">swsusp_free</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">swsusp_read</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">flags_p</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">swsusp_write</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">swsusp_close</span><span class="p">(</span><span class="n">fmode_t</span><span class="p">);</span>

<span class="cm">/* kernel/power/block_io.c */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">hib_resume_bdev</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">hib_bio_read_page</span><span class="p">(</span><span class="n">pgoff_t</span> <span class="n">page_off</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">bio</span> <span class="o">**</span><span class="n">bio_chain</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">hib_bio_write_page</span><span class="p">(</span><span class="n">pgoff_t</span> <span class="n">page_off</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">bio</span> <span class="o">**</span><span class="n">bio_chain</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">hib_wait_on_bio_chain</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">**</span><span class="n">bio_chain</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">timeval</span><span class="p">;</span>
<span class="cm">/* kernel/power/swsusp.c */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">swsusp_show_speed</span><span class="p">(</span><span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SUSPEND</span>
<span class="cm">/* kernel/power/suspend.c */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">pm_states</span><span class="p">[];</span>

<span class="k">extern</span> <span class="n">bool</span> <span class="n">valid_state</span><span class="p">(</span><span class="n">suspend_state_t</span> <span class="n">state</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">suspend_devices_and_enter</span><span class="p">(</span><span class="n">suspend_state_t</span> <span class="n">state</span><span class="p">);</span>
<span class="cp">#else </span><span class="cm">/* !CONFIG_SUSPEND */</span><span class="cp"></span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">suspend_devices_and_enter</span><span class="p">(</span><span class="n">suspend_state_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">valid_state</span><span class="p">(</span><span class="n">suspend_state_t</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* !CONFIG_SUSPEND */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_PM_TEST_SUSPEND</span>
<span class="cm">/* kernel/power/suspend_test.c */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">suspend_test_start</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">suspend_test_finish</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">label</span><span class="p">);</span>
<span class="cp">#else </span><span class="cm">/* !CONFIG_PM_TEST_SUSPEND */</span><span class="cp"></span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">suspend_test_start</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">suspend_test_finish</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">label</span><span class="p">)</span> <span class="p">{}</span>
<span class="cp">#endif </span><span class="cm">/* !CONFIG_PM_TEST_SUSPEND */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_PM_SLEEP</span>
<span class="cm">/* kernel/power/main.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pm_notifier_call_chain</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_HIGHMEM</span>
<span class="kt">int</span> <span class="n">restore_highmem</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">count_highmem_pages</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">restore_highmem</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Suspend test levels</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="cm">/* keep first */</span>
	<span class="n">TEST_NONE</span><span class="p">,</span>
	<span class="n">TEST_CORE</span><span class="p">,</span>
	<span class="n">TEST_CPUS</span><span class="p">,</span>
	<span class="n">TEST_PLATFORM</span><span class="p">,</span>
	<span class="n">TEST_DEVICES</span><span class="p">,</span>
	<span class="n">TEST_FREEZER</span><span class="p">,</span>
	<span class="cm">/* keep last */</span>
	<span class="n">__TEST_AFTER_LAST</span>
<span class="p">};</span>

<span class="cp">#define TEST_FIRST	TEST_NONE</span>
<span class="cp">#define TEST_MAX	(__TEST_AFTER_LAST - 1)</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">pm_test_level</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SUSPEND_FREEZER</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">suspend_freeze_processes</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">freeze_processes</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * freeze_processes() automatically thaws every task if freezing</span>
<span class="cm">	 * fails. So we need not do anything extra upon error.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">freeze_kernel_threads</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * freeze_kernel_threads() thaws only kernel threads upon freezing</span>
<span class="cm">	 * failure. So we have to thaw the userspace tasks ourselves.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">thaw_processes</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">suspend_thaw_processes</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">thaw_processes</span><span class="p">();</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">suspend_freeze_processes</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">suspend_thaw_processes</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PM_AUTOSLEEP</span>

<span class="cm">/* kernel/power/autosleep.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pm_autosleep_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pm_autosleep_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pm_autosleep_unlock</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">suspend_state_t</span> <span class="n">pm_autosleep_state</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pm_autosleep_set_state</span><span class="p">(</span><span class="n">suspend_state_t</span> <span class="n">state</span><span class="p">);</span>

<span class="cp">#else </span><span class="cm">/* !CONFIG_PM_AUTOSLEEP */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pm_autosleep_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pm_autosleep_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pm_autosleep_unlock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">suspend_state_t</span> <span class="nf">pm_autosleep_state</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">PM_SUSPEND_ON</span><span class="p">;</span> <span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* !CONFIG_PM_AUTOSLEEP */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_PM_WAKELOCKS</span>

<span class="cm">/* kernel/power/wakelock.c */</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">pm_show_wakelocks</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">bool</span> <span class="n">show_active</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pm_wake_lock</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pm_wake_unlock</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* !CONFIG_PM_WAKELOCKS */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
