<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › lockdep.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>lockdep.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * kernel/lockdep.c</span>
<span class="cm"> *</span>
<span class="cm"> * Runtime locking correctness validator</span>
<span class="cm"> *</span>
<span class="cm"> * Started by Ingo Molnar:</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 2006,2007 Red Hat, Inc., Ingo Molnar &lt;mingo@redhat.com&gt;</span>
<span class="cm"> *  Copyright (C) 2007 Red Hat, Inc., Peter Zijlstra &lt;pzijlstr@redhat.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * this code maps all the lock dependencies as they occur in a live kernel</span>
<span class="cm"> * and will warn about the following classes of locking bugs:</span>
<span class="cm"> *</span>
<span class="cm"> * - lock inversion scenarios</span>
<span class="cm"> * - circular lock dependencies</span>
<span class="cm"> * - hardirq/softirq safe/unsafe locking bugs</span>
<span class="cm"> *</span>
<span class="cm"> * Bugs are reported even if the current locking scenario does not cause</span>
<span class="cm"> * any deadlock at this point.</span>
<span class="cm"> *</span>
<span class="cm"> * I.e. if anytime in the past two locks were taken in a different order,</span>
<span class="cm"> * even if it happened for another task, even if those were different</span>
<span class="cm"> * locks (but of the same class as this lock), this code will detect it.</span>
<span class="cm"> *</span>
<span class="cm"> * Thanks to Arjan van de Ven for coming up with the initial idea of</span>
<span class="cm"> * mapping lock dependencies runtime.</span>
<span class="cm"> */</span>
<span class="cp">#define DISABLE_BRANCH_PROFILING</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/kallsyms.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/stacktrace.h&gt;</span>
<span class="cp">#include &lt;linux/debug_locks.h&gt;</span>
<span class="cp">#include &lt;linux/irqflags.h&gt;</span>
<span class="cp">#include &lt;linux/utsname.h&gt;</span>
<span class="cp">#include &lt;linux/hash.h&gt;</span>
<span class="cp">#include &lt;linux/ftrace.h&gt;</span>
<span class="cp">#include &lt;linux/stringify.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;linux/kmemcheck.h&gt;</span>

<span class="cp">#include &lt;asm/sections.h&gt;</span>

<span class="cp">#include &quot;lockdep_internals.h&quot;</span>

<span class="cp">#define CREATE_TRACE_POINTS</span>
<span class="cp">#include &lt;trace/events/lock.h&gt;</span>

<span class="cp">#ifdef CONFIG_PROVE_LOCKING</span>
<span class="kt">int</span> <span class="n">prove_locking</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">prove_locking</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp">#define prove_locking 0</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_LOCK_STAT</span>
<span class="kt">int</span> <span class="n">lock_stat</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">lock_stat</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp">#define lock_stat 0</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * lockdep_lock: protects the lockdep graph, the hashes and the</span>
<span class="cm"> *               class/list/hash allocators.</span>
<span class="cm"> *</span>
<span class="cm"> * This is one of the rare exceptions where it&#39;s justified</span>
<span class="cm"> * to use a raw spinlock - we really dont want the spinlock</span>
<span class="cm"> * code to recurse back into the lockdep code...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">arch_spinlock_t</span> <span class="n">lockdep_lock</span> <span class="o">=</span> <span class="p">(</span><span class="n">arch_spinlock_t</span><span class="p">)</span><span class="n">__ARCH_SPIN_LOCK_UNLOCKED</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">graph_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">arch_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lockdep_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Make sure that if another CPU detected a bug while</span>
<span class="cm">	 * walking the graph we dont change it (while the other</span>
<span class="cm">	 * CPU is busy printing out stuff with the graph lock</span>
<span class="cm">	 * dropped already)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug_locks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">arch_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lockdep_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* prevent any recursions within lockdep from causing deadlocks */</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">lockdep_recursion</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">graph_unlock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_locks</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">arch_spin_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lockdep_lock</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The lockdep graph lock isn&#39;t locked while we expect it to</span>
<span class="cm">		 * be, we&#39;re confused now, bye!</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">current</span><span class="o">-&gt;</span><span class="n">lockdep_recursion</span><span class="o">--</span><span class="p">;</span>
	<span class="n">arch_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lockdep_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Turn lock debugging off and return with 0 if it was off already,</span>
<span class="cm"> * and also release the graph lock:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">debug_locks_off_graph_unlock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">debug_locks_off</span><span class="p">();</span>

	<span class="n">arch_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lockdep_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">lockdep_initialized</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_list_entries</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lock_list</span> <span class="n">list_entries</span><span class="p">[</span><span class="n">MAX_LOCKDEP_ENTRIES</span><span class="p">];</span>

<span class="cm">/*</span>
<span class="cm"> * All data structures here are protected by the global debug_lock.</span>
<span class="cm"> *</span>
<span class="cm"> * Mutex key structs only get allocated, once during bootup, and never</span>
<span class="cm"> * get freed - this significantly simplifies the debugging code.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_lock_classes</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lock_class</span> <span class="n">lock_classes</span><span class="p">[</span><span class="n">MAX_LOCKDEP_KEYS</span><span class="p">];</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="nf">hlock_class</span><span class="p">(</span><span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">hlock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hlock</span><span class="o">-&gt;</span><span class="n">class_idx</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Someone passed in garbage, we give up.</span>
<span class="cm">		 */</span>
		<span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">lock_classes</span> <span class="o">+</span> <span class="n">hlock</span><span class="o">-&gt;</span><span class="n">class_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_LOCK_STAT</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_class_stats</span><span class="p">[</span><span class="n">MAX_LOCKDEP_KEYS</span><span class="p">],</span>
		      <span class="n">cpu_lock_stats</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">lockstat_clock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">local_clock</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">lock_point</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">points</span><span class="p">[],</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LOCKSTAT_POINTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ip</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">ip</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">lock_time_inc</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_time</span> <span class="o">*</span><span class="n">lt</span><span class="p">,</span> <span class="n">u64</span> <span class="n">time</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">time</span> <span class="o">&gt;</span> <span class="n">lt</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">)</span>
		<span class="n">lt</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">=</span> <span class="n">time</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">time</span> <span class="o">&lt;</span> <span class="n">lt</span><span class="o">-&gt;</span><span class="n">min</span> <span class="o">||</span> <span class="o">!</span><span class="n">lt</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">)</span>
		<span class="n">lt</span><span class="o">-&gt;</span><span class="n">min</span> <span class="o">=</span> <span class="n">time</span><span class="p">;</span>

	<span class="n">lt</span><span class="o">-&gt;</span><span class="n">total</span> <span class="o">+=</span> <span class="n">time</span><span class="p">;</span>
	<span class="n">lt</span><span class="o">-&gt;</span><span class="n">nr</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">lock_time_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_time</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lock_time</span> <span class="o">*</span><span class="n">dst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">&gt;</span> <span class="n">dst</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">)</span>
		<span class="n">dst</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">min</span> <span class="o">&lt;</span> <span class="n">dst</span><span class="o">-&gt;</span><span class="n">min</span> <span class="o">||</span> <span class="o">!</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">)</span>
		<span class="n">dst</span><span class="o">-&gt;</span><span class="n">min</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">min</span><span class="p">;</span>

	<span class="n">dst</span><span class="o">-&gt;</span><span class="n">total</span> <span class="o">+=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">total</span><span class="p">;</span>
	<span class="n">dst</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">+=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">lock_class_stats</span> <span class="nf">lock_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">class</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lock_class_stats</span> <span class="n">stats</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stats</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_class_stats</span><span class="p">));</span>
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">lock_class_stats</span> <span class="o">*</span><span class="n">pcs</span> <span class="o">=</span>
			<span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_lock_stats</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)[</span><span class="n">class</span> <span class="o">-</span> <span class="n">lock_classes</span><span class="p">];</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">stats</span><span class="p">.</span><span class="n">contention_point</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">stats</span><span class="p">.</span><span class="n">contention_point</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">pcs</span><span class="o">-&gt;</span><span class="n">contention_point</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">stats</span><span class="p">.</span><span class="n">contending_point</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">stats</span><span class="p">.</span><span class="n">contending_point</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">pcs</span><span class="o">-&gt;</span><span class="n">contending_point</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">lock_time_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcs</span><span class="o">-&gt;</span><span class="n">read_waittime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stats</span><span class="p">.</span><span class="n">read_waittime</span><span class="p">);</span>
		<span class="n">lock_time_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcs</span><span class="o">-&gt;</span><span class="n">write_waittime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stats</span><span class="p">.</span><span class="n">write_waittime</span><span class="p">);</span>

		<span class="n">lock_time_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcs</span><span class="o">-&gt;</span><span class="n">read_holdtime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stats</span><span class="p">.</span><span class="n">read_holdtime</span><span class="p">);</span>
		<span class="n">lock_time_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcs</span><span class="o">-&gt;</span><span class="n">write_holdtime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stats</span><span class="p">.</span><span class="n">write_holdtime</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">stats</span><span class="p">.</span><span class="n">bounces</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">stats</span><span class="p">.</span><span class="n">bounces</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">pcs</span><span class="o">-&gt;</span><span class="n">bounces</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">stats</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">clear_lock_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">class</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">lock_class_stats</span> <span class="o">*</span><span class="n">cpu_stats</span> <span class="o">=</span>
			<span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_lock_stats</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)[</span><span class="n">class</span> <span class="o">-</span> <span class="n">lock_classes</span><span class="p">];</span>

		<span class="n">memset</span><span class="p">(</span><span class="n">cpu_stats</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_class_stats</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">contention_point</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">contention_point</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">contending_point</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">contending_point</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">lock_class_stats</span> <span class="o">*</span><span class="nf">get_lock_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">class</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">get_cpu_var</span><span class="p">(</span><span class="n">cpu_lock_stats</span><span class="p">)[</span><span class="n">class</span> <span class="o">-</span> <span class="n">lock_classes</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">put_lock_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_class_stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">put_cpu_var</span><span class="p">(</span><span class="n">cpu_lock_stats</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">lock_release_holdtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">hlock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lock_class_stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">holdtime</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lock_stat</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">holdtime</span> <span class="o">=</span> <span class="n">lockstat_clock</span><span class="p">()</span> <span class="o">-</span> <span class="n">hlock</span><span class="o">-&gt;</span><span class="n">holdtime_stamp</span><span class="p">;</span>

	<span class="n">stats</span> <span class="o">=</span> <span class="n">get_lock_stats</span><span class="p">(</span><span class="n">hlock_class</span><span class="p">(</span><span class="n">hlock</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hlock</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">)</span>
		<span class="n">lock_time_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">read_holdtime</span><span class="p">,</span> <span class="n">holdtime</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">lock_time_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">write_holdtime</span><span class="p">,</span> <span class="n">holdtime</span><span class="p">);</span>
	<span class="n">put_lock_stats</span><span class="p">(</span><span class="n">stats</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">lock_release_holdtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">hlock</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * We keep a global list of all lock classes. The list only grows,</span>
<span class="cm"> * never shrinks. The list is only accessed with the lockdep</span>
<span class="cm"> * spinlock lock held.</span>
<span class="cm"> */</span>
<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">all_lock_classes</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The lockdep classes are in a hash-table as well, for fast lookup:</span>
<span class="cm"> */</span>
<span class="cp">#define CLASSHASH_BITS		(MAX_LOCKDEP_KEYS_BITS - 1)</span>
<span class="cp">#define CLASSHASH_SIZE		(1UL &lt;&lt; CLASSHASH_BITS)</span>
<span class="cp">#define __classhashfn(key)	hash_long((unsigned long)key, CLASSHASH_BITS)</span>
<span class="cp">#define classhashentry(key)	(classhash_table + __classhashfn((key)))</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="n">classhash_table</span><span class="p">[</span><span class="n">CLASSHASH_SIZE</span><span class="p">];</span>

<span class="cm">/*</span>
<span class="cm"> * We put the lock dependency chains into a hash-table as well, to cache</span>
<span class="cm"> * their existence:</span>
<span class="cm"> */</span>
<span class="cp">#define CHAINHASH_BITS		(MAX_LOCKDEP_CHAINS_BITS-1)</span>
<span class="cp">#define CHAINHASH_SIZE		(1UL &lt;&lt; CHAINHASH_BITS)</span>
<span class="cp">#define __chainhashfn(chain)	hash_long(chain, CHAINHASH_BITS)</span>
<span class="cp">#define chainhashentry(chain)	(chainhash_table + __chainhashfn((chain)))</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="n">chainhash_table</span><span class="p">[</span><span class="n">CHAINHASH_SIZE</span><span class="p">];</span>

<span class="cm">/*</span>
<span class="cm"> * The hash key of the lock dependency chains is a hash itself too:</span>
<span class="cm"> * it&#39;s a hash of all locks taken up to that lock, including that lock.</span>
<span class="cm"> * It&#39;s a 64-bit hash, because it&#39;s important for the keys to be</span>
<span class="cm"> * unique.</span>
<span class="cm"> */</span>
<span class="cp">#define iterate_chain_key(key1, key2) \</span>
<span class="cp">	(((key1) &lt;&lt; MAX_LOCKDEP_KEYS_BITS) ^ \</span>
<span class="cp">	((key1) &gt;&gt; (64-MAX_LOCKDEP_KEYS_BITS)) ^ \</span>
<span class="cp">	(key2))</span>

<span class="kt">void</span> <span class="nf">lockdep_off</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">lockdep_recursion</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">lockdep_off</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">lockdep_on</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">lockdep_recursion</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">lockdep_on</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Debugging switches:</span>
<span class="cm"> */</span>

<span class="cp">#define VERBOSE			0</span>
<span class="cp">#define VERY_VERBOSE		0</span>

<span class="cp">#if VERBOSE</span>
<span class="cp"># define HARDIRQ_VERBOSE	1</span>
<span class="cp"># define SOFTIRQ_VERBOSE	1</span>
<span class="cp"># define RECLAIM_VERBOSE	1</span>
<span class="cp">#else</span>
<span class="cp"># define HARDIRQ_VERBOSE	0</span>
<span class="cp"># define SOFTIRQ_VERBOSE	0</span>
<span class="cp"># define RECLAIM_VERBOSE	0</span>
<span class="cp">#endif</span>

<span class="cp">#if VERBOSE || HARDIRQ_VERBOSE || SOFTIRQ_VERBOSE || RECLAIM_VERBOSE</span>
<span class="cm">/*</span>
<span class="cm"> * Quick filtering for interesting events:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">class_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">class</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	/* Example */</span>
<span class="c">	if (class-&gt;name_version == 1 &amp;&amp;</span>
<span class="c">			!strcmp(class-&gt;name, &quot;lockname&quot;))</span>
<span class="c">		return 1;</span>
<span class="c">	if (class-&gt;name_version == 1 &amp;&amp;</span>
<span class="c">			!strcmp(class-&gt;name, &quot;&amp;struct-&gt;lockfield&quot;))</span>
<span class="c">		return 1;</span>
<span class="cp">#endif</span>
	<span class="cm">/* Filter everything else. 1 would be to allow everything else */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">verbose</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">class</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if VERBOSE</span>
	<span class="k">return</span> <span class="n">class_filter</span><span class="p">(</span><span class="n">class</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Stack-trace: tightly packed array of stack backtrace</span>
<span class="cm"> * addresses. Protected by the graph_lock.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_stack_trace_entries</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stack_trace</span><span class="p">[</span><span class="n">MAX_STACK_TRACE_ENTRIES</span><span class="p">];</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">save_trace</span><span class="p">(</span><span class="k">struct</span> <span class="n">stack_trace</span> <span class="o">*</span><span class="n">trace</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace</span><span class="o">-&gt;</span><span class="n">nr_entries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">trace</span><span class="o">-&gt;</span><span class="n">max_entries</span> <span class="o">=</span> <span class="n">MAX_STACK_TRACE_ENTRIES</span> <span class="o">-</span> <span class="n">nr_stack_trace_entries</span><span class="p">;</span>
	<span class="n">trace</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">=</span> <span class="n">stack_trace</span> <span class="o">+</span> <span class="n">nr_stack_trace_entries</span><span class="p">;</span>

	<span class="n">trace</span><span class="o">-&gt;</span><span class="n">skip</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

	<span class="n">save_stack_trace</span><span class="p">(</span><span class="n">trace</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some daft arches put -1 at the end to indicate its a full trace.</span>
<span class="cm">	 *</span>
<span class="cm">	 * &lt;rant&gt; this is buggy anyway, since it takes a whole extra entry so a</span>
<span class="cm">	 * complete trace that maxes out the entries provided will be reported</span>
<span class="cm">	 * as incomplete, friggin useless &lt;/rant&gt;</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trace</span><span class="o">-&gt;</span><span class="n">nr_entries</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">trace</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">trace</span><span class="o">-&gt;</span><span class="n">nr_entries</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">ULONG_MAX</span><span class="p">)</span>
		<span class="n">trace</span><span class="o">-&gt;</span><span class="n">nr_entries</span><span class="o">--</span><span class="p">;</span>

	<span class="n">trace</span><span class="o">-&gt;</span><span class="n">max_entries</span> <span class="o">=</span> <span class="n">trace</span><span class="o">-&gt;</span><span class="n">nr_entries</span><span class="p">;</span>

	<span class="n">nr_stack_trace_entries</span> <span class="o">+=</span> <span class="n">trace</span><span class="o">-&gt;</span><span class="n">nr_entries</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr_stack_trace_entries</span> <span class="o">&gt;=</span> <span class="n">MAX_STACK_TRACE_ENTRIES</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug_locks_off_graph_unlock</span><span class="p">())</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;BUG: MAX_STACK_TRACE_ENTRIES too low!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;turning off the locking correctness validator.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_hardirq_chains</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_softirq_chains</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_process_chains</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_lockdep_depth</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_DEBUG_LOCKDEP</span>
<span class="cm">/*</span>
<span class="cm"> * We cannot printk in early bootup code. Not even early_printk()</span>
<span class="cm"> * might work. So we mark any initialization errors and printk</span>
<span class="cm"> * about it later on, in lockdep_info().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lockdep_init_error</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">lock_init_error</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lockdep_init_trace_data</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">stack_trace</span> <span class="n">lockdep_init_trace</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">max_entries</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">lockdep_init_trace_data</span><span class="p">),</span>
	<span class="p">.</span><span class="n">entries</span> <span class="o">=</span> <span class="n">lockdep_init_trace_data</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Various lockdep statistics:</span>
<span class="cm"> */</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">lockdep_stats</span><span class="p">,</span> <span class="n">lockdep_stats</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Locking printouts:</span>
<span class="cm"> */</span>

<span class="cp">#define __USAGE(__STATE)						\</span>
<span class="cp">	[LOCK_USED_IN_##__STATE] = &quot;IN-&quot;__stringify(__STATE)&quot;-W&quot;,	\</span>
<span class="cp">	[LOCK_ENABLED_##__STATE] = __stringify(__STATE)&quot;-ON-W&quot;,		\</span>
<span class="cp">	[LOCK_USED_IN_##__STATE##_READ] = &quot;IN-&quot;__stringify(__STATE)&quot;-R&quot;,\</span>
<span class="cp">	[LOCK_ENABLED_##__STATE##_READ] = __stringify(__STATE)&quot;-ON-R&quot;,</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">usage_str</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
<span class="cp">#define LOCKDEP_STATE(__STATE) __USAGE(__STATE)</span>
<span class="cp">#include &quot;lockdep_states.h&quot;</span>
<span class="cp">#undef LOCKDEP_STATE</span>
	<span class="p">[</span><span class="n">LOCK_USED</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;INITIAL USE&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="nf">__get_key_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">lockdep_subclass_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kallsyms_lookup</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">key</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">lock_flag</span><span class="p">(</span><span class="k">enum</span> <span class="n">lock_usage_bit</span> <span class="n">bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">char</span> <span class="nf">get_usage_char</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">class</span><span class="p">,</span> <span class="k">enum</span> <span class="n">lock_usage_bit</span> <span class="n">bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="sc">&#39;.&#39;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">usage_mask</span> <span class="o">&amp;</span> <span class="n">lock_flag</span><span class="p">(</span><span class="n">bit</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span>
		<span class="n">c</span> <span class="o">=</span> <span class="sc">&#39;+&#39;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">usage_mask</span> <span class="o">&amp;</span> <span class="n">lock_flag</span><span class="p">(</span><span class="n">bit</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">c</span> <span class="o">=</span> <span class="sc">&#39;-&#39;</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">usage_mask</span> <span class="o">&amp;</span> <span class="n">lock_flag</span><span class="p">(</span><span class="n">bit</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span>
			<span class="n">c</span> <span class="o">=</span> <span class="sc">&#39;?&#39;</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">get_usage_chars</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">class</span><span class="p">,</span> <span class="kt">char</span> <span class="n">usage</span><span class="p">[</span><span class="n">LOCK_USAGE_CHARS</span><span class="p">])</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#define LOCKDEP_STATE(__STATE) 						\</span>
<span class="cp">	usage[i++] = get_usage_char(class, LOCK_USED_IN_##__STATE);	\</span>
<span class="cp">	usage[i++] = get_usage_char(class, LOCK_USED_IN_##__STATE##_READ);</span>
<span class="cp">#include &quot;lockdep_states.h&quot;</span>
<span class="cp">#undef LOCKDEP_STATE</span>

	<span class="n">usage</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__print_lock_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">class</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="n">KSYM_NAME_LEN</span><span class="p">];</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>

	<span class="n">name</span> <span class="o">=</span> <span class="n">class</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">name</span> <span class="o">=</span> <span class="n">__get_key_name</span><span class="p">(</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">name_version</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;#%d&quot;</span><span class="p">,</span> <span class="n">class</span><span class="o">-&gt;</span><span class="n">name_version</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">subclass</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;/%d&quot;</span><span class="p">,</span> <span class="n">class</span><span class="o">-&gt;</span><span class="n">subclass</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_lock_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">class</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">usage</span><span class="p">[</span><span class="n">LOCK_USAGE_CHARS</span><span class="p">];</span>

	<span class="n">get_usage_chars</span><span class="p">(</span><span class="n">class</span><span class="p">,</span> <span class="n">usage</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; (&quot;</span><span class="p">);</span>
	<span class="n">__print_lock_name</span><span class="p">(</span><span class="n">class</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;){%s}&quot;</span><span class="p">,</span> <span class="n">usage</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_lockdep_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">lockdep_map</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="n">KSYM_NAME_LEN</span><span class="p">];</span>

	<span class="n">name</span> <span class="o">=</span> <span class="n">lock</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">name</span><span class="p">)</span>
		<span class="n">name</span> <span class="o">=</span> <span class="n">__get_key_name</span><span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">subkeys</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">hlock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">print_lock_name</span><span class="p">(</span><span class="n">hlock_class</span><span class="p">(</span><span class="n">hlock</span><span class="p">));</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;, at: &quot;</span><span class="p">);</span>
	<span class="n">print_ip_sym</span><span class="p">(</span><span class="n">hlock</span><span class="o">-&gt;</span><span class="n">acquire_ip</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">lockdep_print_held_locks</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">lockdep_depth</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">depth</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;no locks held by %s/%d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">curr</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%d lock%s held by %s/%d:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">depth</span><span class="p">,</span> <span class="n">depth</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">?</span> <span class="s">&quot;s&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">curr</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">depth</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot; #%d: &quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">print_lock</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">held_locks</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_kernel_ident</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s %.*s %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">init_utsname</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">strcspn</span><span class="p">(</span><span class="n">init_utsname</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">),</span>
		<span class="n">init_utsname</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">,</span>
		<span class="n">print_tainted</span><span class="p">());</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">very_verbose</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">class</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if VERY_VERBOSE</span>
	<span class="k">return</span> <span class="n">class_filter</span><span class="p">(</span><span class="n">class</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Is this the address of a static object:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">static_obj</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">_stext</span><span class="p">,</span>
		      <span class="n">end</span>   <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">_end</span><span class="p">,</span>
		      <span class="n">addr</span>  <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">obj</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * static variable?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">start</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arch_is_kernel_data</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * in-kernel percpu var?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_kernel_percpu_address</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * module static or percpu var?</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">is_module_address</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">||</span> <span class="n">is_module_percpu_address</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * To make lock name printouts unique, we calculate a unique</span>
<span class="cm"> * class-&gt;name_version generation counter:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">count_matching_names</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">new_class</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">class</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_class</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">class</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">all_lock_classes</span><span class="p">,</span> <span class="n">lock_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_class</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">-</span> <span class="n">new_class</span><span class="o">-&gt;</span><span class="n">subclass</span> <span class="o">==</span> <span class="n">class</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">class</span><span class="o">-&gt;</span><span class="n">name_version</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">new_class</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span>
			<span class="n">count</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">class</span><span class="o">-&gt;</span><span class="n">name_version</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Register a lock&#39;s class in the hash-table, if the class is not present</span>
<span class="cm"> * yet. Otherwise we look it up. We cache the result in the lock object</span>
<span class="cm"> * itself, so actual lookup of the hash should be once per lock object.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span>
<span class="nf">look_up_lock_class</span><span class="p">(</span><span class="k">struct</span> <span class="n">lockdep_map</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">subclass</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lockdep_subclass_key</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">hash_head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">class</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_DEBUG_LOCKDEP</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the architecture calls into lockdep before initializing</span>
<span class="cm">	 * the hashes then we&#39;ll warn about it later. (we cannot printk</span>
<span class="cm">	 * right now)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">lockdep_initialized</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lockdep_init</span><span class="p">();</span>
		<span class="n">lockdep_init_error</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">lock_init_error</span> <span class="o">=</span> <span class="n">lock</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
		<span class="n">save_stack_trace</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lockdep_init_trace</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">subclass</span> <span class="o">&gt;=</span> <span class="n">MAX_LOCKDEP_SUBCLASSES</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">debug_locks_off</span><span class="p">();</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
			<span class="s">&quot;BUG: looking up invalid subclass: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">subclass</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
			<span class="s">&quot;turning off the locking correctness validator.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Static locks do not have their class-keys yet - for them the key</span>
<span class="cm">	 * is the lock object itself:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">))</span>
		<span class="n">lock</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">lock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * NOTE: the class-key must be unique. For dynamic locks, a static</span>
<span class="cm">	 * lock_class_key variable is passed in through the mutex_init()</span>
<span class="cm">	 * (or spin_lock_init()) call - which acts as the key. For static</span>
<span class="cm">	 * locks we use the lock object itself as the key.</span>
<span class="cm">	 */</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_class_key</span><span class="p">)</span> <span class="o">&gt;</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lockdep_map</span><span class="p">));</span>

	<span class="n">key</span> <span class="o">=</span> <span class="n">lock</span><span class="o">-&gt;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">subkeys</span> <span class="o">+</span> <span class="n">subclass</span><span class="p">;</span>

	<span class="n">hash_head</span> <span class="o">=</span> <span class="n">classhashentry</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We can walk the hash lockfree, because the hash only</span>
<span class="cm">	 * grows, and we are careful when adding entries to the end:</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">class</span><span class="p">,</span> <span class="n">hash_head</span><span class="p">,</span> <span class="n">hash_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">==</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Huh! same key, different name? Did someone trample</span>
<span class="cm">			 * on some memory? We&#39;re most confused.</span>
<span class="cm">			 */</span>
			<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">!=</span> <span class="n">lock</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">class</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Register a lock&#39;s class in the hash-table, if the class is not present</span>
<span class="cm"> * yet. Otherwise we look it up. We cache the result in the lock object</span>
<span class="cm"> * itself, so actual lookup of the hash should be once per lock object.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span>
<span class="nf">register_lock_class</span><span class="p">(</span><span class="k">struct</span> <span class="n">lockdep_map</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">subclass</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lockdep_subclass_key</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">hash_head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">class</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">class</span> <span class="o">=</span> <span class="n">look_up_lock_class</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">subclass</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">class</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_set_class_cache</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Debug-check: all keys must be persistent!</span>
<span class="cm"> 	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">static_obj</span><span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">debug_locks_off</span><span class="p">();</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;INFO: trying to register non-static key.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;the code is fine but needs lockdep annotation.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;turning off the locking correctness validator.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>

		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">key</span> <span class="o">=</span> <span class="n">lock</span><span class="o">-&gt;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">subkeys</span> <span class="o">+</span> <span class="n">subclass</span><span class="p">;</span>
	<span class="n">hash_head</span> <span class="o">=</span> <span class="n">classhashentry</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>

	<span class="n">raw_local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">graph_lock</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">raw_local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * We have to do the hash-walk again, to avoid races</span>
<span class="cm">	 * with another CPU:</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">class</span><span class="p">,</span> <span class="n">hash_head</span><span class="p">,</span> <span class="n">hash_entry</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">==</span> <span class="n">key</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock_set</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Allocate a new key from the static array, and add it to</span>
<span class="cm">	 * the hash:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_lock_classes</span> <span class="o">&gt;=</span> <span class="n">MAX_LOCKDEP_KEYS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug_locks_off_graph_unlock</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">raw_local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">raw_local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;BUG: MAX_LOCKDEP_KEYS too low!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;turning off the locking correctness validator.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">class</span> <span class="o">=</span> <span class="n">lock_classes</span> <span class="o">+</span> <span class="n">nr_lock_classes</span><span class="o">++</span><span class="p">;</span>
	<span class="n">debug_atomic_inc</span><span class="p">(</span><span class="n">nr_unused_locks</span><span class="p">);</span>
	<span class="n">class</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
	<span class="n">class</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">lock</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="n">class</span><span class="o">-&gt;</span><span class="n">subclass</span> <span class="o">=</span> <span class="n">subclass</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">lock_entry</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">locks_before</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">locks_after</span><span class="p">);</span>
	<span class="n">class</span><span class="o">-&gt;</span><span class="n">name_version</span> <span class="o">=</span> <span class="n">count_matching_names</span><span class="p">(</span><span class="n">class</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * We use RCU&#39;s safe list-add method to make</span>
<span class="cm">	 * parallel walking of the hash-list safe:</span>
<span class="cm">	 */</span>
	<span class="n">list_add_tail_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">hash_entry</span><span class="p">,</span> <span class="n">hash_head</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Add it to the global list of classes:</span>
<span class="cm">	 */</span>
	<span class="n">list_add_tail_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">lock_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">all_lock_classes</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">verbose</span><span class="p">(</span><span class="n">class</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">graph_unlock</span><span class="p">();</span>
		<span class="n">raw_local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">new class %p: %s&quot;</span><span class="p">,</span> <span class="n">class</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">class</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">name_version</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;#%d&quot;</span><span class="p">,</span> <span class="n">class</span><span class="o">-&gt;</span><span class="n">name_version</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>

		<span class="n">raw_local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">graph_lock</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">raw_local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out_unlock_set:</span>
	<span class="n">graph_unlock</span><span class="p">();</span>
	<span class="n">raw_local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

<span class="nl">out_set_class_cache:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">subclass</span> <span class="o">||</span> <span class="n">force</span><span class="p">)</span>
		<span class="n">lock</span><span class="o">-&gt;</span><span class="n">class_cache</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">class</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">subclass</span> <span class="o">&lt;</span> <span class="n">NR_LOCKDEP_CACHING_CLASSES</span><span class="p">)</span>
		<span class="n">lock</span><span class="o">-&gt;</span><span class="n">class_cache</span><span class="p">[</span><span class="n">subclass</span><span class="p">]</span> <span class="o">=</span> <span class="n">class</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Hash collision, did we smoke some? We found a class with a matching</span>
<span class="cm">	 * hash but the subclass -- which is hashed in -- didn&#39;t match.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">(</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">subclass</span> <span class="o">!=</span> <span class="n">subclass</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">class</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PROVE_LOCKING</span>
<span class="cm">/*</span>
<span class="cm"> * Allocate a lockdep entry. (assumes the graph_lock held, returns</span>
<span class="cm"> * with NULL on failure)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="nf">alloc_list_entry</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_list_entries</span> <span class="o">&gt;=</span> <span class="n">MAX_LOCKDEP_ENTRIES</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug_locks_off_graph_unlock</span><span class="p">())</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;BUG: MAX_LOCKDEP_ENTRIES too low!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;turning off the locking correctness validator.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">list_entries</span> <span class="o">+</span> <span class="n">nr_list_entries</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Add a new dependency to the head of the list:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">add_lock_to_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">class</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">distance</span><span class="p">,</span> <span class="k">struct</span> <span class="n">stack_trace</span> <span class="o">*</span><span class="n">trace</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Lock not present yet - get a new dependency struct and</span>
<span class="cm">	 * add it to the list:</span>
<span class="cm">	 */</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">alloc_list_entry</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">=</span> <span class="n">this</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">trace</span> <span class="o">=</span> <span class="o">*</span><span class="n">trace</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Since we never remove from the dependency list, the list can</span>
<span class="cm">	 * be walked lockless by other CPUs, it&#39;s only allocation</span>
<span class="cm">	 * that must be protected by the spinlock. But this also means</span>
<span class="cm">	 * we must make new entries visible only once writes to the</span>
<span class="cm">	 * entry become visible - hence the RCU op:</span>
<span class="cm">	 */</span>
	<span class="n">list_add_tail_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * For good efficiency of modular, we use power of 2</span>
<span class="cm"> */</span>
<span class="cp">#define MAX_CIRCULAR_QUEUE_SIZE		4096UL</span>
<span class="cp">#define CQ_MASK				(MAX_CIRCULAR_QUEUE_SIZE-1)</span>

<span class="cm">/*</span>
<span class="cm"> * The circular_queue and helpers is used to implement the</span>
<span class="cm"> * breadth-first search(BFS)algorithem, by which we can build</span>
<span class="cm"> * the shortest path from the next lock to be acquired to the</span>
<span class="cm"> * previous held lock if there is a circular between them.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">circular_queue</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">element</span><span class="p">[</span><span class="n">MAX_CIRCULAR_QUEUE_SIZE</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">front</span><span class="p">,</span> <span class="n">rear</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">circular_queue</span> <span class="n">lock_cq</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_bfs_queue_depth</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lockdep_dependency_gen_id</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__cq_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">circular_queue</span> <span class="o">*</span><span class="n">cq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cq</span><span class="o">-&gt;</span><span class="n">front</span> <span class="o">=</span> <span class="n">cq</span><span class="o">-&gt;</span><span class="n">rear</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lockdep_dependency_gen_id</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__cq_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">circular_queue</span> <span class="o">*</span><span class="n">cq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">cq</span><span class="o">-&gt;</span><span class="n">front</span> <span class="o">==</span> <span class="n">cq</span><span class="o">-&gt;</span><span class="n">rear</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__cq_full</span><span class="p">(</span><span class="k">struct</span> <span class="n">circular_queue</span> <span class="o">*</span><span class="n">cq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">cq</span><span class="o">-&gt;</span><span class="n">rear</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CQ_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">cq</span><span class="o">-&gt;</span><span class="n">front</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__cq_enqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">circular_queue</span> <span class="o">*</span><span class="n">cq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">elem</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__cq_full</span><span class="p">(</span><span class="n">cq</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">cq</span><span class="o">-&gt;</span><span class="n">element</span><span class="p">[</span><span class="n">cq</span><span class="o">-&gt;</span><span class="n">rear</span><span class="p">]</span> <span class="o">=</span> <span class="n">elem</span><span class="p">;</span>
	<span class="n">cq</span><span class="o">-&gt;</span><span class="n">rear</span> <span class="o">=</span> <span class="p">(</span><span class="n">cq</span><span class="o">-&gt;</span><span class="n">rear</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CQ_MASK</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__cq_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">circular_queue</span> <span class="o">*</span><span class="n">cq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">elem</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__cq_empty</span><span class="p">(</span><span class="n">cq</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="o">*</span><span class="n">elem</span> <span class="o">=</span> <span class="n">cq</span><span class="o">-&gt;</span><span class="n">element</span><span class="p">[</span><span class="n">cq</span><span class="o">-&gt;</span><span class="n">front</span><span class="p">];</span>
	<span class="n">cq</span><span class="o">-&gt;</span><span class="n">front</span> <span class="o">=</span> <span class="p">(</span><span class="n">cq</span><span class="o">-&gt;</span><span class="n">front</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CQ_MASK</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>  <span class="nf">__cq_get_elem_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">circular_queue</span> <span class="o">*</span><span class="n">cq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">cq</span><span class="o">-&gt;</span><span class="n">rear</span> <span class="o">-</span> <span class="n">cq</span><span class="o">-&gt;</span><span class="n">front</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CQ_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mark_lock_accessed</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">;</span>

	<span class="n">nr</span> <span class="o">=</span> <span class="n">lock</span> <span class="o">-</span> <span class="n">list_entries</span><span class="p">;</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">nr</span> <span class="o">&gt;=</span> <span class="n">nr_list_entries</span><span class="p">);</span> <span class="cm">/* Out-of-bounds, input fail */</span>
	<span class="n">lock</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
	<span class="n">lock</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">dep_gen_id</span> <span class="o">=</span> <span class="n">lockdep_dependency_gen_id</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">lock_accessed</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">;</span>

	<span class="n">nr</span> <span class="o">=</span> <span class="n">lock</span> <span class="o">-</span> <span class="n">list_entries</span><span class="p">;</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">nr</span> <span class="o">&gt;=</span> <span class="n">nr_list_entries</span><span class="p">);</span> <span class="cm">/* Out-of-bounds, input fail */</span>
	<span class="k">return</span> <span class="n">lock</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">dep_gen_id</span> <span class="o">==</span> <span class="n">lockdep_dependency_gen_id</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="nf">get_lock_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">child</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">get_lock_depth</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">child</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">parent</span> <span class="o">=</span> <span class="n">get_lock_parent</span><span class="p">(</span><span class="n">child</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">child</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
		<span class="n">depth</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">depth</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__bfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">source_entry</span><span class="p">,</span>
		 <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		 <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">),</span>
		 <span class="k">struct</span> <span class="n">lock_list</span> <span class="o">**</span><span class="n">target_entry</span><span class="p">,</span>
		 <span class="kt">int</span> <span class="n">forward</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">circular_queue</span> <span class="o">*</span><span class="n">cq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lock_cq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="p">(</span><span class="n">source_entry</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">target_entry</span> <span class="o">=</span> <span class="n">source_entry</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">forward</span><span class="p">)</span>
		<span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">source_entry</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">locks_after</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">source_entry</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">locks_before</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="n">head</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="n">__cq_init</span><span class="p">(</span><span class="n">cq</span><span class="p">);</span>
	<span class="n">__cq_enqueue</span><span class="p">(</span><span class="n">cq</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">source_entry</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">__cq_empty</span><span class="p">(</span><span class="n">cq</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">lock</span><span class="p">;</span>

		<span class="n">__cq_dequeue</span><span class="p">(</span><span class="n">cq</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">forward</span><span class="p">)</span>
			<span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">locks_after</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">locks_before</span><span class="p">;</span>

		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lock_accessed</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span> <span class="p">{</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cq_depth</span><span class="p">;</span>
				<span class="n">mark_lock_accessed</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">lock</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span> <span class="p">{</span>
					<span class="o">*</span><span class="n">target_entry</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">__cq_enqueue</span><span class="p">(</span><span class="n">cq</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">entry</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">cq_depth</span> <span class="o">=</span> <span class="n">__cq_get_elem_count</span><span class="p">(</span><span class="n">cq</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">max_bfs_queue_depth</span> <span class="o">&lt;</span> <span class="n">cq_depth</span><span class="p">)</span>
					<span class="n">max_bfs_queue_depth</span> <span class="o">=</span> <span class="n">cq_depth</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">exit:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__bfs_forwards</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">src_entry</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">),</span>
			<span class="k">struct</span> <span class="n">lock_list</span> <span class="o">**</span><span class="n">target_entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__bfs</span><span class="p">(</span><span class="n">src_entry</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">target_entry</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__bfs_backwards</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">src_entry</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">),</span>
			<span class="k">struct</span> <span class="n">lock_list</span> <span class="o">**</span><span class="n">target_entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__bfs</span><span class="p">(</span><span class="n">src_entry</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">target_entry</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Recursive, forwards-direction lock-dependency checking, used for</span>
<span class="cm"> * both noncyclic checking and for hardirq-unsafe/softirq-unsafe</span>
<span class="cm"> * checking.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Print a dependency chain entry (this is only done when a deadlock</span>
<span class="cm"> * has been detected):</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span>
<span class="nf">print_circular_bug_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_locks_silent</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">-&gt; #%u&quot;</span><span class="p">,</span> <span class="n">depth</span><span class="p">);</span>
	<span class="n">print_lock_name</span><span class="p">(</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">print_stack_trace</span><span class="p">(</span><span class="o">&amp;</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">trace</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">print_circular_lock_scenario</span><span class="p">(</span><span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">tgt</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">prt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">source</span> <span class="o">=</span> <span class="n">hlock_class</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">target</span> <span class="o">=</span> <span class="n">hlock_class</span><span class="p">(</span><span class="n">tgt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">prt</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * A direct locking problem where unsafe_class lock is taken</span>
<span class="cm">	 * directly by safe_class lock, then all we need to show</span>
<span class="cm">	 * is the deadlock scenario, as it is obvious that the</span>
<span class="cm">	 * unsafe lock is taken under the safe lock.</span>
<span class="cm">	 *</span>
<span class="cm">	 * But if there is a chain instead, where the safe lock takes</span>
<span class="cm">	 * an intermediate lock (middle_class) where this lock is</span>
<span class="cm">	 * not the same as the safe lock, then the lock chain is</span>
<span class="cm">	 * used to describe the problem. Otherwise we would need</span>
<span class="cm">	 * to show a different CPU case for each link in the chain</span>
<span class="cm">	 * from the safe_class lock to the unsafe_class lock.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span> <span class="o">!=</span> <span class="n">source</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Chain exists of:</span><span class="se">\n</span><span class="s">  &quot;</span><span class="p">);</span>
		<span class="n">__print_lock_name</span><span class="p">(</span><span class="n">source</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot; --&gt; &quot;</span><span class="p">);</span>
		<span class="n">__print_lock_name</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot; --&gt; &quot;</span><span class="p">);</span>
		<span class="n">__print_lock_name</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; Possible unsafe locking scenario:</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;       CPU0                    CPU1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;       ----                    ----</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  lock(&quot;</span><span class="p">);</span>
	<span class="n">__print_lock_name</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;);</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;                               lock(&quot;</span><span class="p">);</span>
	<span class="n">__print_lock_name</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;);</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;                               lock(&quot;</span><span class="p">);</span>
	<span class="n">__print_lock_name</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;);</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  lock(&quot;</span><span class="p">);</span>
	<span class="n">__print_lock_name</span><span class="p">(</span><span class="n">source</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;);</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s"> *** DEADLOCK ***</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When a circular dependency is detected, print the</span>
<span class="cm"> * header first:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span>
<span class="nf">print_circular_bug_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">check_src</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">check_tgt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debug_locks_silent</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;======================================================</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;[ INFO: possible circular locking dependency detected ]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">print_kernel_ident</span><span class="p">();</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;-------------------------------------------------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s/%d is trying to acquire lock:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">curr</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">curr</span><span class="p">));</span>
	<span class="n">print_lock</span><span class="p">(</span><span class="n">check_src</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">but task is already holding lock:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">print_lock</span><span class="p">(</span><span class="n">check_tgt</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">which lock already depends on the new lock.</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">the existing dependency chain (in reverse order) is:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">print_circular_bug_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">depth</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">class_equal</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">==</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">print_circular_bug</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">check_src</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">check_tgt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">first_parent</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">depth</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug_locks_off_graph_unlock</span><span class="p">()</span> <span class="o">||</span> <span class="n">debug_locks_silent</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">save_trace</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">trace</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">depth</span> <span class="o">=</span> <span class="n">get_lock_depth</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>

	<span class="n">print_circular_bug_header</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">check_src</span><span class="p">,</span> <span class="n">check_tgt</span><span class="p">);</span>

	<span class="n">parent</span> <span class="o">=</span> <span class="n">get_lock_parent</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>
	<span class="n">first_parent</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">print_circular_bug_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="o">--</span><span class="n">depth</span><span class="p">);</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="n">get_lock_parent</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">other info that might help us debug this:</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">print_circular_lock_scenario</span><span class="p">(</span><span class="n">check_src</span><span class="p">,</span> <span class="n">check_tgt</span><span class="p">,</span>
				     <span class="n">first_parent</span><span class="p">);</span>

	<span class="n">lockdep_print_held_locks</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">stack backtrace:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">dump_stack</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">print_bfs_bug</span><span class="p">(</span><span class="kt">int</span> <span class="n">ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug_locks_off_graph_unlock</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Breadth-first-search failed, graph got corrupted?</span>
<span class="cm">	 */</span>
	<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;lockdep bfs error:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">noop_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">__lockdep_count_forward_deps</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">this</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>  <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">uninitialized_var</span><span class="p">(</span><span class="n">target_entry</span><span class="p">);</span>

	<span class="n">__bfs_forwards</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="n">noop_count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">target_entry</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">lockdep_count_forward_deps</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">class</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ret</span><span class="p">,</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock_list</span> <span class="n">this</span><span class="p">;</span>

	<span class="n">this</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">this</span><span class="p">.</span><span class="n">class</span> <span class="o">=</span> <span class="n">class</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">arch_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lockdep_lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__lockdep_count_forward_deps</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="p">);</span>
	<span class="n">arch_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lockdep_lock</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">__lockdep_count_backward_deps</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">this</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>  <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">uninitialized_var</span><span class="p">(</span><span class="n">target_entry</span><span class="p">);</span>

	<span class="n">__bfs_backwards</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="n">noop_count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">target_entry</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">lockdep_count_backward_deps</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">class</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ret</span><span class="p">,</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock_list</span> <span class="n">this</span><span class="p">;</span>

	<span class="n">this</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">this</span><span class="p">.</span><span class="n">class</span> <span class="o">=</span> <span class="n">class</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">arch_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lockdep_lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__lockdep_count_backward_deps</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="p">);</span>
	<span class="n">arch_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lockdep_lock</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Prove that the dependency graph starting at &lt;entry&gt; can not</span>
<span class="cm"> * lead to &lt;target&gt;. Print an error and return 0 if it does.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span>
<span class="nf">check_noncircular</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">lock_list</span> <span class="o">**</span><span class="n">target_entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">debug_atomic_inc</span><span class="p">(</span><span class="n">nr_cyclic_checks</span><span class="p">);</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">__bfs_forwards</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">class_equal</span><span class="p">,</span> <span class="n">target_entry</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if defined(CONFIG_TRACE_IRQFLAGS) &amp;&amp; defined(CONFIG_PROVE_LOCKING)</span>
<span class="cm">/*</span>
<span class="cm"> * Forwards and backwards subgraph searching, for the purposes of</span>
<span class="cm"> * proving that two subgraphs can be connected by a new dependency</span>
<span class="cm"> * without creating any illegal irq-safe -&gt; irq-unsafe lock dependency.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">usage_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">usage_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="k">enum</span> <span class="n">lock_usage_bit</span><span class="p">)</span><span class="n">bit</span><span class="p">);</span>
<span class="p">}</span>



<span class="cm">/*</span>
<span class="cm"> * Find a node in the forwards-direction dependency sub-graph starting</span>
<span class="cm"> * at @root-&gt;class that matches @bit.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if such a node exists in the subgraph, and put that node</span>
<span class="cm"> * into *@target_entry.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 1 otherwise and keep *@target_entry unchanged.</span>
<span class="cm"> * Return &lt;0 on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">find_usage_forwards</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">enum</span> <span class="n">lock_usage_bit</span> <span class="n">bit</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">lock_list</span> <span class="o">**</span><span class="n">target_entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">debug_atomic_inc</span><span class="p">(</span><span class="n">nr_find_usage_forwards_checks</span><span class="p">);</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">__bfs_forwards</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">bit</span><span class="p">,</span> <span class="n">usage_match</span><span class="p">,</span> <span class="n">target_entry</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find a node in the backwards-direction dependency sub-graph starting</span>
<span class="cm"> * at @root-&gt;class that matches @bit.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if such a node exists in the subgraph, and put that node</span>
<span class="cm"> * into *@target_entry.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 1 otherwise and keep *@target_entry unchanged.</span>
<span class="cm"> * Return &lt;0 on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">find_usage_backwards</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">enum</span> <span class="n">lock_usage_bit</span> <span class="n">bit</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">lock_list</span> <span class="o">**</span><span class="n">target_entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">debug_atomic_inc</span><span class="p">(</span><span class="n">nr_find_usage_backwards_checks</span><span class="p">);</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">__bfs_backwards</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">bit</span><span class="p">,</span> <span class="n">usage_match</span><span class="p">,</span> <span class="n">target_entry</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_lock_class_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">class</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bit</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%*s-&gt;&quot;</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
	<span class="n">print_lock_name</span><span class="p">(</span><span class="n">class</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; ops: %lu&quot;</span><span class="p">,</span> <span class="n">class</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; {</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">bit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bit</span> <span class="o">&lt;</span> <span class="n">LOCK_USAGE_STATES</span><span class="p">;</span> <span class="n">bit</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">usage_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">depth</span><span class="p">;</span>

			<span class="n">len</span> <span class="o">+=</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;%*s   %s&quot;</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">usage_str</span><span class="p">[</span><span class="n">bit</span><span class="p">]);</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot; at:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">print_stack_trace</span><span class="p">(</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">usage_traces</span> <span class="o">+</span> <span class="n">bit</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%*s }</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%*s ... key      at: &quot;</span><span class="p">,</span><span class="n">depth</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">);</span>
	<span class="n">print_ip_sym</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * printk the shortest lock dependencies from @start to @end in reverse order:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__used</span>
<span class="nf">print_shortest_lock_dependencies</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">leaf</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">leaf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">depth</span><span class="p">;</span>

	<span class="cm">/*compute depth from generated tree by BFS*/</span>
	<span class="n">depth</span> <span class="o">=</span> <span class="n">get_lock_depth</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">print_lock_class_header</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">,</span> <span class="n">depth</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%*s ... acquired at:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
		<span class="n">print_stack_trace</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">trace</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">entry</span> <span class="o">!=</span> <span class="n">root</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;lockdep:%s bad path found in chain graph</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">entry</span> <span class="o">=</span> <span class="n">get_lock_parent</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
		<span class="n">depth</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">entry</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">depth</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">));</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">print_irq_lock_scenario</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">safe_entry</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">unsafe_entry</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">prev_class</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">next_class</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">safe_class</span> <span class="o">=</span> <span class="n">safe_entry</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">unsafe_class</span> <span class="o">=</span> <span class="n">unsafe_entry</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">middle_class</span> <span class="o">=</span> <span class="n">prev_class</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">middle_class</span> <span class="o">==</span> <span class="n">safe_class</span><span class="p">)</span>
		<span class="n">middle_class</span> <span class="o">=</span> <span class="n">next_class</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * A direct locking problem where unsafe_class lock is taken</span>
<span class="cm">	 * directly by safe_class lock, then all we need to show</span>
<span class="cm">	 * is the deadlock scenario, as it is obvious that the</span>
<span class="cm">	 * unsafe lock is taken under the safe lock.</span>
<span class="cm">	 *</span>
<span class="cm">	 * But if there is a chain instead, where the safe lock takes</span>
<span class="cm">	 * an intermediate lock (middle_class) where this lock is</span>
<span class="cm">	 * not the same as the safe lock, then the lock chain is</span>
<span class="cm">	 * used to describe the problem. Otherwise we would need</span>
<span class="cm">	 * to show a different CPU case for each link in the chain</span>
<span class="cm">	 * from the safe_class lock to the unsafe_class lock.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">middle_class</span> <span class="o">!=</span> <span class="n">unsafe_class</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Chain exists of:</span><span class="se">\n</span><span class="s">  &quot;</span><span class="p">);</span>
		<span class="n">__print_lock_name</span><span class="p">(</span><span class="n">safe_class</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot; --&gt; &quot;</span><span class="p">);</span>
		<span class="n">__print_lock_name</span><span class="p">(</span><span class="n">middle_class</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot; --&gt; &quot;</span><span class="p">);</span>
		<span class="n">__print_lock_name</span><span class="p">(</span><span class="n">unsafe_class</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; Possible interrupt unsafe locking scenario:</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;       CPU0                    CPU1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;       ----                    ----</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  lock(&quot;</span><span class="p">);</span>
	<span class="n">__print_lock_name</span><span class="p">(</span><span class="n">unsafe_class</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;);</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;                               local_irq_disable();</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;                               lock(&quot;</span><span class="p">);</span>
	<span class="n">__print_lock_name</span><span class="p">(</span><span class="n">safe_class</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;);</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;                               lock(&quot;</span><span class="p">);</span>
	<span class="n">__print_lock_name</span><span class="p">(</span><span class="n">middle_class</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;);</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  &lt;Interrupt&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;    lock(&quot;</span><span class="p">);</span>
	<span class="n">__print_lock_name</span><span class="p">(</span><span class="n">safe_class</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;);</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s"> *** DEADLOCK ***</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">print_bad_irq_dependency</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">prev_root</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">next_root</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">backwards_entry</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">forwards_entry</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span>
			 <span class="k">enum</span> <span class="n">lock_usage_bit</span> <span class="n">bit1</span><span class="p">,</span>
			 <span class="k">enum</span> <span class="n">lock_usage_bit</span> <span class="n">bit2</span><span class="p">,</span>
			 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">irqclass</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug_locks_off_graph_unlock</span><span class="p">()</span> <span class="o">||</span> <span class="n">debug_locks_silent</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;======================================================</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;[ INFO: %s-safe -&gt; %s-unsafe lock order detected ]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">irqclass</span><span class="p">,</span> <span class="n">irqclass</span><span class="p">);</span>
	<span class="n">print_kernel_ident</span><span class="p">();</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;------------------------------------------------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s/%d [HC%u[%lu]:SC%u[%lu]:HE%u:SE%u] is trying to acquire:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">curr</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">curr</span><span class="p">),</span>
		<span class="n">curr</span><span class="o">-&gt;</span><span class="n">hardirq_context</span><span class="p">,</span> <span class="n">hardirq_count</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="n">HARDIRQ_SHIFT</span><span class="p">,</span>
		<span class="n">curr</span><span class="o">-&gt;</span><span class="n">softirq_context</span><span class="p">,</span> <span class="n">softirq_count</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="n">SOFTIRQ_SHIFT</span><span class="p">,</span>
		<span class="n">curr</span><span class="o">-&gt;</span><span class="n">hardirqs_enabled</span><span class="p">,</span>
		<span class="n">curr</span><span class="o">-&gt;</span><span class="n">softirqs_enabled</span><span class="p">);</span>
	<span class="n">print_lock</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">and this task is already holding:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">print_lock</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;which would create a new lock dependency:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">print_lock_name</span><span class="p">(</span><span class="n">hlock_class</span><span class="p">(</span><span class="n">prev</span><span class="p">));</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; -&gt;&quot;</span><span class="p">);</span>
	<span class="n">print_lock_name</span><span class="p">(</span><span class="n">hlock_class</span><span class="p">(</span><span class="n">next</span><span class="p">));</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">but this new dependency connects a %s-irq-safe lock:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">irqclass</span><span class="p">);</span>
	<span class="n">print_lock_name</span><span class="p">(</span><span class="n">backwards_entry</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">... which became %s-irq-safe at:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">irqclass</span><span class="p">);</span>

	<span class="n">print_stack_trace</span><span class="p">(</span><span class="n">backwards_entry</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">usage_traces</span> <span class="o">+</span> <span class="n">bit1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">to a %s-irq-unsafe lock:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">irqclass</span><span class="p">);</span>
	<span class="n">print_lock_name</span><span class="p">(</span><span class="n">forwards_entry</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">... which became %s-irq-unsafe at:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">irqclass</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;...&quot;</span><span class="p">);</span>

	<span class="n">print_stack_trace</span><span class="p">(</span><span class="n">forwards_entry</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">usage_traces</span> <span class="o">+</span> <span class="n">bit2</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">other info that might help us debug this:</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">print_irq_lock_scenario</span><span class="p">(</span><span class="n">backwards_entry</span><span class="p">,</span> <span class="n">forwards_entry</span><span class="p">,</span>
				<span class="n">hlock_class</span><span class="p">(</span><span class="n">prev</span><span class="p">),</span> <span class="n">hlock_class</span><span class="p">(</span><span class="n">next</span><span class="p">));</span>

	<span class="n">lockdep_print_held_locks</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">the dependencies between %s-irq-safe lock&quot;</span><span class="p">,</span> <span class="n">irqclass</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; and the holding lock:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">save_trace</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prev_root</span><span class="o">-&gt;</span><span class="n">trace</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">print_shortest_lock_dependencies</span><span class="p">(</span><span class="n">backwards_entry</span><span class="p">,</span> <span class="n">prev_root</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">the dependencies between the lock to be acquired&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; and %s-irq-unsafe lock:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">irqclass</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">save_trace</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next_root</span><span class="o">-&gt;</span><span class="n">trace</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">print_shortest_lock_dependencies</span><span class="p">(</span><span class="n">forwards_entry</span><span class="p">,</span> <span class="n">next_root</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">stack backtrace:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">dump_stack</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">check_usage</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span>
	    <span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="k">enum</span> <span class="n">lock_usage_bit</span> <span class="n">bit_backwards</span><span class="p">,</span>
	    <span class="k">enum</span> <span class="n">lock_usage_bit</span> <span class="n">bit_forwards</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">irqclass</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock_list</span> <span class="n">this</span><span class="p">,</span> <span class="n">that</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">uninitialized_var</span><span class="p">(</span><span class="n">target_entry</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">uninitialized_var</span><span class="p">(</span><span class="n">target_entry1</span><span class="p">);</span>

	<span class="n">this</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">this</span><span class="p">.</span><span class="n">class</span> <span class="o">=</span> <span class="n">hlock_class</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">find_usage_backwards</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="p">,</span> <span class="n">bit_backwards</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">target_entry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">print_bfs_bug</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">that</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">that</span><span class="p">.</span><span class="n">class</span> <span class="o">=</span> <span class="n">hlock_class</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">find_usage_forwards</span><span class="p">(</span><span class="o">&amp;</span><span class="n">that</span><span class="p">,</span> <span class="n">bit_forwards</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">target_entry1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">print_bfs_bug</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">print_bad_irq_dependency</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">that</span><span class="p">,</span>
			<span class="n">target_entry</span><span class="p">,</span> <span class="n">target_entry1</span><span class="p">,</span>
			<span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span>
			<span class="n">bit_backwards</span><span class="p">,</span> <span class="n">bit_forwards</span><span class="p">,</span> <span class="n">irqclass</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">state_names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="cp">#define LOCKDEP_STATE(__STATE) \</span>
<span class="cp">	__stringify(__STATE),</span>
<span class="cp">#include &quot;lockdep_states.h&quot;</span>
<span class="cp">#undef LOCKDEP_STATE</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">state_rnames</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="cp">#define LOCKDEP_STATE(__STATE) \</span>
<span class="cp">	__stringify(__STATE)&quot;-READ&quot;,</span>
<span class="cp">#include &quot;lockdep_states.h&quot;</span>
<span class="cp">#undef LOCKDEP_STATE</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">state_name</span><span class="p">(</span><span class="k">enum</span> <span class="n">lock_usage_bit</span> <span class="n">bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">bit</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">state_rnames</span><span class="p">[</span><span class="n">bit</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">]</span> <span class="o">:</span> <span class="n">state_names</span><span class="p">[</span><span class="n">bit</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">exclusive_bit</span><span class="p">(</span><span class="kt">int</span> <span class="n">new_bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * USED_IN</span>
<span class="cm">	 * USED_IN_READ</span>
<span class="cm">	 * ENABLED</span>
<span class="cm">	 * ENABLED_READ</span>
<span class="cm">	 *</span>
<span class="cm">	 * bit 0 - write/read</span>
<span class="cm">	 * bit 1 - used_in/enabled</span>
<span class="cm">	 * bit 2+  state</span>
<span class="cm">	 */</span>

	<span class="kt">int</span> <span class="n">state</span> <span class="o">=</span> <span class="n">new_bit</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">3</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">new_bit</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * keep state, bit flip the direction and strip read.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">state</span> <span class="o">|</span> <span class="p">(</span><span class="n">dir</span> <span class="o">^</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_irq_usage</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="k">enum</span> <span class="n">lock_usage_bit</span> <span class="n">bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Prove that the new dependency does not connect a hardirq-safe</span>
<span class="cm">	 * lock with a hardirq-unsafe lock - to achieve this we search</span>
<span class="cm">	 * the backwards-subgraph starting at &lt;prev&gt;, and the</span>
<span class="cm">	 * forwards-subgraph starting at &lt;next&gt;:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_usage</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">bit</span><span class="p">,</span>
			   <span class="n">exclusive_bit</span><span class="p">(</span><span class="n">bit</span><span class="p">),</span> <span class="n">state_name</span><span class="p">(</span><span class="n">bit</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">bit</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* _READ */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Prove that the new dependency does not connect a hardirq-safe-read</span>
<span class="cm">	 * lock with a hardirq-unsafe lock - to achieve this we search</span>
<span class="cm">	 * the backwards-subgraph starting at &lt;prev&gt;, and the</span>
<span class="cm">	 * forwards-subgraph starting at &lt;next&gt;:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_usage</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">bit</span><span class="p">,</span>
			   <span class="n">exclusive_bit</span><span class="p">(</span><span class="n">bit</span><span class="p">),</span> <span class="n">state_name</span><span class="p">(</span><span class="n">bit</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">check_prev_add_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#define LOCKDEP_STATE(__STATE)						\</span>
<span class="cp">	if (!check_irq_usage(curr, prev, next, LOCK_USED_IN_##__STATE))	\</span>
<span class="cp">		return 0;</span>
<span class="cp">#include &quot;lockdep_states.h&quot;</span>
<span class="cp">#undef LOCKDEP_STATE</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">inc_chains</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">hardirq_context</span><span class="p">)</span>
		<span class="n">nr_hardirq_chains</span><span class="o">++</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">softirq_context</span><span class="p">)</span>
			<span class="n">nr_softirq_chains</span><span class="o">++</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">nr_process_chains</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">check_prev_add_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">inc_chains</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nr_process_chains</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">print_deadlock_scenario</span><span class="p">(</span><span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">nxt</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">prv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">hlock_class</span><span class="p">(</span><span class="n">nxt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="n">hlock_class</span><span class="p">(</span><span class="n">prv</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; Possible unsafe locking scenario:</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;       CPU0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;       ----</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  lock(&quot;</span><span class="p">);</span>
	<span class="n">__print_lock_name</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;);</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  lock(&quot;</span><span class="p">);</span>
	<span class="n">__print_lock_name</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;);</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s"> *** DEADLOCK ***</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; May be due to missing lock nesting notation</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">print_deadlock_bug</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug_locks_off_graph_unlock</span><span class="p">()</span> <span class="o">||</span> <span class="n">debug_locks_silent</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;=============================================</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;[ INFO: possible recursive locking detected ]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">print_kernel_ident</span><span class="p">();</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;---------------------------------------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s/%d is trying to acquire lock:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">curr</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">curr</span><span class="p">));</span>
	<span class="n">print_lock</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">but task is already holding lock:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">print_lock</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">other info that might help us debug this:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">print_deadlock_scenario</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>
	<span class="n">lockdep_print_held_locks</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">stack backtrace:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">dump_stack</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check whether we are holding such a class already.</span>
<span class="cm"> *</span>
<span class="cm"> * (Note that this has to be done separately, because the graph cannot</span>
<span class="cm"> * detect such classes of deadlocks.)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 on deadlock detected, 1 on OK, 2 on recursive read</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">check_deadlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span>
	       <span class="k">struct</span> <span class="n">lockdep_map</span> <span class="o">*</span><span class="n">next_instance</span><span class="p">,</span> <span class="kt">int</span> <span class="n">read</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">nest</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">lockdep_depth</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">held_locks</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">instance</span> <span class="o">==</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">nest_lock</span><span class="p">)</span>
			<span class="n">nest</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hlock_class</span><span class="p">(</span><span class="n">prev</span><span class="p">)</span> <span class="o">!=</span> <span class="n">hlock_class</span><span class="p">(</span><span class="n">next</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Allow read-after-read recursion of the same</span>
<span class="cm">		 * lock class (i.e. read_lock(lock)+read_lock(lock)):</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">read</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We&#39;re holding the nest_lock, which serializes this lock&#39;s</span>
<span class="cm">		 * nesting behaviour.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nest</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">print_deadlock_bug</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * There was a chain-cache miss, and we are about to add a new dependency</span>
<span class="cm"> * to a previous lock. We recursively validate the following rules:</span>
<span class="cm"> *</span>
<span class="cm"> *  - would the adding of the &lt;prev&gt; -&gt; &lt;next&gt; dependency create a</span>
<span class="cm"> *    circular dependency in the graph? [== circular deadlock]</span>
<span class="cm"> *</span>
<span class="cm"> *  - does the new prev-&gt;next dependency connect any hardirq-safe lock</span>
<span class="cm"> *    (in the full backwards-subgraph starting at &lt;prev&gt;) with any</span>
<span class="cm"> *    hardirq-unsafe lock (in the full forwards-subgraph starting at</span>
<span class="cm"> *    &lt;next&gt;)? [== illegal lock inversion with hardirq contexts]</span>
<span class="cm"> *</span>
<span class="cm"> *  - does the new prev-&gt;next dependency connect any softirq-safe lock</span>
<span class="cm"> *    (in the full backwards-subgraph starting at &lt;prev&gt;) with any</span>
<span class="cm"> *    softirq-unsafe lock (in the full forwards-subgraph starting at</span>
<span class="cm"> *    &lt;next&gt;)? [== illegal lock inversion with softirq contexts]</span>
<span class="cm"> *</span>
<span class="cm"> * any of these scenarios could lead to a deadlock.</span>
<span class="cm"> *</span>
<span class="cm"> * Then if all the validations pass, we add the forwards and backwards</span>
<span class="cm"> * dependency.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">check_prev_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span>
	       <span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="kt">int</span> <span class="n">distance</span><span class="p">,</span> <span class="kt">int</span> <span class="n">trylock_loop</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock_list</span> <span class="n">this</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">uninitialized_var</span><span class="p">(</span><span class="n">target_entry</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Static variable, serialized by the graph_lock().</span>
<span class="cm">	 *</span>
<span class="cm">	 * We use this static variable to save the stack trace in case</span>
<span class="cm">	 * we call into this function multiple times due to encountering</span>
<span class="cm">	 * trylocks in the held lock stack.</span>
<span class="cm">	 */</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">stack_trace</span> <span class="n">trace</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Prove that the new &lt;prev&gt; -&gt; &lt;next&gt; dependency would not</span>
<span class="cm">	 * create a circular dependency in the graph. (We do this by</span>
<span class="cm">	 * forward-recursing into the graph starting at &lt;next&gt;, and</span>
<span class="cm">	 * checking whether we can reach &lt;prev&gt;.)</span>
<span class="cm">	 *</span>
<span class="cm">	 * We are using global variables to control the recursion, to</span>
<span class="cm">	 * keep the stackframe size of the recursive functions low:</span>
<span class="cm">	 */</span>
	<span class="n">this</span><span class="p">.</span><span class="n">class</span> <span class="o">=</span> <span class="n">hlock_class</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
	<span class="n">this</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">check_noncircular</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="p">,</span> <span class="n">hlock_class</span><span class="p">(</span><span class="n">prev</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">target_entry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">print_circular_bug</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="p">,</span> <span class="n">target_entry</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">print_bfs_bug</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_prev_add_irq</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * For recursive read-locks we do all the dependency checks,</span>
<span class="cm">	 * but we dont store read-triggered dependencies (only</span>
<span class="cm">	 * write-triggered dependencies). This ensures that only the</span>
<span class="cm">	 * write-side dependencies matter, and that if for example a</span>
<span class="cm">	 * write-lock never takes any other locks, then the reads are</span>
<span class="cm">	 * equivalent to a NOP.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Is the &lt;prev&gt; -&gt; &lt;next&gt; dependency already present?</span>
<span class="cm">	 *</span>
<span class="cm">	 * (this may occur even though this is a new chain: consider</span>
<span class="cm">	 *  e.g. the L1 -&gt; L2 -&gt; L3 -&gt; L4 and the L5 -&gt; L1 -&gt; L2 -&gt; L3</span>
<span class="cm">	 *  chains - the second one will be new, but L1 already has</span>
<span class="cm">	 *  L2 added to its dependency list, due to the first chain.)</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hlock_class</span><span class="p">(</span><span class="n">prev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">locks_after</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">==</span> <span class="n">hlock_class</span><span class="p">(</span><span class="n">next</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">distance</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">entry</span><span class="o">-&gt;</span><span class="n">distance</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trylock_loop</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">save_trace</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ok, all validations passed, add the new lock</span>
<span class="cm">	 * to the previous lock&#39;s dependency list:</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">add_lock_to_list</span><span class="p">(</span><span class="n">hlock_class</span><span class="p">(</span><span class="n">prev</span><span class="p">),</span> <span class="n">hlock_class</span><span class="p">(</span><span class="n">next</span><span class="p">),</span>
			       <span class="o">&amp;</span><span class="n">hlock_class</span><span class="p">(</span><span class="n">prev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">locks_after</span><span class="p">,</span>
			       <span class="n">next</span><span class="o">-&gt;</span><span class="n">acquire_ip</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trace</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">add_lock_to_list</span><span class="p">(</span><span class="n">hlock_class</span><span class="p">(</span><span class="n">next</span><span class="p">),</span> <span class="n">hlock_class</span><span class="p">(</span><span class="n">prev</span><span class="p">),</span>
			       <span class="o">&amp;</span><span class="n">hlock_class</span><span class="p">(</span><span class="n">next</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">locks_before</span><span class="p">,</span>
			       <span class="n">next</span><span class="o">-&gt;</span><span class="n">acquire_ip</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trace</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Debugging printouts:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">verbose</span><span class="p">(</span><span class="n">hlock_class</span><span class="p">(</span><span class="n">prev</span><span class="p">))</span> <span class="o">||</span> <span class="n">verbose</span><span class="p">(</span><span class="n">hlock_class</span><span class="p">(</span><span class="n">next</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">graph_unlock</span><span class="p">();</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s"> new dependency: &quot;</span><span class="p">);</span>
		<span class="n">print_lock_name</span><span class="p">(</span><span class="n">hlock_class</span><span class="p">(</span><span class="n">prev</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot; =&gt; &quot;</span><span class="p">);</span>
		<span class="n">print_lock_name</span><span class="p">(</span><span class="n">hlock_class</span><span class="p">(</span><span class="n">next</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="k">return</span> <span class="n">graph_lock</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Add the dependency to all directly-previous locks that are &#39;relevant&#39;.</span>
<span class="cm"> * The ones that are relevant are (in increasing distance from curr):</span>
<span class="cm"> * all consecutive trylock entries and the final non-trylock entry - or</span>
<span class="cm"> * the end of this context&#39;s lock-chain - whichever comes first.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">check_prevs_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">lockdep_depth</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">trylock_loop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">hlock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Debugging checks.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Depth must not be zero for a non-head lock:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">depth</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_bug</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * At least two relevant locks must exist for this</span>
<span class="cm">	 * to be a head:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">held_locks</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">irq_context</span> <span class="o">!=</span>
			<span class="n">curr</span><span class="o">-&gt;</span><span class="n">held_locks</span><span class="p">[</span><span class="n">depth</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">irq_context</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_bug</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">lockdep_depth</span> <span class="o">-</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">hlock</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">held_locks</span> <span class="o">+</span> <span class="n">depth</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Only non-recursive-read entries get new dependencies</span>
<span class="cm">		 * added:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hlock</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_prev_add</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">hlock</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span>
						<span class="n">distance</span><span class="p">,</span> <span class="n">trylock_loop</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Stop after the first non-trylock entry,</span>
<span class="cm">			 * as non-trylock entries have added their</span>
<span class="cm">			 * own direct dependencies already, so this</span>
<span class="cm">			 * lock is connected to them indirectly:</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hlock</span><span class="o">-&gt;</span><span class="n">trylock</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">depth</span><span class="o">--</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * End of lock-stack?</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">depth</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Stop the search if we cross into another context:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">held_locks</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">irq_context</span> <span class="o">!=</span>
				<span class="n">curr</span><span class="o">-&gt;</span><span class="n">held_locks</span><span class="p">[</span><span class="n">depth</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">irq_context</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">trylock_loop</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">out_bug:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug_locks_off_graph_unlock</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clearly we all shouldn&#39;t be here, but since we made it we</span>
<span class="cm">	 * can reliable say we messed up our state. See the above two</span>
<span class="cm">	 * gotos for reasons why we could possibly end up here.</span>
<span class="cm">	 */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_lock_chains</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">lock_chain</span> <span class="n">lock_chains</span><span class="p">[</span><span class="n">MAX_LOCKDEP_CHAINS</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">nr_chain_hlocks</span><span class="p">;</span>
<span class="k">static</span> <span class="n">u16</span> <span class="n">chain_hlocks</span><span class="p">[</span><span class="n">MAX_LOCKDEP_CHAIN_HLOCKS</span><span class="p">];</span>

<span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="nf">lock_chain_get_class</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_chain</span> <span class="o">*</span><span class="n">chain</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">lock_classes</span> <span class="o">+</span> <span class="n">chain_hlocks</span><span class="p">[</span><span class="n">chain</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Look up a dependency chain. If the key is not present yet then</span>
<span class="cm"> * add it and return 1 - in this case the new dependency chain is</span>
<span class="cm"> * validated. If the key is already hashed, return 0.</span>
<span class="cm"> * (On return with 1 graph_lock is held.)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">lookup_chain_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">hlock</span><span class="p">,</span>
				     <span class="n">u64</span> <span class="n">chain_key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">class</span> <span class="o">=</span> <span class="n">hlock_class</span><span class="p">(</span><span class="n">hlock</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">hash_head</span> <span class="o">=</span> <span class="n">chainhashentry</span><span class="p">(</span><span class="n">chain_key</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lock_chain</span> <span class="o">*</span><span class="n">chain</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">hlock_curr</span><span class="p">,</span> <span class="o">*</span><span class="n">hlock_next</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We might need to take the graph lock, ensure we&#39;ve got IRQs</span>
<span class="cm">	 * disabled to make this an IRQ-safe lock.. for recursion reasons</span>
<span class="cm">	 * lockdep won&#39;t complain about its own locking errors.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">()))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We can walk it lock-free, because entries only get added</span>
<span class="cm">	 * to the hash:</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">hash_head</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chain</span><span class="o">-&gt;</span><span class="n">chain_key</span> <span class="o">==</span> <span class="n">chain_key</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">cache_hit:</span>
			<span class="n">debug_atomic_inc</span><span class="p">(</span><span class="n">chain_lookup_hits</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">very_verbose</span><span class="p">(</span><span class="n">class</span><span class="p">))</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">hash chain already cached, key: &quot;</span>
					<span class="s">&quot;%016Lx tail class: [%p] %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">chain_key</span><span class="p">,</span>
					<span class="n">class</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">class</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">very_verbose</span><span class="p">(</span><span class="n">class</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">new hash chain, key: %016Lx tail class: [%p] %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">chain_key</span><span class="p">,</span> <span class="n">class</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">class</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Allocate a new chain entry from the static array, and add</span>
<span class="cm">	 * it to the hash:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">graph_lock</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We have to walk the chain again locked - to avoid duplicates:</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">hash_head</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chain</span><span class="o">-&gt;</span><span class="n">chain_key</span> <span class="o">==</span> <span class="n">chain_key</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">graph_unlock</span><span class="p">();</span>
			<span class="k">goto</span> <span class="n">cache_hit</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">nr_lock_chains</span> <span class="o">&gt;=</span> <span class="n">MAX_LOCKDEP_CHAINS</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug_locks_off_graph_unlock</span><span class="p">())</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;BUG: MAX_LOCKDEP_CHAINS too low!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;turning off the locking correctness validator.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">chain</span> <span class="o">=</span> <span class="n">lock_chains</span> <span class="o">+</span> <span class="n">nr_lock_chains</span><span class="o">++</span><span class="p">;</span>
	<span class="n">chain</span><span class="o">-&gt;</span><span class="n">chain_key</span> <span class="o">=</span> <span class="n">chain_key</span><span class="p">;</span>
	<span class="n">chain</span><span class="o">-&gt;</span><span class="n">irq_context</span> <span class="o">=</span> <span class="n">hlock</span><span class="o">-&gt;</span><span class="n">irq_context</span><span class="p">;</span>
	<span class="cm">/* Find the first held_lock of current chain */</span>
	<span class="n">hlock_next</span> <span class="o">=</span> <span class="n">hlock</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">lockdep_depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hlock_curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">held_locks</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hlock_curr</span><span class="o">-&gt;</span><span class="n">irq_context</span> <span class="o">!=</span> <span class="n">hlock_next</span><span class="o">-&gt;</span><span class="n">irq_context</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">hlock_next</span> <span class="o">=</span> <span class="n">hlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="n">chain</span><span class="o">-&gt;</span><span class="n">depth</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">lockdep_depth</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">nr_chain_hlocks</span> <span class="o">+</span> <span class="n">chain</span><span class="o">-&gt;</span><span class="n">depth</span> <span class="o">&lt;=</span> <span class="n">MAX_LOCKDEP_CHAIN_HLOCKS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">chain</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">nr_chain_hlocks</span><span class="p">;</span>
		<span class="n">nr_chain_hlocks</span> <span class="o">+=</span> <span class="n">chain</span><span class="o">-&gt;</span><span class="n">depth</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">chain</span><span class="o">-&gt;</span><span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">lock_id</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">held_locks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">class_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">chain_hlocks</span><span class="p">[</span><span class="n">chain</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">lock_id</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">chain_hlocks</span><span class="p">[</span><span class="n">chain</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">class</span> <span class="o">-</span> <span class="n">lock_classes</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_add_tail_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chain</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="n">hash_head</span><span class="p">);</span>
	<span class="n">debug_atomic_inc</span><span class="p">(</span><span class="n">chain_lookup_misses</span><span class="p">);</span>
	<span class="n">inc_chains</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">validate_chain</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lockdep_map</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">hlock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">chain_head</span><span class="p">,</span> <span class="n">u64</span> <span class="n">chain_key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Trylock needs to maintain the stack of held locks, but it</span>
<span class="cm">	 * does not add new dependencies, because trylock can be done</span>
<span class="cm">	 * in any order.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We look up the chain_key and do the O(N^2) check and update of</span>
<span class="cm">	 * the dependencies only if this is a new dependency chain.</span>
<span class="cm">	 * (If lookup_chain_cache() returns with 1 it acquires</span>
<span class="cm">	 * graph_lock for us)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hlock</span><span class="o">-&gt;</span><span class="n">trylock</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">hlock</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">lookup_chain_cache</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">hlock</span><span class="p">,</span> <span class="n">chain_key</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Check whether last held lock:</span>
<span class="cm">		 *</span>
<span class="cm">		 * - is irq-safe, if this lock is irq-unsafe</span>
<span class="cm">		 * - is softirq-safe, if this lock is hardirq-unsafe</span>
<span class="cm">		 *</span>
<span class="cm">		 * And check whether the new lock&#39;s dependency graph</span>
<span class="cm">		 * could lead back to the previous lock.</span>
<span class="cm">		 *</span>
<span class="cm">		 * any of these scenarios could lead to a deadlock. If</span>
<span class="cm">		 * All validations</span>
<span class="cm">		 */</span>
		<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">check_deadlock</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">hlock</span><span class="p">,</span> <span class="n">lock</span><span class="p">,</span> <span class="n">hlock</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Mark recursive read, as we jump over it when</span>
<span class="cm">		 * building dependencies (just like we jump over</span>
<span class="cm">		 * trylock entries):</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">hlock</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Add dependency only if this lock is not the head</span>
<span class="cm">		 * of the chain, and if it&#39;s not a secondary read-lock:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chain_head</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_prevs_add</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">hlock</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">graph_unlock</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="cm">/* after lookup_chain_cache(): */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">debug_locks</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">validate_chain</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span>
	       	<span class="k">struct</span> <span class="n">lockdep_map</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">hlock</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">chain_head</span><span class="p">,</span> <span class="n">u64</span> <span class="n">chain_key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * We are building curr_chain_key incrementally, so double-check</span>
<span class="cm"> * it from scratch, to make sure that it&#39;s done correctly:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_chain_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_DEBUG_LOCKDEP</span>
	<span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">hlock</span><span class="p">,</span> <span class="o">*</span><span class="n">prev_hlock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">id</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">chain_key</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">lockdep_depth</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hlock</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">held_locks</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chain_key</span> <span class="o">!=</span> <span class="n">hlock</span><span class="o">-&gt;</span><span class="n">prev_chain_key</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">debug_locks_off</span><span class="p">();</span>
			<span class="cm">/*</span>
<span class="cm">			 * We got mighty confused, our chain keys don&#39;t match</span>
<span class="cm">			 * with what we expect, someone trample on our task state?</span>
<span class="cm">			 */</span>
			<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;hm#1, depth: %u [%u], %016Lx != %016Lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">curr</span><span class="o">-&gt;</span><span class="n">lockdep_depth</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">chain_key</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">hlock</span><span class="o">-&gt;</span><span class="n">prev_chain_key</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">id</span> <span class="o">=</span> <span class="n">hlock</span><span class="o">-&gt;</span><span class="n">class_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Whoops ran out of static storage again?</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">(</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">MAX_LOCKDEP_KEYS</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">prev_hlock</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">prev_hlock</span><span class="o">-&gt;</span><span class="n">irq_context</span> <span class="o">!=</span>
							<span class="n">hlock</span><span class="o">-&gt;</span><span class="n">irq_context</span><span class="p">))</span>
			<span class="n">chain_key</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">chain_key</span> <span class="o">=</span> <span class="n">iterate_chain_key</span><span class="p">(</span><span class="n">chain_key</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
		<span class="n">prev_hlock</span> <span class="o">=</span> <span class="n">hlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chain_key</span> <span class="o">!=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">curr_chain_key</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debug_locks_off</span><span class="p">();</span>
		<span class="cm">/*</span>
<span class="cm">		 * More smoking hash instead of calculating it, damn see these</span>
<span class="cm">		 * numbers float.. I bet that a pink elephant stepped on my memory.</span>
<span class="cm">		 */</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;hm#2, depth: %u [%u], %016Lx != %016Lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">curr</span><span class="o">-&gt;</span><span class="n">lockdep_depth</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">chain_key</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">curr_chain_key</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">print_usage_bug_scenario</span><span class="p">(</span><span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">class</span> <span class="o">=</span> <span class="n">hlock_class</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; Possible unsafe locking scenario:</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;       CPU0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;       ----</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  lock(&quot;</span><span class="p">);</span>
	<span class="n">__print_lock_name</span><span class="p">(</span><span class="n">class</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;);</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  &lt;Interrupt&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;    lock(&quot;</span><span class="p">);</span>
	<span class="n">__print_lock_name</span><span class="p">(</span><span class="n">class</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;);</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s"> *** DEADLOCK ***</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">print_usage_bug</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">lock_usage_bit</span> <span class="n">prev_bit</span><span class="p">,</span> <span class="k">enum</span> <span class="n">lock_usage_bit</span> <span class="n">new_bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug_locks_off_graph_unlock</span><span class="p">()</span> <span class="o">||</span> <span class="n">debug_locks_silent</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;=================================</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;[ INFO: inconsistent lock state ]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">print_kernel_ident</span><span class="p">();</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;---------------------------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;inconsistent {%s} -&gt; {%s} usage.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">usage_str</span><span class="p">[</span><span class="n">prev_bit</span><span class="p">],</span> <span class="n">usage_str</span><span class="p">[</span><span class="n">new_bit</span><span class="p">]);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s/%d [HC%u[%lu]:SC%u[%lu]:HE%u:SE%u] takes:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">curr</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">curr</span><span class="p">),</span>
		<span class="n">trace_hardirq_context</span><span class="p">(</span><span class="n">curr</span><span class="p">),</span> <span class="n">hardirq_count</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="n">HARDIRQ_SHIFT</span><span class="p">,</span>
		<span class="n">trace_softirq_context</span><span class="p">(</span><span class="n">curr</span><span class="p">),</span> <span class="n">softirq_count</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="n">SOFTIRQ_SHIFT</span><span class="p">,</span>
		<span class="n">trace_hardirqs_enabled</span><span class="p">(</span><span class="n">curr</span><span class="p">),</span>
		<span class="n">trace_softirqs_enabled</span><span class="p">(</span><span class="n">curr</span><span class="p">));</span>
	<span class="n">print_lock</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;{%s} state was registered at:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">usage_str</span><span class="p">[</span><span class="n">prev_bit</span><span class="p">]);</span>
	<span class="n">print_stack_trace</span><span class="p">(</span><span class="n">hlock_class</span><span class="p">(</span><span class="n">this</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">usage_traces</span> <span class="o">+</span> <span class="n">prev_bit</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">print_irqtrace_events</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">other info that might help us debug this:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">print_usage_bug_scenario</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>

	<span class="n">lockdep_print_held_locks</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">stack backtrace:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">dump_stack</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Print out an error if an invalid bit is set:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">valid_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span>
	    <span class="k">enum</span> <span class="n">lock_usage_bit</span> <span class="n">new_bit</span><span class="p">,</span> <span class="k">enum</span> <span class="n">lock_usage_bit</span> <span class="n">bad_bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">hlock_class</span><span class="p">(</span><span class="n">this</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">usage_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bad_bit</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">print_usage_bug</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">this</span><span class="p">,</span> <span class="n">bad_bit</span><span class="p">,</span> <span class="n">new_bit</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">mark_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span>
		     <span class="k">enum</span> <span class="n">lock_usage_bit</span> <span class="n">new_bit</span><span class="p">);</span>

<span class="cp">#if defined(CONFIG_TRACE_IRQFLAGS) &amp;&amp; defined(CONFIG_PROVE_LOCKING)</span>

<span class="cm">/*</span>
<span class="cm"> * print irq inversion bug:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">print_irq_inversion_bug</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">other</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span> <span class="kt">int</span> <span class="n">forwards</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">irqclass</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">other</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">middle</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">depth</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug_locks_off_graph_unlock</span><span class="p">()</span> <span class="o">||</span> <span class="n">debug_locks_silent</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;=========================================================</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;[ INFO: possible irq lock inversion dependency detected ]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">print_kernel_ident</span><span class="p">();</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;---------------------------------------------------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s/%d just changed the state of lock:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">curr</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">curr</span><span class="p">));</span>
	<span class="n">print_lock</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">forwards</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;but this lock took another, %s-unsafe lock in the past:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">irqclass</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;but this lock was taken by another, %s-safe lock in the past:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">irqclass</span><span class="p">);</span>
	<span class="n">print_lock_name</span><span class="p">(</span><span class="n">other</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n\n</span><span class="s">and interrupts could create inverse lock ordering between them.</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">other info that might help us debug this:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Find a middle lock (if one exists) */</span>
	<span class="n">depth</span> <span class="o">=</span> <span class="n">get_lock_depth</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">entry</span> <span class="o">!=</span> <span class="n">root</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;lockdep:%s bad path found in chain graph</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">middle</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">get_lock_parent</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
		<span class="n">depth</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">entry</span> <span class="o">&amp;&amp;</span> <span class="n">entry</span> <span class="o">!=</span> <span class="n">root</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">depth</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">forwards</span><span class="p">)</span>
		<span class="n">print_irq_lock_scenario</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span>
			<span class="n">middle</span> <span class="o">?</span> <span class="n">middle</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">:</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">,</span> <span class="n">other</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">print_irq_lock_scenario</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span>
			<span class="n">middle</span> <span class="o">?</span> <span class="n">middle</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">:</span> <span class="n">other</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">);</span>

	<span class="n">lockdep_print_held_locks</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">the shortest dependencies between 2nd lock and 1st lock:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">save_trace</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">trace</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">print_shortest_lock_dependencies</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">stack backtrace:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">dump_stack</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Prove that in the forwards-direction subgraph starting at &lt;this&gt;</span>
<span class="cm"> * there is no lock matching &lt;mask&gt;:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">check_usage_forwards</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span>
		     <span class="k">enum</span> <span class="n">lock_usage_bit</span> <span class="n">bit</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">irqclass</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock_list</span> <span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">uninitialized_var</span><span class="p">(</span><span class="n">target_entry</span><span class="p">);</span>

	<span class="n">root</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">root</span><span class="p">.</span><span class="n">class</span> <span class="o">=</span> <span class="n">hlock_class</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">find_usage_forwards</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="p">,</span> <span class="n">bit</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">target_entry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">print_bfs_bug</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">print_irq_inversion_bug</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="p">,</span> <span class="n">target_entry</span><span class="p">,</span>
					<span class="n">this</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">irqclass</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Prove that in the backwards-direction subgraph starting at &lt;this&gt;</span>
<span class="cm"> * there is no lock matching &lt;mask&gt;:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">check_usage_backwards</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span>
		      <span class="k">enum</span> <span class="n">lock_usage_bit</span> <span class="n">bit</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">irqclass</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock_list</span> <span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock_list</span> <span class="o">*</span><span class="n">uninitialized_var</span><span class="p">(</span><span class="n">target_entry</span><span class="p">);</span>

	<span class="n">root</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">root</span><span class="p">.</span><span class="n">class</span> <span class="o">=</span> <span class="n">hlock_class</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">find_usage_backwards</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="p">,</span> <span class="n">bit</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">target_entry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">print_bfs_bug</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">print_irq_inversion_bug</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="p">,</span> <span class="n">target_entry</span><span class="p">,</span>
					<span class="n">this</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">irqclass</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">print_irqtrace_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;irq event stamp: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">irq_events</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;hardirqs last  enabled at (%u): &quot;</span><span class="p">,</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">hardirq_enable_event</span><span class="p">);</span>
	<span class="n">print_ip_sym</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">hardirq_enable_ip</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;hardirqs last disabled at (%u): &quot;</span><span class="p">,</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">hardirq_disable_event</span><span class="p">);</span>
	<span class="n">print_ip_sym</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">hardirq_disable_ip</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;softirqs last  enabled at (%u): &quot;</span><span class="p">,</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">softirq_enable_event</span><span class="p">);</span>
	<span class="n">print_ip_sym</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">softirq_enable_ip</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;softirqs last disabled at (%u): &quot;</span><span class="p">,</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">softirq_disable_event</span><span class="p">);</span>
	<span class="n">print_ip_sym</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">softirq_disable_ip</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">HARDIRQ_verbose</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">class</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if HARDIRQ_VERBOSE</span>
	<span class="k">return</span> <span class="n">class_filter</span><span class="p">(</span><span class="n">class</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">SOFTIRQ_verbose</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">class</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if SOFTIRQ_VERBOSE</span>
	<span class="k">return</span> <span class="n">class_filter</span><span class="p">(</span><span class="n">class</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">RECLAIM_FS_verbose</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">class</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if RECLAIM_VERBOSE</span>
	<span class="k">return</span> <span class="n">class_filter</span><span class="p">(</span><span class="n">class</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define STRICT_READ_CHECKS	1</span>

<span class="k">static</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">state_verbose_f</span><span class="p">[])(</span><span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">class</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
<span class="cp">#define LOCKDEP_STATE(__STATE) \</span>
<span class="cp">	__STATE##_verbose,</span>
<span class="cp">#include &quot;lockdep_states.h&quot;</span>
<span class="cp">#undef LOCKDEP_STATE</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">state_verbose</span><span class="p">(</span><span class="k">enum</span> <span class="n">lock_usage_bit</span> <span class="n">bit</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">class</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">state_verbose_f</span><span class="p">[</span><span class="n">bit</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">](</span><span class="n">class</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">check_usage_f</span><span class="p">)(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="p">,</span>
			     <span class="k">enum</span> <span class="n">lock_usage_bit</span> <span class="n">bit</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">mark_lock_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">lock_usage_bit</span> <span class="n">new_bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">excl_bit</span> <span class="o">=</span> <span class="n">exclusive_bit</span><span class="p">(</span><span class="n">new_bit</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">read</span> <span class="o">=</span> <span class="n">new_bit</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">new_bit</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * mark USED_IN has to look forwards -- to ensure no dependency</span>
<span class="cm">	 * has ENABLED state, which would allow recursion deadlocks.</span>
<span class="cm">	 *</span>
<span class="cm">	 * mark ENABLED has to look backwards -- to ensure no dependee</span>
<span class="cm">	 * has USED_IN state, which, again, would allow  recursion deadlocks.</span>
<span class="cm">	 */</span>
	<span class="n">check_usage_f</span> <span class="n">usage</span> <span class="o">=</span> <span class="n">dir</span> <span class="o">?</span>
		<span class="n">check_usage_backwards</span> <span class="o">:</span> <span class="n">check_usage_forwards</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Validate that this particular lock does not have conflicting</span>
<span class="cm">	 * usage states.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">valid_state</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">this</span><span class="p">,</span> <span class="n">new_bit</span><span class="p">,</span> <span class="n">excl_bit</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Validate that the lock dependencies don&#39;t have conflicting usage</span>
<span class="cm">	 * states.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">read</span> <span class="o">||</span> <span class="o">!</span><span class="n">dir</span> <span class="o">||</span> <span class="n">STRICT_READ_CHECKS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">usage</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">this</span><span class="p">,</span> <span class="n">excl_bit</span><span class="p">,</span> <span class="n">state_name</span><span class="p">(</span><span class="n">new_bit</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">1</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check for read in write conflicts</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">read</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">valid_state</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">this</span><span class="p">,</span> <span class="n">new_bit</span><span class="p">,</span> <span class="n">excl_bit</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">STRICT_READ_CHECKS</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">usage</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">this</span><span class="p">,</span> <span class="n">excl_bit</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
				<span class="n">state_name</span><span class="p">(</span><span class="n">new_bit</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state_verbose</span><span class="p">(</span><span class="n">new_bit</span><span class="p">,</span> <span class="n">hlock_class</span><span class="p">(</span><span class="n">this</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">mark_type</span> <span class="p">{</span>
<span class="cp">#define LOCKDEP_STATE(__STATE)	__STATE,</span>
<span class="cp">#include &quot;lockdep_states.h&quot;</span>
<span class="cp">#undef LOCKDEP_STATE</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Mark all held locks with a usage bit:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">mark_held_locks</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="k">enum</span> <span class="n">mark_type</span> <span class="n">mark</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">lock_usage_bit</span> <span class="n">usage_bit</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">hlock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">lockdep_depth</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hlock</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">held_locks</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">usage_bit</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">mark</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span> <span class="cm">/* ENABLED */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hlock</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">)</span>
			<span class="n">usage_bit</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* READ */</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">usage_bit</span> <span class="o">&gt;=</span> <span class="n">LOCK_USAGE_STATES</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hlock_class</span><span class="p">(</span><span class="n">hlock</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">==</span> <span class="n">__lockdep_no_validate__</span><span class="p">.</span><span class="n">subkeys</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mark_lock</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">hlock</span><span class="p">,</span> <span class="n">usage_bit</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Hardirqs will be enabled:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__trace_hardirqs_on_caller</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

	<span class="cm">/* we&#39;ll do an OFF -&gt; ON transition: */</span>
	<span class="n">curr</span><span class="o">-&gt;</span><span class="n">hardirqs_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We are going to turn hardirqs on, so set the</span>
<span class="cm">	 * usage bit for all held locks:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mark_held_locks</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">HARDIRQ</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we have softirqs enabled, then set the usage</span>
<span class="cm">	 * bit for all held locks. (disabled hardirqs prevented</span>
<span class="cm">	 * this bit from being set before)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">softirqs_enabled</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mark_held_locks</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">SOFTIRQ</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>

	<span class="n">curr</span><span class="o">-&gt;</span><span class="n">hardirq_enable_ip</span> <span class="o">=</span> <span class="n">ip</span><span class="p">;</span>
	<span class="n">curr</span><span class="o">-&gt;</span><span class="n">hardirq_enable_event</span> <span class="o">=</span> <span class="o">++</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">irq_events</span><span class="p">;</span>
	<span class="n">debug_atomic_inc</span><span class="p">(</span><span class="n">hardirqs_on_events</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">trace_hardirqs_on_caller</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">time_hardirqs_on</span><span class="p">(</span><span class="n">CALLER_ADDR0</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">debug_locks</span> <span class="o">||</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">lockdep_recursion</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">hardirqs_enabled</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Neither irq nor preemption are disabled here</span>
<span class="cm">		 * so this is racy by nature but losing one hit</span>
<span class="cm">		 * in a stat is not a big deal.</span>
<span class="cm">		 */</span>
		<span class="n">__debug_atomic_inc</span><span class="p">(</span><span class="n">redundant_hardirqs_on</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We&#39;re enabling irqs and according to our state above irqs weren&#39;t</span>
<span class="cm">	 * already enabled, yet we find the hardware thinks they are in fact</span>
<span class="cm">	 * enabled.. someone messed up their IRQ state tracing.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">()))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * See the fine text that goes along with this variable definition.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">early_boot_irqs_disabled</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Can&#39;t allow enabling interrupts while in an interrupt handler,</span>
<span class="cm">	 * that&#39;s general bad form and such. Recursion, limited stack etc..</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">hardirq_context</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">current</span><span class="o">-&gt;</span><span class="n">lockdep_recursion</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__trace_hardirqs_on_caller</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">lockdep_recursion</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">trace_hardirqs_on_caller</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">trace_hardirqs_on</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_hardirqs_on_caller</span><span class="p">(</span><span class="n">CALLER_ADDR0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">trace_hardirqs_on</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Hardirqs were disabled:</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">trace_hardirqs_off_caller</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

	<span class="n">time_hardirqs_off</span><span class="p">(</span><span class="n">CALLER_ADDR0</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">debug_locks</span> <span class="o">||</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">lockdep_recursion</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * So we&#39;re supposed to get called after you mask local IRQs, but for</span>
<span class="cm">	 * some reason the hardware doesn&#39;t quite think you did a proper job.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">()))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">hardirqs_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We have done an ON -&gt; OFF transition:</span>
<span class="cm">		 */</span>
		<span class="n">curr</span><span class="o">-&gt;</span><span class="n">hardirqs_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">curr</span><span class="o">-&gt;</span><span class="n">hardirq_disable_ip</span> <span class="o">=</span> <span class="n">ip</span><span class="p">;</span>
		<span class="n">curr</span><span class="o">-&gt;</span><span class="n">hardirq_disable_event</span> <span class="o">=</span> <span class="o">++</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">irq_events</span><span class="p">;</span>
		<span class="n">debug_atomic_inc</span><span class="p">(</span><span class="n">hardirqs_off_events</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">debug_atomic_inc</span><span class="p">(</span><span class="n">redundant_hardirqs_off</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">trace_hardirqs_off_caller</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">trace_hardirqs_off</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_hardirqs_off_caller</span><span class="p">(</span><span class="n">CALLER_ADDR0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">trace_hardirqs_off</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Softirqs will be enabled:</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">trace_softirqs_on</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">debug_locks</span> <span class="o">||</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">lockdep_recursion</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We fancy IRQs being disabled here, see softirq.c, avoids</span>
<span class="cm">	 * funny state and nesting things.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">()))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">softirqs_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debug_atomic_inc</span><span class="p">(</span><span class="n">redundant_softirqs_on</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">current</span><span class="o">-&gt;</span><span class="n">lockdep_recursion</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We&#39;ll do an OFF -&gt; ON transition:</span>
<span class="cm">	 */</span>
	<span class="n">curr</span><span class="o">-&gt;</span><span class="n">softirqs_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">curr</span><span class="o">-&gt;</span><span class="n">softirq_enable_ip</span> <span class="o">=</span> <span class="n">ip</span><span class="p">;</span>
	<span class="n">curr</span><span class="o">-&gt;</span><span class="n">softirq_enable_event</span> <span class="o">=</span> <span class="o">++</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">irq_events</span><span class="p">;</span>
	<span class="n">debug_atomic_inc</span><span class="p">(</span><span class="n">softirqs_on_events</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * We are going to turn softirqs on, so set the</span>
<span class="cm">	 * usage bit for all held locks, if hardirqs are</span>
<span class="cm">	 * enabled too:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">hardirqs_enabled</span><span class="p">)</span>
		<span class="n">mark_held_locks</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">SOFTIRQ</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">lockdep_recursion</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Softirqs were disabled:</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">trace_softirqs_off</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">debug_locks</span> <span class="o">||</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">lockdep_recursion</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We fancy IRQs being disabled here, see softirq.c</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">()))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">softirqs_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We have done an ON -&gt; OFF transition:</span>
<span class="cm">		 */</span>
		<span class="n">curr</span><span class="o">-&gt;</span><span class="n">softirqs_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">curr</span><span class="o">-&gt;</span><span class="n">softirq_disable_ip</span> <span class="o">=</span> <span class="n">ip</span><span class="p">;</span>
		<span class="n">curr</span><span class="o">-&gt;</span><span class="n">softirq_disable_event</span> <span class="o">=</span> <span class="o">++</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">irq_events</span><span class="p">;</span>
		<span class="n">debug_atomic_inc</span><span class="p">(</span><span class="n">softirqs_off_events</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Whoops, we wanted softirqs off, so why aren&#39;t they?</span>
<span class="cm">		 */</span>
		<span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">softirq_count</span><span class="p">());</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">debug_atomic_inc</span><span class="p">(</span><span class="n">redundant_softirqs_off</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__lockdep_trace_alloc</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">debug_locks</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* no reclaim without waiting on it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_WAIT</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* this guy won&#39;t enter reclaim */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_MEMALLOC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_NOMEMALLOC</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* We&#39;re only interested __GFP_FS allocations for now */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_FS</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Oi! Can&#39;t be having __GFP_FS allocations with IRQs disabled.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">(</span><span class="n">irqs_disabled_flags</span><span class="p">(</span><span class="n">flags</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mark_held_locks</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">RECLAIM_FS</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">check_flags</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">lockdep_trace_alloc</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">lockdep_recursion</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">raw_local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">check_flags</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">lockdep_recursion</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__lockdep_trace_alloc</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">lockdep_recursion</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">raw_local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mark_irqflags</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">hlock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * If non-trylock use in a hardirq or softirq context, then</span>
<span class="cm">	 * mark the lock as used in these contexts:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hlock</span><span class="o">-&gt;</span><span class="n">trylock</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hlock</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">hardirq_context</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mark_lock</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">hlock</span><span class="p">,</span>
						<span class="n">LOCK_USED_IN_HARDIRQ_READ</span><span class="p">))</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">softirq_context</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mark_lock</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">hlock</span><span class="p">,</span>
						<span class="n">LOCK_USED_IN_SOFTIRQ_READ</span><span class="p">))</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">hardirq_context</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mark_lock</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">hlock</span><span class="p">,</span> <span class="n">LOCK_USED_IN_HARDIRQ</span><span class="p">))</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">softirq_context</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mark_lock</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">hlock</span><span class="p">,</span> <span class="n">LOCK_USED_IN_SOFTIRQ</span><span class="p">))</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hlock</span><span class="o">-&gt;</span><span class="n">hardirqs_off</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hlock</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mark_lock</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">hlock</span><span class="p">,</span>
					<span class="n">LOCK_ENABLED_HARDIRQ_READ</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">softirqs_enabled</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mark_lock</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">hlock</span><span class="p">,</span>
						<span class="n">LOCK_ENABLED_SOFTIRQ_READ</span><span class="p">))</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mark_lock</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">hlock</span><span class="p">,</span>
					<span class="n">LOCK_ENABLED_HARDIRQ</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">softirqs_enabled</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mark_lock</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">hlock</span><span class="p">,</span>
						<span class="n">LOCK_ENABLED_SOFTIRQ</span><span class="p">))</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We reuse the irq context infrastructure more broadly as a general</span>
<span class="cm">	 * context checking code. This tests GFP_FS recursion (a lock taken</span>
<span class="cm">	 * during reclaim for a GFP_FS allocation is held over a GFP_FS</span>
<span class="cm">	 * allocation).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hlock</span><span class="o">-&gt;</span><span class="n">trylock</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">lockdep_reclaim_gfp</span> <span class="o">&amp;</span> <span class="n">__GFP_FS</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hlock</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mark_lock</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">hlock</span><span class="p">,</span> <span class="n">LOCK_USED_IN_RECLAIM_FS_READ</span><span class="p">))</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mark_lock</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">hlock</span><span class="p">,</span> <span class="n">LOCK_USED_IN_RECLAIM_FS</span><span class="p">))</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">separate_irq_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">hlock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">lockdep_depth</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Keep track of points where we cross into an interrupt context:</span>
<span class="cm">	 */</span>
	<span class="n">hlock</span><span class="o">-&gt;</span><span class="n">irq_context</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">hardirq_context</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span>
				<span class="n">curr</span><span class="o">-&gt;</span><span class="n">softirq_context</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">depth</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">prev_hlock</span><span class="p">;</span>

		<span class="n">prev_hlock</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">held_locks</span> <span class="o">+</span> <span class="n">depth</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we cross into another context, reset the</span>
<span class="cm">		 * hash key (this also prevents the checking and the</span>
<span class="cm">		 * adding of the dependency to &#39;prev&#39;):</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prev_hlock</span><span class="o">-&gt;</span><span class="n">irq_context</span> <span class="o">!=</span> <span class="n">hlock</span><span class="o">-&gt;</span><span class="n">irq_context</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* defined(CONFIG_TRACE_IRQFLAGS) &amp;&amp; defined(CONFIG_PROVE_LOCKING) */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">int</span> <span class="nf">mark_lock_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">lock_usage_bit</span> <span class="n">new_bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="cm">/* Impossible innit? when we don&#39;t have TRACE_IRQFLAG */</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mark_irqflags</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">hlock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">separate_irq_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">hlock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">lockdep_trace_alloc</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* defined(CONFIG_TRACE_IRQFLAGS) &amp;&amp; defined(CONFIG_PROVE_LOCKING) */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Mark a lock with a usage bit, and validate the state transition:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mark_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span>
			     <span class="k">enum</span> <span class="n">lock_usage_bit</span> <span class="n">new_bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">new_mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">new_bit</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If already set then do not dirty the cacheline,</span>
<span class="cm">	 * nor do any checks:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">hlock_class</span><span class="p">(</span><span class="n">this</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">usage_mask</span> <span class="o">&amp;</span> <span class="n">new_mask</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">graph_lock</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Make sure we didn&#39;t race:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">hlock_class</span><span class="p">(</span><span class="n">this</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">usage_mask</span> <span class="o">&amp;</span> <span class="n">new_mask</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">graph_unlock</span><span class="p">();</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hlock_class</span><span class="p">(</span><span class="n">this</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">usage_mask</span> <span class="o">|=</span> <span class="n">new_mask</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">save_trace</span><span class="p">(</span><span class="n">hlock_class</span><span class="p">(</span><span class="n">this</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">usage_traces</span> <span class="o">+</span> <span class="n">new_bit</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">new_bit</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#define LOCKDEP_STATE(__STATE)			\</span>
<span class="cp">	case LOCK_USED_IN_##__STATE:		\</span>
<span class="cp">	case LOCK_USED_IN_##__STATE##_READ:	\</span>
<span class="cp">	case LOCK_ENABLED_##__STATE:		\</span>
<span class="cp">	case LOCK_ENABLED_##__STATE##_READ:</span>
<span class="cp">#include &quot;lockdep_states.h&quot;</span>
<span class="cp">#undef LOCKDEP_STATE</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">mark_lock_irq</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">this</span><span class="p">,</span> <span class="n">new_bit</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LOCK_USED</span>:
		<span class="n">debug_atomic_dec</span><span class="p">(</span><span class="n">nr_unused_locks</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug_locks_off_graph_unlock</span><span class="p">())</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">graph_unlock</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * We must printk outside of the graph_lock:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">marked lock as {%s}:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">usage_str</span><span class="p">[</span><span class="n">new_bit</span><span class="p">]);</span>
		<span class="n">print_lock</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
		<span class="n">print_irqtrace_events</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize a lock instance&#39;s lock-class mapping info:</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">lockdep_init_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">lockdep_map</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">subclass</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">kmemcheck_mark_initialized</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">lock</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_LOCKDEP_CACHING_CLASSES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">lock</span><span class="o">-&gt;</span><span class="n">class_cache</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_LOCK_STAT</span>
	<span class="n">lock</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">raw_smp_processor_id</span><span class="p">();</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Can&#39;t be having no nameless bastards around this place!</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lock</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;NULL&quot;</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lock</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * No key, no joy, we need to hash something.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">key</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Sanity check, the lock-class key must be persistent:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">static_obj</span><span class="p">(</span><span class="n">key</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;BUG: key %p not in .data!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * What it says above ^^^^^, I suggest you read it.</span>
<span class="cm">		 */</span>
		<span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lock</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">debug_locks</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">subclass</span><span class="p">)</span>
		<span class="n">register_lock_class</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">subclass</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">lockdep_init_map</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">lock_class_key</span> <span class="n">__lockdep_no_validate__</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * This gets called for every mutex_lock*()/spin_lock*() operation.</span>
<span class="cm"> * We maintain the dependency maps and validate the locking attempt:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__lock_acquire</span><span class="p">(</span><span class="k">struct</span> <span class="n">lockdep_map</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">subclass</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">trylock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">read</span><span class="p">,</span> <span class="kt">int</span> <span class="n">check</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hardirqs_off</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">lockdep_map</span> <span class="o">*</span><span class="n">nest_lock</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">references</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">class</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">hlock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">,</span> <span class="n">id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chain_head</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">class_idx</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">chain_key</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prove_locking</span><span class="p">)</span>
		<span class="n">check</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">debug_locks</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Lockdep should run with IRQs disabled, otherwise we could</span>
<span class="cm">	 * get an interrupt which would want to take locks, which would</span>
<span class="cm">	 * end up in lockdep and have you got a head-ache already?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">()))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">__lockdep_no_validate__</span><span class="p">)</span>
		<span class="n">check</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">subclass</span> <span class="o">&lt;</span> <span class="n">NR_LOCKDEP_CACHING_CLASSES</span><span class="p">)</span>
		<span class="n">class</span> <span class="o">=</span> <span class="n">lock</span><span class="o">-&gt;</span><span class="n">class_cache</span><span class="p">[</span><span class="n">subclass</span><span class="p">];</span>
	<span class="cm">/*</span>
<span class="cm">	 * Not cached?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">class</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">class</span> <span class="o">=</span> <span class="n">register_lock_class</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">subclass</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">class</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">atomic_inc</span><span class="p">((</span><span class="n">atomic_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">very_verbose</span><span class="p">(</span><span class="n">class</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">acquire class [%p] %s&quot;</span><span class="p">,</span> <span class="n">class</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">class</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">name_version</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;#%d&quot;</span><span class="p">,</span> <span class="n">class</span><span class="o">-&gt;</span><span class="n">name_version</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Add the lock to the list of currently held locks.</span>
<span class="cm">	 * (we dont increase the depth just yet, up until the</span>
<span class="cm">	 * dependency checks are done)</span>
<span class="cm">	 */</span>
	<span class="n">depth</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">lockdep_depth</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Ran out of static storage for our per-task lock stack again have we?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">(</span><span class="n">depth</span> <span class="o">&gt;=</span> <span class="n">MAX_LOCK_DEPTH</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">class_idx</span> <span class="o">=</span> <span class="n">class</span> <span class="o">-</span> <span class="n">lock_classes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">depth</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hlock</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">held_locks</span> <span class="o">+</span> <span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hlock</span><span class="o">-&gt;</span><span class="n">class_idx</span> <span class="o">==</span> <span class="n">class_idx</span> <span class="o">&amp;&amp;</span> <span class="n">nest_lock</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hlock</span><span class="o">-&gt;</span><span class="n">references</span><span class="p">)</span>
				<span class="n">hlock</span><span class="o">-&gt;</span><span class="n">references</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">hlock</span><span class="o">-&gt;</span><span class="n">references</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">hlock</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">held_locks</span> <span class="o">+</span> <span class="n">depth</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Plain impossible, we just registered it and checked it weren&#39;t no</span>
<span class="cm">	 * NULL like.. I bet this mushroom I ate was good!</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">class</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hlock</span><span class="o">-&gt;</span><span class="n">class_idx</span> <span class="o">=</span> <span class="n">class_idx</span><span class="p">;</span>
	<span class="n">hlock</span><span class="o">-&gt;</span><span class="n">acquire_ip</span> <span class="o">=</span> <span class="n">ip</span><span class="p">;</span>
	<span class="n">hlock</span><span class="o">-&gt;</span><span class="n">instance</span> <span class="o">=</span> <span class="n">lock</span><span class="p">;</span>
	<span class="n">hlock</span><span class="o">-&gt;</span><span class="n">nest_lock</span> <span class="o">=</span> <span class="n">nest_lock</span><span class="p">;</span>
	<span class="n">hlock</span><span class="o">-&gt;</span><span class="n">trylock</span> <span class="o">=</span> <span class="n">trylock</span><span class="p">;</span>
	<span class="n">hlock</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">=</span> <span class="n">read</span><span class="p">;</span>
	<span class="n">hlock</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">=</span> <span class="n">check</span><span class="p">;</span>
	<span class="n">hlock</span><span class="o">-&gt;</span><span class="n">hardirqs_off</span> <span class="o">=</span> <span class="o">!!</span><span class="n">hardirqs_off</span><span class="p">;</span>
	<span class="n">hlock</span><span class="o">-&gt;</span><span class="n">references</span> <span class="o">=</span> <span class="n">references</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_LOCK_STAT</span>
	<span class="n">hlock</span><span class="o">-&gt;</span><span class="n">waittime_stamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hlock</span><span class="o">-&gt;</span><span class="n">holdtime_stamp</span> <span class="o">=</span> <span class="n">lockstat_clock</span><span class="p">();</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">check</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mark_irqflags</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">hlock</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* mark it as used: */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mark_lock</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">hlock</span><span class="p">,</span> <span class="n">LOCK_USED</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate the chain hash: it&#39;s the combined hash of all the</span>
<span class="cm">	 * lock keys along the dependency chain. We save the hash value</span>
<span class="cm">	 * at every step so that we can get the current hash easily</span>
<span class="cm">	 * after unlock. The chain hash is then used to cache dependency</span>
<span class="cm">	 * results.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The &#39;key ID&#39; is what is the most compact key value to drive</span>
<span class="cm">	 * the hash, not class-&gt;key.</span>
<span class="cm">	 */</span>
	<span class="n">id</span> <span class="o">=</span> <span class="n">class</span> <span class="o">-</span> <span class="n">lock_classes</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Whoops, we did it again.. ran straight out of our static allocation.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">(</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">MAX_LOCKDEP_KEYS</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">chain_key</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">curr_chain_key</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">depth</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * How can we have a chain hash when we ain&#39;t got no keys?!</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">(</span><span class="n">chain_key</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">chain_head</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hlock</span><span class="o">-&gt;</span><span class="n">prev_chain_key</span> <span class="o">=</span> <span class="n">chain_key</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">separate_irq_context</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">hlock</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">chain_key</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">chain_head</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">chain_key</span> <span class="o">=</span> <span class="n">iterate_chain_key</span><span class="p">(</span><span class="n">chain_key</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">validate_chain</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">lock</span><span class="p">,</span> <span class="n">hlock</span><span class="p">,</span> <span class="n">chain_head</span><span class="p">,</span> <span class="n">chain_key</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">curr</span><span class="o">-&gt;</span><span class="n">curr_chain_key</span> <span class="o">=</span> <span class="n">chain_key</span><span class="p">;</span>
	<span class="n">curr</span><span class="o">-&gt;</span><span class="n">lockdep_depth</span><span class="o">++</span><span class="p">;</span>
	<span class="n">check_chain_key</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_DEBUG_LOCKDEP</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">debug_locks</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">lockdep_depth</span> <span class="o">&gt;=</span> <span class="n">MAX_LOCK_DEPTH</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">debug_locks_off</span><span class="p">();</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;BUG: MAX_LOCK_DEPTH too low!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;turning off the locking correctness validator.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">lockdep_depth</span> <span class="o">&gt;</span> <span class="n">max_lockdep_depth</span><span class="p">))</span>
		<span class="n">max_lockdep_depth</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">lockdep_depth</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">print_unlock_inbalance_bug</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lockdep_map</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug_locks_off</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_locks_silent</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;=====================================</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;[ BUG: bad unlock balance detected! ]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">print_kernel_ident</span><span class="p">();</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;-------------------------------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s/%d is trying to release lock (&quot;</span><span class="p">,</span>
		<span class="n">curr</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">curr</span><span class="p">));</span>
	<span class="n">print_lockdep_cache</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;) at:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">print_ip_sym</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;but there are no more locks to release!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">other info that might help us debug this:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">lockdep_print_held_locks</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">stack backtrace:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">dump_stack</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Common debugging checks for both nested and non-nested unlock:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lockdep_map</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">debug_locks</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Lockdep should run with IRQs disabled, recursion, head-ache, etc..</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">()))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">lockdep_depth</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">print_unlock_inbalance_bug</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">lock</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">match_held_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">hlock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lockdep_map</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hlock</span><span class="o">-&gt;</span><span class="n">instance</span> <span class="o">==</span> <span class="n">lock</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hlock</span><span class="o">-&gt;</span><span class="n">references</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">class</span> <span class="o">=</span> <span class="n">lock</span><span class="o">-&gt;</span><span class="n">class_cache</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">class</span><span class="p">)</span>
			<span class="n">class</span> <span class="o">=</span> <span class="n">look_up_lock_class</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If look_up_lock_class() failed to find a class, we&#39;re trying</span>
<span class="cm">		 * to test if we hold a lock that has never yet been acquired.</span>
<span class="cm">		 * Clearly if the lock hasn&#39;t been acquired _ever_, we&#39;re not</span>
<span class="cm">		 * holding it either, so report failure.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">class</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * References, but not a lock we&#39;re actually ref-counting?</span>
<span class="cm">		 * State got messed up, follow the sites that change -&gt;references</span>
<span class="cm">		 * and try to make sense of it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">hlock</span><span class="o">-&gt;</span><span class="n">nest_lock</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hlock</span><span class="o">-&gt;</span><span class="n">class_idx</span> <span class="o">==</span> <span class="n">class</span> <span class="o">-</span> <span class="n">lock_classes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">__lock_set_class</span><span class="p">(</span><span class="k">struct</span> <span class="n">lockdep_map</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">subclass</span><span class="p">,</span>
		 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">hlock</span><span class="p">,</span> <span class="o">*</span><span class="n">prev_hlock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">class</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">depth</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">lockdep_depth</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * This function is about (re)setting the class of a held lock,</span>
<span class="cm">	 * yet we&#39;re not actually holding any locks. Naughty user!</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">depth</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">prev_hlock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">depth</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hlock</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">held_locks</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * We must not cross into another context:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prev_hlock</span> <span class="o">&amp;&amp;</span> <span class="n">prev_hlock</span><span class="o">-&gt;</span><span class="n">irq_context</span> <span class="o">!=</span> <span class="n">hlock</span><span class="o">-&gt;</span><span class="n">irq_context</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">match_held_lock</span><span class="p">(</span><span class="n">hlock</span><span class="p">,</span> <span class="n">lock</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">found_it</span><span class="p">;</span>
		<span class="n">prev_hlock</span> <span class="o">=</span> <span class="n">hlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">print_unlock_inbalance_bug</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">lock</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>

<span class="nl">found_it:</span>
	<span class="n">lockdep_init_map</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">class</span> <span class="o">=</span> <span class="n">register_lock_class</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">subclass</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">hlock</span><span class="o">-&gt;</span><span class="n">class_idx</span> <span class="o">=</span> <span class="n">class</span> <span class="o">-</span> <span class="n">lock_classes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">curr</span><span class="o">-&gt;</span><span class="n">lockdep_depth</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">curr</span><span class="o">-&gt;</span><span class="n">curr_chain_key</span> <span class="o">=</span> <span class="n">hlock</span><span class="o">-&gt;</span><span class="n">prev_chain_key</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">depth</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hlock</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">held_locks</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__lock_acquire</span><span class="p">(</span><span class="n">hlock</span><span class="o">-&gt;</span><span class="n">instance</span><span class="p">,</span>
			<span class="n">hlock_class</span><span class="p">(</span><span class="n">hlock</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">subclass</span><span class="p">,</span> <span class="n">hlock</span><span class="o">-&gt;</span><span class="n">trylock</span><span class="p">,</span>
				<span class="n">hlock</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">,</span> <span class="n">hlock</span><span class="o">-&gt;</span><span class="n">check</span><span class="p">,</span> <span class="n">hlock</span><span class="o">-&gt;</span><span class="n">hardirqs_off</span><span class="p">,</span>
				<span class="n">hlock</span><span class="o">-&gt;</span><span class="n">nest_lock</span><span class="p">,</span> <span class="n">hlock</span><span class="o">-&gt;</span><span class="n">acquire_ip</span><span class="p">,</span>
				<span class="n">hlock</span><span class="o">-&gt;</span><span class="n">references</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * I took it apart and put it back together again, except now I have</span>
<span class="cm">	 * these &#39;spare&#39; parts.. where shall I put them.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">lockdep_depth</span> <span class="o">!=</span> <span class="n">depth</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove the lock to the list of currently held locks in a</span>
<span class="cm"> * potentially non-nested (out of order) manner. This is a</span>
<span class="cm"> * relatively rare operation, as all the unlock APIs default</span>
<span class="cm"> * to nested mode (which uses lock_release()):</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lock_release_non_nested</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">lockdep_map</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">hlock</span><span class="p">,</span> <span class="o">*</span><span class="n">prev_hlock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check whether the lock exists in the current stack</span>
<span class="cm">	 * of held locks:</span>
<span class="cm">	 */</span>
	<span class="n">depth</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">lockdep_depth</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * So we&#39;re all set to release this lock.. wait what lock? We don&#39;t</span>
<span class="cm">	 * own any locks, you&#39;ve been drinking again?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">depth</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">prev_hlock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">depth</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hlock</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">held_locks</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * We must not cross into another context:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prev_hlock</span> <span class="o">&amp;&amp;</span> <span class="n">prev_hlock</span><span class="o">-&gt;</span><span class="n">irq_context</span> <span class="o">!=</span> <span class="n">hlock</span><span class="o">-&gt;</span><span class="n">irq_context</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">match_held_lock</span><span class="p">(</span><span class="n">hlock</span><span class="p">,</span> <span class="n">lock</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">found_it</span><span class="p">;</span>
		<span class="n">prev_hlock</span> <span class="o">=</span> <span class="n">hlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">print_unlock_inbalance_bug</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">lock</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>

<span class="nl">found_it:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hlock</span><span class="o">-&gt;</span><span class="n">instance</span> <span class="o">==</span> <span class="n">lock</span><span class="p">)</span>
		<span class="n">lock_release_holdtime</span><span class="p">(</span><span class="n">hlock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hlock</span><span class="o">-&gt;</span><span class="n">references</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hlock</span><span class="o">-&gt;</span><span class="n">references</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hlock</span><span class="o">-&gt;</span><span class="n">references</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We had, and after removing one, still have</span>
<span class="cm">			 * references, the current lock stack is still</span>
<span class="cm">			 * valid. We&#39;re done!</span>
<span class="cm">			 */</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We have the right lock to unlock, &#39;hlock&#39; points to it.</span>
<span class="cm">	 * Now we remove it from the stack, and add back the other</span>
<span class="cm">	 * entries (if any), recalculating the hash along the way:</span>
<span class="cm">	 */</span>

	<span class="n">curr</span><span class="o">-&gt;</span><span class="n">lockdep_depth</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">curr</span><span class="o">-&gt;</span><span class="n">curr_chain_key</span> <span class="o">=</span> <span class="n">hlock</span><span class="o">-&gt;</span><span class="n">prev_chain_key</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">++</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">depth</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hlock</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">held_locks</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__lock_acquire</span><span class="p">(</span><span class="n">hlock</span><span class="o">-&gt;</span><span class="n">instance</span><span class="p">,</span>
			<span class="n">hlock_class</span><span class="p">(</span><span class="n">hlock</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">subclass</span><span class="p">,</span> <span class="n">hlock</span><span class="o">-&gt;</span><span class="n">trylock</span><span class="p">,</span>
				<span class="n">hlock</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">,</span> <span class="n">hlock</span><span class="o">-&gt;</span><span class="n">check</span><span class="p">,</span> <span class="n">hlock</span><span class="o">-&gt;</span><span class="n">hardirqs_off</span><span class="p">,</span>
				<span class="n">hlock</span><span class="o">-&gt;</span><span class="n">nest_lock</span><span class="p">,</span> <span class="n">hlock</span><span class="o">-&gt;</span><span class="n">acquire_ip</span><span class="p">,</span>
				<span class="n">hlock</span><span class="o">-&gt;</span><span class="n">references</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We had N bottles of beer on the wall, we drank one, but now</span>
<span class="cm">	 * there&#39;s not N-1 bottles of beer left on the wall...</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">lockdep_depth</span> <span class="o">!=</span> <span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove the lock to the list of currently held locks - this gets</span>
<span class="cm"> * called on mutex_unlock()/spin_unlock*() (or on a failed</span>
<span class="cm"> * mutex_lock_interruptible()). This is done for unlocks that nest</span>
<span class="cm"> * perfectly. (i.e. the current top of the lock-stack is unlocked)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">lock_release_nested</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">lockdep_map</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">hlock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Pop off the top of the lock stack:</span>
<span class="cm">	 */</span>
	<span class="n">depth</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">lockdep_depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">hlock</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">held_locks</span> <span class="o">+</span> <span class="n">depth</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Is the unlock non-nested:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hlock</span><span class="o">-&gt;</span><span class="n">instance</span> <span class="o">!=</span> <span class="n">lock</span> <span class="o">||</span> <span class="n">hlock</span><span class="o">-&gt;</span><span class="n">references</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">lock_release_non_nested</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">lock</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
	<span class="n">curr</span><span class="o">-&gt;</span><span class="n">lockdep_depth</span><span class="o">--</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * No more locks, but somehow we&#39;ve got hash left over, who left it?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">depth</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">hlock</span><span class="o">-&gt;</span><span class="n">prev_chain_key</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">curr</span><span class="o">-&gt;</span><span class="n">curr_chain_key</span> <span class="o">=</span> <span class="n">hlock</span><span class="o">-&gt;</span><span class="n">prev_chain_key</span><span class="p">;</span>

	<span class="n">lock_release_holdtime</span><span class="p">(</span><span class="n">hlock</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_DEBUG_LOCKDEP</span>
	<span class="n">hlock</span><span class="o">-&gt;</span><span class="n">prev_chain_key</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hlock</span><span class="o">-&gt;</span><span class="n">class_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hlock</span><span class="o">-&gt;</span><span class="n">acquire_ip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hlock</span><span class="o">-&gt;</span><span class="n">irq_context</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove the lock to the list of currently held locks - this gets</span>
<span class="cm"> * called on mutex_unlock()/spin_unlock*() (or on a failed</span>
<span class="cm"> * mutex_lock_interruptible()). This is done for unlocks that nest</span>
<span class="cm"> * perfectly. (i.e. the current top of the lock-stack is unlocked)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">__lock_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">lockdep_map</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nested</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_unlock</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">lock</span><span class="p">,</span> <span class="n">ip</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nested</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lock_release_nested</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">lock</span><span class="p">,</span> <span class="n">ip</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lock_release_non_nested</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">lock</span><span class="p">,</span> <span class="n">ip</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">check_chain_key</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__lock_is_held</span><span class="p">(</span><span class="k">struct</span> <span class="n">lockdep_map</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">lockdep_depth</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">hlock</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">held_locks</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">match_held_lock</span><span class="p">(</span><span class="n">hlock</span><span class="p">,</span> <span class="n">lock</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check whether we follow the irq-flags state precisely:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_flags</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if defined(CONFIG_PROVE_LOCKING) &amp;&amp; defined(CONFIG_DEBUG_LOCKDEP) &amp;&amp; \</span>
<span class="cp">    defined(CONFIG_TRACE_IRQFLAGS)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug_locks</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irqs_disabled_flags</span><span class="p">(</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">hardirqs_enabled</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;possible reason: unannotated irqs-off.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">hardirqs_enabled</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;possible reason: unannotated irqs-on.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We dont accurately track softirq state in e.g.</span>
<span class="cm">	 * hardirq contexts (such as on 4KSTACKS), so only</span>
<span class="cm">	 * check if not in hardirq contexts:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hardirq_count</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">softirq_count</span><span class="p">())</span> <span class="p">{</span>
			<span class="cm">/* like the above, but with softirqs */</span>
			<span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">softirqs_enabled</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* lick the above, does it taste good? */</span>
			<span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">softirqs_enabled</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug_locks</span><span class="p">)</span>
		<span class="n">print_irqtrace_events</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">lock_set_class</span><span class="p">(</span><span class="k">struct</span> <span class="n">lockdep_map</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">subclass</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">lockdep_recursion</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">raw_local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">lockdep_recursion</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">check_flags</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__lock_set_class</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">subclass</span><span class="p">,</span> <span class="n">ip</span><span class="p">))</span>
		<span class="n">check_chain_key</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">lockdep_recursion</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">raw_local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">lock_set_class</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * We are not always called with irqs disabled - do that here,</span>
<span class="cm"> * and also avoid lockdep recursion:</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">lock_acquire</span><span class="p">(</span><span class="k">struct</span> <span class="n">lockdep_map</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">subclass</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">trylock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">read</span><span class="p">,</span> <span class="kt">int</span> <span class="n">check</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">lockdep_map</span> <span class="o">*</span><span class="n">nest_lock</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">lockdep_recursion</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">raw_local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">check_flags</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">current</span><span class="o">-&gt;</span><span class="n">lockdep_recursion</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">trace_lock_acquire</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">subclass</span><span class="p">,</span> <span class="n">trylock</span><span class="p">,</span> <span class="n">read</span><span class="p">,</span> <span class="n">check</span><span class="p">,</span> <span class="n">nest_lock</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
	<span class="n">__lock_acquire</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">subclass</span><span class="p">,</span> <span class="n">trylock</span><span class="p">,</span> <span class="n">read</span><span class="p">,</span> <span class="n">check</span><span class="p">,</span>
		       <span class="n">irqs_disabled_flags</span><span class="p">(</span><span class="n">flags</span><span class="p">),</span> <span class="n">nest_lock</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">lockdep_recursion</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">raw_local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">lock_acquire</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">lock_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">lockdep_map</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nested</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">lockdep_recursion</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">raw_local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">check_flags</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">lockdep_recursion</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">trace_lock_release</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
	<span class="n">__lock_release</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">nested</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">lockdep_recursion</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">raw_local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">lock_release</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">lock_is_held</span><span class="p">(</span><span class="k">struct</span> <span class="n">lockdep_map</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">lockdep_recursion</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* avoid false negative lockdep_assert_held() */</span>

	<span class="n">raw_local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">check_flags</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">current</span><span class="o">-&gt;</span><span class="n">lockdep_recursion</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__lock_is_held</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">lockdep_recursion</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">raw_local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">lock_is_held</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">lockdep_set_current_reclaim_state</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">lockdep_reclaim_gfp</span> <span class="o">=</span> <span class="n">gfp_mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">lockdep_clear_current_reclaim_state</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">lockdep_reclaim_gfp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_LOCK_STAT</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">print_lock_contention_bug</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lockdep_map</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug_locks_off</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_locks_silent</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;=================================</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;[ BUG: bad contention detected! ]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">print_kernel_ident</span><span class="p">();</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;---------------------------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s/%d is trying to contend lock (&quot;</span><span class="p">,</span>
		<span class="n">curr</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">curr</span><span class="p">));</span>
	<span class="n">print_lockdep_cache</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;) at:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">print_ip_sym</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;but there are no locks held!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">other info that might help us debug this:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">lockdep_print_held_locks</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">stack backtrace:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">dump_stack</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">__lock_contended</span><span class="p">(</span><span class="k">struct</span> <span class="n">lockdep_map</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">hlock</span><span class="p">,</span> <span class="o">*</span><span class="n">prev_hlock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock_class_stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">contention_point</span><span class="p">,</span> <span class="n">contending_point</span><span class="p">;</span>

	<span class="n">depth</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">lockdep_depth</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Whee, we contended on this lock, except it seems we&#39;re not</span>
<span class="cm">	 * actually trying to acquire anything much at all..</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">depth</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">prev_hlock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">depth</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hlock</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">held_locks</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * We must not cross into another context:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prev_hlock</span> <span class="o">&amp;&amp;</span> <span class="n">prev_hlock</span><span class="o">-&gt;</span><span class="n">irq_context</span> <span class="o">!=</span> <span class="n">hlock</span><span class="o">-&gt;</span><span class="n">irq_context</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">match_held_lock</span><span class="p">(</span><span class="n">hlock</span><span class="p">,</span> <span class="n">lock</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">found_it</span><span class="p">;</span>
		<span class="n">prev_hlock</span> <span class="o">=</span> <span class="n">hlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">print_lock_contention_bug</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">lock</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">found_it:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hlock</span><span class="o">-&gt;</span><span class="n">instance</span> <span class="o">!=</span> <span class="n">lock</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">hlock</span><span class="o">-&gt;</span><span class="n">waittime_stamp</span> <span class="o">=</span> <span class="n">lockstat_clock</span><span class="p">();</span>

	<span class="n">contention_point</span> <span class="o">=</span> <span class="n">lock_point</span><span class="p">(</span><span class="n">hlock_class</span><span class="p">(</span><span class="n">hlock</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">contention_point</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
	<span class="n">contending_point</span> <span class="o">=</span> <span class="n">lock_point</span><span class="p">(</span><span class="n">hlock_class</span><span class="p">(</span><span class="n">hlock</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">contending_point</span><span class="p">,</span>
				      <span class="n">lock</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span>

	<span class="n">stats</span> <span class="o">=</span> <span class="n">get_lock_stats</span><span class="p">(</span><span class="n">hlock_class</span><span class="p">(</span><span class="n">hlock</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">contention_point</span> <span class="o">&lt;</span> <span class="n">LOCKSTAT_POINTS</span><span class="p">)</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">contention_point</span><span class="p">[</span><span class="n">contention_point</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">contending_point</span> <span class="o">&lt;</span> <span class="n">LOCKSTAT_POINTS</span><span class="p">)</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">contending_point</span><span class="p">[</span><span class="n">contending_point</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">smp_processor_id</span><span class="p">())</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">bounces</span><span class="p">[</span><span class="n">bounce_contended</span> <span class="o">+</span> <span class="o">!!</span><span class="n">hlock</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="n">put_lock_stats</span><span class="p">(</span><span class="n">stats</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">__lock_acquired</span><span class="p">(</span><span class="k">struct</span> <span class="n">lockdep_map</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">hlock</span><span class="p">,</span> <span class="o">*</span><span class="n">prev_hlock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock_class_stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">now</span><span class="p">,</span> <span class="n">waittime</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">depth</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">lockdep_depth</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Yay, we acquired ownership of this lock we didn&#39;t try to</span>
<span class="cm">	 * acquire, how the heck did that happen?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">depth</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">prev_hlock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">depth</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hlock</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">held_locks</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * We must not cross into another context:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prev_hlock</span> <span class="o">&amp;&amp;</span> <span class="n">prev_hlock</span><span class="o">-&gt;</span><span class="n">irq_context</span> <span class="o">!=</span> <span class="n">hlock</span><span class="o">-&gt;</span><span class="n">irq_context</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">match_held_lock</span><span class="p">(</span><span class="n">hlock</span><span class="p">,</span> <span class="n">lock</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">found_it</span><span class="p">;</span>
		<span class="n">prev_hlock</span> <span class="o">=</span> <span class="n">hlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">print_lock_contention_bug</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">lock</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">found_it:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hlock</span><span class="o">-&gt;</span><span class="n">instance</span> <span class="o">!=</span> <span class="n">lock</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hlock</span><span class="o">-&gt;</span><span class="n">waittime_stamp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">now</span> <span class="o">=</span> <span class="n">lockstat_clock</span><span class="p">();</span>
		<span class="n">waittime</span> <span class="o">=</span> <span class="n">now</span> <span class="o">-</span> <span class="n">hlock</span><span class="o">-&gt;</span><span class="n">waittime_stamp</span><span class="p">;</span>
		<span class="n">hlock</span><span class="o">-&gt;</span><span class="n">holdtime_stamp</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">trace_lock_acquired</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>

	<span class="n">stats</span> <span class="o">=</span> <span class="n">get_lock_stats</span><span class="p">(</span><span class="n">hlock_class</span><span class="p">(</span><span class="n">hlock</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">waittime</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hlock</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">)</span>
			<span class="n">lock_time_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">read_waittime</span><span class="p">,</span> <span class="n">waittime</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">lock_time_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">write_waittime</span><span class="p">,</span> <span class="n">waittime</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">cpu</span><span class="p">)</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">bounces</span><span class="p">[</span><span class="n">bounce_acquired</span> <span class="o">+</span> <span class="o">!!</span><span class="n">hlock</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="n">put_lock_stats</span><span class="p">(</span><span class="n">stats</span><span class="p">);</span>

	<span class="n">lock</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="n">lock</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">=</span> <span class="n">ip</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">lock_contended</span><span class="p">(</span><span class="k">struct</span> <span class="n">lockdep_map</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">lock_stat</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">lockdep_recursion</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">raw_local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">check_flags</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">lockdep_recursion</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">trace_lock_contended</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
	<span class="n">__lock_contended</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">lockdep_recursion</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">raw_local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">lock_contended</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">lock_acquired</span><span class="p">(</span><span class="k">struct</span> <span class="n">lockdep_map</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">lock_stat</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">lockdep_recursion</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">raw_local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">check_flags</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">lockdep_recursion</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__lock_acquired</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">lockdep_recursion</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">raw_local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">lock_acquired</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Used by the testsuite, sanitize the validator state</span>
<span class="cm"> * after a simulated failure:</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">lockdep_reset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">raw_local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">curr_chain_key</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">lockdep_depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">lockdep_recursion</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">held_locks</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MAX_LOCK_DEPTH</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">held_lock</span><span class="p">));</span>
	<span class="n">nr_hardirq_chains</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">nr_softirq_chains</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">nr_process_chains</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">debug_locks</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CHAINHASH_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="n">chainhash_table</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">raw_local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">zap_class</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">class</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Remove all dependencies this lock is</span>
<span class="cm">	 * involved in:</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_list_entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">class</span> <span class="o">==</span> <span class="n">class</span><span class="p">)</span>
			<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">entry</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Unhash the class and remove it from the all_lock_classes list:</span>
<span class="cm">	 */</span>
	<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">hash_entry</span><span class="p">);</span>
	<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">lock_entry</span><span class="p">);</span>

	<span class="n">class</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">within</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">start</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">lockdep_free_key_range</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">class</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">locked</span><span class="p">;</span>

	<span class="n">raw_local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">locked</span> <span class="o">=</span> <span class="n">graph_lock</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Unhash all classes that were created by this module:</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CLASSHASH_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">head</span> <span class="o">=</span> <span class="n">classhash_table</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="n">head</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">class</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">hash_entry</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">within</span><span class="p">(</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
				<span class="n">zap_class</span><span class="p">(</span><span class="n">class</span><span class="p">);</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">within</span><span class="p">(</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
				<span class="n">zap_class</span><span class="p">(</span><span class="n">class</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">locked</span><span class="p">)</span>
		<span class="n">graph_unlock</span><span class="p">();</span>
	<span class="n">raw_local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">lockdep_reset_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">lockdep_map</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lock_class</span> <span class="o">*</span><span class="n">class</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">locked</span><span class="p">;</span>

	<span class="n">raw_local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Remove all classes this lock might have:</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">MAX_LOCKDEP_SUBCLASSES</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the class exists we look it up and zap it:</span>
<span class="cm">		 */</span>
		<span class="n">class</span> <span class="o">=</span> <span class="n">look_up_lock_class</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">class</span><span class="p">)</span>
			<span class="n">zap_class</span><span class="p">(</span><span class="n">class</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Debug check: in the end all mapped classes should</span>
<span class="cm">	 * be gone.</span>
<span class="cm">	 */</span>
	<span class="n">locked</span> <span class="o">=</span> <span class="n">graph_lock</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CLASSHASH_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">head</span> <span class="o">=</span> <span class="n">classhash_table</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="n">head</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">class</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">hash_entry</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">match</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">NR_LOCKDEP_CACHING_CLASSES</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
				<span class="n">match</span> <span class="o">|=</span> <span class="n">class</span> <span class="o">==</span> <span class="n">lock</span><span class="o">-&gt;</span><span class="n">class_cache</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">match</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">debug_locks_off_graph_unlock</span><span class="p">())</span> <span class="p">{</span>
					<span class="cm">/*</span>
<span class="cm">					 * We all just reset everything, how did it match?</span>
<span class="cm">					 */</span>
					<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="k">goto</span> <span class="n">out_restore</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">locked</span><span class="p">)</span>
		<span class="n">graph_unlock</span><span class="p">();</span>

<span class="nl">out_restore:</span>
	<span class="n">raw_local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">lockdep_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some architectures have their own start_kernel()</span>
<span class="cm">	 * code which calls lockdep_init(), while we also</span>
<span class="cm">	 * call lockdep_init() from the start_kernel() itself,</span>
<span class="cm">	 * and we want to initialize the hashes only once:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lockdep_initialized</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CLASSHASH_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="n">classhash_table</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CHAINHASH_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="n">chainhash_table</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

	<span class="n">lockdep_initialized</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">lockdep_info</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Lock dependency validator: Copyright (c) 2006 Red Hat, Inc., Ingo Molnar</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;... MAX_LOCKDEP_SUBCLASSES:  %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">MAX_LOCKDEP_SUBCLASSES</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;... MAX_LOCK_DEPTH:          %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">MAX_LOCK_DEPTH</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;... MAX_LOCKDEP_KEYS:        %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">MAX_LOCKDEP_KEYS</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;... CLASSHASH_SIZE:          %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">CLASSHASH_SIZE</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;... MAX_LOCKDEP_ENTRIES:     %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">MAX_LOCKDEP_ENTRIES</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;... MAX_LOCKDEP_CHAINS:      %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">MAX_LOCKDEP_CHAINS</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;... CHAINHASH_SIZE:          %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">CHAINHASH_SIZE</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; memory used by lock dependency info: %lu kB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_class</span><span class="p">)</span> <span class="o">*</span> <span class="n">MAX_LOCKDEP_KEYS</span> <span class="o">+</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span><span class="p">)</span> <span class="o">*</span> <span class="n">CLASSHASH_SIZE</span> <span class="o">+</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_list</span><span class="p">)</span> <span class="o">*</span> <span class="n">MAX_LOCKDEP_ENTRIES</span> <span class="o">+</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_chain</span><span class="p">)</span> <span class="o">*</span> <span class="n">MAX_LOCKDEP_CHAINS</span> <span class="o">+</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span><span class="p">)</span> <span class="o">*</span> <span class="n">CHAINHASH_SIZE</span>
<span class="cp">#ifdef CONFIG_PROVE_LOCKING</span>
		<span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">circular_queue</span><span class="p">)</span>
<span class="cp">#endif</span>
		<span class="p">)</span> <span class="o">/</span> <span class="mi">1024</span>
		<span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; per task-struct memory footprint: %lu bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">held_lock</span><span class="p">)</span> <span class="o">*</span> <span class="n">MAX_LOCK_DEPTH</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_DEBUG_LOCKDEP</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lockdep_init_error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;WARNING: lockdep init error! lock-%s was acquired&quot;</span>
			<span class="s">&quot;before lockdep_init</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">lock_init_error</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Call stack leading to lockdep invocation was:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">print_stack_trace</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lockdep_init_trace</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">print_freed_lock_bug</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mem_from</span><span class="p">,</span>
		     <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mem_to</span><span class="p">,</span> <span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">hlock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug_locks_off</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_locks_silent</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;=========================</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;[ BUG: held lock freed! ]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">print_kernel_ident</span><span class="p">();</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;-------------------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s/%d is freeing memory %p-%p, with a lock still held there!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">curr</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">curr</span><span class="p">),</span> <span class="n">mem_from</span><span class="p">,</span> <span class="n">mem_to</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">print_lock</span><span class="p">(</span><span class="n">hlock</span><span class="p">);</span>
	<span class="n">lockdep_print_held_locks</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">stack backtrace:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">dump_stack</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">not_in_range</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">mem_from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mem_len</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">lock_from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lock_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">lock_from</span> <span class="o">+</span> <span class="n">lock_len</span> <span class="o">&lt;=</span> <span class="n">mem_from</span> <span class="o">||</span>
		<span class="n">mem_from</span> <span class="o">+</span> <span class="n">mem_len</span> <span class="o">&lt;=</span> <span class="n">lock_from</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called when kernel memory is freed (or unmapped), or if a lock</span>
<span class="cm"> * is destroyed or reinitialized - this code checks whether there is</span>
<span class="cm"> * any held lock in the memory range of &lt;from&gt; to &lt;to&gt;:</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">debug_check_no_locks_freed</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mem_from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mem_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">held_lock</span> <span class="o">*</span><span class="n">hlock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">debug_locks</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">lockdep_depth</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hlock</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">held_locks</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">not_in_range</span><span class="p">(</span><span class="n">mem_from</span><span class="p">,</span> <span class="n">mem_len</span><span class="p">,</span> <span class="n">hlock</span><span class="o">-&gt;</span><span class="n">instance</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hlock</span><span class="o">-&gt;</span><span class="n">instance</span><span class="p">)))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">print_freed_lock_bug</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">mem_from</span><span class="p">,</span> <span class="n">mem_from</span> <span class="o">+</span> <span class="n">mem_len</span><span class="p">,</span> <span class="n">hlock</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">debug_check_no_locks_freed</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_held_locks_bug</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug_locks_off</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_locks_silent</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;=====================================</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;[ BUG: lock held at task exit time! ]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">print_kernel_ident</span><span class="p">();</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;-------------------------------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s/%d is exiting with locks still held!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">curr</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">curr</span><span class="p">));</span>
	<span class="n">lockdep_print_held_locks</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">stack backtrace:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">dump_stack</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">debug_check_no_locks_held</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">lockdep_depth</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">print_held_locks_bug</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">debug_show_all_locks</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">g</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">unlock</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">debug_locks</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;INFO: lockdep is turned off.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Showing all locks held in the system:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Here we try to get the tasklist_lock as hard as possible,</span>
<span class="cm">	 * if not successful after 2 seconds we ignore it (but keep</span>
<span class="cm">	 * trying). This is to enable a debug printout even if a</span>
<span class="cm">	 * tasklist_lock-holding task deadlocks or crashes.</span>
<span class="cm">	 */</span>
<span class="nl">retry:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">read_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">10</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;hm, tasklist_lock locked, retrying... &quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">count</span><span class="o">--</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot; #%d&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="o">-</span><span class="n">count</span><span class="p">);</span>
			<span class="n">mdelay</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot; ignoring it.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">unlock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">!=</span> <span class="mi">10</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot; locked it.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">do_each_thread</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * It&#39;s not reliable to print a task&#39;s held locks</span>
<span class="cm">		 * if it&#39;s not sleeping (or if it&#39;s not the current</span>
<span class="cm">		 * task):</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">TASK_RUNNING</span> <span class="o">&amp;&amp;</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">current</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lockdep_depth</span><span class="p">)</span>
			<span class="n">lockdep_print_held_locks</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">unlock</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">read_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">))</span>
				<span class="n">unlock</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">while_each_thread</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;=============================================</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlock</span><span class="p">)</span>
		<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">debug_show_all_locks</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Careful: only use this function if you are sure that</span>
<span class="cm"> * the task cannot run in parallel!</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">debug_show_held_locks</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">debug_locks</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;INFO: lockdep is turned off.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lockdep_print_held_locks</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">debug_show_held_locks</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">lockdep_sys_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">lockdep_depth</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug_locks_off</span><span class="p">())</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;================================================</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;[ BUG: lock held when returning to user space! ]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">print_kernel_ident</span><span class="p">();</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;------------------------------------------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s/%d is leaving the kernel with locks still held!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">curr</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="n">lockdep_print_held_locks</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">lockdep_rcu_suspicious</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">line</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

<span class="cp">#ifndef CONFIG_PROVE_RCU_REPEATEDLY</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug_locks_off</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* #ifdef CONFIG_PROVE_RCU_REPEATEDLY */</span><span class="cp"></span>
	<span class="cm">/* Note: the following can be executed concurrently, so be careful. */</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;===============================</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;[ INFO: suspicious RCU usage. ]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">print_kernel_ident</span><span class="p">();</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;-------------------------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s:%d %s!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">other info that might help us debug this:</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">%srcu_scheduler_active = %d, debug_locks = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="o">!</span><span class="n">rcu_lockdep_current_cpu_online</span><span class="p">()</span>
			<span class="o">?</span> <span class="s">&quot;RCU used illegally from offline CPU!</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="o">:</span> <span class="n">rcu_is_cpu_idle</span><span class="p">()</span>
				<span class="o">?</span> <span class="s">&quot;RCU used illegally from idle CPU!</span><span class="se">\n</span><span class="s">&quot;</span>
				<span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
	       <span class="n">rcu_scheduler_active</span><span class="p">,</span> <span class="n">debug_locks</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If a CPU is in the RCU-free window in idle (ie: in the section</span>
<span class="cm">	 * between rcu_idle_enter() and rcu_idle_exit(), then RCU</span>
<span class="cm">	 * considers that CPU to be in an &quot;extended quiescent state&quot;,</span>
<span class="cm">	 * which means that RCU will be completely ignoring that CPU.</span>
<span class="cm">	 * Therefore, rcu_read_lock() and friends have absolutely no</span>
<span class="cm">	 * effect on a CPU running in that state. In other words, even if</span>
<span class="cm">	 * such an RCU-idle CPU has called rcu_read_lock(), RCU might well</span>
<span class="cm">	 * delete data structures out from under it.  RCU really has no</span>
<span class="cm">	 * choice here: we need to keep an RCU-free window in idle where</span>
<span class="cm">	 * the CPU may possibly enter into low power mode. This way we can</span>
<span class="cm">	 * notice an extended quiescent state to other CPUs that started a grace</span>
<span class="cm">	 * period. Otherwise we would delay any grace period as long as we run</span>
<span class="cm">	 * in the idle task.</span>
<span class="cm">	 *</span>
<span class="cm">	 * So complain bitterly if someone does call rcu_read_lock(),</span>
<span class="cm">	 * rcu_read_lock_bh() and so on from extended quiescent states.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rcu_is_cpu_idle</span><span class="p">())</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;RCU used illegally from extended quiescent state!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">lockdep_print_held_locks</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">stack backtrace:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">dump_stack</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">lockdep_rcu_suspicious</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
