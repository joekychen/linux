<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › debug › kdb › kdb_support.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>kdb_support.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Kernel Debugger Architecture Independent Support Functions</span>
<span class="cm"> *</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 1999-2004 Silicon Graphics, Inc.  All Rights Reserved.</span>
<span class="cm"> * Copyright (c) 2009 Wind River Systems, Inc.  All Rights Reserved.</span>
<span class="cm"> * 03/02/13    added new 2.5 kallsyms &lt;xavier.bru@bull.net&gt;</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;stdarg.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/kallsyms.h&gt;</span>
<span class="cp">#include &lt;linux/stddef.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/ptrace.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/hardirq.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/kdb.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &quot;kdb_private.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * kdbgetsymval - Return the address of the given symbol.</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *	symname	Character string containing symbol name</span>
<span class="cm"> *      symtab  Structure to receive results</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *	0	Symbol not found, symtab zero filled</span>
<span class="cm"> *	1	Symbol mapped to module/symbol/section, data in symtab</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">kdbgetsymval</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">symname</span><span class="p">,</span> <span class="n">kdb_symtab_t</span> <span class="o">*</span><span class="n">symtab</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">KDB_DEBUG</span><span class="p">(</span><span class="n">AR</span><span class="p">))</span>
		<span class="n">kdb_printf</span><span class="p">(</span><span class="s">&quot;kdbgetsymval: symname=%s, symtab=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">symname</span><span class="p">,</span>
			   <span class="n">symtab</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">symtab</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">symtab</span><span class="p">));</span>
	<span class="n">symtab</span><span class="o">-&gt;</span><span class="n">sym_start</span> <span class="o">=</span> <span class="n">kallsyms_lookup_name</span><span class="p">(</span><span class="n">symname</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">symtab</span><span class="o">-&gt;</span><span class="n">sym_start</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">KDB_DEBUG</span><span class="p">(</span><span class="n">AR</span><span class="p">))</span>
			<span class="n">kdb_printf</span><span class="p">(</span><span class="s">&quot;kdbgetsymval: returns 1, &quot;</span>
				   <span class="s">&quot;symtab-&gt;sym_start=0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">symtab</span><span class="o">-&gt;</span><span class="n">sym_start</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">KDB_DEBUG</span><span class="p">(</span><span class="n">AR</span><span class="p">))</span>
		<span class="n">kdb_printf</span><span class="p">(</span><span class="s">&quot;kdbgetsymval: returns 0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kdbgetsymval</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">kdb_name_table</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>	<span class="cm">/* arbitrary size */</span>

<span class="cm">/*</span>
<span class="cm"> * kdbnearsym -	Return the name of the symbol with the nearest address</span>
<span class="cm"> *	less than &#39;addr&#39;.</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *	addr	Address to check for symbol near</span>
<span class="cm"> *	symtab  Structure to receive results</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *	0	No sections contain this address, symtab zero filled</span>
<span class="cm"> *	1	Address mapped to module/symbol/section, data in symtab</span>
<span class="cm"> * Remarks:</span>
<span class="cm"> *	2.6 kallsyms has a &quot;feature&quot; where it unpacks the name into a</span>
<span class="cm"> *	string.  If that string is reused before the caller expects it</span>
<span class="cm"> *	then the caller sees its string change without warning.  To</span>
<span class="cm"> *	avoid cluttering up the main kdb code with lots of kdb_strdup,</span>
<span class="cm"> *	tests and kfree calls, kdbnearsym maintains an LRU list of the</span>
<span class="cm"> *	last few unique strings.  The list is sized large enough to</span>
<span class="cm"> *	hold active strings, no kdb caller of kdbnearsym makes more</span>
<span class="cm"> *	than ~20 later calls before using a saved value.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">kdbnearsym</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">kdb_symtab_t</span> <span class="o">*</span><span class="n">symtab</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">symbolsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#define knt1_size 128		</span><span class="cm">/* must be &gt;= kallsyms table size */</span><span class="cp"></span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">knt1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">KDB_DEBUG</span><span class="p">(</span><span class="n">AR</span><span class="p">))</span>
		<span class="n">kdb_printf</span><span class="p">(</span><span class="s">&quot;kdbnearsym: addr=0x%lx, symtab=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">symtab</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">symtab</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">symtab</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="mi">4096</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">knt1</span> <span class="o">=</span> <span class="n">debug_kmalloc</span><span class="p">(</span><span class="n">knt1_size</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">knt1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kdb_printf</span><span class="p">(</span><span class="s">&quot;kdbnearsym: addr=0x%lx cannot kmalloc knt1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">addr</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">symtab</span><span class="o">-&gt;</span><span class="n">sym_name</span> <span class="o">=</span> <span class="n">kallsyms_lookup</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">symbolsize</span> <span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">symtab</span><span class="o">-&gt;</span><span class="n">mod_name</span><span class="p">),</span> <span class="n">knt1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">symtab</span><span class="o">-&gt;</span><span class="n">sym_name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">symbolsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">symtab</span><span class="o">-&gt;</span><span class="n">sym_start</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">symtab</span><span class="o">-&gt;</span><span class="n">sym_end</span> <span class="o">=</span> <span class="n">symtab</span><span class="o">-&gt;</span><span class="n">sym_start</span> <span class="o">+</span> <span class="n">symbolsize</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">symtab</span><span class="o">-&gt;</span><span class="n">sym_name</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="p">(</span><span class="n">symtab</span><span class="o">-&gt;</span><span class="n">sym_name</span><span class="p">)</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="cm">/* Another 2.6 kallsyms &quot;feature&quot;.  Sometimes the sym_name is</span>
<span class="cm">		 * set but the buffer passed into kallsyms_lookup is not used,</span>
<span class="cm">		 * so it contains garbage.  The caller has to work out which</span>
<span class="cm">		 * buffer needs to be saved.</span>
<span class="cm">		 *</span>
<span class="cm">		 * What was Rusty smoking when he wrote that code?</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">symtab</span><span class="o">-&gt;</span><span class="n">sym_name</span> <span class="o">!=</span> <span class="n">knt1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">strncpy</span><span class="p">(</span><span class="n">knt1</span><span class="p">,</span> <span class="n">symtab</span><span class="o">-&gt;</span><span class="n">sym_name</span><span class="p">,</span> <span class="n">knt1_size</span><span class="p">);</span>
			<span class="n">knt1</span><span class="p">[</span><span class="n">knt1_size</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">kdb_name_table</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">kdb_name_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
			    <span class="n">strcmp</span><span class="p">(</span><span class="n">kdb_name_table</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">knt1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">kdb_name_table</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">debug_kfree</span><span class="p">(</span><span class="n">kdb_name_table</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">kdb_name_table</span><span class="p">,</span> <span class="n">kdb_name_table</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="n">kdb_name_table</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span>
			       <span class="p">(</span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">kdb_name_table</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">debug_kfree</span><span class="p">(</span><span class="n">knt1</span><span class="p">);</span>
			<span class="n">knt1</span> <span class="o">=</span> <span class="n">kdb_name_table</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">kdb_name_table</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="n">kdb_name_table</span><span class="o">+</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="n">kdb_name_table</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span>
			       <span class="p">(</span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">kdb_name_table</span><span class="p">)</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">kdb_name_table</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">kdb_name_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">knt1</span><span class="p">;</span>
		<span class="n">symtab</span><span class="o">-&gt;</span><span class="n">sym_name</span> <span class="o">=</span> <span class="n">kdb_name_table</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">knt1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">symtab</span><span class="o">-&gt;</span><span class="n">mod_name</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">symtab</span><span class="o">-&gt;</span><span class="n">mod_name</span> <span class="o">=</span> <span class="s">&quot;kernel&quot;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">KDB_DEBUG</span><span class="p">(</span><span class="n">AR</span><span class="p">))</span>
		<span class="n">kdb_printf</span><span class="p">(</span><span class="s">&quot;kdbnearsym: returns %d symtab-&gt;sym_start=0x%lx, &quot;</span>
		   <span class="s">&quot;symtab-&gt;mod_name=%p, symtab-&gt;sym_name=%p (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span>
		   <span class="n">symtab</span><span class="o">-&gt;</span><span class="n">sym_start</span><span class="p">,</span> <span class="n">symtab</span><span class="o">-&gt;</span><span class="n">mod_name</span><span class="p">,</span> <span class="n">symtab</span><span class="o">-&gt;</span><span class="n">sym_name</span><span class="p">,</span>
		   <span class="n">symtab</span><span class="o">-&gt;</span><span class="n">sym_name</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">debug_kfree</span><span class="p">(</span><span class="n">knt1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kdbnearsym_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">kdb_name_table</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kdb_name_table</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">debug_kfree</span><span class="p">(</span><span class="n">kdb_name_table</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">kdb_name_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">char</span> <span class="n">ks_namebuf</span><span class="p">[</span><span class="n">KSYM_NAME_LEN</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">ks_namebuf_prev</span><span class="p">[</span><span class="n">KSYM_NAME_LEN</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>

<span class="cm">/*</span>
<span class="cm"> * kallsyms_symbol_complete</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *	prefix_name	prefix of a symbol name to lookup</span>
<span class="cm"> *	max_len		maximum length that can be returned</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *	Number of symbols which match the given prefix.</span>
<span class="cm"> * Notes:</span>
<span class="cm"> *	prefix_name is changed to contain the longest unique prefix that</span>
<span class="cm"> *	starts with this prefix (tab completion).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">kallsyms_symbol_complete</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">prefix_name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">loff_t</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">prefix_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">prefix_name</span><span class="p">),</span> <span class="n">prev_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">name</span> <span class="o">=</span> <span class="n">kdb_walk_kallsyms</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pos</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">prefix_name</span><span class="p">,</span> <span class="n">prefix_len</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">strcpy</span><span class="p">(</span><span class="n">ks_namebuf</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
			<span class="cm">/* Work out the longest name that matches the prefix */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">number</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">prev_len</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">max_len</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
						 <span class="n">strlen</span><span class="p">(</span><span class="n">ks_namebuf</span><span class="p">));</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">ks_namebuf_prev</span><span class="p">,</span> <span class="n">ks_namebuf</span><span class="p">,</span> <span class="n">prev_len</span><span class="p">);</span>
				<span class="n">ks_namebuf_prev</span><span class="p">[</span><span class="n">prev_len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">prev_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ks_namebuf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ks_namebuf_prev</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
					<span class="n">prev_len</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
					<span class="n">ks_namebuf_prev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prev_len</span> <span class="o">&gt;</span> <span class="n">prefix_len</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">prefix_name</span><span class="p">,</span> <span class="n">ks_namebuf_prev</span><span class="p">,</span> <span class="n">prev_len</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * kallsyms_symbol_next</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *	prefix_name	prefix of a symbol name to lookup</span>
<span class="cm"> *	flag	0 means search from the head, 1 means continue search.</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *	1 if a symbol matches the given prefix.</span>
<span class="cm"> *	0 if no string found</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">kallsyms_symbol_next</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">prefix_name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">prefix_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">prefix_name</span><span class="p">);</span>
	<span class="k">static</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">flag</span><span class="p">)</span>
		<span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">name</span> <span class="o">=</span> <span class="n">kdb_walk_kallsyms</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pos</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">prefix_name</span><span class="p">,</span> <span class="n">prefix_len</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">strncpy</span><span class="p">(</span><span class="n">prefix_name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * kdb_symbol_print - Standard method for printing a symbol name and offset.</span>
<span class="cm"> * Inputs:</span>
<span class="cm"> *	addr	Address to be printed.</span>
<span class="cm"> *	symtab	Address of symbol data, if NULL this routine does its</span>
<span class="cm"> *		own lookup.</span>
<span class="cm"> *	punc	Punctuation for string, bit field.</span>
<span class="cm"> * Remarks:</span>
<span class="cm"> *	The string and its punctuation is only printed if the address</span>
<span class="cm"> *	is inside the kernel, except that the value is always printed</span>
<span class="cm"> *	when requested.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">kdb_symbol_print</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="k">const</span> <span class="n">kdb_symtab_t</span> <span class="o">*</span><span class="n">symtab_p</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">punc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kdb_symtab_t</span> <span class="n">symtab</span><span class="p">,</span> <span class="o">*</span><span class="n">symtab_p2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">symtab_p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">symtab_p2</span> <span class="o">=</span> <span class="p">(</span><span class="n">kdb_symtab_t</span> <span class="o">*</span><span class="p">)</span><span class="n">symtab_p</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">symtab_p2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">symtab</span><span class="p">;</span>
		<span class="n">kdbnearsym</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">symtab_p2</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">symtab_p2</span><span class="o">-&gt;</span><span class="n">sym_name</span> <span class="o">||</span> <span class="p">(</span><span class="n">punc</span> <span class="o">&amp;</span> <span class="n">KDB_SP_VALUE</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">punc</span> <span class="o">&amp;</span> <span class="n">KDB_SP_SPACEB</span><span class="p">)</span>
		<span class="n">kdb_printf</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">punc</span> <span class="o">&amp;</span> <span class="n">KDB_SP_VALUE</span><span class="p">)</span>
		<span class="n">kdb_printf</span><span class="p">(</span><span class="n">kdb_machreg_fmt0</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">symtab_p2</span><span class="o">-&gt;</span><span class="n">sym_name</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">punc</span> <span class="o">&amp;</span> <span class="n">KDB_SP_VALUE</span><span class="p">)</span>
			<span class="n">kdb_printf</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">punc</span> <span class="o">&amp;</span> <span class="n">KDB_SP_PAREN</span><span class="p">)</span>
			<span class="n">kdb_printf</span><span class="p">(</span><span class="s">&quot;(&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">symtab_p2</span><span class="o">-&gt;</span><span class="n">mod_name</span><span class="p">,</span> <span class="s">&quot;kernel&quot;</span><span class="p">))</span>
			<span class="n">kdb_printf</span><span class="p">(</span><span class="s">&quot;[%s]&quot;</span><span class="p">,</span> <span class="n">symtab_p2</span><span class="o">-&gt;</span><span class="n">mod_name</span><span class="p">);</span>
		<span class="n">kdb_printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">symtab_p2</span><span class="o">-&gt;</span><span class="n">sym_name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">!=</span> <span class="n">symtab_p2</span><span class="o">-&gt;</span><span class="n">sym_start</span><span class="p">)</span>
			<span class="n">kdb_printf</span><span class="p">(</span><span class="s">&quot;+0x%lx&quot;</span><span class="p">,</span> <span class="n">addr</span> <span class="o">-</span> <span class="n">symtab_p2</span><span class="o">-&gt;</span><span class="n">sym_start</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">punc</span> <span class="o">&amp;</span> <span class="n">KDB_SP_SYMSIZE</span><span class="p">)</span>
			<span class="n">kdb_printf</span><span class="p">(</span><span class="s">&quot;/0x%lx&quot;</span><span class="p">,</span>
				   <span class="n">symtab_p2</span><span class="o">-&gt;</span><span class="n">sym_end</span> <span class="o">-</span> <span class="n">symtab_p2</span><span class="o">-&gt;</span><span class="n">sym_start</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">punc</span> <span class="o">&amp;</span> <span class="n">KDB_SP_PAREN</span><span class="p">)</span>
			<span class="n">kdb_printf</span><span class="p">(</span><span class="s">&quot;)&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">punc</span> <span class="o">&amp;</span> <span class="n">KDB_SP_SPACEA</span><span class="p">)</span>
		<span class="n">kdb_printf</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">punc</span> <span class="o">&amp;</span> <span class="n">KDB_SP_NEWLINE</span><span class="p">)</span>
		<span class="n">kdb_printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * kdb_strdup - kdb equivalent of strdup, for disasm code.</span>
<span class="cm"> * Inputs:</span>
<span class="cm"> *	str	The string to duplicate.</span>
<span class="cm"> *	type	Flags to kmalloc for the new string.</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *	Address of the new string, NULL if storage could not be allocated.</span>
<span class="cm"> * Remarks:</span>
<span class="cm"> *	This is not in lib/string.c because it uses kmalloc which is not</span>
<span class="cm"> *	available when string.o is used in boot loaders.</span>
<span class="cm"> */</span>
<span class="kt">char</span> <span class="o">*</span><span class="nf">kdb_strdup</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">strcpy</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * kdb_getarea_size - Read an area of data.  The kdb equivalent of</span>
<span class="cm"> *	copy_from_user, with kdb messages for invalid addresses.</span>
<span class="cm"> * Inputs:</span>
<span class="cm"> *	res	Pointer to the area to receive the result.</span>
<span class="cm"> *	addr	Address of the area to copy.</span>
<span class="cm"> *	size	Size of the area.</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *	0 for success, &lt; 0 for error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">kdb_getarea_size</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">probe_kernel_read</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">res</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">KDB_STATE</span><span class="p">(</span><span class="n">SUPPRESS</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kdb_printf</span><span class="p">(</span><span class="s">&quot;kdb_getarea: Bad address 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
			<span class="n">KDB_STATE_SET</span><span class="p">(</span><span class="n">SUPPRESS</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">KDB_BADADDR</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">KDB_STATE_CLEAR</span><span class="p">(</span><span class="n">SUPPRESS</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * kdb_putarea_size - Write an area of data.  The kdb equivalent of</span>
<span class="cm"> *	copy_to_user, with kdb messages for invalid addresses.</span>
<span class="cm"> * Inputs:</span>
<span class="cm"> *	addr	Address of the area to write to.</span>
<span class="cm"> *	res	Pointer to the area holding the data.</span>
<span class="cm"> *	size	Size of the area.</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *	0 for success, &lt; 0 for error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">kdb_putarea_size</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">probe_kernel_read</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">res</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">KDB_STATE</span><span class="p">(</span><span class="n">SUPPRESS</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kdb_printf</span><span class="p">(</span><span class="s">&quot;kdb_putarea: Bad address 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
			<span class="n">KDB_STATE_SET</span><span class="p">(</span><span class="n">SUPPRESS</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">KDB_BADADDR</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">KDB_STATE_CLEAR</span><span class="p">(</span><span class="n">SUPPRESS</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * kdb_getphys - Read data from a physical address. Validate the</span>
<span class="cm"> * 	address is in range, use kmap_atomic() to get data</span>
<span class="cm"> * 	similar to kdb_getarea() - but for phys addresses</span>
<span class="cm"> * Inputs:</span>
<span class="cm"> * 	res	Pointer to the word to receive the result</span>
<span class="cm"> * 	addr	Physical address of the area to copy</span>
<span class="cm"> * 	size	Size of the area</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *	0 for success, &lt; 0 for error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">kdb_getphys</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="n">pfn</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pfn_valid</span><span class="p">(</span><span class="n">pfn</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
	<span class="n">vaddr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">vaddr</span> <span class="o">+</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * kdb_getphysword</span>
<span class="cm"> * Inputs:</span>
<span class="cm"> *	word	Pointer to the word to receive the result.</span>
<span class="cm"> *	addr	Address of the area to copy.</span>
<span class="cm"> *	size	Size of the area.</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *	0 for success, &lt; 0 for error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">kdb_getphysword</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">word</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">diag</span><span class="p">;</span>
	<span class="n">__u8</span>  <span class="n">w1</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">w2</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">w4</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">w8</span><span class="p">;</span>
	<span class="o">*</span><span class="n">word</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* Default value if addr or size is invalid */</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">diag</span> <span class="o">=</span> <span class="n">kdb_getphys</span><span class="p">(</span><span class="o">&amp;</span><span class="n">w1</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">w1</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">diag</span><span class="p">)</span>
			<span class="o">*</span><span class="n">word</span> <span class="o">=</span> <span class="n">w1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">diag</span> <span class="o">=</span> <span class="n">kdb_getphys</span><span class="p">(</span><span class="o">&amp;</span><span class="n">w2</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">w2</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">diag</span><span class="p">)</span>
			<span class="o">*</span><span class="n">word</span> <span class="o">=</span> <span class="n">w2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4</span>:
		<span class="n">diag</span> <span class="o">=</span> <span class="n">kdb_getphys</span><span class="p">(</span><span class="o">&amp;</span><span class="n">w4</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">w4</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">diag</span><span class="p">)</span>
			<span class="o">*</span><span class="n">word</span> <span class="o">=</span> <span class="n">w4</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">8</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">word</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">diag</span> <span class="o">=</span> <span class="n">kdb_getphys</span><span class="p">(</span><span class="o">&amp;</span><span class="n">w8</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">w8</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">diag</span><span class="p">)</span>
				<span class="o">*</span><span class="n">word</span> <span class="o">=</span> <span class="n">w8</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* drop through */</span>
	<span class="nl">default:</span>
		<span class="n">diag</span> <span class="o">=</span> <span class="n">KDB_BADWIDTH</span><span class="p">;</span>
		<span class="n">kdb_printf</span><span class="p">(</span><span class="s">&quot;kdb_getphysword: bad width %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">size</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">diag</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * kdb_getword - Read a binary value.  Unlike kdb_getarea, this treats</span>
<span class="cm"> *	data as numbers.</span>
<span class="cm"> * Inputs:</span>
<span class="cm"> *	word	Pointer to the word to receive the result.</span>
<span class="cm"> *	addr	Address of the area to copy.</span>
<span class="cm"> *	size	Size of the area.</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *	0 for success, &lt; 0 for error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">kdb_getword</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">word</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">diag</span><span class="p">;</span>
	<span class="n">__u8</span>  <span class="n">w1</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">w2</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">w4</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">w8</span><span class="p">;</span>
	<span class="o">*</span><span class="n">word</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* Default value if addr or size is invalid */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">diag</span> <span class="o">=</span> <span class="n">kdb_getarea</span><span class="p">(</span><span class="n">w1</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">diag</span><span class="p">)</span>
			<span class="o">*</span><span class="n">word</span> <span class="o">=</span> <span class="n">w1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">diag</span> <span class="o">=</span> <span class="n">kdb_getarea</span><span class="p">(</span><span class="n">w2</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">diag</span><span class="p">)</span>
			<span class="o">*</span><span class="n">word</span> <span class="o">=</span> <span class="n">w2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4</span>:
		<span class="n">diag</span> <span class="o">=</span> <span class="n">kdb_getarea</span><span class="p">(</span><span class="n">w4</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">diag</span><span class="p">)</span>
			<span class="o">*</span><span class="n">word</span> <span class="o">=</span> <span class="n">w4</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">8</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">word</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">diag</span> <span class="o">=</span> <span class="n">kdb_getarea</span><span class="p">(</span><span class="n">w8</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">diag</span><span class="p">)</span>
				<span class="o">*</span><span class="n">word</span> <span class="o">=</span> <span class="n">w8</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* drop through */</span>
	<span class="nl">default:</span>
		<span class="n">diag</span> <span class="o">=</span> <span class="n">KDB_BADWIDTH</span><span class="p">;</span>
		<span class="n">kdb_printf</span><span class="p">(</span><span class="s">&quot;kdb_getword: bad width %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">size</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">diag</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * kdb_putword - Write a binary value.  Unlike kdb_putarea, this</span>
<span class="cm"> *	treats data as numbers.</span>
<span class="cm"> * Inputs:</span>
<span class="cm"> *	addr	Address of the area to write to..</span>
<span class="cm"> *	word	The value to set.</span>
<span class="cm"> *	size	Size of the area.</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *	0 for success, &lt; 0 for error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">kdb_putword</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">word</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">diag</span><span class="p">;</span>
	<span class="n">__u8</span>  <span class="n">w1</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">w2</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">w4</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">w8</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">w1</span> <span class="o">=</span> <span class="n">word</span><span class="p">;</span>
		<span class="n">diag</span> <span class="o">=</span> <span class="n">kdb_putarea</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">w1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">w2</span> <span class="o">=</span> <span class="n">word</span><span class="p">;</span>
		<span class="n">diag</span> <span class="o">=</span> <span class="n">kdb_putarea</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">w2</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4</span>:
		<span class="n">w4</span> <span class="o">=</span> <span class="n">word</span><span class="p">;</span>
		<span class="n">diag</span> <span class="o">=</span> <span class="n">kdb_putarea</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">w4</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">8</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">word</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">w8</span> <span class="o">=</span> <span class="n">word</span><span class="p">;</span>
			<span class="n">diag</span> <span class="o">=</span> <span class="n">kdb_putarea</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">w8</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* drop through */</span>
	<span class="nl">default:</span>
		<span class="n">diag</span> <span class="o">=</span> <span class="n">KDB_BADWIDTH</span><span class="p">;</span>
		<span class="n">kdb_printf</span><span class="p">(</span><span class="s">&quot;kdb_putword: bad width %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">size</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">diag</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * kdb_task_state_string - Convert a string containing any of the</span>
<span class="cm"> *	letters DRSTCZEUIMA to a mask for the process state field and</span>
<span class="cm"> *	return the value.  If no argument is supplied, return the mask</span>
<span class="cm"> *	that corresponds to environment variable PS, DRSTCZEU by</span>
<span class="cm"> *	default.</span>
<span class="cm"> * Inputs:</span>
<span class="cm"> *	s	String to convert</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *	Mask for process state.</span>
<span class="cm"> * Notes:</span>
<span class="cm"> *	The mask folds data from several sources into a single long value, so</span>
<span class="cm"> *	be careful not to overlap the bits.  TASK_* bits are in the LSB,</span>
<span class="cm"> *	special cases like UNRUNNABLE are in the MSB.  As of 2.6.10-rc1 there</span>
<span class="cm"> *	is no overlap between TASK_* and EXIT_* but that may not always be</span>
<span class="cm"> *	true, so EXIT_* bits are shifted left 16 bits before being stored in</span>
<span class="cm"> *	the mask.</span>
<span class="cm"> */</span>

<span class="cm">/* unrunnable is &lt; 0 */</span>
<span class="cp">#define UNRUNNABLE	(1UL &lt;&lt; (8*sizeof(unsigned long) - 1))</span>
<span class="cp">#define RUNNING		(1UL &lt;&lt; (8*sizeof(unsigned long) - 2))</span>
<span class="cp">#define IDLE		(1UL &lt;&lt; (8*sizeof(unsigned long) - 3))</span>
<span class="cp">#define DAEMON		(1UL &lt;&lt; (8*sizeof(unsigned long) - 4))</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">kdb_task_state_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">kdbgetenv</span><span class="p">(</span><span class="s">&quot;PS&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">)</span>
			<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;DRSTCZEU&quot;</span><span class="p">;</span>	<span class="cm">/* default value for ps */</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="sc">&#39;D&#39;</span>:
			<span class="n">res</span> <span class="o">|=</span> <span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;R&#39;</span>:
			<span class="n">res</span> <span class="o">|=</span> <span class="n">RUNNING</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;S&#39;</span>:
			<span class="n">res</span> <span class="o">|=</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;T&#39;</span>:
			<span class="n">res</span> <span class="o">|=</span> <span class="n">TASK_STOPPED</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;C&#39;</span>:
			<span class="n">res</span> <span class="o">|=</span> <span class="n">TASK_TRACED</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;Z&#39;</span>:
			<span class="n">res</span> <span class="o">|=</span> <span class="n">EXIT_ZOMBIE</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;E&#39;</span>:
			<span class="n">res</span> <span class="o">|=</span> <span class="n">EXIT_DEAD</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;U&#39;</span>:
			<span class="n">res</span> <span class="o">|=</span> <span class="n">UNRUNNABLE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;I&#39;</span>:
			<span class="n">res</span> <span class="o">|=</span> <span class="n">IDLE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;M&#39;</span>:
			<span class="n">res</span> <span class="o">|=</span> <span class="n">DAEMON</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;A&#39;</span>:
			<span class="n">res</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			  <span class="n">kdb_printf</span><span class="p">(</span><span class="s">&quot;%s: unknown flag &#39;%c&#39; ignored</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">__func__</span><span class="p">,</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
			  <span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">++</span><span class="n">s</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * kdb_task_state_char - Return the character that represents the task state.</span>
<span class="cm"> * Inputs:</span>
<span class="cm"> *	p	struct task for the process</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *	One character to represent the task state.</span>
<span class="cm"> */</span>
<span class="kt">char</span> <span class="nf">kdb_task_state_char</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">state</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span> <span class="o">||</span> <span class="n">probe_kernel_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)))</span>
		<span class="k">return</span> <span class="sc">&#39;E&#39;</span><span class="p">;</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="n">kdb_process_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">state</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="sc">&#39;R&#39;</span> <span class="o">:</span>
		<span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="sc">&#39;U&#39;</span> <span class="o">:</span>
		<span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">)</span> <span class="o">?</span> <span class="sc">&#39;D&#39;</span> <span class="o">:</span>
		<span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">TASK_STOPPED</span><span class="p">)</span> <span class="o">?</span> <span class="sc">&#39;T&#39;</span> <span class="o">:</span>
		<span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">TASK_TRACED</span><span class="p">)</span> <span class="o">?</span> <span class="sc">&#39;C&#39;</span> <span class="o">:</span>
		<span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">exit_state</span> <span class="o">&amp;</span> <span class="n">EXIT_ZOMBIE</span><span class="p">)</span> <span class="o">?</span> <span class="sc">&#39;Z&#39;</span> <span class="o">:</span>
		<span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">exit_state</span> <span class="o">&amp;</span> <span class="n">EXIT_DEAD</span><span class="p">)</span> <span class="o">?</span> <span class="sc">&#39;E&#39;</span> <span class="o">:</span>
		<span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">)</span> <span class="o">?</span> <span class="sc">&#39;S&#39;</span> <span class="o">:</span> <span class="sc">&#39;?&#39;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_idle_task</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Idle task.  Is it really idle, apart from the kdb</span>
<span class="cm">		 * interrupt? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kdb_task_has_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">||</span> <span class="n">kgdb_info</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">irq_depth</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">kdb_initial_cpu</span><span class="p">)</span>
				<span class="n">state</span> <span class="o">=</span> <span class="sc">&#39;I&#39;</span><span class="p">;</span>	<span class="cm">/* idle task */</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">&amp;&amp;</span> <span class="n">state</span> <span class="o">==</span> <span class="sc">&#39;S&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">state</span> <span class="o">=</span> <span class="sc">&#39;M&#39;</span><span class="p">;</span>	<span class="cm">/* sleeping system daemon */</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">state</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * kdb_task_state - Return true if a process has the desired state</span>
<span class="cm"> *	given by the mask.</span>
<span class="cm"> * Inputs:</span>
<span class="cm"> *	p	struct task for the process</span>
<span class="cm"> *	mask	mask from kdb_task_state_string to select processes</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *	True if the process matches at least one criteria defined by the mask.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">kdb_task_state</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">state</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">kdb_task_state_char</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="sc">&#39;\0&#39;</span> <span class="p">};</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">kdb_task_state_string</span><span class="p">(</span><span class="n">state</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * kdb_print_nameval - Print a name and its value, converting the</span>
<span class="cm"> *	value to a symbol lookup if possible.</span>
<span class="cm"> * Inputs:</span>
<span class="cm"> *	name	field name to print</span>
<span class="cm"> *	val	value of field</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">kdb_print_nameval</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kdb_symtab_t</span> <span class="n">symtab</span><span class="p">;</span>
	<span class="n">kdb_printf</span><span class="p">(</span><span class="s">&quot;  %-11.11s &quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kdbnearsym</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">symtab</span><span class="p">))</span>
		<span class="n">kdb_symbol_print</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">symtab</span><span class="p">,</span>
				 <span class="n">KDB_SP_VALUE</span><span class="o">|</span><span class="n">KDB_SP_SYMSIZE</span><span class="o">|</span><span class="n">KDB_SP_NEWLINE</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">kdb_printf</span><span class="p">(</span><span class="s">&quot;0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Last ditch allocator for debugging, so we can still debug even when</span>
<span class="cm"> * the GFP_ATOMIC pool has been exhausted.  The algorithms are tuned</span>
<span class="cm"> * for space usage, not for speed.  One smallish memory pool, the free</span>
<span class="cm"> * chain is always in ascending address order to allow coalescing,</span>
<span class="cm"> * allocations are done in brute force best fit.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">debug_alloc_header</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">next</span><span class="p">;</span>	<span class="cm">/* offset of next header from start of pool */</span>
	<span class="n">u32</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">caller</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* The memory returned by this allocator must be aligned, which means</span>
<span class="cm"> * so must the header size.  Do not assume that sizeof(struct</span>
<span class="cm"> * debug_alloc_header) is a multiple of the alignment, explicitly</span>
<span class="cm"> * calculate the overhead of this header, including the alignment.</span>
<span class="cm"> * The rest of this code must not use sizeof() on any header or</span>
<span class="cm"> * pointer to a header.</span>
<span class="cm"> */</span>
<span class="cp">#define dah_align 8</span>
<span class="cp">#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)</span>

<span class="k">static</span> <span class="n">u64</span> <span class="n">debug_alloc_pool_aligned</span><span class="p">[</span><span class="mi">256</span><span class="o">*</span><span class="mi">1024</span><span class="o">/</span><span class="n">dah_align</span><span class="p">];</span>	<span class="cm">/* 256K pool */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">debug_alloc_pool</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">debug_alloc_pool_aligned</span><span class="p">;</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">dah_first</span><span class="p">,</span> <span class="n">dah_first_call</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dah_used</span><span class="p">,</span> <span class="n">dah_used_max</span><span class="p">;</span>

<span class="cm">/* Locking is awkward.  The debug code is called from all contexts,</span>
<span class="cm"> * including non maskable interrupts.  A normal spinlock is not safe</span>
<span class="cm"> * in NMI context.  Try to get the debug allocator lock, if it cannot</span>
<span class="cm"> * be obtained after a second then give up.  If the lock could not be</span>
<span class="cm"> * previously obtained on this cpu then only try once.</span>
<span class="cm"> *</span>
<span class="cm"> * sparse has no annotation for &quot;this function _sometimes_ acquires a</span>
<span class="cm"> * lock&quot;, so fudge the acquire/release notation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">dap_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_dap_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
	<span class="n">__acquires</span><span class="p">(</span><span class="n">dap_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">dap_locked</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dap_locked</span> <span class="o">==</span> <span class="n">smp_processor_id</span><span class="p">())</span>
		<span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">count</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">spin_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dap_lock</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dap_locked</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="o">--</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">dap_locked</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="n">__acquire</span><span class="p">(</span><span class="n">dap_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">debug_kmalloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rem</span><span class="p">,</span> <span class="n">h_offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">debug_alloc_header</span> <span class="o">*</span><span class="n">best</span><span class="p">,</span> <span class="o">*</span><span class="n">bestprev</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">get_dap_lock</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">__release</span><span class="p">(</span><span class="n">dap_lock</span><span class="p">);</span>	<span class="cm">/* we never actually got it */</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">debug_alloc_header</span> <span class="o">*</span><span class="p">)(</span><span class="n">debug_alloc_pool</span> <span class="o">+</span> <span class="n">dah_first</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dah_first_call</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">debug_alloc_pool_aligned</span><span class="p">)</span> <span class="o">-</span> <span class="n">dah_overhead</span><span class="p">;</span>
		<span class="n">dah_first_call</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">dah_align</span><span class="p">);</span>
	<span class="n">prev</span> <span class="o">=</span> <span class="n">best</span> <span class="o">=</span> <span class="n">bestprev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">size</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">best</span> <span class="o">||</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">best</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">best</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
			<span class="n">bestprev</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">==</span> <span class="n">size</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
		<span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">debug_alloc_header</span> <span class="o">*</span><span class="p">)(</span><span class="n">debug_alloc_pool</span> <span class="o">+</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">best</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">rem</span> <span class="o">=</span> <span class="n">best</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">size</span><span class="p">;</span>
	<span class="cm">/* The pool must always contain at least one header */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">best</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">bestprev</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">rem</span> <span class="o">&lt;</span> <span class="n">dah_overhead</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rem</span> <span class="o">&gt;=</span> <span class="n">dah_overhead</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">best</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">h_offset</span> <span class="o">=</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">best</span> <span class="o">-</span> <span class="n">debug_alloc_pool</span><span class="p">)</span> <span class="o">+</span>
			   <span class="n">dah_overhead</span> <span class="o">+</span> <span class="n">best</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">debug_alloc_header</span> <span class="o">*</span><span class="p">)(</span><span class="n">debug_alloc_pool</span> <span class="o">+</span> <span class="n">h_offset</span><span class="p">);</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">rem</span> <span class="o">-</span> <span class="n">dah_overhead</span><span class="p">;</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">best</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">h_offset</span> <span class="o">=</span> <span class="n">best</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="n">best</span><span class="o">-&gt;</span><span class="n">caller</span> <span class="o">=</span> <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">dah_used</span> <span class="o">+=</span> <span class="n">best</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
	<span class="n">dah_used_max</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dah_used</span><span class="p">,</span> <span class="n">dah_used_max</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bestprev</span><span class="p">)</span>
		<span class="n">bestprev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">h_offset</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">dah_first</span> <span class="o">=</span> <span class="n">h_offset</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">best</span> <span class="o">+</span> <span class="n">dah_overhead</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">POISON_INUSE</span><span class="p">,</span> <span class="n">best</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="o">*</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span> <span class="o">+</span> <span class="n">best</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">POISON_END</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dap_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">debug_kfree</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">debug_alloc_header</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">h_offset</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span> <span class="o">&lt;</span> <span class="n">debug_alloc_pool</span> <span class="o">||</span>
	    <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span> <span class="o">&gt;=</span> <span class="n">debug_alloc_pool</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">debug_alloc_pool_aligned</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">get_dap_lock</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">__release</span><span class="p">(</span><span class="n">dap_lock</span><span class="p">);</span>	<span class="cm">/* we never actually got it */</span>
		<span class="k">return</span><span class="p">;</span>		<span class="cm">/* memory leak, cannot be helped */</span>
	<span class="p">}</span>
	<span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">debug_alloc_header</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span> <span class="o">-</span> <span class="n">dah_overhead</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">POISON_FREE</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="o">*</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span> <span class="o">+</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">POISON_END</span><span class="p">;</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">caller</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dah_used</span> <span class="o">-=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
	<span class="n">h_offset</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">h</span> <span class="o">-</span> <span class="n">debug_alloc_pool</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">h_offset</span> <span class="o">&lt;</span> <span class="n">dah_first</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">dah_first</span><span class="p">;</span>
		<span class="n">dah_first</span> <span class="o">=</span> <span class="n">h_offset</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">debug_alloc_header</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">prev_offset</span><span class="p">;</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">debug_alloc_header</span> <span class="o">*</span><span class="p">)(</span><span class="n">debug_alloc_pool</span> <span class="o">+</span>
						     <span class="n">dah_first</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">||</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">&gt;</span> <span class="n">h_offset</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">prev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">debug_alloc_header</span> <span class="o">*</span><span class="p">)</span>
				<span class="p">(</span><span class="n">debug_alloc_pool</span> <span class="o">+</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">prev_offset</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">prev</span> <span class="o">-</span> <span class="n">debug_alloc_pool</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prev_offset</span> <span class="o">+</span> <span class="n">dah_overhead</span> <span class="o">+</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">==</span> <span class="n">h_offset</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">prev</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">+=</span> <span class="n">dah_overhead</span> <span class="o">+</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">POISON_FREE</span><span class="p">,</span> <span class="n">dah_overhead</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="o">*</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">h</span> <span class="o">+</span> <span class="n">dah_overhead</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">POISON_END</span><span class="p">;</span>
			<span class="n">h</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
			<span class="n">h_offset</span> <span class="o">=</span> <span class="n">prev_offset</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">h</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">h_offset</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">h_offset</span> <span class="o">+</span> <span class="n">dah_overhead</span> <span class="o">+</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">==</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">debug_alloc_header</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
		<span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">debug_alloc_header</span> <span class="o">*</span><span class="p">)</span>
			<span class="p">(</span><span class="n">debug_alloc_pool</span> <span class="o">+</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">+=</span> <span class="n">dah_overhead</span> <span class="o">+</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">POISON_FREE</span><span class="p">,</span> <span class="n">dah_overhead</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="o">*</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">next</span> <span class="o">+</span> <span class="n">dah_overhead</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">POISON_END</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dap_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">debug_kusage</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">debug_alloc_header</span> <span class="o">*</span><span class="n">h_free</span><span class="p">,</span> <span class="o">*</span><span class="n">h_used</span><span class="p">;</span>
<span class="cp">#ifdef	CONFIG_IA64</span>
	<span class="cm">/* FIXME: using dah for ia64 unwind always results in a memory leak.</span>
<span class="cm">	 * Fix that memory leak first, then set debug_kusage_one_time = 1 for</span>
<span class="cm">	 * all architectures.</span>
<span class="cm">	 */</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">debug_kusage_one_time</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">debug_kusage_one_time</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">get_dap_lock</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">__release</span><span class="p">(</span><span class="n">dap_lock</span><span class="p">);</span>	<span class="cm">/* we never actually got it */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">h_free</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">debug_alloc_header</span> <span class="o">*</span><span class="p">)(</span><span class="n">debug_alloc_pool</span> <span class="o">+</span> <span class="n">dah_first</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dah_first</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">h_free</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">debug_alloc_pool_aligned</span><span class="p">)</span> <span class="o">-</span> <span class="n">dah_overhead</span> <span class="o">||</span>
	     <span class="n">dah_first_call</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug_kusage_one_time</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">debug_kusage_one_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">kdb_printf</span><span class="p">(</span><span class="s">&quot;%s: debug_kmalloc memory leak dah_first %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">__func__</span><span class="p">,</span> <span class="n">dah_first</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dah_first</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">h_used</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">debug_alloc_header</span> <span class="o">*</span><span class="p">)</span><span class="n">debug_alloc_pool</span><span class="p">;</span>
		<span class="n">kdb_printf</span><span class="p">(</span><span class="s">&quot;%s: h_used %p size %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">h_used</span><span class="p">,</span>
			   <span class="n">h_used</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">h_used</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">debug_alloc_header</span> <span class="o">*</span><span class="p">)</span>
			  <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">h_free</span> <span class="o">+</span> <span class="n">dah_overhead</span> <span class="o">+</span> <span class="n">h_free</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
		<span class="n">kdb_printf</span><span class="p">(</span><span class="s">&quot;%s: h_used %p size %d caller %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">h_used</span><span class="p">,</span> <span class="n">h_used</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">h_used</span><span class="o">-&gt;</span><span class="n">caller</span><span class="p">);</span>
		<span class="n">h_free</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">debug_alloc_header</span> <span class="o">*</span><span class="p">)</span>
			  <span class="p">(</span><span class="n">debug_alloc_pool</span> <span class="o">+</span> <span class="n">h_free</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">h_free</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
	<span class="n">h_used</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">debug_alloc_header</span> <span class="o">*</span><span class="p">)</span>
		  <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">h_free</span> <span class="o">+</span> <span class="n">dah_overhead</span> <span class="o">+</span> <span class="n">h_free</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">h_used</span> <span class="o">-</span> <span class="n">debug_alloc_pool</span> <span class="o">!=</span>
	    <span class="k">sizeof</span><span class="p">(</span><span class="n">debug_alloc_pool_aligned</span><span class="p">))</span>
		<span class="n">kdb_printf</span><span class="p">(</span><span class="s">&quot;%s: h_used %p size %d caller %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">h_used</span><span class="p">,</span> <span class="n">h_used</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">h_used</span><span class="o">-&gt;</span><span class="n">caller</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dap_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Maintain a small stack of kdb_flags to allow recursion without disturbing</span>
<span class="cm"> * the global kdb state.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">kdb_flags_stack</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">kdb_flags_index</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">kdb_save_flags</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">kdb_flags_index</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">kdb_flags_stack</span><span class="p">));</span>
	<span class="n">kdb_flags_stack</span><span class="p">[</span><span class="n">kdb_flags_index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">kdb_flags</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kdb_restore_flags</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">kdb_flags_index</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">kdb_flags</span> <span class="o">=</span> <span class="n">kdb_flags_stack</span><span class="p">[</span><span class="o">--</span><span class="n">kdb_flags_index</span><span class="p">];</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
